<html>
<head><meta charset="utf-8"><title>Full-stack performance analysis involving WASM guests · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/index.html">general</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Full-stack.20performance.20analysis.20involving.20WASM.20guests.html">Full-stack performance analysis involving WASM guests</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="421278302"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Full-stack%20performance%20analysis%20involving%20WASM%20guests/near/421278302" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Geoff Goodman <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Full-stack.20performance.20analysis.20involving.20WASM.20guests.html#421278302">(Feb 13 2024 at 16:16)</a>:</h4>
<p>In more traditional stacks, there are often go-to tools for performing performance analysis at different levels of detail. In this world of WASM, the isolation membrane around the guest code adds new challenges. How to instrument such code without the cost of instrumentation rendering the insight meaningless?</p>
<p>How are folks going about getting more detailed insight than the classic: 1) compilation; 2) instantiation; and 3) ~execution?</p>
<p>What about measuring the cost of host calls and calls from the host to the guest?</p>



<a name="421300657"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Full-stack%20performance%20analysis%20involving%20WASM%20guests/near/421300657" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Full-stack.20performance.20analysis.20involving.20WASM.20guests.html#421300657">(Feb 13 2024 at 18:24)</a>:</h4>
<p>At least in the context of Wasmtime I can say I primarily use <code>perf</code> on Linux for this. Using that gives a pretty good picture of host/guest combined, although it does still leave bits and pieces to be desired.</p>
<p>Otherwise though call overhead is definitely something we've optimized a lot in Wasmtime as well, not so much on a continuing basis of "we've compared ourselves to other runtimes" but moreso "we got it as fast as we could and we do our best not to regress"</p>



<a name="421300759"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Full-stack%20performance%20analysis%20involving%20WASM%20guests/near/421300759" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Full-stack.20performance.20analysis.20involving.20WASM.20guests.html#421300759">(Feb 13 2024 at 18:25)</a>:</h4>
<p>Bottlenecks tend to vary application-by-application however which is where we design APIs and guidelines and such to work for as wide of an array of use cases as is possible</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>