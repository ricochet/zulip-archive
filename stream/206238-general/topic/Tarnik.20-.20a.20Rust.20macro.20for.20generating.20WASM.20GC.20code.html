<html>
<head><meta charset="utf-8"><title>Tarnik - a Rust macro for generating WASM GC code 路 general 路 Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/index.html">general</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html">Tarnik - a Rust macro for generating WASM GC code</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="484407612"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/484407612" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#484407612">(Nov 25 2024 at 23:29)</a>:</h4>
<p>I couldn't find any good and ergonomic way to generate WASM GC code, and writing it by hand is kinda tedious, so I created a project to help with that: <a href="https://github.com/drogus/tarnik">Tarnik</a>. It's an early stage, but I like getting feedback early, so I decided to open source it already. The primary aim is to use it in <a href="https://github.com/drogus/jawsm">jawsm</a> and I think I will be able to do it soon. There is an example in the README and a few more in the <a href="https://github.com/drogus/tarnik/blob/0a14d33010dd147af660f1d897643b0d7a68f5aa/testing/src/lib.rs#L34-L39">tests</a>. I plan to add more stuff in the next few weeks as I would really like to start using it in jawsm soon.</p>
<p>Let me know what you think!</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/tarnik" style="background-image: url(&quot;https://uploads.zulipusercontent.net/d6d176c124656907b656ff3685b2e263149fa87e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636239633737346336316364643634393263373039393038396561636264333262363733636434646333643863656431623436383130643437333063336231302f64726f6775732f7461726e696b&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/tarnik" title="GitHub - drogus/tarnik: Generate WASM GC code using a Rust macro">GitHub - drogus/tarnik: Generate WASM GC code using a Rust macro</a></div><div class="message_embed_description">Generate WASM GC code using a Rust macro. Contribute to drogus/tarnik development by creating an account on GitHub.</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/jawsm" style="background-image: url(&quot;https://uploads.zulipusercontent.net/04a895ed823e82de3bbe37b920cea357150ebb9b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353362346330633164343564353438393335336338303665646533666461363031666366353235306436353833343530616438373339316531373564306463362f64726f6775732f6a6177736d&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/jawsm" title="GitHub - drogus/jawsm: JavaScript to WASM compiler">GitHub - drogus/jawsm: JavaScript to WASM compiler</a></div><div class="message_embed_description">JavaScript to WASM compiler. Contribute to drogus/jawsm development by creating an account on GitHub.</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/tarnik/blob/0a14d33010dd147af660f1d897643b0d7a68f5aa/testing/src/lib.rs#L34-L39" style="background-image: url(&quot;https://uploads.zulipusercontent.net/d6d176c124656907b656ff3685b2e263149fa87e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636239633737346336316364643634393263373039393038396561636264333262363733636434646333643863656431623436383130643437333063336231302f64726f6775732f7461726e696b&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/tarnik/blob/0a14d33010dd147af660f1d897643b0d7a68f5aa/testing/src/lib.rs#L34-L39" title="tarnik/testing/src/lib.rs at 0a14d33010dd147af660f1d897643b0d7a68f5aa 路 drogus/tarnik">tarnik/testing/src/lib.rs at 0a14d33010dd147af660f1d897643b0d7a68f5aa 路 drogus/tarnik</a></div><div class="message_embed_description">Generate WASM GC code using a Rust macro. Contribute to drogus/tarnik development by creating an account on GitHub.</div></div></div>



<a name="485578949"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/485578949" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#485578949">(Dec 02 2024 at 09:25)</a>:</h4>
<p>I figured out I might use this thread as a way to write about updates to the tool. It's too early to create any official releases I think, but recently I've added a few more things:</p>
<ul>
<li>defining and exporting memories</li>
<li>exporting functions and types</li>
<li>I implemented most of the binary and unary operations  (I think the only left are <code>!</code> and <code>&amp;&amp;</code> + <code>||</code>)</li>
</ul>
<p>So this compiles successfully now:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tarnik</span><span class="p">::</span><span class="n">wasm</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#[export(</span><span class="s">"memory"</span><span class="cp">)]</span>
<span class="w">  </span><span class="n">memory</span><span class="o">!</span><span class="p">(</span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">mut</span><span class="w"> </span><span class="kt">i8</span><span class="p">];</span>

<span class="w">  </span><span class="cp">#[export(</span><span class="s">"_start"</span><span class="cp">)]</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hello world"</span><span class="p">;</span>
<span class="w">    </span><span class="n">foo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">'a'</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">byte</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"{module}"</span><span class="p">);</span>
</code></pre></div>
<p>Next thing to implement is memory access, which shouldn't be too hard, and then <code>ref.cast</code> + <code>ref.test</code>, which should be enough for me to actually start using it in Jawsm <span aria-label="fingers crossed" class="emoji emoji-1f91e" role="img" title="fingers crossed">:fingers_crossed:</span></p>



<a name="486065229"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/486065229" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#486065229">(Dec 04 2024 at 11:01)</a>:</h4>
<p>Another small update. I implemented casting (like: <code>i as i64</code>), memory store/load support and imports, so now you can write fully functioning WASI program (using p1 for simplicity):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">tarnik</span><span class="p">::</span><span class="n">wasm</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cp">#[export(</span><span class="s">"memory"</span><span class="cp">)]</span>
<span class="w">    </span><span class="n">memory</span><span class="o">!</span><span class="p">(</span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="cp">#[import(</span><span class="s">"wasi_snapshot_preview1"</span><span class="cp">, </span><span class="s">"fd_write"</span><span class="cp">)]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="n">a1</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">a3</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span>

<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">ImmutableString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="p">];</span>

<span class="w">    </span><span class="cp">#[export(</span><span class="s">"_start"</span><span class="cp">)]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="kt">str</span><span class="p">:</span><span class="w"> </span><span class="nc">ImmutableString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hello world!"</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// store io vectors</span>
<span class="w">        </span><span class="n">memory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">        </span><span class="n">memory</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// `let: foo`` is small hack, if a function returns a value it needs to be somehow consumed</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write</span><span class="p">(</span>
<span class="w">            </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// stdout</span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// io vectors start</span>
<span class="w">            </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// number of io vectors</span>
<span class="w">            </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="c1">// where to write the result</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>



<a name="486121054"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/486121054" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Victor Adossi <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#486121054">(Dec 04 2024 at 15:36)</a>:</h4>
<p>Just chiming in to say this is pretty awesome, enjoying reading along :)</p>



<a name="486795937"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/486795937" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#486795937">(Dec 08 2024 at 19:21)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="598440">@Victor Adossi</span>!</p>
<p>In the recent few days I've added quite a few things:</p>
<ol>
<li>try/catch/catch_all support, along with passing argument to an exception <a href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L91-L113">example</a></li>
<li><code>ref.test</code> with <code>ref_test!</code> macro <a href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L60">example</a></li>
<li><code>len!()</code> macro for getting length of an array</li>
<li>Inserting data strings with <code>data!()</code> macro, for example <code>data!["foo"]</code> will insert a <code>data</code> entry with the string "foo" and it will return an offset <a href="https://github.com/drogus/tarnik/blob/4321f0fc3ef39dce1f5d85dd9660ea2befbd2dac/testing/src/lib.rs#L15-L23">example</a> (I still need to implement getting data entry length)</li>
</ol>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L91-L113" style="background-image: url(&quot;https://uploads.zulipusercontent.net/7c0a717f2029c2410672e8697dfee608d29aea4d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363334316236636639616633643431616263666530646661623163383830643062353933333262373334323934346563623931353539316535396561616434342f64726f6775732f7461726e696b&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L91-L113" title="tarnik/testing/src/lib.rs at 2a1b3356cdd6193f7f60150bb6bc50c8664245c5 路 drogus/tarnik">tarnik/testing/src/lib.rs at 2a1b3356cdd6193f7f60150bb6bc50c8664245c5 路 drogus/tarnik</a></div><div class="message_embed_description">Generate WASM GC code using a Rust macro. Contribute to drogus/tarnik development by creating an account on GitHub.</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L60" style="background-image: url(&quot;https://uploads.zulipusercontent.net/7c0a717f2029c2410672e8697dfee608d29aea4d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363334316236636639616633643431616263666530646661623163383830643062353933333262373334323934346563623931353539316535396561616434342f64726f6775732f7461726e696b&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/tarnik/blob/2a1b3356cdd6193f7f60150bb6bc50c8664245c5/testing/src/lib.rs#L60" title="tarnik/testing/src/lib.rs at 2a1b3356cdd6193f7f60150bb6bc50c8664245c5 路 drogus/tarnik">tarnik/testing/src/lib.rs at 2a1b3356cdd6193f7f60150bb6bc50c8664245c5 路 drogus/tarnik</a></div><div class="message_embed_description">Generate WASM GC code using a Rust macro. Contribute to drogus/tarnik development by creating an account on GitHub.</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/tarnik/blob/4321f0fc3ef39dce1f5d85dd9660ea2befbd2dac/testing/src/lib.rs#L15-L23" style="background-image: url(&quot;https://uploads.zulipusercontent.net/7c0a717f2029c2410672e8697dfee608d29aea4d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363334316236636639616633643431616263666530646661623163383830643062353933333262373334323934346563623931353539316535396561616434342f64726f6775732f7461726e696b&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/tarnik/blob/4321f0fc3ef39dce1f5d85dd9660ea2befbd2dac/testing/src/lib.rs#L15-L23" title="tarnik/testing/src/lib.rs at 4321f0fc3ef39dce1f5d85dd9660ea2befbd2dac 路 drogus/tarnik">tarnik/testing/src/lib.rs at 4321f0fc3ef39dce1f5d85dd9660ea2befbd2dac 路 drogus/tarnik</a></div><div class="message_embed_description">Generate WASM GC code using a Rust macro. Contribute to drogus/tarnik development by creating an account on GitHub.</div></div></div>



<a name="488191923"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/488191923" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#488191923">(Dec 11 2024 at 21:28)</a>:</h4>
<p>Another update, and this one is exciting (at least for me). Till now I've been working on Tarnik without any real world usage, but the plan was always to use it in my other project: Jawsm compiler. I just finished rewriting about 3k lines of WAT code into about 1.5k of Rust-like code <a href="https://github.com/drogus/jawsm/pull/5/files#diff-6d7bc9e99526e7f06b818a6103bd30aaa067263cc8e34a14197e1a3bcf2dd4db">PR</a>. I think this is a good stress test, that also uncovered a few issues, like for example problems when using expressions with casting (like <code>-1 as i32 as i31ref</code>) and a few other edge cases. I restructured the code to fix some of them, but I also fixed other issues so the code I already had just worked as it should. The list of latest changes:</p>
<ul>
<li>fix try/catch in context of an if statement and a while loop (it will still break for a <code>for</code> loop)</li>
<li>implement negation <code>-</code> and not <code>!</code> operators for numeric types</li>
<li>implement <code>&amp;&amp;</code> and <code>||</code> for numeric types (it still doesn't work for refs, but I plan to implement it at some point as a <code>ref_test</code> for null values)</li>
<li>generalize struct fields access, so more forms are possible, like for example <code>(anyobject as Number).value = 1 as f64</code>. before only <code>a_struct.field = value</code> was possible</li>
<li>implement float literal</li>
<li>implement <code>continue</code> and <code>break</code></li>
<li>implement parenthesis, eg. <code>(1 + 2) as i64</code></li>
<li>fix accessing globals (it would previously break in some scenarios)</li>
<li>implement calling func refs</li>
<li>generalize <code>ref_test!</code>. It was only capable of checking a path like:<code>ref_test!(number, Number)</code>, now it will accept any expression, like: <code>ref_test!(numbers[1].value, Number)</code></li>
<li>implement ability to set type for store/load with <code>memory::&lt;i8&gt;[0]</code>. The default is to use <code>i32</code> store and load versions</li>
<li>fix a few instructions that were wrongly handled (like issuing I32Add<br>
      instead of I32Sub)</li>
</ul>
<p>For now I will probably slow down development of new features as I will shift my focus a bit towards Jawsm, but I'll try to improve the crate whenever I have time.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/drogus/jawsm/pull/5/files#diff-6d7bc9e99526e7f06b818a6103bd30aaa067263cc8e34a14197e1a3bcf2dd4db" style="background-image: url(&quot;https://uploads.zulipusercontent.net/ab458ccef1a6d75f3886a680276a7df9be3e0303/68747470733a2f2f617661746172732e67697468756275736572636f6e74656e742e636f6d2f752f353030343f733d34303026763d34&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/drogus/jawsm/pull/5/files#diff-6d7bc9e99526e7f06b818a6103bd30aaa067263cc8e34a14197e1a3bcf2dd4db" title="Tarnik rewrite by drogus 路 Pull Request #5 路 drogus/jawsm">Tarnik rewrite by drogus 路 Pull Request #5 路 drogus/jawsm</a></div><div class="message_embed_description">JavaScript to WASM compiler. Contribute to drogus/jawsm development by creating an account on GitHub.</div></div></div>



<a name="491268616"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/Tarnik%20-%20a%20Rust%20macro%20for%20generating%20WASM%20GC%20code/near/491268616" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Piotr Sarnacki <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/Tarnik.20-.20a.20Rust.20macro.20for.20generating.20WASM.20GC.20code.html#491268616">(Dec 30 2024 at 11:04)</a>:</h4>
<p>I don't really have any big updates as in the last weeks I've been mostly focusing on using Tarnik in JAWSM, but I have a few observations. One thing is that I feel like it speeds up a lot of the implementation, especially when I have to debug something. As code is much more concise than in WAT format, it's much easier to quickly skim the code and look for any obvious mistakes. I still need to read the WAT code from time to time, but I rely much more on the higher level code. In the recent weeks the size of the code using the wasm macro grew to almost 4k lines, which would be roughly an equivalent of 8-10k lines of WAT code and I really doubt I could work that fast in WAT (keep in mind that I only work on the project on my limited free time).</p>
<p>Another observation is that I'm outgrowing what macros are intended for in Rust, for a few reasons. I started with a macro, cause it was the easiest way to start, but there are a couple of drawbacks, with the biggest one being there is currently no way to split the code into smaller pieces. I think it might be fixable, but not entirely easy to do, cause Rust macros can't evaluate any code from outside the macro. rust-analyzer also starts to struggle with a few thousand lines in one macro <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> At some point I might just go for implementing a full blown parser (probably based on one of the Rust parsers as the syntax is very similar) that will make it easier to do more advanced stuff. I hold off for now, though, as I'm not far from implementing the entire JS syntax, so I prefer to go with "do the thing that doesn't scale first".</p>
<p>I have also a few more ideas on how to simplify the code even more, but first I would like to write a bit more code with the macro, maybe even take stab at another language like Python or Ruby. Not a full implementation, cause of limited time, but just enough to see if there are any big differences in how I structure the code to implement semantics.</p>
<p>Regarding the features for simplifying the code there are a few smaller ones that I want to do soonish, like:</p>
<ul>
<li>allow to check for null using equality, like <code>foo == null</code> instead of <code>ref_test!(foo, null)</code>. Still not sure what to do with <code>ref.test</code> in general. In theory I could allow <code>foo == Function</code>, but I don't like it too much as it conflates checking a value and checking the type. Maybe some custom operator like <code>foo is Function</code>?</li>
<li>fix some small issues like for example: <code>-1 as i31ref</code> doesn't work properly, or you can't access array elements using expressions, so only <code>foo[1]</code> works, not <code>object.foo[1]</code> nor <code>(object as Array)[1]</code> etc.</li>
<li>fix parenthesis, at the moment it doesn't really work as intended when you want to group some operators with parens</li>
</ul>
<p>Regarding bigger features, I think the two biggest ones would be enums and some lightweight trait system. As WASM doesn't really have an enum type, it would have to be simulated, but I think it won't be hard to compile it to WASM code that doesn't have any overhead - the type checking would be done mostly on compile time. At the moment I have a lot of code like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="n">ref_test</span><span class="o">!</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">value_object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Object</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ref_test</span><span class="o">!</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">Function</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">value_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Function</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ....</span>
<span class="p">}</span>
</code></pre></div>
<p>One problem here is that whenever I add a new type to be handled, I have to figure out which places I need to change. Another one is verbosity. I think it would be neat if all those ifs could be changed to a trait implementation and in places where I still have to enumerate some options, to use an enum. It would translate to a static if statement anyway, but the high level code would be much more concise. On a similar note, a match statement would then be nice too, so you can either match an enum or match on types, like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Function</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<p>maybe even with something like Rust's <code>@</code> operator:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// v here would be already cast to function maybe?</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<p>I don't think I will have time to do all of these anytime soon, but I'll be definitely pondering on these and keeping a list of stuff to do once I can get back to the library.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>