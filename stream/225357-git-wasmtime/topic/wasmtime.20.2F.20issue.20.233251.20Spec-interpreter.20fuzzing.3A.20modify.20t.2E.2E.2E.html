<html>
<head><meta charset="utf-8"><title>wasmtime / issue #3251 Spec-interpreter fuzzing: modify t... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html">wasmtime / issue #3251 Spec-interpreter fuzzing: modify t...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="250814484"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/250814484" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#250814484">(Aug 26 2021 at 18:03)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>
<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>
<p>This is sort of a breadth-vs-depth situation: the "depth" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the "breadth" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>
<p>cc @abrown @alexcrichton </p>
</blockquote>



<a name="251928659"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/251928659" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#251928659">(Sep 03 2021 at 19:10)</a>:</h4>
<p>alexcrichton labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>
<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>
<p>This is sort of a breadth-vs-depth situation: the "depth" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the "breadth" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>
<p>cc @abrown @alexcrichton </p>
</blockquote>



<a name="262089162"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262089162" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262089162">(Nov 19 2021 at 16:21)</a>:</h4>
<p>alexcrichton labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>
<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>
<p>This is sort of a breadth-vs-depth situation: the "depth" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the "breadth" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>
<p>cc @abrown @alexcrichton </p>
</blockquote>



<a name="262089163"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262089163" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262089163">(Nov 19 2021 at 16:21)</a>:</h4>
<p>alexcrichton unlabeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>
<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>
<p>This is sort of a breadth-vs-depth situation: the "depth" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the "breadth" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>
<p>cc @abrown @alexcrichton </p>
</blockquote>



<a name="262089515"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262089515" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262089515">(Nov 19 2021 at 16:23)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974215576">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "fuzzing"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: fuzzing</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="262104830"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262104830" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262104830">(Nov 19 2021 at 18:04)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974290644">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>My intuition is that combining multiple instructions, even if it is just two or three, would give us much more bang for our buck than testing single instructions.</p>
</blockquote>



<a name="262109674"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262109674" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262109674">(Nov 19 2021 at 18:39)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974314714">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>Ah, old issue, paging back in context (I'm not sure why the labeler decided to tag you just now on a discussion from August!)...</p>
<p>Yup, agreed, that's the "or a straight-line sequence with no control flow or calls" above :-)</p>
<p>Adding some more thought just now: IMHO we should do it only up to the max depth of our instruction combining patterns. The point of this suggestion was specifically to target the fuzz throughput in a different way, at the input-value space rather than the input-program space. As we test straightline sequences of <code>n</code> instructions we have <code>O(|wasm opcodes|^n)</code> possibilities, and cut our time spent (on exploring argument values) per individual test program exponentially.</p>
<p>In other words, if my goal is to say that <em>all</em> cases for (say) SIMD instruction X have been covered, then separately fuzzing <code>vector_add(X(x, y, z), [1.0, 1.0, 1.0, 1.0])</code> and <code>vector_add(X(x, y, z), [2.0, 2.0, 2.0, 2.0])</code> doesn't really add any coverage. Testing <code>vector_add(X, ...)</code> and <code>vector_mul(X, ...)</code> might, if we have combining patterns that differ for those. But combining instructions may also <em>mask</em> some of the value space, for any operation that isn't bijective (e.g. extract one lane, or multiply by zero, or min/max).</p>
<p>So, said another way, what I think would be useful is a unit-test-inspired approach where we take each individual lowering and then throw a long test-vector of argument values at it. (In other words the <code>Arbitrary</code> type is a <code>(short inst sequence, Vec&lt;ArgValues&gt;)</code>.) That gets us "each individual lowering is good" coverage in a way that might hide when we're testing <code>n</code> (for <code>n</code> larger) instructions at a time.</p>
<p>cc @abrown , any interest in looking at this as a way to get the spec interpreter in active fuzzing use?<br>
</p>
</blockquote>



<a name="262530465"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/262530465" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#262530465">(Nov 23 2021 at 23:49)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-977292607">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>I would eventually like to look into this more but if anyone else has the bandwidth feel free to jump in first (read: I'm not sure when I will get to this).</p>
</blockquote>



<a name="267009323"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/267009323" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#267009323">(Jan 05 2022 at 23:58)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-1006171689">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>@cfallin, in a separate project I did something using <code>proptest</code> that reminded me of this. The basic idea, adapted to Wasmtime, would be to:</p>
<ul>
<li>construct a single-instruction WebAssembly module</li>
<li>create random inputs using <code>proptest</code></li>
<li>run the module's sole function in two different engines and check the results for equality</li>
</ul>
<p>I wasn't too concerned with multiple-instruction sequences and other things mentioned above but if we have a place to put this <code>proptest</code>-guided fuzz test then I would be happy to contribute the code.</p>
</blockquote>



<a name="294941560"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/294941560" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#294941560">(Aug 23 2022 at 20:28)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-1224828398">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>I think this is closed by #4409 which is now in use by the new <code>differential</code> fuzz target (#4515).</p>
</blockquote>



<a name="294941561"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233251%20Spec-interpreter%20fuzzing%3A%20modify%20t.../near/294941561" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233251.20Spec-interpreter.20fuzzing.3A.20modify.20t.2E.2E.2E.html#294941561">(Aug 23 2022 at 20:28)</a>:</h4>
<p>abrown closed <a href="https://github.com/bytecodealliance/wasmtime/issues/3251">issue #3251</a>:</p>
<blockquote>
<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>
<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>
<p>This is sort of a breadth-vs-depth situation: the "depth" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the "breadth" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>
<p>cc @abrown @alexcrichton </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>