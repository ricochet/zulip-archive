<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4000 Cranelift: JIT relocations depend ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html">wasmtime / issue #4000 Cranelift: JIT relocations depend ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="278025198"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025198" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025198">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278025199"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025199" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025199">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278025200"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025200" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025200">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278026078"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278026078" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278026078">(Apr 06 2022 at 13:50)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090297821">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<blockquote>
<p>Don't allocate on the heap. Cranelift's selinux-fix features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</blockquote>
<p>I think this is the best fix. Possibly in combination with reserving the full 2GB as PROT_NONE. Allowing the GOT to be split between each such 2GB chunk should also allow more code to be used when PIC is enabled.</p>
</blockquote>



<a name="278054784"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278054784" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278054784">(Apr 06 2022 at 17:01)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090496744">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>This is covered I think by the <code>colocated</code> flag on external function definitions: the intent is to denote that a function is in the same module (hence can use near calls) or elsewhere (hence needs an absolute 64-bit relocation). <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/ir/extfunc.rs#L369-L382">This</a> flag in the <code>ExtFuncData</code> controls which kind of call is generated. It looks like this may not be surfaced in the <code>JITModule</code> API; we'd be happy to take a PR to fix that if so!</p>
</blockquote>



<a name="278060421"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278060421" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278060421">(Apr 06 2022 at 17:44)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090551603">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>That is not the problem here. The problem is that a function and the GOT or PLT it accesses may end up more than 2GB from each other due to memory fragmentation. All calls already go through the GOT and PLT anyway so for as long as those are within 2GB it doesn't matter where the function is, independent of the <code>colocated</code> flag.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>