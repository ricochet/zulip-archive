<html>
<head><meta charset="utf-8"><title>wasmtime / issue #2566 Add Webassembly backend · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html">wasmtime / issue #2566 Add Webassembly backend</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="248438374"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/248438374" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#248438374">(Aug 05 2021 at 04:57)</a>:</h4>
<p>Birbe <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-893163908">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I'm working a Java Virtual Machine implementation in Rust and one of my plans is to write a WASM backend along with a general JIT implementation using Cranelift, and if everything were unified to just be Cranelift that would be great. I might give creating a WASM backend a shot, would benefit my project as well as Cranelift</p>
</blockquote>



<a name="266441402"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266441402" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266441402">(Dec 30 2021 at 16:46)</a>:</h4>
<p>teymour-aldridge <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003104285">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I would be interested in implementing this!</p>
<p>I had a look, and I'm not sure where the correct place to implement this would be. My thought was in <code>cranelift_codegen::isa</code>, however the <code>MachBackend</code> trait seems to reply upon the existence of registers in the target architecture (which makes sense, but WebAssembly is sort-of a stack machine). Would it make sense to emulate registers by using WebAssembly locals, or is that a bad idea?</p>
</blockquote>



<a name="266441418"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266441418" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266441418">(Dec 30 2021 at 16:46)</a>:</h4>
<p>teymour-aldridge edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003104285">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I would be interested in implementing this!</p>
<p>I had a look, and I'm not sure where the correct place to implement this would be. My thought was in <code>cranelift_codegen::isa</code>, however the <code>MachBackend</code> trait seems to reply upon the existence of registers in the target architecture (which makes sense for other architectures, but WebAssembly is sort-of a stack machine). Would it make sense to emulate registers by using WebAssembly locals, or is that a bad idea?</p>
</blockquote>



<a name="266443798"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266443798" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266443798">(Dec 30 2021 at 17:25)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003118113">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Wasm is a fundamentally different architecture from all other supported architectures in that it is a stack machine rather than a register machine, it uses structured control flow rather than arbitrary jumps, allows more than one memory, ... For this reason I think you should avoid using the existing backend infrastructure. One possible implementation method would be to have an implementation of the <code>Module</code> trait from <code>cranelift_module</code> in a separate crate and then write the lowering from clif ir to wasm bytecode in this crate.</p>
</blockquote>



<a name="266456741"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266456741" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266456741">(Dec 30 2021 at 20:40)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003174897">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Indeed, this would best be structured as a separate framework that consumes Cranelift's IR, I think.</p>
<p>There are lots of resources you could look at for the various parts; the Stackifier algorithm to start with, to recover structured control flow, and then some scheme to map operators back to stack code using locals where necessary (a sort of combined regalloc and instruction-scheduling problem: reordering operators can let you use the stack directly).</p>
<p>We'll need to decide what we do about runtime-specific implementations of Wasm memories, tables, globals, and imports as well. Traditionally Cranelift has these bits filled in by the "environment", and our embedding (Wasmtime, Lucet, SpiderMonkey, something else) fills in some IR that uses e.g. machine-native pointers to implement Wasm memory/table accesses. If we compile back to Wasm, should a table just become a table, and a memory become a memory? Probably, but this will require some careful thought in the frontend/environment too. Possibly we add new IR operators (primitives) and just lower <code>table.get</code> 1-to-1 to this primitive, then back to <code>table.get</code> in the backend.</p>
<p>FWIW, I have a little side-project (<a href="https://github.com/cfallin/waffle">waffle</a>) that is attempting to be a Wasm-to-CFG-of-SSA-to-Wasm framework, which might be useful to look at to see what it takes to compile SSA IR with blockparams back to Wasm. (It kind of works: it roundtrips a hello-world, but has some bugs beyond that. Side-project, no guarantees, etc!)</p>
</blockquote>



<a name="266456776"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266456776" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266456776">(Dec 30 2021 at 20:41)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003174897">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Indeed, this would best be structured as a separate framework that consumes Cranelift's IR, I think.</p>
<p>There are lots of resources you could look at for the various parts; the Stackifier algorithm to start with, to recover structured control flow, and then some scheme to map operators back to stack code using locals where necessary (a sort of combined regalloc and instruction-scheduling problem: reordering operators can let you use the stack directly).</p>
<p>We'll need to decide what we do about runtime-specific implementations of Wasm memories, tables, globals, and imports as well (EDIT: when using the <code>cranelift-wasm</code> frontend). Traditionally <code>cranelift-wasm</code> has these bits filled in by the "environment", and our embedding (Wasmtime, Lucet, SpiderMonkey, something else) fills in some IR that uses e.g. machine-native pointers to implement Wasm memory/table accesses. If we compile back to Wasm, should a table just become a table, and a memory become a memory? Probably, but this will require some careful thought in the frontend/environment too. Possibly we add new IR operators (primitives) and just lower <code>table.get</code> 1-to-1 to this primitive, then back to <code>table.get</code> in the backend.</p>
<p>FWIW, I have a little side-project (<a href="https://github.com/cfallin/waffle">waffle</a>) that is attempting to be a Wasm-to-CFG-of-SSA-to-Wasm framework, which might be useful to look at to see what it takes to compile SSA IR with blockparams back to Wasm. (It kind of works: it roundtrips a hello-world, but has some bugs beyond that. Side-project, no guarantees, etc!)</p>
</blockquote>



<a name="266462643"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266462643" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266462643">(Dec 30 2021 at 22:13)</a>:</h4>
<p>Birbe <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003197585">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<blockquote>
<p>There are lots of resources you could look at for the various parts; the Stackifier algorithm to start with,</p>
</blockquote>
<p><a href="https://docs.rs/relooper/latest/relooper/">https://docs.rs/relooper/latest/relooper/</a> might be a good way to easily implement this (I believe it actually implements the <a href="https://medium.com/leaningtech/solving-the-structured-control-flow-problem-once-and-for-all-5123117b1ee2">stackifier</a> algorithm even though it's called relooper)</p>
</blockquote>



<a name="266562427"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266562427" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266562427">(Jan 01 2022 at 15:34)</a>:</h4>
<p>teymour-aldridge <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003574642">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<blockquote>
<p>There are lots of resources you could look at for the various parts; the Stackifier algorithm to start with, to recover structured control flow, and then some scheme to map operators back to stack code using locals where necessary (a sort of combined regalloc and instruction-scheduling problem: reordering operators can let you use the stack directly).</p>
</blockquote>
<p>I'm not sure how <code>regalloc</code> could be used to translate operators to stack code. Would you mind elaborating (a link to something explaining the idea would be great if you have one).</p>
<p>My thoughts were that this should be done by recursively inserting WebAssembly instructions to compute <code>Value</code>s.</p>
<p>So something like:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">instruction_code</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">operand</span><span class="w"></span>
<span class="w">    </span><span class="n">instruction_code</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">code</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="p">(</span><span class="n">apply</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">push</span><span class="p">)</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>



<a name="266563198"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266563198" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266563198">(Jan 01 2022 at 15:57)</a>:</h4>
<p>teymour-aldridge edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003574642">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Thank you for the advice!</p>
<blockquote>
<p>There are lots of resources you could look at for the various parts; the Stackifier algorithm to start with, to recover structured control flow, and then some scheme to map operators back to stack code using locals where necessary (a sort of combined regalloc and instruction-scheduling problem: reordering operators can let you use the stack directly).</p>
</blockquote>
<p>I'm not sure how <code>regalloc</code> could be used to translate operators to stack code. Would you mind elaborating (a link to something explaining the idea would be great if you have one).</p>
<p>My thoughts were that this should be done by recursively inserting WebAssembly instructions to compute <code>Value</code>s.</p>
<p>So something like:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">instruction_code</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">operand</span><span class="w"></span>
<span class="w">    </span><span class="n">instruction_code</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">code</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="p">(</span><span class="n">apply</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">push</span><span class="p">)</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>



<a name="266571075"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266571075" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266571075">(Jan 01 2022 at 19:18)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003604703">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>That scheme is a good start, and works for tree-shaped code, but not DAG-shaped code: as soon as an operator (SSA value) is used more than once, you either need to recompute it or store it in a local and then reload it at each use-site.</p>
<p>The use of locals to store SSA values is the register allocation problem -- with a range of solutions, from a "one local (register) per SSA value" approach up to more sophisticated approaches that reuse locals. Given Wasm engines' limits on locals, and given the way that baseline Wasm compilers allocate separate stack slots for each local (leading to huge stackframes if we are not frugal with locals), we probably want to do something better than one-local-per-value.</p>
<p>The reason I described this as a "combined regalloc / instruction scheduling problem" is that the two are intertwined. Once we've decided to use locals to carry values, we could do the simplest thing and emit <code>local.get</code> for every operand, then the operator, then <code>local.set</code>. But that's also inefficient; we want to use the stack when we can. So the order of operators matters. Your scheme (recursive value generation) is actually doing implicit code-motion in order to take advantage of stack dataflow (by sinking operators to use-sites), which is great, and what we want. But we have to be careful about it for two reasons:</p>
<ul>
<li>Some operators have side-effects, so we have to be careful about moving them. We can slide them over pure operators but not other side-effecting operators. (Trapping is a side-effect too, so this is not just for loads/stores/calls.)</li>
<li>When a value is used more than once, we need to choose a location to compute it that dominates all of its use-sites. We can't, for example, just generate it onto the stack on demand the first time it's used then save it in a local for later times -- consider when two branches of an if-else use a value computed before the control-flow split.</li>
</ul>
<p>In the most general form of the problem, we could also consider rematerialization: some operations (such as, e.g., <code>i32.iconst 0</code>) are trivial to compute and so it would probably not be a good idea to compute this once at the top of the function (GVN will often dedup constants like tihs) and store it in a local thereafter. Rematerialization can be considered part of the regalloc problem (because a regalloc might not want to spill and remat is then an option) and some regalloc implementations can do this; one can also do it in a more ad-hoc way in the code one generates prior to allocating registers.</p>
<p>A scheme that  might work is to "treeify" the operands before generating code. Basically each operand of an operator could then be:</p>
<ul>
<li><code>SingleUse(Value)</code>: We are the only use of the value, and the operator that produces it is pure, so it will be generated in-place on the stack (your scheme);</li>
<li><code>NormalUse(Value)</code>: We are one of several uses of the value; it should be generated into a local at its original location in the program, then loaded here; or</li>
<li><code>Rematerialize(Value)</code>: We replicate the operator here. Used for pure ops like <code>iconst</code> only.</li>
</ul>
<p>So one would generate ops in original program location if used by a <code>NormalUse</code> elsewhere, and otherwise only at the use-site. This would result in code that then refers to values, which we can subsequently do register allocation over to assign to locals.</p>
<p>There's not really a good document on this that I know of; it's just applications of general concepts (regalloc, remat, instruction scheduling) to a specific and somewhat odd target. We're inventing as we go here. That said it'd probably be good to understand how e.g. LLVM's Wasm backend does this; I haven't really looked at the dataflow side (just the stackifier).</p>
<p>Anyway hopefully this helps!</p>
</blockquote>



<a name="266571098"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266571098" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266571098">(Jan 01 2022 at 19:19)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003604703">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>That scheme is a good start, and works for tree-shaped code, but not DAG-shaped code: as soon as an operator (SSA value) is used more than once, you either need to recompute it or store it in a local and then reload it at each use-site.</p>
<p>The use of locals to store SSA values is the register allocation problem -- with a range of solutions, from a "one local (register) per SSA value" approach up to more sophisticated approaches that reuse locals. Given Wasm engines' limits on locals, and given the way that baseline Wasm compilers allocate separate stack slots for each local (leading to huge stackframes if we are not frugal with locals), we probably want to do something better than one-local-per-value.</p>
<p>The reason I described this as a "combined regalloc / instruction scheduling problem" is that the two are intertwined. Once we've decided to use locals to carry values, we could do the simplest thing and emit <code>local.get</code> for every operand, then the operator, then <code>local.set</code>. But that's also inefficient; we want to use the stack when we can. So the order of operators matters. Your scheme (recursive value generation) is actually doing implicit code-motion in order to take advantage of stack dataflow (by sinking operators to use-sites), which is great, and what we want. But we have to be careful about it for two reasons:</p>
<ul>
<li>Some operators have side-effects, so we have to be careful about moving them. We can slide them over pure operators but not other side-effecting operators. (Trapping is a side-effect too, so this is not just for loads/stores/calls.)</li>
<li>When a value is used more than once, we need to choose a location to compute it that dominates all of its use-sites. We can't, for example, just generate it onto the stack on demand the first time it's used then save it in a local for later times -- consider when two branches of an if-else use a value computed before the control-flow split.</li>
</ul>
<p>In the most general form of the problem, we could also consider rematerialization: some operations (such as, e.g., <code>i32.const 0</code>) are trivial to compute and so it would probably not be a good idea to compute this once at the top of the function (GVN will often dedup constants like this) and store it in a local thereafter. Rematerialization can be considered part of the regalloc problem (because a regalloc might not want to spill and remat is then an option) and some regalloc implementations can do this; one can also do it in a more ad-hoc way in the code one generates prior to allocating registers.</p>
<p>A scheme that  might work is to "treeify" the operands before generating code. Basically each operand of an operator could then be:</p>
<ul>
<li><code>SingleUse(Value)</code>: We are the only use of the value, and the operator that produces it is pure, so it will be generated in-place on the stack (your scheme);</li>
<li><code>NormalUse(Value)</code>: We are one of several uses of the value; it should be generated into a local at its original location in the program, then loaded here; or</li>
<li><code>Rematerialize(Value)</code>: We replicate the operator here. Used for pure ops like <code>iconst</code> only.</li>
</ul>
<p>So one would generate ops in original program location if used by a <code>NormalUse</code> elsewhere, and otherwise only at the use-site. This would result in code that then refers to values, which we can subsequently do register allocation over to assign to locals.</p>
<p>There's not really a good document on this that I know of; it's just applications of general concepts (regalloc, remat, instruction scheduling) to a specific and somewhat odd target. We're inventing as we go here. That said it'd probably be good to understand how e.g. LLVM's Wasm backend does this; I haven't really looked at the dataflow side (just the stackifier).</p>
<p>Anyway hopefully this helps!</p>
</blockquote>



<a name="266633462"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/266633462" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#266633462">(Jan 02 2022 at 21:18)</a>:</h4>
<p>teymour-aldridge <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1003776704">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Thanks so much!</p>
</blockquote>



<a name="267068958"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/267068958" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#267068958">(Jan 06 2022 at 14:51)</a>:</h4>
<p>teymour-aldridge <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1006651633">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I have started to implement something in: <a href="https://github.com/teymour-aldridge/cranelift_codegen_wasm">https://github.com/teymour-aldridge/cranelift_codegen_wasm</a></p>
<p>Unfortunately there are quite a few bugs and many things (e.g. data objects, instructions) are not yet supported.</p>
</blockquote>



<a name="281219054"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/281219054" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#281219054">(May 04 2022 at 21:02)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>Add a Cranelift backend that compiles to Webassembly.</p>
<h4>Benefit</h4>
<p>This would allow a compiler to run in the browser and compile code to run in the browser.</p>
<h4>Implementation</h4>
<p>No plan yet</p>
<h4>Alternatives</h4>
<p>Not adding a Webassembly backend.</p>
</blockquote>



<a name="281219059"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/281219059" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#281219059">(May 04 2022 at 21:02)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>Add a Cranelift backend that compiles to Webassembly.</p>
<h4>Benefit</h4>
<p>This would allow a compiler to run in the browser and compile code to run in the browser.</p>
<h4>Implementation</h4>
<p>No plan yet</p>
<h4>Alternatives</h4>
<p>Not adding a Webassembly backend.</p>
</blockquote>



<a name="315730209"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/315730209" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#315730209">(Dec 14 2022 at 03:37)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1350345180">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Since I chanced upon this issue again, I'll leave a note that my <a href="https://github.com/cfallin/waffle">waffle</a> crate now has a working Wasm compilation pipeline from an SSA-based IR that is very similar to Cranelift's IR. It could serve either as the model for, or as a codegen library for, a WebAssembly backend for Cranelift. It currently requires reducible control flow (will panic when given an irreducible CFG) but this is "just" an implementation question, as the API is based on a standard CFG. The crate has been fuzzed with roundtrip + differential execution and is in a fairly robust state (can roundtrip complex Wasms like SpiderMonkey).</p>
<p>The main challenge that remains is in the semantic gap between Wasm and CLIF: lowering loses information about tables, heaps, globals and the like, and we would need to "lift" CLIF's raw memory accesses back to Wasm-level concepts. That's maybe not so bad though: one could use a "null" environment when lowering the Wasm, leaving heap accesses to memory zero as-is (address computation is the identity function), and then compile accesses to raw memory in CLIF back to accesses to a single Wasm memory. Function pointers (taking the address of symbols) will require some care. Also, CLIF is not exactly 1-to-1 with Wasm opcodes, especially the SIMD ones. But, doable. This is probably a 1-2 month project for someone at this point.</p>
</blockquote>



<a name="315730528"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/315730528" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#315730528">(Dec 14 2022 at 03:42)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1350348043">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>(I'll note too that some of my thoughts above are specific to a "Wasm roundtripping" context, which probably is actually the least interesting application; serving as a backend for something that starts with a native-code model, like cg_clif, is more interesting, and for that the mappings are a little simpler. One raw address space goes to one Wasm memory, and all function pointers are indices into one table, with entries populated as we observe function-address operators. I guess there is just the question of "relocations" for external symbol references.)</p>
</blockquote>



<a name="315802566"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/315802566" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#315802566">(Dec 14 2022 at 12:07)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1351206821">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I just took a look at waffle, but it seems basically everything necessary to build a module is private. Would it make sense to move the wasm frontend to a separate crate. This way everything the wasm frontend and other frontends need is forced to be public.</p>
</blockquote>



<a name="315802610"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/315802610" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#315802610">(Dec 14 2022 at 12:07)</a>:</h4>
<p>bjorn3 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1351206821">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>I just took a look at waffle, but it seems basically everything necessary to build a module is private. Would it make sense to move the wasm frontend to a separate crate? This way everything the wasm frontend and other frontends need is forced to be public.</p>
</blockquote>



<a name="315855282"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/315855282" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#315855282">(Dec 14 2022 at 16:08)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1351699864">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<blockquote>
<p>I just took a look at waffle, but it seems basically everything necessary to build a module is private. Would it make sense to move the wasm frontend to a separate crate? This way everything the wasm frontend and other frontends need is forced to be public.</p>
</blockquote>
<p>Yes, for sure; the crate's API polish hasn't gotten much attention, it was just codeveloped for a single initial purpose (roundtripping with modifications). Happy to discuss further there and/or take PRs from folks :-)</p>
</blockquote>



<a name="389098610"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/389098610" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#389098610">(Sep 05 2023 at 04:02)</a>:</h4>
<p>madsmtm <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-1705914568">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>A WebAssembly backend would likely be very useful for projects like <a href="https://github.com/ruffle-rs/ruffle">Ruffle</a> as well</p>
</blockquote>



<a name="431226633"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/431226633" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#431226633">(Apr 04 2024 at 05:15)</a>:</h4>
<p>skyne98 <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2036206615">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Hi, thanks for the amazing work! Any plans for this? Really excited for the feature, will allow me to drop wasm-opt as a dependency in lots of my projects <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span> (+ working with cranelift is generally very pleasant!).</p>
<p>@bjorn3 </p>
</blockquote>



<a name="431331452"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/431331452" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#431331452">(Apr 04 2024 at 14:49)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2037423224">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>@skyne98 we don't have anyone looking at this right now, and as it's a large engineering project, it's unlikely to be prioritized by the folks who work on Cranelift full-time. That doesn't mean we wouldn't like to have it, just that there are other things that are more important, and time is limited.</p>
<p>As always with an open-source project, I'd be happy to review a PR from anyone who wants this and builds it!</p>
</blockquote>



<a name="431333042"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/431333042" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#431333042">(Apr 04 2024 at 14:56)</a>:</h4>
<p>skyne98 <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2037440296">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Of course, thanks for the reply, much appreciated! It seems like a project that requires quite a bit of expertise, based on your comments, so I hope someone can pick it up one day! (Or I get confident enough with it to help out <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>). </p>
<p>One quick question, if you don't mind: does running WASM in embedded wasmtime (with optimizations turned on &amp; cranelift) already fully utilizes cranelift's optimization capability? And, also, is there potentially a way I get yonk the optimized IR out of the pipeline to print it and check it?</p>
</blockquote>



<a name="431346799"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/431346799" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#431346799">(Apr 04 2024 at 15:56)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2037596606">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Wasmtime does turn on Cranelift's optimizations by default, yes (this can be controlled with <code>-O opt-level=N</code>, 0 for off and 2 for all on. You can get unoptimized IR with <code>wasmtime compile --emit-clif</code>; optimized IR could be printed with a similar option, but you'd need to add similar code around <a href="https://github.com/bytecodealliance/wasmtime/blob/c1741470798dfe3bb8e8273bb35cc11e5299ba64/crates/cranelift/src/compiler.rs#L749">here</a> (and handle the cached case somehow?) using logic similar to [this}https://github.com/bytecodealliance/wasmtime/blob/c1741470798dfe3bb8e8273bb35cc11e5299ba64/crates/cranelift/src/compiler.rs#L216-L225). Or, as a hack, <code>println!()</code> it directly at that point.</p>
</blockquote>



<a name="431346880"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/431346880" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#431346880">(Apr 04 2024 at 15:56)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2037596606">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Wasmtime does turn on Cranelift's optimizations by default, yes (this can be controlled with <code>-O opt-level=N</code>, 0 for off and 2 for all on. You can get unoptimized IR with <code>wasmtime compile --emit-clif</code>; optimized IR could be printed with a similar option, but you'd need to add similar code around <a href="https://github.com/bytecodealliance/wasmtime/blob/c1741470798dfe3bb8e8273bb35cc11e5299ba64/crates/cranelift/src/compiler.rs#L749">here</a> (and handle the cached case somehow?) using logic similar to <a href="https://github.com/bytecodealliance/wasmtime/blob/c1741470798dfe3bb8e8273bb35cc11e5299ba64/crates/cranelift/src/compiler.rs#L216-L225">this</a>. Or, as a hack, <code>println!()</code> it directly at that point.</p>
</blockquote>



<a name="433297572"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%232566%20Add%20Webassembly%20backend/near/433297572" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.232566.20Add.20Webassembly.20backend.html#433297572">(Apr 15 2024 at 13:54)</a>:</h4>
<p>skyne98 <a href="https://github.com/bytecodealliance/wasmtime/issues/2566#issuecomment-2056922320">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2566">issue #2566</a>:</p>
<blockquote>
<p>Would have been nice to be able to pass optional callbacks to hook into different parts of the pipeline <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span> </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>