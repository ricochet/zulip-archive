<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #1385 Re-design constant pools · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html">wasmtime / Issue #1385 Re-design constant pools</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="191506795"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/191506795" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#191506795">(Mar 23 2020 at 17:19)</a>:</h4>
<p>abrown opened <a href="https://github.com/bytecodealliance/wasmtime/issues/1385" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>This is an open-ended issue for re-designing Cranelift's constant pools. In #1377 I added the ability to calculate the address of constants using <code>const_addr</code> and to declare constants in function preambles (e..g <code>const42 = [0 1 2...]</code>). Constant pools are still implemented at the function level, though, so there is no coalescing of constant values across functions.</p>
<p>I added the function-level <code>ConstantPool</code> implementation in order to support SIMD constants (which don't fit in the immediate fields of Cranelift's IR). This is not a pressing issue yet, but before other components start using constants, it might be good to discuss:</p>
<ul>
<li>should we implement constant pools at the global level and what would this look like?</li>
<li>what should the relocation hooks look like for a more general constant pool implementation? Currently the interface looks like <code>RelocSink::reloc_constant(&amp;mut self, CodeOffset, Reloc, ConstantOffset)</code> and this may need to change.</li>
</ul>
</blockquote>



<a name="192093439"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/192093439" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#192093439">(Mar 27 2020 at 23:44)</a>:</h4>
<p>abrown labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/1385" title="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>This is an open-ended issue for re-designing Cranelift's constant pools. In #1377 I added the ability to calculate the address of constants using <code>const_addr</code> and to declare constants in function preambles (e..g <code>const42 = [0 1 2...]</code>). Constant pools are still implemented at the function level, though, so there is no coalescing of constant values across functions.</p>
<p>I added the function-level <code>ConstantPool</code> implementation in order to support SIMD constants (which don't fit in the immediate fields of Cranelift's IR). This is not a pressing issue yet, but before other components start using constants, it might be good to discuss:</p>
<ul>
<li>should we implement constant pools at the global level and what would this look like?</li>
<li>what should the relocation hooks look like for a more general constant pool implementation? Currently the interface looks like <code>RelocSink::reloc_constant(&amp;mut self, CodeOffset, Reloc, ConstantOffset)</code> and this may need to change.</li>
</ul>
</blockquote>



<a name="214635216"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/214635216" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#214635216">(Oct 26 2020 at 21:25)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer; to implement this instruction, we would have to search through </code>MachBuffer::pending_constants<code> to find a value that matched the </code>ConstantData<code> behind its </code>const_addr<code>'s </code>Constant` handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[ ] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[ ] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li><code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.</li>
</ul>
</blockquote>



<a name="214635268"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/214635268" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#214635268">(Oct 26 2020 at 21:25)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer; to implement this instruction, we would have to search through </code>MachBuffer::pending_constants<code> to find a value that matched the </code>ConstantData<code> behind its </code>const_addr<code>'s </code>Constant` handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[ ] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[ ] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[ ] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.</li>
</ul>
</blockquote>



<a name="214636285"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/214636285" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#214636285">(Oct 26 2020 at 21:35)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer</code>; to implement this instruction, we would have to search through <code>MachBuffer::pending_constants</code> to find a value that matched the <code>ConstantData</code> behind its <code>const_addr</code>'s <code>Constant</code> handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[ ] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[ ] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[ ] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.</li>
</ul>
</blockquote>



<a name="214643215"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/214643215" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#214643215">(Oct 26 2020 at 22:56)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716868734">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>Hi @abrown -- thanks for the detailed look into this!</p>
<p><code>MachBuffer::defer_constant</code> is indeed the way forward here; the infra is built to emit constant pools, but just isn't wired up yet.</p>
<p>The API expects the client (so, the lowering code) to allocate its own labels, and specify the label for each constant. So the most straightforward thing to do here would be, for constants in the <code>ConstantPool</code>, make an initial pass over them and allocate labels, keeping them in a table. Then the lookup from constant-pool handle to <code>MachLabel</code> is just an array access. Or, slightly better, we lazily emit deferred constants, and the lookup table holds <code>Option&lt;MachLabel&gt;</code>.</p>
<p>I think we should probably build that first before deduplication at the MachInst-lowering level; I'm not fully convinced that the overhead of a hashmap lookup on every new constant generation is worth the potential code-size reduction (but we should measure).</p>
<p>So I would say we should:</p>
<ul>
<li>Clean up the constant-related APIs on <code>x64::MachInst</code> and <code>LowerCtx</code>, as you suggest</li>
<li>Add a table to the <code>LowerCtx</code> tracking labels for every constant, emitting on first request. Then we have something like <code>LowerCtx::constant_pool_label(...)</code>.</li>
<li>Eventually, deduplicate inside <code>LowerCtx</code> if we find it to be worthwhile.</li>
</ul>
</blockquote>



<a name="214646702"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/214646702" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#214646702">(Oct 26 2020 at 23:48)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716886840">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>Yeah, I like this better. I'll try it out and see what happens!</p>
</blockquote>



<a name="218373318"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/218373318" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#218373318">(Dec 01 2020 at 02:16)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer</code>; to implement this instruction, we would have to search through <code>MachBuffer::pending_constants</code> to find a value that matched the <code>ConstantData</code> behind its <code>const_addr</code>'s <code>Constant</code> handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[ ] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[ ] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[x] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.<br>
</li>
</ul>
</blockquote>



<a name="218373455"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/218373455" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#218373455">(Dec 01 2020 at 02:19)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer</code>; to implement this instruction, we would have to search through <code>MachBuffer::pending_constants</code> to find a value that matched the <code>ConstantData</code> behind its <code>const_addr</code>'s <code>Constant</code> handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[ ] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[x] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[x] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.<br>
</li>
</ul>
</blockquote>



<a name="218630444"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/218630444" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#218630444">(Dec 02 2020 at 22:39)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer</code>; to implement this instruction, we would have to search through <code>MachBuffer::pending_constants</code> to find a value that matched the <code>ConstantData</code> behind its <code>const_addr</code>'s <code>Constant</code> handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[ ] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[x] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[x] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[x] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.<br>
</li>
</ul>
</blockquote>



<a name="218630446"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231385%20Re-design%20constant%20pools/near/218630446" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231385.20Re-design.20constant.20pools.html#218630446">(Dec 02 2020 at 22:39)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1385#issuecomment-716832771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1385">Issue #1385</a>:</p>
<blockquote>
<p>@cfallin, now that I think I understand the new backend better, I think this issue can be moved a bit further:</p>
<h3>How things currently work in the new backend:</h3>
<ul>
<li>at the emission level, <code>MachBuffer::pending_constants</code> is the vector containing the constant values; eventually these get emitted into the buffer and the <code>MachLabel</code>s are fixed up</li>
<li><code>MachBuffer::defer_constant(label, align, data, max_distance)</code> is the user-accessible way to add a constant during emission (e.g. see uses of <code>sink.defer_constant...</code> in <code>emit.rs</code>)</li>
<li><code>Inst::gen_constant</code> is the user-accessible way to create constant-generating instructions during lowering, but it only accepts values up to <code>u64</code> in size</li>
<li>
<p>so there are problems:</p>
<ol>
<li><code>Inst::gen_constant</code> cannot be used to generate vector values</li>
<li><code>MachBuffer::defer_constant</code> will duplicate constant values</li>
<li><code>const_addr</code> (a way to retrieve the address of constants for read-only table lookups) does not know which <code>MachLabel</code> to use in <code>MachBuffer</code>; to implement this instruction, we would have to search through <code>MachBuffer::pending_constants</code> to find a value that matched the <code>ConstantData</code> behind its <code>const_addr</code>'s <code>Constant</code> handle</li>
</ol>
</li>
</ul>
<h3>To simplify the creation of vector constants (all constants, really):</h3>
<ul>
<li>[x] change the signature of <code>MachInst::gen_constant</code> to accept a <code>DataValue</code> instead of a <code>u64</code> (involves fixing up 9 uses of this method)</li>
<li>[ ] search through <code>lower.rs</code> to see other places that should be using <code>gen_constant</code> but are not (e.g. using <code>PXOR</code> directly)</li>
<li>[x] add a way for gen_constant to generate vectors of all 0s (<code>PXOR/XORPS/XORPD</code>) and all 1s (<code>CMPPS/PCMPEQ</code>)</li>
<li>[x] modify <code>Inst::XmmLoadConstSeq</code> to become <code>XmmLoadConst</code>--instead of emitting the vector inline with the function code it would use <code>sink.defer_constant</code></li>
<li>
<p>all of this suggests some related refactoring:</p>
<ol>
<li>remove <code>LowerCtx::get_constant</code>: <code>LowerCtx::get_constant</code> and <code>LowerCtx::get_immediate</code> are doing the same thing except that <code>get_constant</code> returns a <code>u64</code> instead of the larger <code>DataValue</code></li>
<li>this affects <code>LowerCtx::get_input</code>, which returns a <code>LowerInput</code> with a <code>constant: Option&lt;u64&gt;</code> field--this field could go away (12 uses), replaced by <code>ctx.get_immediate(...)</code></li>
</ol>
</li>
</ul>
<h3>To keep ConstantPool's de-duplicated values AND allow const_addr to retrieve the address of a constant:</h3>
<ul>
<li>[x] <code>MachBuffer::defer_constant</code> should keep a mapping of constant values to <code>MachLabels</code> (e.g. a <code>HashMap</code>?) and only return the <code>MachLabel</code> for a given value, de-duplicating them</li>
<li>this is redundant work since <code>ConstantPool</code> has already done this, but it is necessary work because lowering could introduce new constant values</li>
<li>I struggle with how to approach this inefficiency (suggestions?): this approach would mean that entire values would have to hashed/compared every time they are used (unlike <code>ConstantPool</code>, which uses <code>Constant(u32)</code> handles)... but perhaps this could be optimized in the future</li>
<li>perhaps we can even genericize the ConstantPool and reuse it?</li>
</ul>
<h3>When the old backend goes away:</h3>
<ul>
<li><code>ConstantPool</code> can be simplified: <code>ConstantPool::get_offset</code>, <code>ConstantPool::set_offset</code>, <code>binemit::const_disp4</code> can all go away since they are only necessary to work around old backend quirks.<br>
</li>
</ul>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>