<html>
<head><meta charset="utf-8"><title>wasmtime / PR #8516 WIP: cranelift: omit function prologu... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html">wasmtime / PR #8516 WIP: cranelift: omit function prologu...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="436476724"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436476724" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436476724">(May 01 2024 at 09:58)</a>:</h4>
<p>tertsdiepraam opened <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a> from <code>tertsdiepraam:preserve-fp-false-x64</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
<p>This makes cranelift omit the function prologue and epilogue on the x64 architecture if possible, like it already does for aarch64.</p>
<p>However, this is not quite right yet, because (if I understand correctly) the <code>is_leaf</code> computation is wrong for x64 when SIMD instructions are involved. With this change, this function gives a segfault:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">swizzle_i8x16</span><span class="p">(</span><span class="n">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">i8x16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">i8x16</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="nc">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="nc">i8x16</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swizzle</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v2</span>
<span class="p">}</span>
</code></pre></div>
<p>I think this happens because it generated this assembly:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">pushq</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">paddusb</span><span class="w"> </span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">xmm1</span>
<span class="n">movabsq</span><span class="w"> </span><span class="cp">$</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">r9</span>
<span class="n">callq</span><span class="w">   </span><span class="o">*%</span><span class="n">r9</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rsp</span>
<span class="n">popq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">retq</span>
<span class="n">addb</span><span class="w">    </span><span class="o">%</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">)</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x92</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x94</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x96</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x98</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9a</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9c</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9e</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0xa0</span>
</code></pre></div>
<p>Note that there's a <code>callq</code> in there, which means that this is not a leaf function, but according to the architecture-independent <code>is_leaf</code> function of <code>FunctionStencil</code> it looks like a leaf function, because that only considers calls in CLIF.</p>
<p>This means that I need some advice on how to proceed. I could try to make the <code>is_leaf</code> function architecture-dependent or conservatively treat (some?) SIMD instructions as calls in general. Or maybe the information that I need is already computed somewhere and I just need to pass that in?<br>
</p>
</blockquote>



<a name="436477851"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436477851" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436477851">(May 01 2024 at 10:08)</a>:</h4>
<p>tertsdiepraam edited <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
<p>This makes cranelift omit the function prologue and epilogue on the x64 architecture if possible, like it already does for aarch64.</p>
<p>However, this is not quite right yet, because (if I understand correctly) the <code>is_leaf</code> computation is wrong for x64 when SIMD instructions are involved. With this change, this function gives a segfault:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">swizzle_i8x16</span><span class="p">(</span><span class="n">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">i8x16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">i8x16</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="nc">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="nc">i8x16</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swizzle</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v2</span>
<span class="p">}</span>
</code></pre></div>
<p>I think this happens because it generated this assembly:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">pushq</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">paddusb</span><span class="w"> </span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">xmm1</span>
<span class="n">movabsq</span><span class="w"> </span><span class="cp">$</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">r9</span>
<span class="n">callq</span><span class="w">   </span><span class="o">*%</span><span class="n">r9</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rsp</span>
<span class="n">popq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">retq</span>
<span class="n">addb</span><span class="w">    </span><span class="o">%</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">)</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x92</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x94</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x96</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x98</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9a</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9c</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9e</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0xa0</span>
</code></pre></div>
<p>Note that there's a <code>callq</code> in there, which means that this is not a leaf function, but according to the architecture-independent <code>is_leaf</code> function of <code>FunctionStencil</code> it looks like a leaf function, because that only considers calls in CLIF.</p>
<p>With ssse3 the call disappears and the test passes.</p>
<p>This means that I need some advice on how to proceed. I could try to make the <code>is_leaf</code> function architecture-dependent or conservatively treat (some?) SIMD instructions as calls in general. Or maybe the information that I need is already computed somewhere and I just need to pass that in?<br>
</p>
</blockquote>



<a name="436478328"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436478328" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436478328">(May 01 2024 at 10:14)</a>:</h4>
<p>tertsdiepraam edited <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
<p>This makes cranelift omit the function prologue and epilogue on the x64 architecture if possible, like it already does for aarch64.</p>
<p>However, this is not quite right yet, because (if I understand correctly) the <code>is_leaf</code> computation is wrong for x64 when SIMD instructions are involved. With this change, this function gives a segfault:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">swizzle_i8x16</span><span class="p">(</span><span class="n">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">i8x16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">i8x16</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="nc">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="nc">i8x16</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swizzle</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v2</span>
<span class="p">}</span>
</code></pre></div>
<p>I think this happens because it generated this assembly:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">pushq</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">paddusb</span><span class="w"> </span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">xmm1</span>
<span class="n">movabsq</span><span class="w"> </span><span class="cp">$</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">r9</span>
<span class="n">callq</span><span class="w">   </span><span class="o">*%</span><span class="n">r9</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rsp</span>
<span class="n">popq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">retq</span>
<span class="n">addb</span><span class="w">    </span><span class="o">%</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">)</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x92</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x94</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x96</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x98</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9a</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9c</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9e</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0xa0</span>
</code></pre></div>
<p>Note that there's a <code>callq</code> in there, which means that this is not a leaf function, but according to the architecture-independent <code>is_leaf</code> function of <code>FunctionStencil</code> it looks like a leaf function, because that only considers calls in CLIF.</p>
<p>With ssse3 the call disappears and the test passes.</p>
<p>This means that I need some advice on how to proceed. I could try to make the <code>is_leaf</code> function architecture-dependent or conservatively treat (some?) SIMD instructions as calls in general. Or maybe the information that I need is already computed somewhere and I just need to pass that in? Or I could remove this optimization if ssse3 or later is not supported, but that doesn't seem great <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> <br>
</p>
</blockquote>



<a name="436479920"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436479920" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436479920">(May 01 2024 at 10:31)</a>:</h4>
<p>tertsdiepraam edited <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
<p>This makes cranelift omit the function prologue and epilogue on the x64 architecture if possible, like it already does for aarch64.</p>
<p>However, this is not quite right yet, because (if I understand correctly) the <code>is_leaf</code> computation is wrong for x64 when SIMD instructions are involved. With this change, this function gives a segfault:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">swizzle_i8x16</span><span class="p">(</span><span class="n">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">i8x16</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">i8x16</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="nc">i8x16</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="nc">i8x16</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swizzle</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v2</span>
<span class="p">}</span>
</code></pre></div>
<p>I think this happens because it generated this assembly:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">pushq</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">paddusb</span><span class="w"> </span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="n">xmm1</span>
<span class="n">movabsq</span><span class="w"> </span><span class="cp">$</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">r9</span>
<span class="n">callq</span><span class="w">   </span><span class="o">*%</span><span class="n">r9</span>
<span class="n">movq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">rsp</span>
<span class="n">popq</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="n">retq</span>
<span class="n">addb</span><span class="w">    </span><span class="o">%</span><span class="n">al</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="n">rax</span><span class="p">)</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x92</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x94</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x96</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x98</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9a</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9c</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0x9e</span>
<span class="n">jo</span><span class="w">      </span><span class="mh">0xa0</span>
</code></pre></div>
<p>Note that there's a <code>callq</code> in there, which means that this is not a leaf function, but according to the architecture-independent <code>is_leaf</code> function of <code>FunctionStencil</code> it looks like a leaf function, because that only considers calls in CLIF.</p>
<p>With ssse3 the call disappears and the test passes.</p>
<p>This means that I need some advice on how to proceed. I could try to make the <code>is_leaf</code> function architecture-dependent or conservatively treat (some?) SIMD instructions as calls in general. Or maybe the information that I need is already computed somewhere and I just need to pass that in? Or I could remove this optimization if ssse3 or later is not supported, but that doesn't seem great <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> </p>
<p>This replaces <a href="https://github.com/bytecodealliance/wasmtime/pull/5352">https://github.com/bytecodealliance/wasmtime/pull/5352</a> and is a follow up of <a href="https://github.com/bytecodealliance/wasmtime/pull/2960">https://github.com/bytecodealliance/wasmtime/pull/2960</a>. I'm not sure why I'm getting to the conclusion that SIMD is the issue, but it wasn't mentioned before. Maybe there are other issues as well. Has the testing setup become more robust in the meantime?</p>
</blockquote>



<a name="436580517"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436580517" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436580517">(May 01 2024 at 22:09)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2089218154">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Neat! I was thinking about working on this soon, because the work that Trevor and I have been doing on cleaning up tail calls has fixed some of the issues that would have made this even harder. But it's even cooler to see somebody else tackling this and I would love to see you continue.</p>
<p>One thing I notice is that <code>cranelift/filetests/filetests/isa/x64/simd-lane-access-compile.clif</code> turns on SSSE3, so the case you're running into isn't represented in our compile tests. That would be good to fix.</p>
<p>After deleting <code>has_ssse3 has_sse41</code> from that file and re-running the filetests with <code>CRANELIFT_TEST_BLESS=1</code>, I see that this call is a lib-call to <code>X86Pshufb</code>.</p>
<p>That's not the only lib-call we may emit on x86; there are also functions implementing floating-point fused multiply-add (FmaF32/64) and various floating-point rounding modes (Ceil/Floor/Nearest/Trunc), for older CPUs without the corresponding instructions.</p>
<p>So this isn't specifically a SIMD issue, and it doesn't apply to most SIMD instructions either. But I'm also not sure where the segfault you saw came from. Off hand, I don't know why omitting a frame pointer would cause a function call to segfault. So more investigation is in order, I think!</p>
</blockquote>



<a name="436641627"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436641627" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436641627">(May 02 2024 at 08:23)</a>:</h4>
<p>tertsdiepraam <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2089884329">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<blockquote>
<p>After deleting has_ssse3 has_sse41 from that file and re-running the filetests with CRANELIFT_TEST_BLESS=1, I see that this call is a lib-call to X86Pshufb.</p>
</blockquote>
<p>Yes, that's what I found too.</p>
<blockquote>
<p>That's not the only lib-call we may emit on x86; there are also functions implementing floating-point fused multiply-add (FmaF32/64) and various floating-point rounding modes (Ceil/Floor/Nearest/Trunc), for older CPUs without the corresponding instructions.</p>
</blockquote>
<p>My (unsubstantiated) guess is that the X86Pshufb function is more complex than those other lib-calls and therefore causes trouble. Replacing the lib call with a custom function in the final x86 does not seem to cause any trouble, so it's not any call that leads to a segfault.</p>
<p>Is this the code for the libcall? <a href="https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736">https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736</a></p>
<p>At the top of that file, it says:</p>
<blockquote>
<p>They must only contain basic, raw i32/i64/f32/f64/pointer parameters that are safe to pass across the system ABI.</p>
</blockquote>
<p>Maybe part of the problem is that x86pshufb requires <code>__m128i</code> as arguments? Or that it requires bumping some things on the stack while the others don't? I don't really know, I'm just guessing at this point.</p>
</blockquote>



<a name="436642123"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436642123" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436642123">(May 02 2024 at 08:26)</a>:</h4>
<p>tertsdiepraam edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2089884329">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<blockquote>
<p>After deleting has_ssse3 has_sse41 from that file and re-running the filetests with CRANELIFT_TEST_BLESS=1, I see that this call is a lib-call to X86Pshufb.</p>
</blockquote>
<p>Yes, that's what I found too.</p>
<blockquote>
<p>That's not the only lib-call we may emit on x86; there are also functions implementing floating-point fused multiply-add (FmaF32/64) and various floating-point rounding modes (Ceil/Floor/Nearest/Trunc), for older CPUs without the corresponding instructions.</p>
</blockquote>
<p>My (unsubstantiated) guess is that the X86Pshufb function is more complex than those other lib-calls and therefore causes trouble. Replacing the lib call with a custom function in the final x86 does not seem to cause any trouble, so it's not any call that leads to a segfault.</p>
<p>Is this the code for the libcall? <a href="https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736">https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736</a></p>
<p>At the top of that file, it says:</p>
<blockquote>
<p>They must only contain basic, raw i32/i64/f32/f64/pointer parameters that are safe to pass across the system ABI.</p>
</blockquote>
<p>Maybe part of the problem is that x86pshufb requires <code>__m128i</code> as arguments? Or that it requires bumping some things on the stack while the others don't? If I throw that libcall in godbolt, it does show that it pushes some thing to the stack, which might then be at the wrong location. I don't really know, I'm just guessing at this point.</p>
</blockquote>



<a name="436692395"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436692395" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436692395">(May 02 2024 at 13:20)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090485838">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>From what I remember when I looked into this a year or so ago was that this was an issue with stack alignment. I think that the libcalls expect a 16byte aligned stack on entry (due to ABI) and will use aligned loads and stores on the stack directly. </p>
<p>Take this with a grain of salt, since it has been a while since I last looked at this.</p>
</blockquote>



<a name="436692935"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436692935" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436692935">(May 02 2024 at 13:22)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090485838">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>From what I remember when I looked into this a year or so ago was that this was an issue with stack alignment. I think that the libcalls expect a 16byte aligned stack on entry (due to ABI) and will use aligned loads and stores on the stack directly, and we weren't respecting that when omitting the frame pointer. </p>
<p>Take this with a grain of salt, since it has been a while since I last looked at this.</p>
</blockquote>



<a name="436693782"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436693782" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436693782">(May 02 2024 at 13:27)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090485838">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>From what I remember when I looked into this a year or so ago was that this was an issue with stack alignment. I think that the libcalls expect a 16byte aligned stack on entry (due to ABI) and will use aligned loads and stores on the stack directly, and we weren't respecting that when omitting the prologue. </p>
<p>Take this with a grain of salt, since it has been a while since I last looked at this.</p>
</blockquote>



<a name="436698239"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436698239" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436698239">(May 02 2024 at 13:47)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090485838">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>From what I remember when I looked into this a year or so ago was that this was an issue with stack alignment. I think that the libcalls expect a 16byte aligned stack on entry (due to ABI) and will use aligned loads and stores on the stack directly, and we weren't respecting that when omitting the prologue. </p>
<p>Take this with a grain of salt, since it has been a while since I last looked at this.</p>
<p>Edit: I should also note that not all libcalls will come from <a href="https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736"><code>wasmtime/crates/wasmtime/src/runtime/vm/libcalls.rs</code></a>. They can be provded by the system's libc or whatever the linker decides, in cases where cranelift isn't used with wasmtime.</p>
</blockquote>



<a name="436712964"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436712964" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436712964">(May 02 2024 at 14:55)</a>:</h4>
<p>tertsdiepraam <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090730646">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Interesting! @afonso360, do you know of a way that I could check that hypothesis?</p>
<blockquote>
<p>I should also note that not all libcalls will come from <a href="https://github.com/bytecodealliance/wasmtime/blob/d911f4b10fe908bc819a1420482952e44b039db3/crates/wasmtime/src/runtime/vm/libcalls.rs#L736">wasmtime/crates/wasmtime/src/runtime/vm/libcalls.rs</a>. They can be provded by the system's libc or whatever the linker decides, in cases where cranelift isn't used with wasmtime.</p>
</blockquote>
<p>Good to know! Thanks!</p>
<p>I wonder if there's some easy way that we can enable this for everything that doesn't involve libcalls? Is there a way to check whether a function will contain libcalls?<br>
</p>
</blockquote>



<a name="436719392"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436719392" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436719392">(May 02 2024 at 15:24)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090802028">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Well, I'd check if the code segfaults in a 16byte aligned load inside the libcall that is referencing the stack and that that address ends up being under-aligned (i.e. only aligned to 8 bytes or less).</p>
<p>And additionally the stack at the entrypoint of that libcall was only aligned to 8 (this by itself is an ABI breakage).</p>
<p>You should be able to do this by running the test under <code>gdb</code>/<code>lldb</code> and setting a breakpoint in the libcall function and checking what the stack pointer is, and where it first crashes, etc...</p>
<p>It would also be nice if we had a libcall that didn't use any SSE instructions or referenced the stack, that would be also another clue that our issue was with that, but we don't.</p>
</blockquote>



<a name="436719758"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436719758" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436719758">(May 02 2024 at 15:26)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090802028">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Well, I'd check if the code segfaults in a 16byte aligned load inside the libcall that is referencing the stack and that, that address is under-aligned (i.e. only aligned to 8 bytes or less).</p>
<p>And additionally the stack at the entrypoint of that libcall was only aligned to 8 (this by itself is an ABI breakage).</p>
<p>You should be able to do this by running the test under <code>gdb</code>/<code>lldb</code> and setting a breakpoint in the libcall function and checking what the stack pointer is, and where it first crashes, etc...</p>
<p>It would also be nice if we had a libcall that didn't use any SSE instructions or referenced the stack, that would be also another clue that our issue was with that, but we don't.</p>
</blockquote>



<a name="436722423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436722423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436722423">(May 02 2024 at 15:39)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090802028">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Well, I'd check if the code segfaults in a 16byte aligned load inside the libcall that is referencing the stack and that, that address is under-aligned (i.e. only aligned to 8 bytes or less).</p>
<p>And additionally the stack at the entrypoint of that libcall was only aligned to 8 (this by itself is an ABI breakage).</p>
<p>You should be able to do this by running the test under <code>gdb</code>/<code>lldb</code> and setting a breakpoint in the libcall function and checking what the stack pointer is, and where it first crashes, etc...</p>
<p>It would also be nice if we had a libcall that didn't use any SSE instructions or referenced the stack, that would be also another clue that our issue was with that, but we don't.</p>
<hr>
<blockquote>
<p>I wonder if there's some easy way that we can enable this for everything that doesn't involve libcalls? Is there a way to check whether a function will contain libcalls?</p>
</blockquote>
<p>Unfortunately I don't think so. Since these libcalls only end up being placed during lowering if we don't have a direct instruction for that, it means that any instruction could end up being lowered to a libcall. In practice there are only a few situations where we do that.</p>
<p>One way that came to mind was to complete #7321 and with the legalizations in place, we could simply check if there was a <code>call</code> opcode in the function. </p>
<p>Otherwise, I'm not too sure, but people might have some ideas.</p>
</blockquote>



<a name="436722657"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436722657" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436722657">(May 02 2024 at 15:40)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090802028">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Well, I'd check if the code segfaults in a 16byte aligned load inside the libcall that is referencing the stack and that, that address is under-aligned (i.e. only aligned to 8 bytes or less).</p>
<p>And additionally the stack at the entrypoint of that libcall was only aligned to 8 (this by itself is an ABI breakage).</p>
<p>You should be able to do this by running the test under <code>gdb</code>/<code>lldb</code> and setting a breakpoint in the libcall function and checking what the stack pointer is, and where it first crashes, etc...</p>
<p>It would also be nice if we had a libcall that didn't use any SSE instructions or referenced the stack, that would be also another clue that our issue was with that, but we don't.</p>
<hr>
<blockquote>
<p>I wonder if there's some easy way that we can enable this for everything that doesn't involve libcalls? Is there a way to check whether a function will contain libcalls?</p>
</blockquote>
<p>Unfortunately I don't think so. Since these libcalls only end up being placed during lowering if we don't have a direct instruction for that, it means that any instruction could end up being lowered to a libcall. In practice there are only a few situations where we do that.</p>
<p>One way that came to mind was to complete #7321 and with the legalizations in place, we could simply check if there was a <code>call</code> opcode in the function since any opcode that we couldn't implement would be legalized into a <code>call</code>.</p>
<p>Otherwise, I'm not too sure, but people might have some ideas.</p>
</blockquote>



<a name="436724385"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436724385" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436724385">(May 02 2024 at 15:49)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2090802028">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Well, I'd check if the code segfaults in a 16byte aligned load inside the libcall that is referencing the stack and that, that address is under-aligned (i.e. only aligned to 8 bytes or less).</p>
<p>And additionally the stack at the entrypoint of that libcall was only aligned to 8 (this by itself is an ABI breakage).</p>
<p>You should be able to do this by running the test under <code>gdb</code>/<code>lldb</code> and setting a breakpoint in the libcall function and checking what the stack pointer is, and where it first crashes, etc...</p>
<p>It would also be nice if we had a libcall that didn't use any SSE instructions or referenced the stack, that would be also another clue that our issue was with that, but we don't.</p>
<hr>
<blockquote>
<p>I wonder if there's some easy way that we can enable this for everything that doesn't involve libcalls? Is there a way to check whether a function will contain libcalls?</p>
</blockquote>
<p>Unfortunately I don't think so. Since these libcalls only end up being placed during lowering if we don't have a direct instruction for that, it means that any instruction could end up being lowered to a libcall. In practice there are only a few situations where we do that.</p>
<p>One way that came to mind was to complete #7321 and with the legalizations in place, we could simply check if there is a <code>call</code> opcode in the function since any opcode that we couldn't implement would be legalized into a <code>call</code>.</p>
<p>Otherwise, I'm not too sure, but people might have some ideas.</p>
</blockquote>



<a name="436733592"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436733592" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436733592">(May 02 2024 at 16:37)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2091018595">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>We compute the frame layout after lowering to vcode, so I think we can make the decision about whether this is a leaf function after we've already made all the decisions about whether to use any libcalls. We "just" need to thread that information through correctly somehow.</p>
</blockquote>



<a name="436741891"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436741891" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436741891">(May 02 2024 at 17:24)</a>:</h4>
<p>tertsdiepraam <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2091116740">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>That sounds reasonable. I'll give that a shot!</p>
</blockquote>



<a name="436744872"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436744872" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436744872">(May 02 2024 at 17:42)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2091150649">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>Oh, I also wanted to note: Good points, both of you, on stack alignment and vector arguments. I hadn't thought about either of those things and I think together they fully explain this symptom. I want to write down this conclusion for future reference although I don't think either of you need the explanation :grin:</p>
<p>Pushing the return address leaves the stack 8-aligned, and normally pushing the frame pointer would make it 16-aligned again, but we skip that step here. Then, most x86 code can actually tolerate 8-aligned stacks, but moving between MMX registers and memory generally requires 16-alignment, and indeed it looks like Rust/LLVM are producing <code>movdqa</code> instructions with 16-aligned offsets from the stack pointer in this particular libcall.</p>
<p>So that explains why you'd only see problems with this specific call. We still should ensure that all libcalls get the ABI-required stack alignment though, so the plan to have any function with a libcall not be a leaf function is still a good one.</p>
</blockquote>



<a name="436745432"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/436745432" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#436745432">(May 02 2024 at 17:45)</a>:</h4>
<p>tertsdiepraam <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2091156498">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>I did in fact need that conclusion <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> Thanks!</p>
</blockquote>



<a name="439229027"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/439229027" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#439229027">(May 17 2024 at 13:57)</a>:</h4>
<p>tertsdiepraam <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2117670600">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>I'm looking at this again and I might need some help. I'm struggling to find where this information should originate from. Is there some struct that can keep track of a boolean or should we scan over the emitted instructions? Or maybe the <code>dfg</code> should also keep track of the libcalls that have been made in addition to the <code>signatures</code> and <code>ext_funcs</code>?</p>
<p>I'm a bit overwhelmed at the moment :)</p>
</blockquote>



<a name="439288247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/439288247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#439288247">(May 17 2024 at 20:34)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2118349006">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<blockquote>
<p>I'm looking at this again and I might need some help. I'm struggling to find where this information should originate from. Is there some struct that can keep track of a boolean …</p>
</blockquote>
<p>Yeah, totally reasonable questions!</p>
<p>I would start by looking at how <code>outgoing_args_size</code> and <code>tail_args_size</code> get computed and used, since those are also properties of the function calls that appear in the current function.</p>
<p>In <code>cranelift/codegen/src/machinst/abi.rs</code>, there are methods on <code>Callee</code> named <code>accumulate_outgoing_args_size</code> and <code>accumulate_tail_args_size</code>. You can look for where these are called. Those are places where, while lowering the body of the function, we found a function call. I don't remember exactly but libcalls should be similar.</p>
<p>Note that if you're using <code>rust-analyzer</code> to navigate, there are some nearby parts of the call-graph that it can't find because they're in macros, so if you hit a point where things seem to be missing you might also want to try just searching for the function's name. Someday I hope to reduce our usage of macros…</p>
<p>Those <code>*_args_size</code> fields are stored on the <code>Callee</code> until <code>Callee::compute_frame_layout</code> is called, and then they're forwarded to the backend's implementation of <code>ABIMachineSpec::compute_frame_layout</code>.</p>
<p>There's another field on <code>Callee</code> that's also forwarded, <code>is_leaf</code>. Maybe the thing to do here is just set that to <code>false</code> if there's any kind of function call, including libcalls.</p>
</blockquote>



<a name="439288646"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238516%20WIP%3A%20cranelift%3A%20omit%20function%20prologu.../near/439288646" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238516.20WIP.3A.20cranelift.3A.20omit.20function.20prologu.2E.2E.2E.html#439288646">(May 17 2024 at 20:37)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8516#issuecomment-2118353098">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8516">PR #8516</a>:</p>
<blockquote>
<p>After a little more investigation: the <code>is_leaf</code> field is currently set by calling <code>FunctionStencil::is_leaf</code>, which tries to guess whether there are function calls or libcalls, and which is not used anywhere else. Let's just delete that method, and compute the true answer during lowering.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>