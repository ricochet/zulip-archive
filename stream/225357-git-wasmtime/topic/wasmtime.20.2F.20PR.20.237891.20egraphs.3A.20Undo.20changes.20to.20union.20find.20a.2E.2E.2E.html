<html>
<head><meta charset="utf-8"><title>wasmtime / PR #7891 egraphs: Undo changes to union find a... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html">wasmtime / PR #7891 egraphs: Undo changes to union find a...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="420356460"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420356460" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420356460">(Feb 07 2024 at 22:49)</a>:</h4>
<p>elliottt opened <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a> from <code>bytecodealliance:revert-union-find</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>This is not an efficient implementation, and is meant to test a theory.</p>
<p>Explicitly cache and restore the values of the union find and gvn map structures when backtracking while traversing the dominator graph. This avoids accidentally violating the invariant provided by <code>Union</code> values: they should only union together values that locally are valid substitutions.</p>
<p>Additionally, remove uses of the union find structure during elaboration, as we have already computed the best values prior to elaboration.</p>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
</blockquote>



<a name="420366766"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420366766" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420366766">(Feb 08 2024 at 00:29)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Re: the "scoping" approach, an efficient implementation (I think!) occurred to me a few days ago. It would probably get at what I think y'all are trying to get at here. Basically what I think we need to do is:</p>
<ul>
<li>Record preorder and postorder indices on the domtree; we can do this when we build <code>DomTreeWithChildren</code>. The <code>(preorder, postorder)</code> intervals have the nice property of giving an O(1) child test -- one node is the child of another if its preorder-postorder pair is contained in the other.</li>
<li>Create a vector indexed by node ID with <code>(preorder, postorder)&gt;</code> values (bitpack that to taste; maybe two <code>u32</code>s at first). This is meant to indicate the subtree of the domtree in which this node can be used. Fill it in as follows:<ul>
<li>When creating nodes with a location (non-pure nodes, i.e., those in the skeleton and blockparams), record the <code>(preorder, postorder)</code> of the containing block. This means that that value, or a value computed using it, can be used within that subtree of the domtree.</li>
<li>When creating pure nodes, record the intersection of the intervals (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</li>
<li>When creating union nodes, record the union of the intervals.</li>
</ul>
</li>
</ul>
<p>Finally, when computing the best nodes in each class, compare based on these intervals first, so the most-widely-available value wins.</p>
<p>This should I think have O(1) cost, require storage of an integer pair per node (maybe a <code>u32</code> if we feel like limiting to 2^16 blocks, <code>u64</code> otherwise), and (I think!) retains the "cost function is purely heuristic" property without the need to think about subsumes.</p>
<p>(I think I have a proof sketch that all this works; more next week if it doesn't break in the meantime :-) )</p>
</blockquote>



<a name="420366778"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420366778" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420366778">(Feb 08 2024 at 00:29)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Re: the "scoping" approach, an efficient implementation (I think!) occurred to me a few days ago. It would probably get at what I think y'all are trying to get at here. Basically what I think we need to do is:</p>
<ul>
<li>Record preorder and postorder indices on the domtree; we can do this when we build <code>DomTreeWithChildren</code>. The <code>(preorder, postorder)</code> intervals have the nice property of giving an O(1) child test -- one node is the child of another if its preorder-postorder pair is contained in the other.</li>
<li>Create a vector indexed by node ID with <code>(preorder, postorder)&gt;</code> values (bitpack that to taste; maybe two <code>u32</code>s at first). This is meant to indicate the subtree of the domtree in which this node can be used. Fill it in as follows:<ul>
<li>When creating nodes with a location (non-pure nodes, i.e., those in the skeleton and blockparams), record the <code>(preorder, postorder)</code> of the containing block. This means that that value, or a value computed using it, can be used within that subtree of the domtree.</li>
<li>When creating pure nodes, record the intersection of the intervals (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</li>
<li>When creating union nodes, record the union of the intervals.</li>
</ul>
</li>
<li>Finally, when computing the best nodes in each class, compare based on these intervals first, so the most-widely-available value wins.</li>
</ul>
<p>This should I think have O(1) cost, require storage of an integer pair per node (maybe a <code>u32</code> if we feel like limiting to 2^16 blocks, <code>u64</code> otherwise), and (I think!) retains the "cost function is purely heuristic" property without the need to think about subsumes.</p>
<p>(I think I have a proof sketch that all this works; more next week if it doesn't break in the meantime :-) )</p>
</blockquote>



<a name="420366844"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420366844" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420366844">(Feb 08 2024 at 00:30)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Re: the "scoping" approach, an efficient implementation (I think!) occurred to me a few days ago. It would probably get at what I think y'all are trying to get at here. Basically what I think we need to do is:</p>
<ul>
<li>Record preorder and postorder indices on the domtree; we can do this when we build <code>DomTreeWithChildren</code>. The <code>(preorder, postorder)</code> intervals have the nice property of giving an O(1) child test -- one node is the child of another if its preorder-postorder pair is contained in the other.</li>
<li>Create a vector indexed by node ID with <code>(preorder, postorder)&gt;</code> values (bitpack that to taste; maybe two <code>u32</code>s at first). This is meant to indicate the subtree of the domtree in which this node can be used. Fill it in as follows:<ul>
<li>When creating nodes with a location (non-pure nodes, i.e., those in the skeleton and blockparams), record the <code>(preorder, postorder)</code> of the containing block. This means that that value, or a value computed using it, can be used within that subtree of the domtree.</li>
<li>When creating pure nodes, record the intersection of the intervals (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</li>
<li>When creating union nodes, record the union of the intervals.</li>
</ul>
</li>
<li>Finally, when computing the best nodes in each class, compare based on these intervals first, so the most-widely-available value wins.</li>
</ul>
<p>This should I think have O(1) cost (edit: per node; O(n) over the program), require storage of an integer pair per node (maybe a <code>u32</code> if we feel like limiting to 2^16 blocks, <code>u64</code> otherwise), and (I think!) retains the "cost function is purely heuristic" property without the need to think about subsumes.</p>
<p>(I think I have a proof sketch that all this works; more next week if it doesn't break in the meantime :-) )</p>
</blockquote>



<a name="420366965"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420366965" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420366965">(Feb 08 2024 at 00:31)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Re: the "scoping" approach, an efficient implementation (I think!) occurred to me a few days ago. It would probably get at what I think y'all are trying to get at here. Basically what I think we need to do is:</p>
<ul>
<li>Record preorder and postorder indices on the domtree; we can do this when we build <code>DomTreeWithChildren</code>. The <code>(preorder, postorder)</code> intervals have the nice property of giving an O(1) child test -- one node is the child of another if its preorder-postorder pair is contained in the other.</li>
<li>Create a vector indexed by node ID with <code>(preorder, postorder)</code> values (bitpack that to taste; maybe two <code>u32</code>s at first). This is meant to indicate the subtree of the domtree in which this node can be used. Fill it in as follows:<ul>
<li>When creating nodes with a location (non-pure nodes, i.e., those in the skeleton and blockparams), record the <code>(preorder, postorder)</code> of the containing block. This means that that value, or a value computed using it, can be used within that subtree of the domtree.</li>
<li>When creating pure nodes, record the intersection of the intervals (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</li>
<li>When creating union nodes, record the union of the intervals.</li>
</ul>
</li>
<li>Finally, when computing the best nodes in each class, compare based on these intervals first, so the most-widely-available value wins.</li>
</ul>
<p>This should I think have O(1) cost (edit: per node; O(n) over the program), require storage of an integer pair per node (maybe a <code>u32</code> if we feel like limiting to 2^16 blocks, <code>u64</code> otherwise), and (I think!) retains the "cost function is purely heuristic" property without the need to think about subsumes.</p>
<p>(I think I have a proof sketch that all this works; more next week if it doesn't break in the meantime :-) )</p>
</blockquote>



<a name="420367047"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420367047" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420367047">(Feb 08 2024 at 00:32)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Re: the "scoping" approach, an efficient implementation (I think!) occurred to me a few days ago. It would probably get at what I think y'all are trying to get at here. Basically what I think we need to do is:</p>
<ul>
<li>Record preorder and postorder indices on the domtree; we can do this when we build <code>DomTreeWithChildren</code>. The <code>(preorder, postorder)</code> intervals have the nice property of giving an O(1) child test -- one node is the child of another if its preorder-postorder pair is contained in the other.</li>
<li>Create a vector indexed by node ID with <code>(preorder, postorder)</code> values (bitpack that to taste; maybe two <code>u32</code>s at first). This is meant to indicate the subtree of the domtree in which this node can be used. Fill it in as follows:<ul>
<li>When creating nodes with a location (non-pure nodes, i.e., those in the skeleton and blockparams), record the <code>(preorder, postorder)</code> of the containing block. This means that that value, or a value computed using it, can be used within that subtree of the domtree.</li>
<li>When creating pure nodes, record the intersection of the intervals of the args (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</li>
<li>When creating union nodes, record the union of the intervals.</li>
</ul>
</li>
<li>Finally, when computing the best nodes in each class, compare based on these intervals first, so the most-widely-available value wins.</li>
</ul>
<p>This should I think have O(1) cost (edit: per node; O(n) over the program), require storage of an integer pair per node (maybe a <code>u32</code> if we feel like limiting to 2^16 blocks, <code>u64</code> otherwise), and (I think!) retains the "cost function is purely heuristic" property without the need to think about subsumes.</p>
<p>(I think I have a proof sketch that all this works; more next week if it doesn't break in the meantime :-) )</p>
</blockquote>



<a name="420374247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/420374247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#420374247">(Feb 08 2024 at 01:56)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933244949">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @cfallin, @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift", "isle"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>cfallin: isle</li>
<li>fitzgen: isle</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="421549184"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421549184" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421549184">(Feb 14 2024 at 23:10)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1944956488">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<blockquote>
<p>When creating pure nodes, record the intersection of the intervals of the args (max of starts, min of ends). Note that the intervals must overlap because of a property of SSA: all inputs ultimately come from blocks up the direct ancestry in the domtree, not "side blocks".</p>
</blockquote>
<p>I'm trying to make sure I follow your reasoning here so I want to restate this in a way that doesn't refer to preorder/postorder intervals, which I think may be a clever implementation detail rather than a necessary aspect of the solution.</p>
<p>All of an instruction's operands must dominate the instruction. The SSA properties imply that dominance imposes a total order on those values which are used together as operands in the same instruction, and in particular one operand must be dominated by all the others. Therefore, the instruction can be placed anywhere in the subtree dominated by that one operand.</p>
<p>Is that right? If so we need to be able to quickly evaluate which block is dominated by all the operands, and we can use the pre/post-order intervals as an implementation detail to identify one operand whose block is the right choice using constant-time comparisons. We can use the same trick to optimize dominance comparisons elsewhere in Cranelift so this may be a useful trick to apply more broadly.</p>
</blockquote>



<a name="421552198"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421552198" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421552198">(Feb 14 2024 at 23:35)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1945021512">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>If I have that right then the neat follow-up trick that I think works is to record a block ID for each value rather than an interval per value. We just need to compare values according to their associated block's interval, we don't need to compute new intervals or map computed intervals back to blocks. And the block ID for a value is just the block where the value is actually defined, so we can get it from the layout rather than needing to store anything extra per value.</p>
<p>I'm not sure how to extend this to union nodes, but I'm also not clear on whether we need to answer dominance questions about union nodes. If your sketch of an algorithm is correct about union nodes, Chris, and if I understand it correctly, then the block associated with a union node is whichever block dominates all the values in the eclass identified by that union node. I'm not sure what that tells us.</p>
<p>By the way, I said this verbally to somebody recently but we should write it down: In the aegraph, every <code>Value</code> identifies an eclass, but some eclasses contain others. It's important to remember that our form of eclass doesn't grow over time, we just may start referring to a different eclass that contains it as a subset. We had quite a bit of confusion about aegraph invariants until we clarified that.</p>
</blockquote>



<a name="421558365"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421558365" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421558365">(Feb 15 2024 at 00:33)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1945172450">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>That all sounds basically correct to me! A few thoughts:</p>
<ul>
<li>
<p>SSA dominance implies a <em>partial</em> order on args, at least with respect to block-level dominance; the greatest-lower-bound (where "top" is the domtree root) is the highest point at which we can compute the instruction, yep.</p>
</li>
<li>
<p>I like very much the block-ID rather than interval (and store intervals elsewhere) idea; one more indirection but likely pays for itself with less storage.</p>
</li>
<li>
<p>Re: "And the block ID for a value is just the block where the value is actually defined, so we can get it from the layout rather than needing to store anything extra per value." this is true for blockparams and side-effecting ops, but for pure ops the block ID is the <em>highest</em> block in the domtree at which it <em>could</em> be computed; this may be higher than any block where we actually encounter it.</p>
</li>
<li>
<p>The value for a union node is computed with the opposite merge function as with respect to arguments, because it's a disjunction rather than conjunction. At an operator, we <em>need</em> all the arguments, so we take the lowest subtree that has them all available. But at a union node, we can take any different alternative way to compute the value, so we take the <em>highest</em> subtree that has any available.</p>
</li>
</ul>
<p>The last bit is pretty subtle: it wasn't apparent to me at first that this would always work. Consider e.g. block B1 dominating two sub-blocks B2 and B3 in the domtree, and two defs of a value v1, v2 in B2 and v3 in B3 (i.e., v1 = union v2, v3.) Maybe <code>v2</code>'s highest-possible-block is B2 and <code>v3</code>'s highest-possible-block is B3. Should <code>v1</code>'s highest-possible-block be B1? There are no valid ways to compute it there!</p>
<p>It turns out that the answer is that this can't happen: the highest-possible-block is sort of a max of a set of "fixed-location" (impure) inputs, and so the only way for <code>v2</code> and <code>v3</code> to be in this situation is for them to be functions of blockparams (or e.g. memory loads) in B2 and B3 respectively. But then they shouldn't be in the same eclass -- they are two separate values that never exist at the same time (there is no block that is dominated by both B2 and B3) -- unless the eclass is incomplete and they both e.g. merge to <code>iconst 0</code> (in which case the highest-available-block is the root).</p>
<p>Said another way, I think the invariant is that all members of an eclass have highest-available-block that lie along a path from some block upward toward the root of the domtree; there is always some unique answer for "block that dominates all other blocks" in this set of blocks. That block is what we hope to propagate forward through union nodes.</p>
</blockquote>



<a name="421776429"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421776429" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421776429">(Feb 16 2024 at 02:35)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1947667930">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Okay, @elliottt and @lpereira and I just spent a couple hours trying to reason through this and I, for one, am toast. But I'm going to see if I can write down what we learned anyway.</p>
<p>As I was writing this I became uncertain that we investigated the right questions, but for reference, the approach we were planning was to filter the result of the <code>gvn_map.get()</code> call in <code>insert_pure_enode</code>. We'd pretend that there was no entry in the map if the value returned was associated with a block that's not dominated by the block associated with the instruction we're trying to look up. (Or maybe it was the other way around, I've already forgotten.) </p>
<p>I wonder if #7922 might have already fixed the underlying issue that #7879 introduced more <code>subsume</code> uses to work around. (We have not yet tried reverting #7879 on top of main to check that, which we should try since #7922 has landed.)</p>
<p>The remaining part of this draft PR that was not covered in #7922 is the changes in <code>egraph.rs</code> that undo union-find and gvn-map changes when backtracking up the dominator tree in <code>remove_pure_and_optimize</code>. So we tried to figure out what impact those changes actually have on correctness. To do that, we commented out the line in this PR that says <code>gvn_map = saved_gvn_map</code>, while still leaving <code>self.eclasses = eclasses</code>, and re-ran the filetests. (We had previously tried the other way around, restoring the GVN map but letting the union-find keep growing, and found that all filetests pass.)</p>
<p>The only test which failed was from <code>cranelift/filetests/filetests/pcc/succeed/opt.clif</code>. Specifically, only the test which is supposed to demonstrate redundant-load elimination failed.</p>
<p>Side note: this proof-carrying-code RLE test does not appear to test what it was supposed to because the <code>v2</code> load is <code>notrap</code> and never used, so it is deleted by the DCE pass before the egraph even sees it. Neither of the remaining loads is redundant with the other as they're on different branches, so the egraph pass doesn't change the function at all.</p>
<p>So the bug we see when we undo changes to the union-find but not to the GVN map only occurs when there are two different branches of the dominance tree containing instructions which have equivalent <code>InstructionData</code>. (Apparently we need to write more filetests with this pattern?) When we encounter the second copy of the instruction, <code>insert_pure_enode</code> tries to record in the union-find that it's equivalent to the first copy as found in the GVN map, but the union-find no longer knows that the first copy exists, and <code>panic</code>s because we tried to <code>union</code> with a value that we didn't <code>add</code> first.</p>
<p>I want to think more carefully about whether this situation can lead to bugs outside of this specific situation (undoing changes to the union-find but not to the GVN map). I guess the question is, what happens with a function like the following? (I haven't tested this.)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i64</span><span class="p">)</span>:
  <span class="nc">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">brif</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">(</span><span class="n">v0</span><span class="p">),</span><span class="w"> </span><span class="n">block2</span>

<span class="n">block1</span><span class="p">(</span><span class="n">v2</span>: <span class="kt">i64</span><span class="p">)</span>:
  <span class="nc">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">  </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span>
<span class="w">  </span><span class="n">jmp</span><span class="w"> </span><span class="n">block1</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span>

<span class="n">block2</span>:
  <span class="nc">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v5</span>
</code></pre></div>
<p>If we don't undo changes in either the GVN map or the union-find, then we'll have <code>v3</code> and <code>v1</code> in the same set in the union-find when we try to look up the instruction defining <code>v5</code> in the map, so we'll decide that it's the same instruction as <code>v4</code> and try to re-use that. If we then choose <code>v3</code>'s <code>isub</code> instruction during elaboration of <code>block2</code> instead of the <code>iconst</code>, we'll try to use <code>block1</code>'s block-parameter in <code>block2</code>, where it isn't in scope. This is because the <code>return</code> instruction points to an eclass (union node) that is only valid in the <code>block1</code> scope.</p>
<p>I am way out of energy at this point but I think this will be a good test case to study when we pick this up again next week, and I think it might be made safe by the plan we discussed today.</p>
</blockquote>



<a name="421777670"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421777670" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421777670">(Feb 16 2024 at 02:51)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1947678222">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>@jameysharp most of this sounds basically right to me and agrees with my understanding; thank you all for looking into this more deeply!</p>
<p>One thought on the "trying to revert..." and experiments in general: I may be misunderstanding the intent here (if so, my apologies), but at least to me it doesn't seem too important to understand exactly which combination of partial fixes is just enough to mask issues; and the empirical approach ("does this particular bug occur on this particular test-case with these particular algorithm knobs turned this way") to me feels like it muddies the waters a bit. I suspect maybe y'all are trying to map the landscape better? Or is there a question of finding some other fix or minimize changes somehow?</p>
<p>In any case, I think the test case you wrote out, combined with worst-case cost extraction (say that we always prefer <code>isub</code> to <code>iconst</code>, for example...) is basically the canonical example to test with here. Maybe the way to develop this fix is to <em>make</em> the cost function "evil" in this way, and then get the dominance-scoping right so the <code>isub</code> is ignored? That way, we can be sure that no matter what we do with the cost function, it's not load-bearing.</p>
</blockquote>



<a name="421778753"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421778753" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421778753">(Feb 16 2024 at 03:03)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1947685813">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>(Actually, that gives me an idea: maybe a chaos-mode knob, or just an <code>OptLevel</code>, could be "as pessimized as possible"; this inverts cost comparisons so we always pick the <em>most expensive</em> enode in any eclass. Can't wait to see what that would do for testing!)</p>
</blockquote>



<a name="421799244"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421799244" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421799244">(Feb 16 2024 at 06:37)</a>:</h4>
<p>elliottt <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1947835821">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>I love the idea of a chaos mode cost function! Much of what we discussed this afternoon was that when choosing the best value from <code>union</code> nodes, it really must be acceptable to choose either branch. Having a chaos mode for the cost function would be a great way to test that we're not accidentally relying on the cost function for correctness anymore.</p>
</blockquote>



<a name="421956358"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/421956358" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#421956358">(Feb 16 2024 at 23:50)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1949496718">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<blockquote>
<p>I suspect maybe y'all are trying to map the landscape better?</p>
</blockquote>
<p>Yeah, exactly. I won't speak for anyone else but I certainly didn't feel like I had a firm grasp on which invariants are important for the bug we investigated a couple weeks ago. So we tried breaking various implicit invariants to see what would fail and whether that would give us better intuitions about what's necessary. I think these experiments did help us get closer.</p>
<p>I also love the idea of the chaos-mode cost function, so maybe we can work on that next week.</p>
</blockquote>



<a name="422728359"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422728359" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422728359">(Feb 22 2024 at 00:52)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1958466785">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>In the interests of trying to make Cranelift give correct results without relying on the <code>subsume</code> guidelines that we recently introduced as a temporary measure, I've constructed an interesting CLIF test.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">bad_reuse</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i8</span> <span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">brif</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

<span class="n">block1</span>:
    <span class="nc">brif</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block3</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>

<span class="n">block2</span><span class="p">(</span><span class="n">v2</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v4</span>

<span class="n">block3</span>:
    <span class="nc">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v5</span>
<span class="p">}</span>
</code></pre></div>
<p>This test currently passes, but with two small changes to the egraph pass it fails.</p>
<ul>
<li>I changed <code>optimize_pure_enode</code> to ignore <code>subsume_values</code>, as if we didn't use <code>subsume</code> in any rules.</li>
<li>I changed <code>compute_best_values</code> to always use the worst option rather than the best, by forcing the <code>use_worst</code> flag from #7968 to true.</li>
</ul>
<p>With those changes, the verifier rejects the output of the egraph pass:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">bad_reuse</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i8</span> <span class="nc">fast</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
        <span class="nc">brif</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

<span class="w">    </span><span class="n">block1</span>:
        <span class="nc">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="n">brif</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block3</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">    </span><span class="n">block2</span><span class="p">(</span><span class="n">v2</span>: <span class="kt">i32</span><span class="p">)</span>:
        <span class="nc">v7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">        </span><span class="n">v8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v7</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">v8</span>

<span class="w">    </span><span class="n">block3</span>:
        <span class="nc">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="p">;</span><span class="w">   </span><span class="o">^~~~~~~~~~~~~~~~~~~~</span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">error</span>: <span class="nc">inst3</span><span class="w"> </span><span class="p">(</span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span>: <span class="nc">uses</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">dominating</span><span class="w"> </span><span class="n">block2</span>

<span class="w">        </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">v4</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>This shows that we're currently relying on either <code>subsume</code> or the cost function to pick valid choices from an eclass constructed through GVN. If we break _both_ of those mechanisms then this test is miscompiled by duplicating the <code>isub</code> into a branch where it isn't legal.</p>
</blockquote>



<a name="422734719"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422734719" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422734719">(Feb 22 2024 at 02:08)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1958530689">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>@jameysharp this aligns with my understanding from our discussion yesterday; thanks for putting together the concrete test-case! Just to ensure I understand your path from here (and to have it written down for others): is the current plan to implement the domtree-scoping idea per node (from <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1933167583">here</a>)?</p>
</blockquote>



<a name="422904662"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422904662" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422904662">(Feb 22 2024 at 21:06)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1960314842">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Yes, roughly, @cfallin, but we've discussed enough variations on that idea that I'm going to try writing it down again explicitly.</p>
<p>The first piece is to compute, for every value in the <code>DataFlowGraph</code>, that value's "available block". This is the unique block, closest to the root of the dominator tree, at which it is legal to place an instruction which computes that value.</p>
<ul>
<li>
<p>For block-parameter values, that is the block where the parameter is defined.</p>
</li>
<li>
<p>For instruction-result values:</p>
<ul>
<li>If the instruction is in the side-effecting skeleton then it's the block where the instruction is located.</li>
<li>Otherwise, it is the same block as whichever operand is dominated by all the other operands, or the entry block if there are no operands. (We can determine this in time linear in the number of operands by using the constant-time dominance check from <code>DominatorTreePreorder</code>.)</li>
</ul>
</li>
<li>
<p>For values which represent an eclass by referring to a union node, we're going to establish a new invariant: both parents of the union node must have the same "available block", and we'll use that block as the available block of the union node too.</p>
</li>
</ul>
<p>So the second piece of this plan is to establish this new invariant. The only time we construct union nodes is in <code>optimize_pure_enode</code>, when we call the ISLE <code>simplify</code> entry-point and union together all the alternatives it gives us. So that's the only place we need to change.</p>
<p>We'll choose to do it by discarding any alternative with an available block that is strictly dominated by the available block of some other alternative. In other words we choose only alternatives that all have the same available block, where that is the block which is closest, of all the alternatives, to the entry block in the dominator tree. One way to think of this is like an eagerly-evaluated cost function, applied to prune the egraph while we're still building it.</p>
<p>This is a form of <code>subsume</code> which automatically covers exactly the cases where we currently need <code>subsume</code> for correctness, but does not cover all cases where we currently use <code>subsume</code> for performance. For example, a rule which rewrites <code>isub x, x</code> to <code>iconst 0</code> will only automatically eliminate the <code>isub</code> from later consideration if <code>x</code> is not available in the entry block, where <code>iconst 0</code> is always available. So we might still want <code>subsume</code> annotations even if we don't strictly need them.</p>
<p>The third piece to consider here is the union-find data structure and the GVN map. There are three general cases where we union values together in the union-find.</p>
<ul>
<li>
<p>When we construct a union node in the <code>DataFlowGraph</code>, we reflect it in the union-find. In this case the new invariant holds in both data structures.</p>
</li>
<li>
<p>When we explicitly <code>subsume</code> a result, we update the union-find to indicate it's in the same eclass as the original expression that we were trying to simplify, as well as any values we looked at earlier in the results from <code>simplify</code>. It's not clear to me that this is okay, so I need to investigate further.</p>
</li>
<li>
<p>When we hit a matching instruction in either the regular GVN map or the effectful GVN map, we record in the union-find that the results of both instructions should be considered equivalent.</p>
<ul>
<li>In the regular GVN map, instructions are considered equivalent if their operands are in the same set in the union-find. So if the union-find sets respect the new invariant on available block, then both versions of the instruction will have the same available block, and unioning their results together will respect the invariant.</li>
<li>The effectful GVN map can reuse instructions from any dominating block, but their available blocks are the blocks where they're defined, so this can put values with different available blocks into the same set in the union-find, violating the invariant.</li>
</ul>
</li>
</ul>
<p>So there's at least one hole in this plan that I haven't sorted out yet.</p>
<hr>
<p>Here's a slightly simpler test case that occurred to me while thinking through this plan.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">bad_reuse</span><span class="p">(</span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i8</span> <span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i64</span><span class="p">)</span>:
    <span class="nc">brif</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span>

<span class="n">block1</span>:
    <span class="nc">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">v0</span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span>

<span class="n">block2</span>:
    <span class="nc">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v5</span>
<span class="p">}</span>
</code></pre></div>
<p>When <code>subsume</code> is disabled and the cost model picks the worst alternative, elaboration tries to duplicate the load into <code>block2</code>. That triggers the "something has gone very wrong if we are elaborating effectful instructions, they should have remained in the skeleton" assertion that was added recently in #7859.</p>
<hr>
<p>It's not immediately obvious to me that this plan is correct with regard to side-effecting instructions, but I think it's okay. The question is, why is an "available block" precise enough, rather than an "available instruction"? What if we construct an eclass where one alternative is legal before a <code>load</code> but the other must be placed after the <code>load</code> because it uses its result? Could elaboration ever pick the latter alternative when trying to place it earlier?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i64</span>:
    <span class="nc">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v0</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span>
</code></pre></div>
<p>I think the answer is that the load, and any earlier instruction in the side-effecting skeleton, can only reference versions of eclasses which contain values that were originally defined before that instruction. So we can only extract a "best" instruction from an eclass that transitively depends on the load when we're elaborating later instructions in the side-effecting skeleton.</p>
<p>That reasoning only holds now that we merged #7922 though, because before that I think the use of the union-find structure could smuggle later versions of eclasses to earlier instructions during elaboration.</p>
</blockquote>



<a name="422906271"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422906271" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422906271">(Feb 22 2024 at 21:18)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1960329845">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Thanks for writing this all out! One question:</p>
<blockquote>
<p>When <code>subsume</code> is disabled and the cost model picks the worst alternative, elaboration tries to duplicate the load into <code>block2</code>. That triggers the "something has gone very wrong if we are elaborating effectful instructions, they should have remained in the skeleton" assertion that was added recently in #7859.</p>
</blockquote>
<p>I'm not sure I understand why the icmp-against-load would still be in the eclass: given your invariant, and checks on union to maintain it, wouldn't the rewriting while still in <code>block1</code> retain only icmp-against-iconst (a new iconst created by the rewrite on <code>isub v1, v1</code>), with an available block of block0 (constrained only by <code>v0</code>), and then we match that when looking up the GVN map in <code>block2</code>?</p>
</blockquote>



<a name="422906536"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422906536" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422906536">(Feb 22 2024 at 21:20)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1960332469">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>Ah and re:</p>
<blockquote>
<p>The question is, why is an "available block" precise enough, rather than an "available instruction"? </p>
</blockquote>
<p>is it enough that we do a forward scan through the block and process in that order? (In other words, what is the bad case that happens with dominance? It occurs because we move back up the domtree, but retain some state from our deep traversal. That doesn't happen within a single block.)</p>
</blockquote>



<a name="422914906"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422914906" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422914906">(Feb 22 2024 at 22:23)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1960427749">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>When <code>subsume</code> is disabled and the cost model picks the worst alternative, elaboration tries to duplicate the load into <code>block2</code>. That triggers the "something has gone very wrong if we are elaborating effectful instructions, they should have remained in the skeleton" assertion that was added recently in #7859.</p>
</blockquote>
<p>I'm not sure I understand why the icmp-against-load would still be in the eclass: given your invariant, and checks on union to maintain it, […]</p>
</blockquote>
<p>I was describing what happens with that test case today, when I break both <code>subsume</code> and the cost model. I believe you're right that the invariant I described should fix this test case, and I believe it should also fix the test case I posted yesterday.</p>
<blockquote>
<blockquote>
<p>The question is, why is an "available block" precise enough, rather than an "available instruction"?</p>
</blockquote>
<p>is it enough that we do a forward scan through the block and process in that order? (In other words, what is the bad case that happens with dominance? It occurs because we move back up the domtree, but retain some state from our deep traversal. That doesn't happen within a single block.)</p>
</blockquote>
<p>Yeah, I think that's getting at the same thing I was trying to say. But scanning in forward order is only sufficient if we're also careful not to let any eclass travel "back in time" during elaboration, like what we fixed in #7922.</p>
</blockquote>



<a name="422925189"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/422925189" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#422925189">(Feb 22 2024 at 23:55)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/7891#issuecomment-1960531054">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>:</p>
<blockquote>
<p>After reasoning this through more with @cfallin, we're both pretty convinced that my worries about the union-find and GVN map are not necessary, and that just pruning the result of <code>simplify</code> is sufficient for correctness.</p>
<p>I was worried that if an instruction was added to the GVN map in one branch, and matched in an unrelated branch, that using the same value could lead to using an eclass that transitively references values that aren't available in the new context. (That's what's happening in the two test cases I've posted in this thread.)</p>
<p>However, Chris pointed out that the new invariant I described means that the only values which can be added to the GVN map are valid everywhere that the instruction could appear.</p>
<p>The most important thing about that is it makes the original motivation of this draft PR irrelevant: We don't need to undo changes in the union-find or in the GVN map during backtracking.</p>
<p>If anyone has more questions about this, please ask, because attempting to answer them will probably help me straighten this out more in my head.</p>
</blockquote>



<a name="425367335"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237891%20egraphs%3A%20Undo%20changes%20to%20union%20find%20a.../near/425367335" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237891.20egraphs.3A.20Undo.20changes.20to.20union.20find.20a.2E.2E.2E.html#425367335">(Mar 07 2024 at 18:18)</a>:</h4>
<p>jameysharp closed without merge <a href="https://github.com/bytecodealliance/wasmtime/pull/7891">PR #7891</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>