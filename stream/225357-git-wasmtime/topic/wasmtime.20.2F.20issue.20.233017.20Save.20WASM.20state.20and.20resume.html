<html>
<head><meta charset="utf-8"><title>wasmtime / issue #3017 Save WASM state and resume · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html">wasmtime / issue #3017 Save WASM state and resume</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="243522399"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243522399" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243522399">(Jun 22 2021 at 14:12)</a>:</h4>
<p>IamTheCarl opened <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>To be able to interrupt and save the state of executing WASM code and then resume it later, possibly on a different host machine.</p>
<h4>Benefit</h4>
<p>I am writing an add on for the Open Computers mod in Minecraft. The mod adds tiny computers that can be programmed by the player. One of their features is that if you quit the game, when you resume later, the state of the machine is restored just as they left it.</p>
<p>The default Lua interpreter uses a custom implementation of Lua that can save and restore its state like this.<br>
There's a small hand full of emulators that just save their memory and registers and restore them later.<br>
I don't see a clear way to do this with wasmtime.</p>
<p>I do see potential in this being useful for a tool similar to Jupyter. You could pause a computationally intensive task and resume it later, or a cloud could serialize a job, and send it to another machine to resume in the case of a scale up/down.</p>
<h4>Implementation</h4>
<p>I can see that modules can be serialized already. What really needs to be saved is the state of memory and execution.<br>
Just dumping the memory into a byte array will be enough to save the memory. Saving the state is what looks hard to me.<br>
Dumping the registers to be restored later could work for a non-portable solution but something that can be restored on another machine of possibly a different architecture would be preferred.</p>
<p>Unfortunately I don't know enough about wasmtime's implementation to give a fantastic recommendation here.</p>
<h4>Alternatives</h4>
<p>This is actually my fallback plan if the feature is rejected.</p>
<p>If you can just serialize the memory of the WASM environment (actually this may already be possible, I just haven't tried yet) you could push the job of tracking state off onto a Rust module's async state machine. You would need a function that is called regularly to resume this state machine and the module would need to frequently interrupt itself so that this function can return to the host.</p>
<p>The advantage here is that you don't need to worry about any kind of register. Saving the state is handled by the async state machine and you can just call that one function to run the state machine to resume the guest application.</p>
<p>The disadvantage is that this is really only practical if the web assembly is written in Rust, and the person writing this Rust code must correctly write an async application.<br>
</p>
</blockquote>



<a name="243523945"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243523945" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243523945">(Jun 22 2021 at 14:22)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866028522">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>To be able to interrupt and save the state of executing WASM code and then resume it later, possibly on a different host machine.</p>
</blockquote>
<p>The on a different host machine will require pessimizing optimizations such that between every instruction all locals and the full stack is known as different backends may optimize instructions in different ways and thus require different information to at a given point continue running. This will probably a significant perf hit. Alternatively interrupting could be limited to certain safepoints, allowing a much smaller perf hit.</p>
<blockquote>
<p>The default Lua interpreter uses a custom implementation of Lua that can save and restore its state like this.</p>
</blockquote>
<p>It is much easier to implement this in an interpreter than a compiler as an interpreter needs to keep all state, while a compiler will "forget" about state as soon as possible to reduce register pressure and will try to fold instructions together (and thus allow forgetting about certain locals) or mangle them in different ways.</p>
</blockquote>



<a name="243525568"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243525568" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243525568">(Jun 22 2021 at 14:33)</a>:</h4>
<p>IamTheCarl <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866037344">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>The on a different host machine will require pessimizing optimizations such that between every instruction all locals and the full stack is known as different backends may optimize instructions in different ways and thus require different information to at a given point continue running. This will probably a significant perf hit.</p>
</blockquote>
<p>I was worried that would be the problem.</p>
<blockquote>
<p>Alternatively interrupting could be limited to certain safepoints, allowing a much smaller perf hit.</p>
</blockquote>
<p>I could easily trick the user into having regular safe points by requiring them to regularly check into something like a watch dog timer. How would you suggest saving the state at these safe points?</p>
</blockquote>



<a name="243531954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243531954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243531954">(Jun 22 2021 at 15:17)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866074761">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>How would you suggest saving the state at these safe points?</p>
</blockquote>
<p>That will still require changes to Cranelift to allow for saving the state and restoring at such a safe point. The changes are just easier and with less of a perf hit than allowing it at arbitrary points.</p>
</blockquote>



<a name="243538030"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243538030" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243538030">(Jun 22 2021 at 15:58)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866113996">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>@IamTheCarl thanks for starting this conversation -- it's a really interesting one!</p>
<p>I'm curious what sort of state-saves are actually necessary. As @bjorn3 says, very general snapshotting at arbitrary points is expensive; if we needed to do something like that, probably the better way would be to just save the registers, heap and stack, ensure we restore into the same generated code (this has limits wrt CPU features too, as mentioned above), and take care to make the stack <em>and register file</em> "relocatable", in the sense that they can be fixed up for other heap-base addresses on restore. (Some thoughts on that: to do so, probably the easiest way would be to tweak codegen so that the heap base always lives in one pinned register, and any address computation uses that as part of its address expression, so we never have intermediate pointers in registers or spilled to stack. Then we just have to fix up frame pointers and return-area pointers on the stack.)</p>
<p>But there's a potentially much easier way: could we get away with only snapshotting when no Wasm frame is on the stack? In other words, when a call into the Wasm has returned all the way out? If so, then we don't have to worry about register or stack state at all; we can just snapshot the heap and globals. We could even restore with different generated code, on a different architecture or just with different CPU features.</p>
<p>This is sort of like what Wizer does, so that's probably the place to look for more ideas. cc @fitzgen for more thoughts!</p>
</blockquote>



<a name="243547149"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243547149" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243547149">(Jun 22 2021 at 17:04)</a>:</h4>
<p>IamTheCarl <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866167893">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>That does sound a bit like my alternative solution.</p>
<p>The idea was to regularly call a function that would let the guest run for a short bit and then return shortly after. It would be up to the developer of the guest code to keep track of the state between calls.<br>
This is inconvenient for the guest developer, since they need to write an application that can run in such an environment (some global mutable variables will be needed). In Rust, using async can make this pretty intuitive, but other languages like C would require they manually build their own state machine.</p>
<p>Of course if we're taking it that far I could then even push off the job of serialization to the guest code. Just send it some kind of event "shutdown now or you'll be force terminated" and that'll give them just a moment to save their state before shutdown. This one is so simple to implement that wasmtime wouldn't even need any modifications, but it is also the most inconvenient for the developer of guest code.</p>
</blockquote>



<a name="243551759"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243551759" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243551759">(Jun 22 2021 at 17:35)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866190506">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>This is sort of like what Wizer does, so that's probably the place to look for more ideas. cc @fitzgen for more thoughts!</p>
</blockquote>
<p>Yeah, saving state without frames on the stack is pretty easy, and as Wizer shows, you don't even need to build that functionality into the engine itself, you can do it with the standard reflection APIs that engines expose and use Wasm itself as your snapshot format. You could even factor out the code from the data (snapshot) and make it so that you don't need to recompile the code for each snapshot, just reuse the already-compiled module from before and pass in new memory/globals for its imports.</p>
<p>Binaryen's asyncify pass can help turn synchronous code into asynchronous code. If my understanding is correct, it lifts frame activations and their local values into linear memory and does some kind of CPS-esque transformation on the code. It might make assumptions about the Web or that you're also using Emscripten; not sure, I haven't actually used it. This might be one way to transform the Wasm so that code can be written synchronously but still make snapshotting with zero activations on the stack viable.</p>
<hr>
<p>One final thought: snapshotting at ~gc safe points could be made possible relatively easily if we spill <em>all</em> registers at safe points. This would be a config option, because we wouldn't want to do this unconditionally. But if we only have to capture and restore stack values, that seems like a much easier problem. Hard part is addressing native pointers. I don't have any good ideas here, but I think you may have some, @cfallin.</p>
</blockquote>



<a name="243556375"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243556375" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243556375">(Jun 22 2021 at 18:07)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866216062">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>I think you may have some, @cfallin.</p>
</blockquote>
<p>Indeed! This is the bit about "no intermediate pointers in registers or the stack" alluded to above. To add a bit more detail, just to get this written down:</p>
<ul>
<li>We need to be a little careful in legalization: where we have loads/stores that decompose into either <code>heap_addr</code> or <code>stack_addr</code> and a native-pointer load/store, we need to at least keep the ops close in the CLIF so that they can be pattern-matched, or ideally do codegen directly on the heap/stack-level ops without decomposing them.</li>
<li>The goal is to turn every Wasm heap access into e.g. <code>ld rA, [rBase + rB]</code> where <code>rB</code> is a 32-bit Wasm pointer, and <code>rBase</code> is a fixed register that we decide and make non-allocatable. We make this part of an internal Wasmtime ABI, and set it before calling into Wasm. (This implies a little care taken w.r.t. hostcalls too but that's manageable I think.)</li>
<li>Similarly, every stack-slot access turns into <code>ld rA, [sp + ...]</code>; we never copy <code>sp</code> to another register and compute an address based on it.</li>
<li>We need to tweak the internal ABI to deal with return-area pointers (for multiple return values) slightly differently. Probably we just use a fixed offset from frame at entry, rather than passing an implicit arg with the pointer.</li>
<li>Finally, either codegen without a frame pointer, or be prepared to fix up the frame-pointer chain on relocation.</li>
</ul>
<p>Given those codegen changes, the code is completely "data-relocatable": the <em>only</em> native-address-space pointers in the register file or on the stack at any time are in <code>sp</code> and <code>rBase</code>. If we set those to different values on Wasm re-start after moving data, we should be just fine.</p>
<p>(Caveat: return addresses; if code is relocated too, probably best to retain frame-pointer chain, rewrite return addresses as relative to module base on snapshot, and re-add the new module base on restore.)</p>
<p>Probably a few weeks' work but would be very useful even beyond this use-case!</p>
</blockquote>



<a name="243563013"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243563013" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243563013">(Jun 22 2021 at 18:57)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866249666">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>This is the bit about "no intermediate pointers in registers or the stack" alluded to above.</p>
</blockquote>
<p>Intermediate pointers are fine if they aren't used across a safe point or if it is the vmctx. In the former case they simply wouldn't need to be stored and in the later case the vmctx value can (and should) trivially be replaced with the newly allocated vmctx when loading.</p>
<blockquote>
<p>We need to tweak the internal ABI to deal with return-area pointers (for multiple return values) slightly differently. Probably we just use a fixed offset from frame at entry, rather than passing an implicit arg with the pointer.</p>
</blockquote>
<p>If this parameter is properly annotated it can be fixed up when loading too by looking at the caller.</p>
<blockquote>
<p>Finally, either codegen without a frame pointer, or be prepared to fix up the frame-pointer chain on relocation.</p>
</blockquote>
<p>The stack doesn't need to be copied verbatim. Only the known locations of spilled values, explicit stackslots (unused by wasm) and the return value need to be copied. The later can be stored as function index + callsite index.</p>
</blockquote>



<a name="243563225"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243563225" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243563225">(Jun 22 2021 at 18:58)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866250632">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>Probably a few weeks' work but would be very useful even beyond this use-case!</p>
</blockquote>
<p>Yeah, might be useful for on stack replacement for eg speculative optimization or going from an interpreter to jitted code.</p>
</blockquote>



<a name="243825974"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243825974" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243825974">(Jun 24 2021 at 18:20)</a>:</h4>
<p>IamTheCarl <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-867857009">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>I am impressed with both the quick reply and eagerness to find solutions in this team.<br>
I'm grateful.</p>
<p>There's a lot of terminology here I'm unfamiliar with, so I'd like to check and make sure I'm following this conversation correctly.<br>
It sounds like your plan at the moment is to take a non-async WASM module and transform it into an async form before it even hits the JIT. I assume this will be implemented somewhere in the IR layer. That's pretty cool.</p>
<p>It also sounds like you're having difficulty knowing how to serialize objects on the heap? I can understand why that would be an issue since you can't depend on getting those same addresses back.</p>
<p>So what comes next?<br>
I'd like to help but I feel I have a lot to catch up on to make a meaningful contribution.</p>
</blockquote>



<a name="243827850"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/243827850" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#243827850">(Jun 24 2021 at 18:34)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-867865009">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>@IamTheCarl it spawned an interesting discussion and one that's timely for other potential uses too, so thank you for starting it!</p>
<blockquote>
<p>non-async Wasm module and transform it</p>
</blockquote>
<p>Yes, this is probably the "easiest" solution (for some definition of easy) -- as @fitzgen suggested above, the Binaryen toolchain has an asyncify transform that might help turn arbitrary Wasm into something that would work with your "call into and execute a bit of Wasm at a time" approach; between those calls, all you need to save is the Wasm heap and globals, not any in-progress execution state such as registers or stack. I don't know much about this tool but it looks like there's a pretty comprehensive intro blog post here: <a href="https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html">https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html</a></p>
<p>The next step after that is to modify Wasmtime itself so that it generates code that allows for snapshotting and restoring, including the in-progress execution state. There are various tradeoffs here involving whether we want to allow restoring on a different machine architecture (hardest), or just with identical JIT'd code (easier); and whether we want to allow arbitrary interruption and checkpoint at any point (hardest, possibly pessimizes codegen), or checkpoint only at certain points, which we're calling "safepoints" above, in reference to some garbage-collector terminology (a bit easier). Anything along these lines though would not be a quick short-term solution for you, so I personally would suggest looking into the asyncify option, or perhaps just defining an execution model where control always returns from your Wasm module periodically.</p>
</blockquote>



<a name="272520666"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/272520666" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#272520666">(Feb 19 2022 at 14:09)</a>:</h4>
<p>RobDavenport <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046026012">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<blockquote>
<p>But there's a potentially much easier way: could we get away with only snapshotting when no Wasm frame is on the stack? In other words, when a call into the Wasm has returned all the way out? If so, then we don't have to worry about register or stack state at all; we can just snapshot the heap and globals.</p>
</blockquote>
<p>Does a method to do this currently exist? I'm exploring various wasm runtimes and have been unable to find such a feature supported as of yet. If not, how difficult would it be to implement? I may be able to take a look at it as it seems to be a heavily requested feature.</p>
</blockquote>



<a name="272528666"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/272528666" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#272528666">(Feb 19 2022 at 16:48)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046058341">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Isn't that what <a href="https://github.com/bytecodealliance/wizer">wizer</a> does?</p>
</blockquote>



<a name="272596455"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/272596455" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#272596455">(Feb 20 2022 at 14:45)</a>:</h4>
<p>RobDavenport <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046253419">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Ahh silly me - I did a google search on wizer after seeing it mentioned before and came up with a completely different result. But yes it looks like it's quite similar to what I'm looking for. While the caveats don't work for my specific use case, (specifically, not being able to call imported functions), it does provide enough of an idea of how to proceed for now.</p>
</blockquote>



<a name="272596481"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/272596481" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#272596481">(Feb 20 2022 at 14:45)</a>:</h4>
<p>RobDavenport edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046253419">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Ahh silly me - I did a google search on wizer after seeing it mentioned before and came up with a completely different unrelated result. But yes it looks like it's quite similar to what I'm looking for. While the caveats don't work for my specific use case, (specifically, not being able to call imported functions during the init function), it does provide enough of an idea of how to proceed for now.</p>
</blockquote>



<a name="272831789"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/272831789" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#272831789">(Feb 22 2022 at 16:51)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1048002291">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Indeed, Wizer came up in the above discussion as well; the main difference in my mind (at least as far as I can remember now) was whether this would be a more generic facility, with an API to snapshot/resume at arbitrary points. Wizer currently runs a <code>wizer.initialize</code> export, and doesn't allow calls to imports (or can allow WASI, as a special case), so it's targeted toward a "precompute some state once" use-case. I imagine it could be extended to be more general, of course!</p>
<p>Interestingly there was a recent PR from @koute (#3691) that did snapshotting as well. The specific use case in that PR should I think be mostly covered by our recent instantiation-time improvements. But if snapshotting in a more general sense continues to arise as a need, at the Wasmtime API level, that could merit more discussion, I suppose.</p>
<p>@RobDavenport I'm curious about your use-case here, on a few axes: (i) do you need continued snapshot/restore (i.e. multiple roundtrips), or just one initial snapshot and then restores from that? And (ii) does it need to be programmatic at the Wasmtime API level, or is a separate tool (e.g. Wizer) usable for you?</p>
</blockquote>



<a name="273132757"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/273132757" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#273132757">(Feb 24 2022 at 18:51)</a>:</h4>
<p>RobDavenport <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1050157608">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Thanks for the question @cfallin , in my case I'm writing something like a game engine and using WASM as my game-logic code. As a need to support rollback multiplayer (like GGPO which is often used in emulators), I need to consistently store the entire state of the game for the past few frames, and, if a mis-prediction is detected, rollback to a confirmed synchronized state and re-simulate the rest of the frames (often more than one!) with the new input up until the current time.</p>
<p>I was actually able to get this working for the most part by following the suggestions in this thread, along with some things from Wizer. Iterating through the instance's exports, cloning the memories and non-const globals, and then just saving them out as a <code>Box&lt;[u8]&gt;</code> via <code>data_unchecked()</code> or as a WASM <code>Value</code> enum along with the related keys. </p>
<p>Loading saved globals is very straightforward and doesn't need any explanation. For memories, doing a <code>copy_from_slice</code> from the snapshot back into the "hot" memory, using the length of the snapshot so the copy function doesn't panic. I believe the snapshot's reserved memory size should always be equal to or less than the "hot" memory, since the WASM's host memory can only grow for a particular instance, and since that snapshot was an actual state the VM was in at one point, the internals should have already allocated enough space for it. </p>
<p>I'm not sure how dangerous this might be since the WASM client script may be allocating or deallocating memory, but I'm under the assumption that since it's all lumped together and already allocated inside the WASM host VM then it should just work unless the instance or store are moved somehow.</p>
<p>So to answer your questions... (i) Yes, multiple trips will be made, however at specific times determined by the host program <em>without</em> any call frames on the stack. These will always be going back in time, though, and then re-simulating and rewriting old snapshots as we progress. (ii) Actually I have no preference, as I was able to do it for my use case mentioned above. The reason I couldn't use Wizer in my case was I needed to allow the WASM code to make callbacks into the host for things like input handling or draw requests.</p>
<p>However, I believe the original requester for this specifically wanted a way to be able to save/resume the WASM state on a fresh application or even potentially another machine. Unfortunately I'm not too familiar with how the internals work so I can't comment on the safety or feasibility of that, as my quick hack is only intended to work with a single module instance, on the same machine, during the same application lifetime.</p>
</blockquote>



<a name="327656020"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/327656020" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#327656020">(Feb 13 2023 at 22:14)</a>:</h4>
<p>IamTheCarl <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1428765859">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>I'm curious if much work has been done on this.<br>
I have another toy project idea where a feature like this could be useful.</p>
<p>I saw that there now appears to be an async interface for wasmtime which I imagine would be useful for a feature like this.</p>
</blockquote>



<a name="327659719"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/327659719" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#327659719">(Feb 13 2023 at 22:41)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1428800616">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>Not much has changed regarding the fundamentals here since the last comments; Wizer is still the state-of-the-art, and unfortunately we don't have anything built into Wasmtime itself for snapshotting.</p>
</blockquote>



<a name="431141348"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/431141348" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#431141348">(Apr 03 2024 at 17:21)</a>:</h4>
<p>ZheniaZuser <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>How hard it would be to make WASI WebGPU and File system to work well with this (properly resume from saved state)?</p>
<p>This may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>
</blockquote>



<a name="431141846"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/431141846" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#431141846">(Apr 03 2024 at 17:25)</a>:</h4>
<p>ZheniaZuser edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>How hard it would be to make WASI WebGPU and File system (assuming the FS will never be changed by any other process) to work well with this (properly resume from saved state)?</p>
<p>This may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>
</blockquote>



<a name="431141897"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233017%20Save%20WASM%20state%20and%20resume/near/431141897" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233017.20Save.20WASM.20state.20and.20resume.html#431141897">(Apr 03 2024 at 17:25)</a>:</h4>
<p>ZheniaZuser edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3017">issue #3017</a>:</p>
<blockquote>
<p>How hard it would be to make WASI WebGPU and File system (assuming the FS will never be changed by any other process) to work well with this (properly resume from saved state)?</p>
<p>This sounds like it may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>