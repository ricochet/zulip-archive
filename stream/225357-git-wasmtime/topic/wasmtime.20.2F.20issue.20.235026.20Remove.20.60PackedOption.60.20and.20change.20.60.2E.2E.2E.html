<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5026 Remove `PackedOption` and change `... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html">wasmtime / issue #5026 Remove `PackedOption` and change `...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="302647884"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/302647884" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#302647884">(Oct 06 2022 at 13:08)</a>:</h4>
<p>jakubDoka opened <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Removal of <code>PackedOption</code>. Making <code>EntityRef</code> a generic struct, where <code>T</code> would be the type it is pointing to.</p>
<h4>Benefit</h4>
<p><code>PackedOption</code> is making code verbose and unnatural. This proposal allows using <code>Option</code> while preserving advantages of <code>PackedOption</code>s compactness. Also eliminates need for <code>ReservedValue</code>.</p>
<p>Changing <code>EntityRef</code> from trait to generic struct can greatly simplify <code>cranelift_entity</code> implementation and save us some names when defining entity data. The structure can also implement all of the useful traits on one place so no shorthand macro is needed.</p>
<h4>Implementation</h4>
<p>Here is a quick demonstration of how this can work. This solution requires (forever) unstable feature.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(rustc_attrs)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">ops</span>::<span class="p">{</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">IndexMut</span><span class="p">}};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">EntityRef</span>::<span class="n">new</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"no more entities can be spawned"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// We might want to choose a different index representation but most common one is</span>
<span class="c1">// as default. Also the name is a bit long for something common, `ERef` or `VRef`</span>
<span class="c1">// (Virtual Reference) might be a better fit.</span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span>: <span class="nc">EntityRefRepr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">R</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">R</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="bp">Self</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">index</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">args</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Making representation as flexible as possible.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EntityRefRepr</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Compiler is able to optimize the size</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Works even on structures that contain non-optional `EntityRef`</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>

<span class="c1">// If we cannot use nightly, this solution is basically useless :(</span>
<span class="cp">#[rustc_layout_scalar_valid_range_end(4294967294)]</span><span class="w"></span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NonMaxU32</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// might not be correct implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">EntityRefRepr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>More extensive demonstration can be found <a href="https://github.com/jakubDoka/Catalyst">here</a>.<br>
</p>
</blockquote>



<a name="302648520"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/302648520" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#302648520">(Oct 06 2022 at 13:11)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-1270020327">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<blockquote>
<p><code>rust
// If we cannot use nightly, this solution is basically useless :(
</code></p>
</blockquote>
<p>Yeah, we can't use unstable.</p>
</blockquote>



<a name="302649291"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/302649291" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#302649291">(Oct 06 2022 at 13:15)</a>:</h4>
<p>jakubDoka <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-1270027062">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>Okay, was not sure about that, I'll close this.<br>
</p>
</blockquote>



<a name="302649368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/302649368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#302649368">(Oct 06 2022 at 13:16)</a>:</h4>
<p>jakubDoka closed <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Removal of <code>PackedOption</code>. Making <code>EntityRef</code> a generic struct, where <code>T</code> would be the type it is pointing to.</p>
<h4>Benefit</h4>
<p><code>PackedOption</code> is making code verbose and unnatural. This proposal allows using <code>Option</code> while preserving advantages of <code>PackedOption</code>s compactness. Also eliminates need for <code>ReservedValue</code>.</p>
<p>Changing <code>EntityRef</code> from trait to generic struct can greatly simplify <code>cranelift_entity</code> implementation and save us some names when defining entity data. The structure can also implement all of the useful traits on one place so no shorthand macro is needed.</p>
<h4>Implementation</h4>
<p>Here is a quick demonstration of how this can work. This solution requires (forever) unstable feature.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(rustc_attrs)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">ops</span>::<span class="p">{</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">IndexMut</span><span class="p">}};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">EntityRef</span>::<span class="n">new</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"no more entities can be spawned"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// We might want to choose a different index representation but most common one is</span>
<span class="c1">// as default. Also the name is a bit long for something common, `ERef` or `VRef`</span>
<span class="c1">// (Virtual Reference) might be a better fit.</span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span>: <span class="nc">EntityRefRepr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">R</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">R</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="bp">Self</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">index</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">args</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Making representation as flexible as possible.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EntityRefRepr</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Compiler is able to optimize the size</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Works even on structures that contain non-optional `EntityRef`</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>

<span class="c1">// If we cannot use nightly, this solution is basically useless :(</span>
<span class="cp">#[rustc_layout_scalar_valid_range_end(4294967294)]</span><span class="w"></span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NonMaxU32</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// might not be correct implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">EntityRefRepr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>More extensive demonstration can be found <a href="https://github.com/jakubDoka/Catalyst">here</a>.<br>
</p>
</blockquote>



<a name="305909928"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/305909928" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#305909928">(Oct 24 2022 at 20:37)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-1289584068">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p><code>PackedOption</code> has been bothering me too, so I was recently also thinking about ways to remove it.</p>
<p>I'd considered using <code>NonZeroU32</code> and making the reserved value be 0 instead of <code>u32::MAX</code>. That would work on stable rustc, but I haven't gotten past idly thinking about it, so maybe there are other difficulties I haven't thought of. For example, does subtracting 1 to get a valid array index in <code>SecondaryMap</code> impose a significant compile-time cost? Individually that's very cheap, but we index into those maps a lot, so maybe it matters.</p>
<p>If you want to try a few things I'd be happy to answer questions and review PRs.</p>
<p>Regardless, I'm re-opening this issue because unless we have evidence that the current design is the best option we have, I think it's worth considering alternatives to <code>PackedOption</code>.</p>
</blockquote>



<a name="305909929"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/305909929" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#305909929">(Oct 24 2022 at 20:37)</a>:</h4>
<p>jameysharp reopened <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Removal of <code>PackedOption</code>. Making <code>EntityRef</code> a generic struct, where <code>T</code> would be the type it is pointing to.</p>
<h4>Benefit</h4>
<p><code>PackedOption</code> is making code verbose and unnatural. This proposal allows using <code>Option</code> while preserving advantages of <code>PackedOption</code>s compactness. Also eliminates need for <code>ReservedValue</code>.</p>
<p>Changing <code>EntityRef</code> from trait to generic struct can greatly simplify <code>cranelift_entity</code> implementation and save us some names when defining entity data. The structure can also implement all of the useful traits on one place so no shorthand macro is needed.</p>
<h4>Implementation</h4>
<p>Here is a quick demonstration of how this can work. This solution requires (forever) unstable feature.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#![feature(rustc_attrs)]</span><span class="w"></span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">,</span><span class="w"> </span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">ops</span>::<span class="p">{</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">IndexMut</span><span class="p">}};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">EntityRef</span>::<span class="n">new</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">"no more entities can be spawned"</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PrimaryMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">index</span><span class="p">()]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// We might want to choose a different index representation but most common one is</span>
<span class="c1">// as default. Also the name is a bit long for something common, `ERef` or `VRef`</span>
<span class="c1">// (Virtual Reference) might be a better fit.</span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span>: <span class="nc">EntityRefRepr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">R</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">R</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="bp">Self</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">PhantomData</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">index</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">args</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Making representation as flexible as possible.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EntityRefRepr</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Compiler is able to optimize the size</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Works even on structures that contain non-optional `EntityRef`</span>
<span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">assert!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">EntityRef</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;&gt;&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>

<span class="c1">// If we cannot use nightly, this solution is basically useless :(</span>
<span class="cp">#[rustc_layout_scalar_valid_range_end(4294967294)]</span><span class="w"></span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NonMaxU32</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">mem</span>::<span class="n">transmute</span><span class="p">(</span><span class="bp">Self</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// might not be correct implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">EntityRefRepr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NonMaxU32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InitArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">args</span>: <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">InitArgs</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>More extensive demonstration can be found <a href="https://github.com/jakubDoka/Catalyst">here</a>.<br>
</p>
</blockquote>



<a name="305912291"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/305912291" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#305912291">(Oct 24 2022 at 20:55)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-1289605793">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>It's definitely worth thinking about options (... uh, pun definitely not intended) here. That said, I'd be a little concerned about an "off by one" invariant: it feels like a bug waiting to happen, or at the very least, a source of confusion when debugging. In addition to that I suspect it might actually carry a measurable cost, given how frequently we access entities given their IDs.</p>
<p>IMHO we probably need to wait until we can encode the invariant for the compiler so it can reason about the niche on its own (i.e. wait for something like the above to become possible in stable Rust).</p>
</blockquote>



<a name="305912619"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/305912619" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#305912619">(Oct 24 2022 at 20:57)</a>:</h4>
<p>sunfishcode <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-1289608394">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>An RFC for a way to encode these kinds of invariants for the compiler to reason about was just opened yesterday: <a href="https://github.com/rust-lang/rfcs/pull/3334">https://github.com/rust-lang/rfcs/pull/3334</a></p>
</blockquote>



<a name="451372889"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/451372889" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#451372889">(Jul 14 2024 at 18:25)</a>:</h4>
<p>meithecatte <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-2227443493">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<blockquote>
<p>I'd be a little concerned about an "off by one" invariant: it feels like a bug waiting to happen, or at the very least, a source of confusion when debugging.</p>
</blockquote>
<p>The way I'd approach this is to encapsulate this into a <code>NonMaxU32</code> type, that does the +/-1 internally during conversions. Then you get a seamless transition once Rust supports something like this natively, and in the meantime, you don't need to worry about correctness.</p>
<p>I am not sure how much actual debuggers are used by cranelift developers (as opposed to <code>dbg!</code>). Handling them properly would require some kind of debugger integration. But cranelift already uses many debugger-unfriendly things – such as data that can't really be interpreted without external context structs, so I imagine that <code>dbg!</code>-style debugging would be much more common – which can be addressed with a proper <code>Debug</code> implementation.</p>
<blockquote>
<p>In addition to that I suspect it might actually carry a measurable cost, given how frequently we access entities given their IDs.</p>
</blockquote>
<p>I wouldn't be too surprised if this turned out to be in the noise. When used as an index, the +/-1 will just be folded into the addressing mode. An extra byte to fetch, and probably zero cost when actually executing (this is me going purely off vibes, I don't know the exact numbers for address generation latency and I don't have the proficiency with the relevant documentation to look it up in reasonable time).</p>
<p>It might even be the case that it'll be a performance win, because the niche at 0 will be easier to test for than <code>u32::MAX</code>.</p>
<p>In fact, there is a chance that the biggest difference will happen whether Rust has support for custom niches or not – the current implementation is "unsafe", with the check for accidentally creating the reserved value by converting a <code>u32</code> being only a <code>debug_assert!</code>. Switching to <code>NonZeroU32</code> will force actually performing this bounds-check.</p>
</blockquote>



<a name="451739466"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/451739466" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#451739466">(Jul 16 2024 at 11:35)</a>:</h4>
<p>jakubDoka <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-2230672245">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>you could also use an array container optimized for 1-based indexing, meaning that the base pointer is always offset by -1 to cancel the index +1 offset, tho miri will be angry</p>
</blockquote>



<a name="451740947"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/451740947" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#451740947">(Jul 16 2024 at 11:46)</a>:</h4>
<p>jakubDoka edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-2230672245">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>you could also use an array container optimized for 1-based indexing, meaning that the base pointer is always offset by -1 to cancel the index +1 offset, tho miri will be angry</p>
<p>edit: another way that surprisingly respects provenance, is offsetting the base by length and subtracting the index, which inverts the order of everything</p>
</blockquote>



<a name="492362973"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/492362973" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#492362973">(Jan 07 2025 at 18:23)</a>:</h4>
<p>hanna-kruppe <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-2575959897">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>The <a href="https://docs.rs/sign-bound/latest/sign_bound/">sign-bound</a> crate demonstrates a neat trick that works on stable and avoids extra arithmetic on indexing as well as unusual addressing modes that are less efficient on some architectures:</p>
<ol>
<li>Define a <code>repr(u8)</code> enum that has variants for every valid value of the <em>most significant byte</em> of your integers. <code>sign-bound</code> uses this for positive and negative integers, so it has two enums of 127 variants each, but for cranelift-entity's purpose the range can be <code>0..=254</code>.</li>
<li>Define a a <code>#[repr(C, align(4))]</code> struct that represents an u32 with the MSB stored as this enum, plus three <code>u8</code>s for the remaining bytes. The correct order of these fields depends on <code>cfg(target_endian)</code>. Doing this for all integer types, as <code>sign-bound</code> does, needs some serious macro-fu, but cranelift-entity only needs the u32 case.</li>
</ol>
<p>I'll call this struct <code>NonMaxU32</code> for brevity, although that's not quite correct. This type is guaranteed to have the same representation in memory as an u32 integer thanks to the <code>repr</code> annotations, so it can be transmuted into and from <code>u32</code> -- as long as the u32 is less than <code>0xFF_00_00_00</code>. This restriction on the MSB enables rustc to make <code>Option&lt;NonMaxU32&gt;</code> the same size. While this layout optimization is not guaranteed, it's fairly simple and has existed for a long time, so I wouldn't be worried about relying on it for performance. However, there's some other limitations:</p>
<ul>
<li>There are no guarantees about the memory layout of <code>Option&lt;NonMaxU32&gt;</code>, nor about how it's handled by calling conventions (unlike <code>repr(transparent)</code> wrappers like <code>NonZeroU32</code>). So the guarantee about <code>PackedOption</code>'s layout added in <a href="https://github.com/bytecodealliance/wasmtime/pull/9697">https://github.com/bytecodealliance/wasmtime/pull/9697</a> can't be salvaged with this approach.</li>
<li>Getting good performance relies on <code>NonZeroU32</code> being passed around and operated on as an ordinary integer, not as an aggregate with four fields. This is not true for the C calling convention on several platforms. Empirically it seems to work fine with the Rust calling convention today (see <a href="https://rust.godbolt.org/z/3sd3K9sdK">https://rust.godbolt.org/z/3sd3K9sdK</a>), but it's not guaranteed.</li>
<li>On some architectures, <code>0xFF_00_00_00</code> is a more awkward to encode as immediate operand than <code>u32::MAX</code> and <code>0</code>. Thus, the comparisons done by <code>EntityRef::new</code> and by pattern matching on <code>Option&lt;NonMaxU32&gt;</code> may sometimes require an extra instruction or a longer instruction encoding.</li>
<li>Because the entire range <code>0xFF_00_00_00..=u32::MAX</code> is invalid, a checked conversion <code>u32 -&gt; Option&lt;NonMaxU32&gt;</code> has to do a comparison and normalize out-of-range values to the <code>None</code> representative (unlike <code>u32 -&gt; Option&lt;NonZeroU32&gt;</code>, which is just a transmute).</li>
<li>It can't represent quite as many distinct values as a type that only excludes <code>u32::MAX</code>, but the difference is tiny, relatively speaking (4.278 billion vs 4.295 billion).</li>
</ul>
</blockquote>



<a name="492485486"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235026%20Remove%20%60PackedOption%60%20and%20change%20%60.../near/492485486" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235026.20Remove.20.60PackedOption.60.20and.20change.20.60.2E.2E.2E.html#492485486">(Jan 08 2025 at 11:35)</a>:</h4>
<p>hanna-kruppe edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5026#issuecomment-2575959897">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5026">issue #5026</a>:</p>
<blockquote>
<p>The <a href="https://docs.rs/sign-bound/latest/sign_bound/">sign-bound</a> crate demonstrates a neat trick that works on stable and avoids extra arithmetic on indexing as well as unusual addressing modes that are less efficient on some architectures:</p>
<ol>
<li>Define a <code>repr(u8)</code> enum that has variants for every valid value of the <em>most significant byte</em> of your integers. <code>sign-bound</code> uses this for positive and negative integers, so it has two enums of 127 variants each, but for cranelift-entity's purpose the range can be <code>0..=254</code>.</li>
<li>Define a a <code>#[repr(C, align(4))]</code> struct that represents an u32 with the MSB stored as this enum, plus three <code>u8</code>s for the remaining bytes. The correct order of these fields depends on <code>cfg(target_endian)</code>. Doing this for all integer types, as <code>sign-bound</code> does, needs some serious macro-fu, but cranelift-entity only needs the u32 case.</li>
</ol>
<p>I'll call this struct <code>NonMaxU32</code> for brevity, although that's not quite correct. This type is guaranteed to have the same representation in memory as an u32 integer thanks to the <code>repr</code> annotations, so it can be transmuted into and from <code>u32</code> -- as long as the u32 is less than <code>0xFF_00_00_00</code>. This restriction on the MSB enables rustc to make <code>Option&lt;NonMaxU32&gt;</code> the same size. While this layout optimization is not guaranteed, it's fairly simple and has existed for a long time, so I wouldn't be worried about relying on it for performance. However, there's some other limitations:</p>
<ul>
<li>There are no guarantees about the memory layout of <code>Option&lt;NonMaxU32&gt;</code>, nor about how it's handled by calling conventions (unlike <code>repr(transparent)</code> wrappers like <code>NonZeroU32</code>). So the guarantee about <code>PackedOption</code>'s layout added in <a href="https://github.com/bytecodealliance/wasmtime/pull/9697">https://github.com/bytecodealliance/wasmtime/pull/9697</a> can't be salvaged with this approach.</li>
<li>Getting good performance relies on the struct being passed around and operated on as an ordinary integer, not as an aggregate with four fields. This is not true for the C calling convention on several platforms. Empirically it seems to work fine with the Rust calling convention today (see <a href="https://rust.godbolt.org/z/3sd3K9sdK">https://rust.godbolt.org/z/3sd3K9sdK</a>), but it's not guaranteed.</li>
<li>On some architectures, <code>0xFF_00_00_00</code> is a more awkward to encode as immediate operand than <code>u32::MAX</code> and <code>0</code>. Thus, the comparisons done by <code>EntityRef::new</code> and by pattern matching on <code>Option&lt;NonMaxU32&gt;</code> may sometimes require an extra instruction or a longer instruction encoding.</li>
<li>Because the entire range <code>0xFF_00_00_00..=u32::MAX</code> is invalid, a checked conversion <code>u32 -&gt; Option&lt;NonMaxU32&gt;</code> has to do a comparison and normalize out-of-range values to the <code>None</code> representative (unlike <code>u32 -&gt; Option&lt;NonZeroU32&gt;</code>, which is just a transmute).</li>
<li>It can't represent quite as many distinct values as a type that only excludes <code>u32::MAX</code>, but the difference is tiny, relatively speaking (4.278 billion vs 4.295 billion).</li>
</ul>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>