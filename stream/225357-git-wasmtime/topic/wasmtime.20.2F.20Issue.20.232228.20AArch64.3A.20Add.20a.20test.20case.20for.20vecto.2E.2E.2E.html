<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #2228 AArch64: Add a test case for vecto... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html">wasmtime / Issue #2228 AArch64: Add a test case for vecto...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="211191356"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211191356" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211191356">(Sep 24 2020 at 21:20)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-698594473">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>The default call call conv for aarch64 is systemv, not aapcs. There are some differences between the two in the float handling on at least arm32. For example <a href="https://github.com/rust-lang/rust/blob/85fbf49ce0e2274d0acf798f6e703747674feec3/compiler/rustc_target/src/abi/call/arm.rs#L91">https://github.com/rust-lang/rust/blob/85fbf49ce0e2274d0acf798f6e703747674feec3/compiler/rustc_target/src/abi/call/arm.rs#L91</a>. I don't know if this is also the case on aarch64 and if so if this is one example.</p>
</blockquote>



<a name="211191916"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211191916" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211191916">(Sep 24 2020 at 21:26)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-698597042">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @bnjbvr</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>bnjbvr: cranelift</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="211193478"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211193478" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211193478">(Sep 24 2020 at 21:44)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-698605150">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>AArch32 is a completely different case, in which there are many ABI variants indeed.</p>
</blockquote>



<a name="211193847"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211193847" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211193847">(Sep 24 2020 at 21:48)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-698606795">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>Thanks @akirilov-arm -- it seems you're right that we could save half of our stack space and memory traffic for FP/vec clobber-saves. This should be a straightforward change in the ABI code; I want to verify first that this won't break SpiderMonkey (I think not, as every register is caller-save, IIRC) then I'll create a PR.</p>
</blockquote>



<a name="211195690"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211195690" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211195690">(Sep 24 2020 at 22:10)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-698614870">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>@cfallin I might have misunderstood you, but let me rephrase: There are 2 issues - one on the caller and one on the callee side. You are talking about the latter, but I am more concerned about the former. Consider the test case in the PR - the compiler is stashing the vectors (and they are full, 128-bit vectors) before the call to <code>%g1</code> in <code>v8</code>, <code>v9</code>, and <code>v10</code>, respectively, which is not going to work in the general case, assuming AAPCS64 compliance.</p>
<p>For comparison, <a href="https://godbolt.org/z/fWqeKo">here</a> is what GCC and LLVM are doing in an equivalent situation.</p>
</blockquote>



<a name="211330917"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211330917" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211330917">(Sep 26 2020 at 00:03)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-699230000">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>Ah, right, this is a bigger issue with respect to callsites; I had missed that half of it, sorry. So because we don't reason about half-clobbers currently (or overlapping registers), we need to treat all vector registers as clobbers on the caller side. I'll create a patch for this first thing Monday.</p>
</blockquote>



<a name="211568722"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211568722" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211568722">(Sep 29 2020 at 00:40)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-700356935">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>So on further consideration (and after doing the one-line patch suggested and studying its effect), the solution is actually more complex than I had suggested above:</p>
<ul>
<li>We need to consider the "half caller-saves" as caller-saves when we generate calls, or else we incorrectly use registers that will be clobbered, as you say.</li>
<li>At the same time, we need to consider the "half caller-saves" as callee-saves when we generate prologues and epilogues, because if we modify the low half we really do need to save them per the ABI.</li>
</ul>
<p>The problem is how these interact: any function call at all now forces a bunch of clobber saves/restores in the caller's prologue and epilogue, because the half-clobbers from the call become full-clobbers (due to the imprecision of not reasoning about half-registers).</p>
<p>In essence, we need a way to "pass through" the half-clobbers from callsite to prologue/epilogue, as long as callee and caller have the same ABI; only true clobbers from the rest of the function body should alter the prologue/epilogue.</p>
<p>I can think of a few hacks, e.g. add the full-clobbers at callsites (as defs) to avoid regalloc using the registers, but compute our own clobber-set by scanning over every instruction except callsites; but this feels very error-prone and fragile compared to simply doing the right thing and reasoning through overlapping registers.</p>
<p>@julian-seward1, thoughts on this re: regalloc and how difficult it would be to support half-defs / half-clobbers?</p>
</blockquote>



<a name="211699547"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211699547" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211699547">(Sep 29 2020 at 23:52)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-701053523">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<p>@cfallin I realized that I should expand my changes and add test cases with <code>f32</code> and <code>f64</code> values, so do not merge anything, please.</p>
<blockquote>
<p>In essence, we need a way to "pass through" the half-clobbers from callsite to prologue/epilogue, as long as callee and caller have the same ABI...</p>
</blockquote>
<p>Do you mean that the caller lowering should pass somehow the clobber information to the callee lowering? I thought that lowering passes for different functions were more or less independent, and indeed happened in different worker threads...</p>
<p>Unfortunately I can't say anything the rest of your comments because I am missing some information - in particular, your quick fix and its effects (expanding the test cases should help with the latter).</p>
</blockquote>



<a name="211700042"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232228%20AArch64%3A%20Add%20a%20test%20case%20for%20vecto.../near/211700042" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232228.20AArch64.3A.20Add.20a.20test.20case.20for.20vecto.2E.2E.2E.html#211700042">(Sep 29 2020 at 23:58)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/2228#issuecomment-701055474">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/2228">Issue #2228</a>:</p>
<blockquote>
<blockquote>
<p>Do you mean that the caller lowering should pass somehow the clobber information to the callee lowering? I thought that lowering passes for different functions were more or less independent, and indeed happened in different worker threads...</p>
</blockquote>
<p>No, what I mean is more conceptual: if the callee clobbers some set of registers <code>C</code>, then by calling it, the caller clobbers at least <code>C</code> as well (that's what I meant by "pass through"; it's something that intrinsically happens, not something we are doing; sorry, it was unclear). So if the caller and callee have the same ABI, then I think we can effectively hack around this limitation by:</p>
<ul>
<li>
<p>Adopting conservative definitions of caller- and callee-save registers at callsite generation and prologue generation respectively, so the half-and-half vector registers in question are <em>both</em> caller- and callee-save, BUT</p>
</li>
<li>
<p>Ignoring the call instructions' defs/clobbers when computing the saved-clobbers list for prologue generation, because (if same ABI) anything it clobbers, we are also allowed to clobber without saving.</p>
</li>
</ul>
<p>So this will require a small change to <code>regalloc.rs</code>, namely a single bit per instruction to indicate "exclude mods/defs from clobbers". @julian-seward1 and @bnjbvr, thoughts on this?</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>