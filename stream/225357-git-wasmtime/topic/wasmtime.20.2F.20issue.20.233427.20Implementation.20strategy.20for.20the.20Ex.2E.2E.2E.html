<html>
<head><meta charset="utf-8"><title>wasmtime / issue #3427 Implementation strategy for the Ex... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html">wasmtime / issue #3427 Implementation strategy for the Ex...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="256882375"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/256882375" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#256882375">(Oct 09 2021 at 16:45)</a>:</h4>
<p>whitequark opened <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>I've been interested in having the <a href="https://github.com/WebAssembly/exception-handling">Exception Handling</a> proposal supported in Wasmtime, so I looked into possible ways to implement it. There's been some prior discussion in issues #2049 and #1677, but those issues focus on details that I think are less important than a high-level strategy.</p>
<p>As far as I see, the core difficulty in implementing this feature is that Wasmtime currently has only one non-local control flow construct, traps, and the only way to catch traps is the scoped <code>wasmtime_setjmp</code> construct implemented in C. There is no particularly good way to use this construct to implement the Wasm exception handling opcodes; it is a C function that manages resources opaque to the rest of the runtime. You could translate <code>try</code> blocks to <code>wasmtime_setjmp</code> calls by splitting each Wasm function that uses exception handling into many Cranelift functions, but this is a very complex transformation that would interfere with optimizations on the fast path, and I expect that no one wants that.</p>
<p>So, a different non-local control flow construct is necessary for exception handling. I see two options here:</p>
<p>1. Reusing the existing OS-specific stack unwinding mechanism (SEH on Windows, DWARF elsewhere), and<br>
  2. Implementing a new Cranelift-specific stack unwinding mechanism.</p>
<p>Option (1) requires a large amount of platform-specific work. Wasmtime does already emit DWARF and SEH tables to be able to capture backtraces with Wasm frames, but a lot more work is necessary to extend that functionality to cover exception handling. </p>
<p>In this case, exceptions and traps would use disjoint mechanisms, which naturally aligns with the semantics <a href="https://github.com/WebAssembly/exception-handling/blob/main/proposals/exception-handling/Exceptions.md#traps">specified</a> in the proposal.</p>
<p>Option (2) makes it possible to use a mostly platform-independent mechanism. It doesn't make a lot of sense to implement a new zero-cost exception handling strategy (you're better off using DWARF/SEH in that case), and the other major approach is SjLj. For example, Wasmtime could maintain a linked list of registered exception handlers in VM context, and a function that has <code>try</code> blocks would append an entry to this list in the prologue, containing the frame pointer and the address of the basic block that dispatches an in-flight exception for a particular <code>try</code> body. (This is a bit similar to 32-bit SEH.) Then, on any control flow into or out of a <code>try</code> body, the address recorded in the entry would be updated. The <code>throw</code> instruction would capture the exception parameters and set SP and IP to the ones in the head of the list, while Cranelift would have to make sure that any SSA values live in the dispatch block are allocated to stack slots.</p>
<p>This option could actually eliminate the dependency on C <code>setjmp</code>/<code>longjmp</code> functions and unify unwinding due to exceptions and traps. However, while it requires less platform-specific work, it is more costly at runtime, and maybe not a good fit for Wasmtime in the long run.</p>
<p>What do you think?</p>
</blockquote>



<a name="256887453"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/256887453" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#256887453">(Oct 09 2021 at 18:02)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-939337310">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<blockquote>
<p>Option (1) requires a large amount of platform-specific work. Wasmtime does already emit DWARF and SEH tables to be able to capture backtraces with Wasm frames, but a lot more work is necessary to extend that functionality to cover exception handling.</p>
</blockquote>
<p>It will have to be implemented anyway at some point for cg_clif. In addition I don't think it is much more complex than option (2). Both options require adding support for alternative exits from a call where all registers are clobbered and where the exit destination can be placed wherever Cranelift wants. Once that is implemented for DWARF (option (1) all that is needed is to register the location in the <code>.gcc_except_table</code> section (or a custom format if preferred) and writing a personality function (or copy the rust one if using the <code>.gcc_except_table</code> format). For option (2) there also needs to be code generated to update the linked list at every point. </p>
<blockquote>
<p>Wasmtime could maintain a linked list of registered exception handlers in VM context, and a function that has try blocks would append an entry to this list in the prologue, containing the frame pointer and the address of the basic block that dispatches an in-flight exception for a particular try body. (This is a bit similar to 32-bit SEH.)</p>
</blockquote>
<p>This hurts performance even when not raising any exceptions. The Unix world switched from SjLj to DWARF unwinding for a reason.</p>
</blockquote>



<a name="256888107"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/256888107" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#256888107">(Oct 09 2021 at 18:13)</a>:</h4>
<p>whitequark <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-939339236">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>You still need to implement the SEH parts for option (1). But the rationale makes sense.</p>
<p>Closing this in favor of #1677.</p>
</blockquote>



<a name="256888109"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/256888109" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#256888109">(Oct 09 2021 at 18:13)</a>:</h4>
<p>whitequark closed <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>I've been interested in having the <a href="https://github.com/WebAssembly/exception-handling">Exception Handling</a> proposal supported in Wasmtime, so I looked into possible ways to implement it. There's been some prior discussion in issues #2049 and #1677, but those issues focus on details that I think are less important than a high-level strategy.</p>
<p>As far as I see, the core difficulty in implementing this feature is that Wasmtime currently has only one non-local control flow construct, traps, and the only way to catch traps is the scoped <code>wasmtime_setjmp</code> construct implemented in C. There is no particularly good way to use this construct to implement the Wasm exception handling opcodes; it is a C function that manages resources opaque to the rest of the runtime. You could translate <code>try</code> blocks to <code>wasmtime_setjmp</code> calls by splitting each Wasm function that uses exception handling into many Cranelift functions, but this is a very complex transformation that would interfere with optimizations on the fast path, and I expect that no one wants that.</p>
<p>So, a different non-local control flow construct is necessary for exception handling. I see two options here:</p>
<p>1. Reusing the existing OS-specific stack unwinding mechanism (SEH on Windows, DWARF elsewhere), and<br>
  2. Implementing a new Cranelift-specific stack unwinding mechanism.</p>
<p>Option (1) requires a large amount of platform-specific work. Wasmtime does already emit DWARF and SEH tables to be able to capture backtraces with Wasm frames, but a lot more work is necessary to extend that functionality to cover exception handling. </p>
<p>In this case, exceptions and traps would use disjoint mechanisms, which naturally aligns with the semantics <a href="https://github.com/WebAssembly/exception-handling/blob/main/proposals/exception-handling/Exceptions.md#traps">specified</a> in the proposal.</p>
<p>Option (2) makes it possible to use a mostly platform-independent mechanism. It doesn't make a lot of sense to implement a new zero-cost exception handling strategy (you're better off using DWARF/SEH in that case), and the other major approach is SjLj. For example, Wasmtime could maintain a linked list of registered exception handlers in VM context, and a function that has <code>try</code> blocks would append an entry to this list in the prologue, containing the frame pointer and the address of the basic block that dispatches an in-flight exception for a particular <code>try</code> body. (This is a bit similar to 32-bit SEH.) Then, on any control flow into or out of a <code>try</code> body, the address recorded in the entry would be updated. The <code>throw</code> instruction would capture the exception parameters and set SP and IP to the ones in the head of the list, while Cranelift would have to make sure that any SSA values live in the dispatch block are allocated to stack slots.</p>
<p>This option could actually eliminate the dependency on C <code>setjmp</code>/<code>longjmp</code> functions and unify unwinding due to exceptions and traps. However, while it requires less platform-specific work, it is more costly at runtime, and maybe not a good fit for Wasmtime in the long run.</p>
<p>What do you think?</p>
</blockquote>



<a name="257086321"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257086321" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257086321">(Oct 11 2021 at 16:17)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940170265">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>HI @whitequark -- thank you so much for starting to look into this! Wasm EH will be an important feature to support for a bunch of reasons and I'm happy to hear you're interested in its implementation as well!</p>
<p>I do think that there is some more discussion that should happen with the relevant Wasmtime and Cranelift folks on this issue before we decide to go with one option or the other. What @bjorn3 says above regarding platform-native code generators (such as <code>cg_clif</code>) is true -- in such cases, it's best to use the platform-native mechanisms -- but in the scope of Wasmtime's VM, it's definitely not clear to me at least that this is the best option.</p>
<p>As one possibly useful anecdotal data point, SpiderMonkey implements exception unwinding (in JS and Wasm) via a custom frame format and unwinder, and this gives the engine runtime both platform orthogonality (they don't need to make every detail compatible with both SEH and DWARF unwind) and ability to optimize and tweak as needed. Note that the unwinding is still based on a PC-table lookup, afaik, so it doesn't require separate generated code to dynamically maintain a linked list.</p>
<p>I have some interest in cleaning up our unwinding story in general; in #2459 we discussed ways to potentially do GC stack-walking without relying on libunwind. IMHO, after implementing the DWARF and SEH unwind info generation for the new backends just far enough to enable stack traces and stafckwalking, we lose a lot of flexibility trying to be generic over both; I had to go through some contortions to find a stackframe format that would be describable by both; and there's still a latent worry I have at least with placing the metadata path on the critical path for correctness, vs. a JIT frame format that we tightly control. libunwind in practice also has tended to be quite slow, compared to a custom walk that one could implement. For EH that's less important but it is something to consider I think.</p>
<p>I don't mean to say that we also must solve the above (GC) issue; just that there are multiple reasons why "build our own JIT-frame format" is interesting, both in terms of prior art (SpiderMonkey) and other things it will also clean up.</p>
<p>All of this is really to say that, at least from my point of view, and I think other Wasmtime folks' as well, this isn't quite a closed decision yet, and it would be great to discuss further!</p>
<p>The Wasmtime biweekly call might be a good venue for that; would you be interested in joining and discussing this (the next one is this Thursday at 16:00 UTC; I think @tschneidereit manages the event and you'd definitely be welcome, as is any other contributor who is reading here)? Alternately we can continue to discuss in this issue, of course.</p>
</blockquote>



<a name="257086322"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257086322" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257086322">(Oct 11 2021 at 16:17)</a>:</h4>
<p>cfallin reopened <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>I've been interested in having the <a href="https://github.com/WebAssembly/exception-handling">Exception Handling</a> proposal supported in Wasmtime, so I looked into possible ways to implement it. There's been some prior discussion in issues #2049 and #1677, but those issues focus on details that I think are less important than a high-level strategy.</p>
<p>As far as I see, the core difficulty in implementing this feature is that Wasmtime currently has only one non-local control flow construct, traps, and the only way to catch traps is the scoped <code>wasmtime_setjmp</code> construct implemented in C. There is no particularly good way to use this construct to implement the Wasm exception handling opcodes; it is a C function that manages resources opaque to the rest of the runtime. You could translate <code>try</code> blocks to <code>wasmtime_setjmp</code> calls by splitting each Wasm function that uses exception handling into many Cranelift functions, but this is a very complex transformation that would interfere with optimizations on the fast path, and I expect that no one wants that.</p>
<p>So, a different non-local control flow construct is necessary for exception handling. I see two options here:</p>
<p>1. Reusing the existing OS-specific stack unwinding mechanism (SEH on Windows, DWARF elsewhere), and<br>
  2. Implementing a new Cranelift-specific stack unwinding mechanism.</p>
<p>Option (1) requires a large amount of platform-specific work. Wasmtime does already emit DWARF and SEH tables to be able to capture backtraces with Wasm frames, but a lot more work is necessary to extend that functionality to cover exception handling. </p>
<p>In this case, exceptions and traps would use disjoint mechanisms, which naturally aligns with the semantics <a href="https://github.com/WebAssembly/exception-handling/blob/main/proposals/exception-handling/Exceptions.md#traps">specified</a> in the proposal.</p>
<p>Option (2) makes it possible to use a mostly platform-independent mechanism. It doesn't make a lot of sense to implement a new zero-cost exception handling strategy (you're better off using DWARF/SEH in that case), and the other major approach is SjLj. For example, Wasmtime could maintain a linked list of registered exception handlers in VM context, and a function that has <code>try</code> blocks would append an entry to this list in the prologue, containing the frame pointer and the address of the basic block that dispatches an in-flight exception for a particular <code>try</code> body. (This is a bit similar to 32-bit SEH.) Then, on any control flow into or out of a <code>try</code> body, the address recorded in the entry would be updated. The <code>throw</code> instruction would capture the exception parameters and set SP and IP to the ones in the head of the list, while Cranelift would have to make sure that any SSA values live in the dispatch block are allocated to stack slots.</p>
<p>This option could actually eliminate the dependency on C <code>setjmp</code>/<code>longjmp</code> functions and unify unwinding due to exceptions and traps. However, while it requires less platform-specific work, it is more costly at runtime, and maybe not a good fit for Wasmtime in the long run.</p>
<p>What do you think?</p>
</blockquote>



<a name="257086745"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257086745" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257086745">(Oct 11 2021 at 16:21)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940170265">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>HI @whitequark -- thank you so much for starting to look into this! Wasm EH will be an important feature to support for a bunch of reasons and I'm happy to hear you're interested in its implementation as well!</p>
<p>I do think that there is some more discussion that should happen with the relevant Wasmtime and Cranelift folks on this issue before we decide to go with one option or the other. What @bjorn3 says above regarding platform-native code generators (such as <code>cg_clif</code>) is true -- in such cases, it's best to use the platform-native mechanisms -- but in the scope of Wasmtime's VM, it's definitely not clear to me at least that this is the best option.</p>
<p>As one possibly useful anecdotal data point, SpiderMonkey implements exception unwinding (in JS and Wasm) via a custom frame format and unwinder, and this gives the engine runtime both platform orthogonality (they don't need to make every detail compatible with both SEH and DWARF unwind) and ability to optimize and tweak as needed. Note that the unwinding is still based on a PC-table lookup, afaik, so it doesn't require separate generated code to dynamically maintain a linked list.</p>
<p>I have some interest in cleaning up our unwinding story in general; in #2459 we discussed ways to potentially do GC stack-walking without relying on libunwind. IMHO, after implementing the DWARF and SEH unwind info generation for the new backends just far enough to enable stack traces and stackwalking, we lose a lot of flexibility trying to be generic over both; I had to go through some contortions to find a stackframe format that would be describable by both; and there's still a latent worry I have at least with placing the metadata path on the critical path for correctness, vs. a JIT frame format that we tightly control. libunwind in practice also has tended to be quite slow, compared to a custom walk that one could implement. For EH that's less important but it is something to consider I think.</p>
<p>I don't mean to say that we also must solve the above (GC) issue; just that there are multiple reasons why "build our own JIT-frame format" is interesting, both in terms of prior art (SpiderMonkey) and other things it will also clean up.</p>
<p>All of this is really to say that, at least from my point of view, and I think other Wasmtime folks' as well, this isn't quite a closed decision yet, and it would be great to discuss further!</p>
<p>The Wasmtime biweekly call might be a good venue for that; would you be interested in joining and discussing this (the next one is this Thursday at 16:00 UTC; I think @tschneidereit manages the event and you'd definitely be welcome, as is any other contributor who is reading here)? Alternately we can continue to discuss in this issue, of course.</p>
</blockquote>



<a name="257088633"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257088633" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257088633">(Oct 11 2021 at 16:38)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940184157">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>One part I would add to what @cfallin already mentioned is that I think designing an implementation in Wasmtime for the exceptions proposal would be a great opportunity to rethink traps and their implementation. I don't think that the setjmp/longjmp strategy is set in stone at all and it has a significant downside in that it's got a fair deal of overhead entering into WebAssembly from the host (need to call <code>setjmp</code> and save regs, currently forces calling a foreign function that isn't inlined in optimized builds, etc).</p>
<p>Personally what I would shoot for is that the exception handling proposal would be zero-cost (or very close to zero) for wasm code which doesn't throw exceptions and then traps would use the same model, ideally making them zero-cost as well to enter from the host.</p>
<p>I'm not personally familiar with how other engines implement exceptions but I suspect we can draw a lot of inspiration from them. I'd be initiall dubiuos that DWARF/SEH are our best options for implementing the exception handling proposal, but I wouldn't necessarily rule it out at the same time. I think it'd be good to gather information first and weigh pros/cons of various implementation strategies. </p>
</blockquote>



<a name="257089477"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257089477" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257089477">(Oct 11 2021 at 16:45)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940188500">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<blockquote>
<p>The Wasmtime biweekly call might be a good venue for that; would you be interested in joining and discussing this (the next one is this Thursday at 16:00 UTC; I think @tschneidereit manages the event and you'd definitely be welcome, as is any other contributor who is reading here)? Alternately we can continue to discuss in this issue, of course.</p>
</blockquote>
<p>I would like to join.</p>
</blockquote>



<a name="257090424"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257090424" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257090424">(Oct 11 2021 at 16:53)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940193743">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<blockquote>
<p>I would like to join.</p>
</blockquote>
<p>Invite sent!</p>
<p>Something I want to highlight: it's definitely not necessary to join this or any other calls in order to weigh in on this or similar decisions. We're more than happy to discuss here, on <a href="">Zulip</a>, or if that seems appropriate for the decision, in <a href="https://github.com/bytecodealliance/rfcs/">RFCs</a>.</p>
</blockquote>



<a name="257096945"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257096945" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257096945">(Oct 11 2021 at 17:50)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940229796">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>To echo what others have said: thanks for filing an issue with lots of great context @whitequark.</p>
<hr>
<p>@alexcrichton @cfallin: to be clear, we don't intend to ever unwind native frames, right?</p>
<p>That is, if we have a stack like <code>wasm --call--&gt; host --call--&gt; wasm</code> and the youngest Wasm frame on the stack throws an exception, we intend to return that as an error variant to the host, right? I am 99% sure the answer is "yes" but if it is <em>ever</em> "no" then we won't really have a way to avoid dealing with native DWARF/SEH unwinding for this stuff.</p>
<p>I guess this seems like the kind of thing we should answer definitively with an RFC.</p>
</blockquote>



<a name="257097349"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257097349" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257097349">(Oct 11 2021 at 17:54)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940232185">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<blockquote>
<p>we don't intend to ever unwind native frames, right?</p>
</blockquote>
<p>I think that's probably a good starting point (though this along with all the other details is up for discussion!). Doing otherwise would require us to think pretty carefully about the host/wasm transition in general (including the trap logic, as @alexcrichton mentioned) and the interactions that would have with unwinding. Not to mention that it is a public API change to say that a call from native code back into a Wasm function can throw a system exception and unwind past the caller; e.g. C code might not expect this and might not clean up properly.</p>
</blockquote>



<a name="257097833"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/257097833" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#257097833">(Oct 11 2021 at 17:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-940244527">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>Yeah especially with C interop I don't think that we'll ever want wasm code to unwind host frames. Even if we do implement this via DWARF or SEH I would expect that all exceptions are caught at the wasm boundary unconditionally and raised from the entry into the host for when wasm calls the host.</p>
<p>This does leak into other API-looking questions, though. My initial naive thought for how we'd represent this is that we'd change all functions that return <code>Result&lt;T, Trap&gt;</code> to return <code>Result&lt;T, anyhow::Error&gt;</code> (like the rest of Wasmtime's APIs) and we'd add a new <code>wasmtime::Exception</code> type to map onto wasm exceptions. That way <code>?</code> would naturally propagate exceptions/traps in Rust and you could still inspect the results of an invocation for just an <code>Exception</code> or just a <code>Trap</code> if you really wanted to.</p>
</blockquote>



<a name="276373800"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/276373800" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#276373800">(Mar 23 2022 at 17:47)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-1076634210">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>I wanted to write down some further thoughts we've realized recently about libunwind and dwarf exception handling (at least on Linux). <a href="https://github.com/alexcrichton/wasmtime-unwinding-timings/blob/f992eccb62d02ed7652adca0abbd682641a24105/src/main.rs">Local testing I've done</a> shows that libunwind gets slower as more modules are loaded and is also significantly slower for the first backtrace in the process than subsequent ones:</p>
<table>
<thead>
<tr>
<th>number of modules</th>
<th>first backtrace</th>
<th>second backtrace</th>
</tr>
</thead>
<tbody>
<tr>
<td>1024</td>
<td>12.34ms</td>
<td>447.34µs</td>
</tr>
<tr>
<td>2048</td>
<td>24.26ms</td>
<td>1.49ms</td>
</tr>
<tr>
<td>4096</td>
<td>48.74ms</td>
<td>3.19ms</td>
</tr>
<tr>
<td>8192</td>
<td>95.92ms</td>
<td>6.06ms</td>
</tr>
<tr>
<td>16384</td>
<td>192.15ms</td>
<td>12.98ms</td>
</tr>
</tbody>
</table>
<p>The libunwind being used here is whatever is shipped with glibc, probably the one in libgcc_s. I haven't done much analysis of its own source or why these timings are as slow as they are, but this poses a significant obstacle for embeddings of Wasmtime that want high performance wasm with also loading lots of modules. Backtrace capturing being on the order of milliseconds is also a far cry from the overhead of calling into wasm which is on the order of nanoseconds. These performance numbers were the primary motivator for <a href="https://github.com/bytecodealliance/wasmtime/pull/3932">https://github.com/bytecodealliance/wasmtime/pull/3932</a>.</p>
<p>It's also worth pointing out that "it's ok for traps to be slow" isn't necessarily a given with WASI's <code>proc_exit(0)</code> being implemented by raising a trap. That means that programs, as part of a normal execution, may raise a trap as they exit the process with a 0 return code. Additionally performance-wise libunwind also performs quite bad at high parallelism since unwinding currently takes a global lock in the Rust <code>backtrace</code> crate.</p>
<p>All this is basically to say that while libunwind/dwarf/seh/etc may be appealing from a compiler simplicity point of view it may not be as appealing from a performance point of view. I believe there's a lot of implementations of libunwind, though, and we can probably investigate some other ones to see if they have reasonable performance compared to whatever the system glibc is. That may change things but if it's still somewhat the same we may, for performance reasons, be pushed to mirror SpiderMonkey's or another JS JIT's implementation of unwinding despite the increase in complexity.<br>
</p>
</blockquote>



<a name="476607876"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/476607876" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#476607876">(Oct 13 2024 at 13:50)</a>:</h4>
<p>sdeleuze <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-2408987952">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>With the WasmGC support now available, I think this issue is the last blocker to get Kotlin (and Java as the GraalVM team is working on compiling JVM bytecode to WasmGC + EH)  running on Wasmtime.</p>
</blockquote>



<a name="476619555"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/476619555" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#476619555">(Oct 13 2024 at 16:38)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-2409044097">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>FWIW, we have an open RFC discussing Wasm exceptions and working towards consensus on implementation strategy and incremental milestones: <a href="https://github.com/bytecodealliance/rfcs/pull/36">https://github.com/bytecodealliance/rfcs/pull/36</a></p>
</blockquote>



<a name="476634536"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233427%20Implementation%20strategy%20for%20the%20Ex.../near/476634536" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233427.20Implementation.20strategy.20for.20the.20Ex.2E.2E.2E.html#476634536">(Oct 13 2024 at 20:16)</a>:</h4>
<p>bashor <a href="https://github.com/bytecodealliance/wasmtime/issues/3427#issuecomment-2409110837">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3427">issue #3427</a>:</p>
<blockquote>
<p>@sdeleuze, you can start experimenting (!) with Kotlin right away but without the ability to throw and catch exceptions.</p>
<p>To prevent using EH by Kotlin/Wasm toolchain, you need to add <a href="https://github.com/Kotlin/kotlin-wasm-wasi-template/blob/main/build.gradle.kts#L39-L41">the following lines</a> to your build.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">tasks</span><span class="p">.</span><span class="n">withType</span><span class="o">&lt;</span><span class="n">org</span><span class="p">.</span><span class="n">jetbrains</span><span class="p">.</span><span class="n">kotlin</span><span class="p">.</span><span class="n">gradle</span><span class="p">.</span><span class="n">dsl</span><span class="p">.</span><span class="n">KotlinJsCompile</span><span class="o">&gt;</span><span class="p">().</span><span class="n">configureEach</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compilerOptions</span><span class="p">.</span><span class="n">freeCompilerArgs</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="s">"-Xwasm-use-traps-instead-of-exceptions"</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p><span aria-label="warning" class="emoji emoji-26a0" role="img" title="warning">:warning:</span> The option was added only to allow earlier experimentation with VMs with limited/lack of EH support. In this mode, throwing an exception will lead to a trap (~program termination).<br>
</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>