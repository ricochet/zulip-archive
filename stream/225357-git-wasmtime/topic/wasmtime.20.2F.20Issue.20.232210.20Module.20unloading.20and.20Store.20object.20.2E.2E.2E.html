<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #2210 Module unloading and Store object ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html">wasmtime / Issue #2210 Module unloading and Store object ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="216456747"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216456747" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216456747">(Nov 12 2020 at 11:35)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime - the removal of individual parts of a module is not necessary.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed.<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm.<br>
Cycles of references can exist through the Wasm Table, which means that cycles would need to be detected and all of the objects in the cycle freed if the cycle is not referenced from elsewhere.<br>
The removal of objects could be done automatically immediately when possible or it could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.</p>
<p>If a module uses dynamic steps, such as memory allocation, during the instantiation of the module (for example when calling the start function right after instantiation step), then the a function that deallocates that memory should be called before unloading the module. This requires the ability to trigger a function when a module is unloaded. The function can be called automatically by the runtime or it can be called by the embedder just before unloading the module through the new functionality. The deallocation function seems like it should potentially be a part of Wasm specification if it is not already.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefits of this approach is that the implementation of if may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
<p>It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function to allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand it allows the embedder to have some control on when the collection should occur.</p>
</blockquote>



<a name="216456893"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216456893" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216456893">(Nov 12 2020 at 11:37)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime - the removal of individual parts of a module is not necessary.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed.</p>
<p>If a module uses dynamic steps, such as memory allocation, during the instantiation of the module (for example when calling the start function right after instantiation step), then the a function that deallocates that memory should be called before unloading the module. This requires the ability to trigger a function when a module is unloaded. The function can be called automatically by the runtime or it can be called by the embedder just before unloading the module through the new functionality. The deallocation function seems like it should potentially be a part of Wasm specification if it is not already.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm.<br>
Cycles of references can exist through the Wasm Table, which means that cycles would need to be detected and all of the objects in the cycle freed if the cycle is not referenced from elsewhere.<br>
The removal of objects could be done automatically immediately when possible or it could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function to allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand it allows the embedder to have some control on when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefits of this approach is that the implementation of if may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="216456925"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216456925" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216456925">(Nov 12 2020 at 11:37)</a>:</h4>
<p>Rochet2 <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-726024793">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>I have now updated the issue with more information on the requirements and intent.<br>
I also added more information on the required implementation and more alternatives.</p>
</blockquote>



<a name="216621395"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216621395" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216621395">(Nov 13 2020 at 14:52)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-726807710">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>Thank you for the detailed description of the feature and its implications, @Rochet2. It does seem to me that the handling of references is really the sticky bit here. There might not be too much upside to making module unloading work in the absence of references, and the semantics of references to require them to stay valid.</p>
<p>I know that there's been some work on cross-store references, and perhaps the answer here might be to extend linking in a way that allows for hierarchies with multiple stores instead of trying to unload modules from a single store?</p>
<p>I have to confess that my understanding of all this is somewhat superficial, but I know that @lukewagner, @fitzgen, @alexcrichton, and others have thought about this more extensively.</p>
</blockquote>



<a name="216887037"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216887037" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216887037">(Nov 16 2020 at 15:33)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-728137616">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>Indeed thanks for  the report! Technically there is a way to unload a module right now which is to deallocate a <code>Store</code> and all objects that refer to it, but that's not a great solution in the long-term and I agree that we should be instead ideally be enabling some form of a persistent <code>Store</code>.</p>
<p>Otherwise though unfortunately reference counting won't work due to the cycle problem you pointed out with functions being able to cross instances and create cycles through tables. Fixing that I think would require some form of GC (probably mark/sweep for us). We do already have a <code>Store::gc</code> method,  however, for reference types that we could piggy-back onto if we ever add this. </p>
<p>What @tschneidereit may also work depending on the use case. We haven't implemented cross-store references today but the thinking is that you could link modules between two stores in a way that they can be easily disconnected. For example if one <code>Store</code> goes away then calling its functions from another <code>Store</code> would simply trap (or something like that)</p>
</blockquote>



<a name="216917967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/216917967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#216917967">(Nov 16 2020 at 19:16)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-728268834">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>We've talked about stacking nested stores on top of each other to allow for pushing and popping sets of instances rather than the current all-or-nothing model. We could maybe do the same with <code>Engine</code>s and <code>Module</code>s (although now there are two stacks that have relationships with each other, which is losing a bit of the stack-y elegance)? This doesn't give full expressibility of adding and removing modules/instances in <em>any</em> order though.</p>
<p>Semi-aside: We've always wanted to support use cases where a full GC isn't desired. At the same time, certain Wasm proposals will require a full tracing GC. When we support those proposals, we might as well also have the GC manage things like modules and instances and stores, etc... to allow for the kind of flexibility requested in this issue. However, it isn't clear to me what we will do when that Wasm feature is <em>not</em> enabled and in situations where a full tracing GC isn't desired. Are we going to forever maintain two versions of the embedder API that you can choose between with cargo features? One tracing GC'd and one ref counted? Or just forever disallow the flexibility requested in OP and only use ref counting?</p>
</blockquote>



<a name="217567725"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217567725" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217567725">(Nov 22 2020 at 20:12)</a>:</h4>
<p>Rochet2 <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>If a GC is not desired, then reference counting could be implemented. The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedded freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack. Any references to memories or tables would be possible also without creating any cycles as long as the call stack cannot refer to itself.</p>
</blockquote>



<a name="217581399"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217581399" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217581399">(Nov 23 2020 at 01:39)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedded freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack. Any references to memories or tables would be possible also without creating any cycles as long as the call stack cannot refer to itself.</p>
</blockquote>



<a name="217581779"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217581779" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217581779">(Nov 23 2020 at 01:49)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack. Any references to memories or tables would be possible also without creating any cycles as long as the call stack cannot refer to itself.</p>
</blockquote>



<a name="217582073"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582073" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582073">(Nov 23 2020 at 01:56)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime - the removal of individual parts of a module is not necessary.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217582147"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582147" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582147">(Nov 23 2020 at 01:58)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217582157"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582157" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582157">(Nov 23 2020 at 01:59)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack. Any references to memories or tables would be possible also without creating any cycles as long as the call stack cannot refer to itself.</p>
<p>I have now updated the main post with this same information.</p>
</blockquote>



<a name="217582236"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582236" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582236">(Nov 23 2020 at 02:01)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference to B held by A. The red-colored arrows signify references held by a table. The Store and the references held by a Store are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables, and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217582425"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582425" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582425">(Nov 23 2020 at 02:05)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference to B held by A. The red-colored arrows signify references held by a table. The Store and the references held by a Store are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack. Any references to memories or tables would be possible also without creating any cycles as long as the call stack cannot refer to itself.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables, and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217582498"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582498" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582498">(Nov 23 2020 at 02:06)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference to B held by A. The red-colored arrows signify references held by a table. The Store and the references held by a Store are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables, and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217582506"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217582506" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217582506">(Nov 23 2020 at 02:06)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed. In such an implementation all references held by a Store would probably be weak references also. As a result, the store would no longer be a key element in keeping the created elements alive.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack.</p>
<p>I have now updated the main post with this same information.</p>
</blockquote>



<a name="217583013"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217583013" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217583013">(Nov 23 2020 at 02:19)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack.</p>
<p>As a result of this scheme, there must be a reference to all modules that should exist for the lifetime of the program. For example, if two modules are loaded and the other is only referenced through a table, it will be unloaded automatically immediately. As a potential solution, the store could hold strong references that the embedder can remove. Alternatively, the host would be required to hold a list of strong references to any modules that should not be unloaded.</p>
<p>I have now updated the main post with this same information.</p>
</blockquote>



<a name="217583058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217583058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217583058">(Nov 23 2020 at 02:20)</a>:</h4>
<p>Rochet2 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>&lt;!-- Please try to describe precisely what you would like to do in<br>
Cranelift/Wasmtime and/or expect from it. You can answer the questions below if<br>
they're relevant and delete this text before submitting. Thanks for opening an<br>
issue! --&gt;</p>
<h4>Feature</h4>
<p>&lt;!-- What is the feature or code improvement you would like to do in<br>
Cranelift/Wasmtime? --&gt;<br>
The ability to unload a module, which practically removes objects from Store.<br>
The specification notes:</p>
<blockquote>
<p>In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.</p>
</blockquote>
<p>From this I infer that the implementing or not implementing such a feature and the details of the implementation are left for the runtime. I imagine that future proposals can affect the implementation this feature. The feature seems to be required in the long term.</p>
<p>Related topics and links:</p>
<ul>
<li><a href="#narrow/stream/206238-general/topic/Unloading.20a.20module">https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Unloading.20a.20module</a></li>
<li><a href="https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0">https://www.w3.org/TR/wasm-core-1/#store%E2%91%A0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/960">https://github.com/bytecodealliance/wasmtime/issues/960</a></li>
<li><a href="https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements">https://github.com/WebAssembly/module-linking/blob/master/proposals/module-linking/Explainer.md#additional-requirements</a></li>
</ul>
<h4>Benefit</h4>
<p>&lt;!-- What is the value of adding this in Cranelift/Wasmtime? --&gt;<br>
Currently, Wasm modules can be linked together, but there is no way to unload modules completely. As a result, programs that would require loading modules for temporary use or to conserve memory will "leak memory" as time goes on and eventually the program will run into issues with memory limitations. Removal of objects that are no longer referenced from anywhere would free the memory of those unused objects. The main goal is to be able to unload an entire module once the module's structures are no longer referenced or the references are removed through the host by the embedder or runtime.</p>
<h4>Implementation</h4>
<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>
algorithms to use? --&gt;<br>
To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference to B held by A. The red-colored arrows signify references held by a table. The Store and the references held by a Store are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p>One approach is to use reference counting of all objects in a store. With the counting, objects that are no longer referenced can be freed. Cycles of references can exist through the Wasm Table, which requires additional handling.</p>
<p>The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack.</p>
<p>As a result of this scheme, there must be a reference to all modules that should exist for the lifetime of the program. For example, if two modules are loaded and the other is only referenced through a table, it will be unloaded automatically immediately. As a potential solution, the store could hold strong references that the embedder can remove. Alternatively, the host would be required to hold a list of strong references to any modules that should not be unloaded.</p>
<h4>Alternatives</h4>
<p>&lt;!-- Have you considered alternative implementations? If so, how are they<br>
better or worse than your proposal? --&gt;<br>
Another approach is to use garbage collection algorithms, such as a mark and sweep algorithm, which can handle cycles in references. The removal of objects could be invoked by the runtime itself periodically or when needed. The collection could be configured by or left to the embedder to invoke.<br>
It seems that WAVM has implemented a GC function that can be called by the embedder. On the surface, it looks like a mark and sweep approach, but I am unsure. <a href="https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252">https://github.com/WAVM/WAVM/blob/530f33cd30c6ea5114a227175b3a7b0af77cadaa/Lib/Runtime/ObjectGC.cpp#L252</a><br>
The function allows garbage collection of unused modules and objects, but it looks like it could only be invoked when the host has control.  On the other hand, it allows the embedder to have some control over when the collection should occur.</p>
<p>An alternative to automatic GC and memory management schemes is to provide the embedder the ability to directly attempt to unload a given module or all parts of a module individually. The module's memories, tables, and other structures would then be freed. This would require the embedder to ensure that no references to the module or its parts exist or the references should be handled by the runtime either by removing them or by handling them gracefully when used.<br>
The benefit of this approach is that the implementation of it may be simpler and more effective. However, the potential references that modules may have are of concern. Either the embedder is trusted or a mechanism to find and potentially remove existing references or raise an error when one is found should be implemented.</p>
</blockquote>



<a name="217583262"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217583262" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217583262">(Nov 23 2020 at 02:26)</a>:</h4>
<p>Rochet2 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731840090">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<p>To help with reasoning about how an unloading system would be implemented I created this graph where two modules share different resources, including table, memory, global. There is also a call stack that refers to the functions of modules.<br>
The modules own only functions and only refer to other resources. The arrow from A to B signifies a reference held by A to B. The red-colored arrows signify references held by a table. The store and the references from a store to basically all elements are omitted.<br>
![WasmUnloading](<a href="https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png">https://user-images.githubusercontent.com/468816/99915524-e0d75d00-2d0c-11eb-8275-d5d1063cc143.png</a>)</p>
<p><strong>If a GC is not desired, then reference counting could be implemented.</strong> The issue of cyclic references could be relatively simply solved by using weak references in tables. If all of the red arrows in the graph are weak references, then there are no strong references that could create a cycle, apart from the ones created between the host. However, the cycles with the host will be resolved by the embedder freeing them when the modules or other resources are no longer needed.</p>
<p>If an element is freed and it is pointed to by a weak reference, then the weak reference could be unset at that time or when it is attempted to be used. However, testing if a reference is valid on every use could cause unnecessary (negligible?) overhead. I am unsure of how the execution is implemented, but I assume that the call stack would have a reference at least to the function in the stack.</p>
<p>As a result of this scheme, there must be a reference to all modules that should exist for the lifetime of the program. For example, if two modules are loaded and the other is only referenced through a table, it will be unloaded automatically immediately. As a potential solution, the store could hold strong references that the embedder can remove. Alternatively, the host would be required to hold a list of strong references to any modules that should not be unloaded.</p>
<p>EDIT: I have now updated the main post with this same information.<br>
EDIT2: Addressed an issue related to automatically unloading a module when only referenced through a table</p>
</blockquote>



<a name="217585340"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232210%20Module%20unloading%20and%20Store%20object%20.../near/217585340" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232210.20Module.20unloading.20and.20Store.20object.20.2E.2E.2E.html#217585340">(Nov 23 2020 at 03:17)</a>:</h4>
<p>Rochet2 <a href="https://github.com/bytecodealliance/wasmtime/issues/2210#issuecomment-731905803">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2210">Issue #2210</a>:</p>
<blockquote>
<blockquote>
<p>I know that there's been some work on cross-store references, and perhaps the answer here might be to extend linking in a way that allows for hierarchies with multiple stores instead of trying to unload modules from a single store?</p>
<p>thinking is that you could link modules between two stores in a way that they can be easily disconnected. For example, if one <code>Store</code> goes away then calling its functions from another <code>Store</code> would simply trap (or something like that)</p>
</blockquote>
<p>Hmm, I have not personally considered or seen discussions yet on multiple stores. Probably need to take a look at that. The first thought is that it could potentially pave the way to <a href="https://hacks.mozilla.org/2019/11/announcing-the-bytecode-alliance/">nano processes</a> sharing data efficiently.</p>
<p>However, to me, it would seem to create complexity and I am unsure what the benefit of that would be exactly without knowing more. If two stores can share a reference to basically any element of another store, then it would be the same as having a single store in my mind as references between all elements must still be handled one way or another.</p>
<p>Per the above suggestions, any invalid references could trap or be set to a null reference instead of pointing to invalid unloaded parts of the system. Unsure if there are some lifetime restrictions that references in a table should impose on the Wasm structures according to the specification. I could not directly find any.</p>
<blockquote>
<p>stacking nested stores on top of each other to allow for pushing and popping sets of instances<br>
This doesn't give full expressibility of adding and removing modules/instances in _any_ order though.</p>
</blockquote>
<p>From the perspective of a system that would require an unloading mechanism as a part of its operation regularly, it would probably be quite hindering if in order to gain memory to load a new module it would need to free an entire stack of modules. Such a runtime design would probably affect the design of the modules themselves I would imagine.</p>
<blockquote>
<p>Semi-aside:<br>
We've always wanted to support use cases where a full GC isn't desired<br>
certain Wasm proposals will require a full tracing GC</p>
</blockquote>
<p>If a GC is required by Wasm, then it should probably be implemented. If a GC is not desired in a use case it could be disabled/not used/never invoked. Proposals that _might_ require a GC would probably need to be thought thoroughly through in case they don't really require one - such as this particular issue on unloading modules.</p>
<p>However, if a GC is not desired even as a part of the implementation when not desired in a use case then that probably imposes large changes to the runtime. Would probably need some examples of such use cases to think it through.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>