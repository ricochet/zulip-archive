<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6583 Implement resources for the compon... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html">wasmtime / issue #6583 Implement resources for the compon...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="366249183"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/366249183" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#366249183">(Jun 14 2023 at 16:58)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[ ] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[ ] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[ ] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[ ] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="366249184"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/366249184" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#366249184">(Jun 14 2023 at 16:58)</a>:</h4>
<p>alexcrichton labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[ ] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[ ] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[ ] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[ ] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="368272711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/368272711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#368272711">(Jun 21 2023 at 15:13)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[ ] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[ ] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[ ] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="368272719"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/368272719" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#368272719">(Jun 21 2023 at 15:13)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[ ] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[ ] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="368272724"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/368272724" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#368272724">(Jun 21 2023 at 15:13)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[ ] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="368272730"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/368272730" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#368272730">(Jun 21 2023 at 15:13)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[ ] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="368272750"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/368272750" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#368272750">(Jun 21 2023 at 15:13)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[x] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[ ] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="371269689"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/371269689" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#371269689">(Jun 30 2023 at 18:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/6583#issuecomment-1615060383">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>As a bit of an update on this the main bulk of the work for wasm-tools is posted at <a href="https://github.com/bytecodealliance/wasm-tools/pull/1084">https://github.com/bytecodealliance/wasm-tools/pull/1084</a> and the main missing piece in wasm-tools is <code>wasm-compose</code>. I've since been working on an implementation in Wasmtime and continue to be hard at work on that. Progress is apace but currently no ETA. I've got some stuff working but still need to figure out things like destructors, <code>borrow</code>, fused adapters, and the specifics of the embedder API.</p>
</blockquote>



<a name="375332473"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/375332473" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#375332473">(Jul 14 2023 at 17:03)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/6583#issuecomment-1636135940">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>The initial wasmtime work should now be complete at <a href="https://github.com/bytecodealliance/wasmtime/pull/6691">https://github.com/bytecodealliance/wasmtime/pull/6691</a> (pending review of course). I plan on closing this issue when that's merged and deferring further work to the linked issues from that PR.</p>
</blockquote>



<a name="376045426"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/376045426" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#376045426">(Jul 17 2023 at 14:29)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[x] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[x] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[ ] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="376045431"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/376045431" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#376045431">(Jul 17 2023 at 14:29)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[x] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[ ] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[x] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[x] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="376045438"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/376045438" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#376045438">(Jul 17 2023 at 14:29)</a>:</h4>
<p>alexcrichton edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[x] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[x] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[x] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[x] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<a name="377452618"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236583%20Implement%20resources%20for%20the%20compon.../near/377452618" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236583.20Implement.20resources.20for.20the.20compon.2E.2E.2E.html#377452618">(Jul 22 2023 at 00:06)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/6583">issue #6583</a>:</p>
<blockquote>
<p>This is intended to be a bit of a tracking issue and/or brain-dump about implementing resources in the component model. The work here spans a number of repositories and isn't exclusively limited to just the Wasmtime repository, but I'm choosing here as probably one of the higher-visibility locations to write all this down.</p>
<h4>Settle on a spec</h4>
<p>Currently as-is in the <a href="https://github.com/webassembly/component-model">component-model repository</a> two resource handles of <code>own</code> and <code>borrow</code> are specified but <a href="https://github.com/WebAssembly/component-model/pull/203">this may change</a> with recent thinking. Settling on this will be necessary for at least completing this work, but isn't necessarily required before any other work goes forward. This will impact the runtime implementation in Wasmtime but likely won't radically change the overall shape, mostly details instead of what each piece is precisely doing.</p>
<h4>Implement resources in <code>wasm-tools</code></h4>
<p>Resources have had their initial implementation landed in <a href="https://github.com/bytecodealliance/wasm-tools/pull/966">https://github.com/bytecodealliance/wasm-tools/pull/966</a> for a number of crates, but not all of them. This implementation will need to be updated depending on how the above spec discussion settles, and the remaining work here is:</p>
<ul>
<li>[x] Integrate resources into <code>wit-parser</code>. This involves parsing syntax, creating AST structures, tracking types-of-handles, etc.</li>
<li>[x] Settle on the "ABI" pseudo-language used in <code>wit-parser</code> to use for resources. This is the <code>abi</code> module of <code>wit-parser</code> which is used by most WIT code generators, and notably the <code>Instruction</code> enum will need to grow variants of what to do for resources. This will be heavily influenced by the spec above.</li>
<li>[x] Implement Wasm&lt;-&gt;WIT translation for resources. This is part of the <code>wit-component</code> crate and dictates how WIT documents are encoded into WASM. This will require defining resource types appropriately and then referring to them via handles appropriately. This is, hopefully, not a large extension beyond what's already implemented.</li>
<li>[x] Integrate resources into <code>wit-smith</code> to fuzz the previous implementation of Wasm&lt;-&gt;WIT translation. This should help stress this piece further to ensure all the various corner cases are covered.</li>
<li>[x] Integrate resources into <code>wasm-tools component new</code>. Like the previous point this lives in the <code>wit-component</code> crate and this is a bigger lift but is the location to define how core wasm actually interacts with resources. This will need to grow support for intrinsics such as new/drop for each resource type and hook those up to <code>canon ...</code> definitions which will be declared in the component. This is effectively defining the standard of "what actually does a guest generator do to integrate with resources".</li>
<li>[ ] Integrate resources into <code>wasm-tools compose</code>. This is the <code>wasm-compose</code> crate and I left panicking stubs largely during the initial implementation. It's unclear how difficult this will be because this requires a form of subtype checking which is not trivial to do with resources. This probably needs to reuse more of the validation machinery in <code>wasmparser</code> but that's just a vague idea I have at this time.</li>
</ul>
<p>Much of this work on wasm-tools is sequentialized and can't be parallelized all that well as each step likely relies on the prior.</p>
<h4>Implement resources in Wasmtime</h4>
<p>Naturally a big part of resources is the actual runtime impelmentation in Wasmtime! The precise steps involved here are more fuzzy to me than the ones above for <code>wasm-tools</code>, but the rough idea I have at this time is:</p>
<ul>
<li>[x] Update translation to record and process resources. Right now there are <code>todo!()</code> or <code>unimplemented!()</code> statements for when resources are encountered during parsing, and effectively those need to be filled out. This will require tracking resources per-component and generally figuring out things such as how many resource tables are required by a component. Precisely how this all works depends on the spec details above but also just figuring out how to track and implement this all in Wasmtime, which I'm less certain about.</li>
<li>[x] Determine how to best implement the new resource-related <code>canon</code> functions. More-or-less this means <a href="https://github.com/bytecodealliance/wasmtime/blob/d03f20e0e07bb64bf82fc35765d151eb568c9e24/crates/environ/src/component/info.rs#L327-L345">expanding the <code>CoreDef</code> enum</a> and propagating changes outwards from there. I'm thinking there'd be new variants like <code>ResourceNew</code> and such.</li>
<li>[x] Determine how the embedding layer will represent and track resources. For example when a component imports a resource what's actually inserted into a <code>Linker</code>? Additionally sketch out the runtime representation of a resource so the embedder can create resources and pass them to a component. Additionally what it might look like to receive a resource defined in a component. For example the host must be able to create a resource and pass it to a component. Conversely for all resources the host must be able to destroy the resource and possibly run its destructor.</li>
</ul>
<p>Unfortunately I feel like at this point I've sort of gone from "draw a circle" to "finish the owl" and I'm not precisely sure what other intermediate steps there are to implement resources in Wasmtime, despite there obviously being quite a few more steps. One thing I can say though is that the Wasmtime work can, in theory, progress in parallel to the remaining wasm-tools work. Towards the "end" when the <code>bindgen!</code> macro gets involved they'll need to sync back up but it should be possible to implement everything related to resources in Wasmtime independent of WIT and the integration there.</p>
<hr>
<p>I plan on starting on the wasm-tools based work in the near future and moving outwards from there, but I wanted to be sure to write down my thoughts on all this in the meantime. I can also try to keep this updated over time with more thinking.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>