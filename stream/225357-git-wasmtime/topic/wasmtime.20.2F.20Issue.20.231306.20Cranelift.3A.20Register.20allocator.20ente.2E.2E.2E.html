<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #1306 Cranelift: Register allocator ente... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html">wasmtime / Issue #1306 Cranelift: Register allocator ente...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="190444042"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444042" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444042">(Mar 12 2020 at 20:56)</a>:</h4>
<p>abrown opened <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into <code>clif
[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)
.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444043"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444043" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444043">(Mar 12 2020 at 20:56)</a>:</h4>
<p>abrown labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into <code>clif
[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)
.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444044"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444044" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444044">(Mar 12 2020 at 20:56)</a>:</h4>
<p>abrown labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into <code>clif
[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)
.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444093"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444093" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444093">(Mar 12 2020 at 20:56)</a>:</h4>
<p>abrown edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into <code>clif
[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)
.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt">clif.txt</a></p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444179"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444179" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444179">(Mar 12 2020 at 20:57)</a>:</h4>
<p>abrown edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into the attached <a href="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444346"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444346" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444346">(Mar 12 2020 at 20:58)</a>:</h4>
<p>abrown edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into the attached <a href="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>
<div class="codehilite"><pre><span></span>$ target/debug/clif-util compile -dDpv text.clif
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]&#39;</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9
</pre></div>


<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190444385"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190444385" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190444385">(Mar 12 2020 at 20:59)</a>:</h4>
<p>abrown edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite"><pre><span></span>...
 DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)
 DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local
 DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,
  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]
  assignments: []
  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]
  moves: []
}

 DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985
 DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986
    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)
 DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]
...
</pre></div>


<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346" target="_blank" title="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into the attached <a href="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>
<div class="codehilite"><pre><span></span>$ target/debug/clif-util compile -dDpv clif.txt
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]&#39;</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9
</pre></div>


<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift" target="_blank" title="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<a name="190458035"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190458035" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190458035">(Mar 12 2020 at 23:48)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>I attempted removing the <code>FPR32</code> register class entirely but that doesn't seem to solve the problem. I mean, the <code>FPR32</code> is gone from the logging but I still get a <code>FPR8:%xmm2 is already free in...</code> error. Also, without <code>FPR32</code> the endless loop seems to be gone and I can run bugpoint to get a 172-instruction version to reproduce: <a href="https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt">clif-reduced.txt</a>.</p>
</blockquote>



<a name="190458072"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190458072" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190458072">(Mar 12 2020 at 23:49)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>I attempted removing the <code>FPR32</code> register class entirely but that doesn't seem tototally  solve the problem. I mean, the <code>FPR32</code> is gone from the logging but I still get a <code>FPR8:%xmm2 is already free in...</code> error when I attempt to <code>compile</code>. On the bright side, without <code>FPR32</code> the endless loop seems to be gone and I can run <code>bugpoint</code> to get a 172-instruction version to reproduce: <a href="https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt" target="_blank" title="https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt">clif-reduced.txt</a>.</p>
</blockquote>



<a name="190786025"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190786025" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190786025">(Mar 16 2020 at 22:06)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>In an attempt to reduce this down to something comprehensible, I started playing around with small test cases:</p>
<div class="codehilite"><pre><span></span>test compile
set enable_simd
target x86_64 skylake

function u0:35() system_v {
block0:
    ; v0 = vconst.i32x4 [0 1 2 3]
    v0 = iconst.i64 0xdeadbeef
    v1 = load.i32x4 v0
    v2 = load.i32x4 v0
    v3 = load.i32x4 v0
    v4 = load.i32x4 v0
    v5 = load.i32x4 v0
    v6 = load.i32x4 v0
    v7 = load.i32x4 v0
    v8 = load.i32x4 v0
    v9 = load.i32x4 v0
    v10 = load.i32x4 v0
    v11 = load.i32x4 v0
    v12 = load.i32x4 v0
    v13 = load.i32x4 v0
    v14 = load.i32x4 v0
    v15 = load.i32x4 v0
    v16 = load.i32x4 v0
    ;; this causes the error
    ;; v17 = load.i32x4 v0

    store v1, v0
    store v2, v0
    store v3, v0
    store v4, v0
    store v5, v0
    store v6, v0
    store v7, v0
    store v8, v0
    store v9, v0
    store v10, v0
    store v11, v0
    store v12, v0
    store v13, v0
    store v14, v0
    store v15, v0
    store v16, v0
    return
}
</pre></div>


<p>On the <code>remove-fpr32</code> branch (see #1318), I run <code>cargo run -p cranelift-tools -- compile -dDpv scratch-tiny.clif</code>. This fails with:</p>
<div class="codehilite"><pre><span></span>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`
  left: `68`,
 right: `64`: Invalid registers for REX-less Op2 encoding&#39;, cranelift/codegen/src/isa/x86/binemit.rs:119:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</pre></div>


<p>When I turn on logging, I see the following right before the failure:</p>
<div class="codehilite"><pre><span></span> DEBUG cranelift_codegen::context              &gt; Compiled:
function u0:35(i64 fp [%rbp]) -&gt; i64 fp [%rbp] system_v {
    ss0 = spill_slot 16, offset -32
    ss1 = incoming_arg 16, offset -16

                                block0(v20: i64 [%rbp]):
[RexOp1pushq#50]                    x86_push v20
[RexOp1copysp#8089]                 copy_special %rsp -&gt; %rbp
[RexOp1adjustsp_ib#d083]            adjust_sp_down_imm 16
[RexOp1pu_id#b8,%rax]               v0 = iconst.i64 0xdead_beef
[DynRexOp2fld#410,%xmm0]            v18 = load.i32x4 v0
[Op2fspillSib32#411,ss0]            v1 = spill v18
[DynRexOp2fld#410,%xmm0]            v2 = load.i32x4 v0
[DynRexOp2fld#410,%xmm1]            v3 = load.i32x4 v0
[DynRexOp2fld#410,%xmm2]            v4 = load.i32x4 v0
[DynRexOp2fld#410,%xmm3]            v5 = load.i32x4 v0
[DynRexOp2fld#410,%xmm4]            v6 = load.i32x4 v0
[DynRexOp2fld#410,%xmm5]            v7 = load.i32x4 v0
[DynRexOp2fld#410,%xmm6]            v8 = load.i32x4 v0
[DynRexOp2fld#410,%xmm7]            v9 = load.i32x4 v0
[DynRexOp2fld#410,%xmm8]            v10 = load.i32x4 v0
[DynRexOp2fld#410,%xmm9]            v11 = load.i32x4 v0
[DynRexOp2fld#410,%xmm10]           v12 = load.i32x4 v0
[DynRexOp2fld#410,%xmm11]           v13 = load.i32x4 v0
[DynRexOp2fld#410,%xmm12]           v14 = load.i32x4 v0
[DynRexOp2fld#410,%xmm13]           v15 = load.i32x4 v0
[DynRexOp2fld#410,%xmm14]           v16 = load.i32x4 v0
[DynRexOp2fld#410,%xmm15]           v17 = load.i32x4 v0
[Op2frmov#428]                      regmove v2, %xmm0 -&gt; %xmm15
[Op2ffillSib32#410,%xmm0]           v19 = fill v1
[DynRexOp2fst#411]                  store v19, v0
[DynRexOp2fst#411]                  store v2, v0
[DynRexOp2fst#411]                  store v3, v0
[DynRexOp2fst#411]                  store v4, v0
[DynRexOp2fst#411]                  store v5, v0
[DynRexOp2fst#411]                  store v6, v0
[DynRexOp2fst#411]                  store v7, v0
[DynRexOp2fst#411]                  store v8, v0
[DynRexOp2fst#411]                  store v9, v0
[DynRexOp2fst#411]                  store v10, v0
[DynRexOp2fst#411]                  store v11, v0
[DynRexOp2fst#411]                  store v12, v0
[DynRexOp2fst#411]                  store v13, v0
[DynRexOp2fst#411]                  store v14, v0
[DynRexOp2fst#411]                  store v15, v0
[DynRexOp2fst#411]                  store v16, v0
[RexOp1adjustsp_ib#8083]            adjust_sp_up_imm 16
[RexOp1popq#58,%rbp]                v21 = x86_pop.i64
[Op1ret#c3]                         return v21
}
</pre></div>


<p>The immediate spilling of <code>v1</code> seems to make sense, and the <code>regmove v2, %xmm0-&gt;%xmm15</code> in order to fill <code>v1</code> into <code>v19</code> does too: <code>v17/%xmm15</code> is never used again so we should be able to use <code>%xmm15</code> for <code>v2</code>'s value. But when I debug the <code>regmove</code> is the instruction causing the failure. Because <code>load</code> and <code>store</code> have the <code>infer_rex()</code> meta-property, they can access all 16 FPR registers but <code>regmove</code>, which has neither <code>infer_rex()</code> nor <code>rex()</code>, can only access FPR8. When I give <code>regmove</code> a <code>rex()</code> prefix the snippet compiles. We have an issue to track that I need to add REX prefixes to a bunch of SIMD instructions, #1127, so I think I will submit a PR for that and then revisit this.</p>
<p>Regardless of whether I fix #1127 or not, though, regalloc should know better than to try to move to a register it can't encode. For SIMD and floats, <code>regmove</code> uses the <code>frmov</code> recipe, which takes a single FPR as an input. I would have expected cranelift to know that the lack of <code>infer_rex()</code> nor <code>rex()</code> meant that <code>regmove</code> would be limited to FPR8, but no. Perhaps it assumes that the source and destination registers are in the same register class.</p>
<p>My plan for now is:</p>
<ul>
<li>fix #1127 by telling adding REX prefixes in a bunch of places</li>
<li>see if the original clif.txt will compile with that fix and without FPR32 support</li>
<li>if that works, try again with FPR32 support</li>
</ul>
</blockquote>



<a name="190786080"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190786080" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190786080">(Mar 16 2020 at 22:07)</a>:</h4>
<p>abrown edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>In an attempt to reduce this down to something comprehensible, I started playing around with small test cases:</p>
<div class="codehilite"><pre><span></span>test compile
set enable_simd
target x86_64 skylake

function u0:35() system_v {
block0:
    v0 = iconst.i64 0xdeadbeef
    v1 = load.i32x4 v0
    v2 = load.i32x4 v0
    v3 = load.i32x4 v0
    v4 = load.i32x4 v0
    v5 = load.i32x4 v0
    v6 = load.i32x4 v0
    v7 = load.i32x4 v0
    v8 = load.i32x4 v0
    v9 = load.i32x4 v0
    v10 = load.i32x4 v0
    v11 = load.i32x4 v0
    v12 = load.i32x4 v0
    v13 = load.i32x4 v0
    v14 = load.i32x4 v0
    v15 = load.i32x4 v0
    v16 = load.i32x4 v0
    ;; this causes the error
    v17 = load.i32x4 v0

    store v1, v0
    store v2, v0
    store v3, v0
    store v4, v0
    store v5, v0
    store v6, v0
    store v7, v0
    store v8, v0
    store v9, v0
    store v10, v0
    store v11, v0
    store v12, v0
    store v13, v0
    store v14, v0
    store v15, v0
    store v16, v0
    return
}
</pre></div>


<p>On the <code>remove-fpr32</code> branch (see #1318), I run <code>cargo run -p cranelift-tools -- compile -dDpv scratch-tiny.clif</code>. This fails with:</p>
<div class="codehilite"><pre><span></span>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`
  left: `68`,
 right: `64`: Invalid registers for REX-less Op2 encoding&#39;, cranelift/codegen/src/isa/x86/binemit.rs:119:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</pre></div>


<p>When I turn on logging, I see the following right before the failure:</p>
<div class="codehilite"><pre><span></span> DEBUG cranelift_codegen::context              &gt; Compiled:
function u0:35(i64 fp [%rbp]) -&gt; i64 fp [%rbp] system_v {
    ss0 = spill_slot 16, offset -32
    ss1 = incoming_arg 16, offset -16

                                block0(v20: i64 [%rbp]):
[RexOp1pushq#50]                    x86_push v20
[RexOp1copysp#8089]                 copy_special %rsp -&gt; %rbp
[RexOp1adjustsp_ib#d083]            adjust_sp_down_imm 16
[RexOp1pu_id#b8,%rax]               v0 = iconst.i64 0xdead_beef
[DynRexOp2fld#410,%xmm0]            v18 = load.i32x4 v0
[Op2fspillSib32#411,ss0]            v1 = spill v18
[DynRexOp2fld#410,%xmm0]            v2 = load.i32x4 v0
[DynRexOp2fld#410,%xmm1]            v3 = load.i32x4 v0
[DynRexOp2fld#410,%xmm2]            v4 = load.i32x4 v0
[DynRexOp2fld#410,%xmm3]            v5 = load.i32x4 v0
[DynRexOp2fld#410,%xmm4]            v6 = load.i32x4 v0
[DynRexOp2fld#410,%xmm5]            v7 = load.i32x4 v0
[DynRexOp2fld#410,%xmm6]            v8 = load.i32x4 v0
[DynRexOp2fld#410,%xmm7]            v9 = load.i32x4 v0
[DynRexOp2fld#410,%xmm8]            v10 = load.i32x4 v0
[DynRexOp2fld#410,%xmm9]            v11 = load.i32x4 v0
[DynRexOp2fld#410,%xmm10]           v12 = load.i32x4 v0
[DynRexOp2fld#410,%xmm11]           v13 = load.i32x4 v0
[DynRexOp2fld#410,%xmm12]           v14 = load.i32x4 v0
[DynRexOp2fld#410,%xmm13]           v15 = load.i32x4 v0
[DynRexOp2fld#410,%xmm14]           v16 = load.i32x4 v0
[DynRexOp2fld#410,%xmm15]           v17 = load.i32x4 v0
[Op2frmov#428]                      regmove v2, %xmm0 -&gt; %xmm15
[Op2ffillSib32#410,%xmm0]           v19 = fill v1
[DynRexOp2fst#411]                  store v19, v0
[DynRexOp2fst#411]                  store v2, v0
[DynRexOp2fst#411]                  store v3, v0
[DynRexOp2fst#411]                  store v4, v0
[DynRexOp2fst#411]                  store v5, v0
[DynRexOp2fst#411]                  store v6, v0
[DynRexOp2fst#411]                  store v7, v0
[DynRexOp2fst#411]                  store v8, v0
[DynRexOp2fst#411]                  store v9, v0
[DynRexOp2fst#411]                  store v10, v0
[DynRexOp2fst#411]                  store v11, v0
[DynRexOp2fst#411]                  store v12, v0
[DynRexOp2fst#411]                  store v13, v0
[DynRexOp2fst#411]                  store v14, v0
[DynRexOp2fst#411]                  store v15, v0
[DynRexOp2fst#411]                  store v16, v0
[RexOp1adjustsp_ib#8083]            adjust_sp_up_imm 16
[RexOp1popq#58,%rbp]                v21 = x86_pop.i64
[Op1ret#c3]                         return v21
}
</pre></div>


<p>The immediate spilling of <code>v1</code> seems to make sense, and the <code>regmove v2, %xmm0-&gt;%xmm15</code> in order to fill <code>v1</code> into <code>v19</code> does too: <code>v17/%xmm15</code> is never used again so we should be able to use <code>%xmm15</code> for <code>v2</code>'s value. But when I debug the <code>regmove</code> is the instruction causing the failure. Because <code>load</code> and <code>store</code> have the <code>infer_rex()</code> meta-property, they can access all 16 FPR registers but <code>regmove</code>, which has neither <code>infer_rex()</code> nor <code>rex()</code>, can only access FPR8. When I give <code>regmove</code> a <code>rex()</code> prefix the snippet compiles. We have an issue to track that I need to add REX prefixes to a bunch of SIMD instructions, #1127, so I think I will submit a PR for that and then revisit this.</p>
<p>Regardless of whether I fix #1127 or not, though, regalloc should know better than to try to move to a register it can't encode. For SIMD and floats, <code>regmove</code> uses the <code>frmov</code> recipe, which takes a single FPR as an input. I would have expected cranelift to know that the lack of <code>infer_rex()</code> nor <code>rex()</code> meant that <code>regmove</code> would be limited to FPR8, but no. Perhaps it assumes that the source and destination registers are in the same register class.</p>
<p>My plan for now is:</p>
<ul>
<li>fix #1127 by telling adding REX prefixes in a bunch of places</li>
<li>see if the original clif.txt will compile with that fix and without FPR32 support</li>
<li>if that works, try again with FPR32 support</li>
</ul>
</blockquote>



<a name="190800118"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/190800118" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#190800118">(Mar 17 2020 at 01:30)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599831922" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599831922">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306" target="_blank" title="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>#1318 and #1335, when merged, should clarify this a bit more.</p>
</blockquote>



<a name="225058516"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/225058516" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#225058516">(Feb 03 2021 at 18:25)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-772721968">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>The new backend framework uses a different register allocator.</p>
</blockquote>



<a name="225059019"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231306%20Cranelift%3A%20Register%20allocator%20ente.../near/225059019" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231306.20Cranelift.3A.20Register.20allocator.20ente.2E.2E.2E.html#225059019">(Feb 03 2021 at 18:29)</a>:</h4>
<p>abrown closed <a href="https://github.com/bytecodealliance/wasmtime/issues/1306">Issue #1306</a>:</p>
<blockquote>
<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">solver</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">add_killed_var</span><span class="p">(</span><span class="n">v6985</span>:<span class="nc">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="o">=%</span><span class="n">xmm0</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">solver</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span>-&gt; <span class="nc">new</span><span class="w"> </span><span class="n">var</span>: <span class="nc">v6985</span><span class="p">(</span><span class="n">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">%</span><span class="n">xmm0</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">solver</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">real_solve</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Solver</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">inputs_done</span>: <span class="nc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">in</span>:  <span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="o">---</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="mi">0</span><span class="o">----------------</span><span class="mi">789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="mi">0</span><span class="o">---------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">out</span>: <span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="o">---</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="mi">0</span><span class="o">----------------</span><span class="mi">789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="mi">0</span><span class="o">---------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">assignments</span>: <span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="n">vars</span>: <span class="p">[</span><span class="n">v191</span><span class="p">(</span><span class="n">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">def</span><span class="p">),</span><span class="w"> </span><span class="n">v6985</span><span class="p">(</span><span class="n">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">%</span><span class="n">xmm0</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w"></span>
<span class="w">  </span><span class="n">moves</span>: <span class="p">[]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Not</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="n">global</span><span class="w"> </span><span class="n">registers</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v191</span><span class="p">,</span><span class="w"> </span><span class="n">trying</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">local</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">solver</span><span class="w">     </span><span class="o">&gt;</span><span class="w"> </span><span class="n">real_solve</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Solver</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">inputs_done</span>: <span class="nc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">in</span>:  <span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="o">---</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="mi">0</span><span class="o">----------------</span><span class="mi">789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="mi">0</span><span class="o">---------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">out</span>: <span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="o">---</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="mi">0</span><span class="o">----------------</span><span class="mi">789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="mi">0</span><span class="o">---------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">assignments</span>: <span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="n">vars</span>: <span class="p">[</span><span class="n">v191</span><span class="p">(</span><span class="n">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">def</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">v6985</span><span class="p">(</span><span class="n">FPR</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">%</span><span class="n">xmm0</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)]</span><span class="w"></span>
<span class="w">  </span><span class="n">moves</span>: <span class="p">[]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w">     </span><span class="n">color</span><span class="w"> </span><span class="n">v191</span><span class="w"> </span>-&gt; <span class="o">%</span><span class="n">xmm0</span><span class="w"> </span><span class="p">(</span><span class="n">global</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">replaced</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Replacing</span><span class="w"> </span><span class="n">global</span><span class="w"> </span><span class="n">defs</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">v191</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">.</span><span class="n">i64x2</span><span class="w"> </span><span class="n">v6985</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w">   </span><span class="o">+</span><span class="w"> </span><span class="n">v191</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">.</span><span class="n">i64x2</span><span class="w"> </span><span class="n">v6986</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">v6986</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">%</span><span class="n">xmm0</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Done</span>: <span class="nc">v6986</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">.</span><span class="n">i64x2</span><span class="w"> </span><span class="n">v6985</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Coloring</span><span class="w"> </span><span class="n">v191</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy</span><span class="p">.</span><span class="n">i64x2</span><span class="w"> </span><span class="n">v6986</span><span class="w"></span>
<span class="w">    </span><span class="n">from</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="o">---</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="o">-----------------</span><span class="mi">789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="o">----------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w">     </span><span class="n">kill</span><span class="w"> </span><span class="n">v6986</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">%</span><span class="n">xmm0</span><span class="w"> </span><span class="p">(</span><span class="n">local</span><span class="w"> </span><span class="n">FPR</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="n">DEBUG</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">regalloc</span>::<span class="n">coloring</span><span class="w">   </span><span class="o">&gt;</span><span class="w">     </span><span class="n">glob</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">GPR</span>: <span class="nc">a</span><span class="o">--</span><span class="n">b</span><span class="o">--</span><span class="n">sd89012345</span><span class="w"> </span><span class="n">FPR32</span>: <span class="o">----------------</span><span class="mi">6789012345678901</span><span class="w"> </span><span class="n">FPR</span>: <span class="o">----------------</span><span class="w"> </span><span class="n">FLAG</span>: <span class="nc">f</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href="https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>
<p>I extracted the function that I believe is causing the issue into the attached <a href="https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>
<ul>
<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>
</ul>
<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>
<ul>
<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>
</ul>
<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>$ target/debug/clif-util compile -dDpv clif.txt
thread <span class="s1">'main'</span> panicked at <span class="s1">'FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]'</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9
</code></pre></div>
<ul>
<li>Which Cranelift version / commit hash / branch are you using?</li>
</ul>
<p><a href="https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>
<ul>
<li>If relevant, can you include some extra information about your environment?<br>
  (Rust version, operating system, architecture...)</li>
</ul>
<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>