<html>
<head><meta charset="utf-8"><title>wasmtime / PR #2504 Draft: I128 support (partial) on x64. · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html">wasmtime / PR #2504 Draft: I128 support (partial) on x64.</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="219747312"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219747312" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219747312">(Dec 13 2020 at 06:32)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219747394"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219747394" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219747394">(Dec 13 2020 at 06:34)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219747900"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219747900" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219747900">(Dec 13 2020 at 06:51)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550890041">PR Review</a>.</p>



<a name="219747901"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219747901" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219747901">(Dec 13 2020 at 06:51)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550890041">PR Review</a>.</p>



<a name="219747902"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219747902" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219747902">(Dec 13 2020 at 06:51)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541860023">PR Review Comment</a>:</p>
<blockquote>
<p>Can regalloc insert an instruction in between?</p>
</blockquote>



<a name="219749386"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219749386" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219749386">(Dec 13 2020 at 07:36)</a>:</h4>
<p>julian-seward1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550893109">PR Review</a>.</p>



<a name="219749387"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219749387" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219749387">(Dec 13 2020 at 07:36)</a>:</h4>
<p>julian-seward1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541867624">PR Review Comment</a>:</p>
<blockquote>
<p>Regalloc is specifically disallowed from inserting any instructions that change the condition codes.  This is specified in comments in the <code>regalloc.rs</code> interface.</p>
</blockquote>



<a name="219749601"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219749601" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219749601">(Dec 13 2020 at 07:43)</a>:</h4>
<p>julian-seward1 edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541867624">PR Review Comment</a>.</p>



<a name="219750015"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219750015" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219750015">(Dec 13 2020 at 07:56)</a>:</h4>
<p>julian-seward1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550894390">PR Review</a>.</p>



<a name="219750016"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219750016" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219750016">(Dec 13 2020 at 07:56)</a>:</h4>
<p>julian-seward1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541870768">PR Review Comment</a>:</p>
<blockquote>
<p>@cfallin Is it really so bad that we have to duplicate these circa 50 lines per-target, to do <code>mul.i128</code>?  It would be even shorter if rustfmt didn't insist on laying out the calls in this space-inefficient way.</p>
<p>There will be roughly equivalent length sequences for 128-bit left/right shifts, and for 128-bit comparisons.  For 128-bit division, we'll have to call a helper on all targets.  On 32-bit targets, we'll probably have to use a helper for multiplies, shifts and comparisons too.</p>
</blockquote>



<a name="219759274"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219759274" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219759274">(Dec 13 2020 at 12:15)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550914558">PR Review</a>.</p>



<a name="219759275"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219759275" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219759275">(Dec 13 2020 at 12:15)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541913522">PR Review Comment</a>:</p>
<blockquote>
<p>Could this be a <code>Result</code> with something like <code>struct OnlyRegError;</code> as error type? That would give a better panic message when unwrapping.</p>
</blockquote>



<a name="219774003"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219774003" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219774003">(Dec 13 2020 at 18:45)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550947930">PR Review</a>.</p>



<a name="219774004"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219774004" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219774004">(Dec 13 2020 at 18:45)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550947930">PR Review</a>.</p>



<a name="219774005"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219774005" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219774005">(Dec 13 2020 at 18:45)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981083">PR Review Comment</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="suggestion"><pre><span></span><code>                let arg_regs = put_input_in_regs(ctx, *input);
</code></pre></div><br>
</p>
</blockquote>



<a name="219774006"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219774006" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219774006">(Dec 13 2020 at 18:45)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981117">PR Review Comment</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="suggestion"><pre><span></span><code>                abi.emit_copy_regs_to_arg(ctx, i, arg_regs);
</code></pre></div><br>
</p>
</blockquote>



<a name="219774007"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219774007" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219774007">(Dec 13 2020 at 18:45)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981047">PR Review Comment</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="suggestion"><pre><span></span><code>                let retval_regs = get_output_reg(ctx, *output);
                abi.emit_copy_retval_to_regs(ctx, i, retval_regs);
</code></pre></div><br>
</p>
</blockquote>



<a name="219790559"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219790559" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219790559">(Dec 14 2020 at 00:47)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219793289"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219793289" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219793289">(Dec 14 2020 at 02:05)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219793341"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219793341" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219793341">(Dec 14 2020 at 02:07)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219795030"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219795030" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219795030">(Dec 14 2020 at 02:51)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219795222"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219795222" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219795222">(Dec 14 2020 at 02:56)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551012607">PR Review</a>.</p>



<a name="219795223"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219795223" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219795223">(Dec 14 2020 at 02:56)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542078087">PR Review Comment</a>:</p>
<blockquote>
<p>Thanks!</p>
</blockquote>



<a name="219795364"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219795364" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219795364">(Dec 14 2020 at 02:58)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219801411"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219801411" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219801411">(Dec 14 2020 at 05:14)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219801424"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219801424" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219801424">(Dec 14 2020 at 05:15)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="219805611"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219805611" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219805611">(Dec 14 2020 at 06:48)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551081854">PR Review</a>.</p>



<a name="219805612"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219805612" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219805612">(Dec 14 2020 at 06:48)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542148134">PR Review Comment</a>:</p>
<blockquote>
<p><code>StructArgument</code> indicates that the argument is a pointer to a piece of memory with the given size that needs to be passed as on the stack in the arguments area. On the caller side you will need to memcpy it to the right place, on the callee side you need to get the address.</p>
</blockquote>



<a name="219805709"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219805709" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219805709">(Dec 14 2020 at 06:51)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551083046">PR Review</a>.</p>



<a name="219805710"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219805710" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219805710">(Dec 14 2020 at 06:51)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542149191">PR Review Comment</a>:</p>
<blockquote>
<p>The old backend didn't handle this either, but the system-v abi defines a specific register for this argument. In addition kn x86_64 at least I think you also need to regurn this value in a different register. (I guess to reduce the need for saving it on the caller side.)</p>
</blockquote>



<a name="219807863"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807863" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807863">(Dec 14 2020 at 07:36)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551103984">PR Review</a>.</p>



<a name="219807864"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807864" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807864">(Dec 14 2020 at 07:36)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542167903">PR Review Comment</a>:</p>
<blockquote>
<p>OK, yes, this is making more sense now. Do you think you would be up for attempting an implementation? (My bandwidth is somewhat stretched thin at the moment, but I can come back to this at ... some point, eventually, if needed. Incidentally this is similar to what I think we also need for Windows fastcall, which is one of the other remaining new-backend TODOs...).</p>
</blockquote>



<a name="219807870"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807870" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807870">(Dec 14 2020 at 07:36)</a>:</h4>
<p>julian-seward1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104062">PR Review</a>.</p>



<a name="219807871"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807871" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807871">(Dec 14 2020 at 07:36)</a>:</h4>
<p>julian-seward1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542167981">PR Review Comment</a>:</p>
<blockquote>
<p>Would it be preferable here to key it on the word size of the target that the resulting CL will be compiling for?  Is that even possible, given the limitations of the Rust config etc system?</p>
</blockquote>



<a name="219807909"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807909" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807909">(Dec 14 2020 at 07:37)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104517">PR Review</a>.</p>



<a name="219807910"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807910" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807910">(Dec 14 2020 at 07:37)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542168422">PR Review Comment</a>:</p>
<blockquote>
<p>Such an option does exist, but the wrench in the works is cross-compilation -- e.g. <code>clif-utils</code> is normally built with all targets enabled (so we need to support arm32 compilation even on an x64 host, etc).</p>
</blockquote>



<a name="219807967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807967">(Dec 14 2020 at 07:38)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104894">PR Review</a>.</p>



<a name="219807968"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219807968" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219807968">(Dec 14 2020 at 07:38)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542168706">PR Review Comment</a>:</p>
<blockquote>
<p>(Ah, sorry, actually I misread your comment -- pointer size of target, not host; I don't think we have a config option for that as we have custom features for each backend.)</p>
</blockquote>



<a name="219814351"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219814351" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219814351">(Dec 14 2020 at 09:01)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551161980">PR Review</a>.</p>



<a name="219814352"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/219814352" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#219814352">(Dec 14 2020 at 09:01)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542215584">PR Review Comment</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="suggestion"><pre><span></span><code>            emit_reloc(sink, state, Reloc::ElfX86_64TlsGd, symbol, -4);
            sink.put4(0);
</code></pre></div><br>
</p>
</blockquote>



<a name="221045974"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221045974" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221045974">(Dec 28 2020 at 08:18)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221046930"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221046930" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221046930">(Dec 28 2020 at 08:38)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-559046352">PR Review</a>.</p>



<a name="221046931"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221046931" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221046931">(Dec 28 2020 at 08:38)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r549262245">PR Review Comment</a>:</p>
<blockquote>
<p>Thanks!</p>
</blockquote>



<a name="221093977"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221093977" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221093977">(Dec 28 2020 at 21:52)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221106212"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221106212" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221106212">(Dec 29 2020 at 02:06)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221120392"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221120392" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221120392">(Dec 29 2020 at 08:51)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221123542"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221123542" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221123542">(Dec 29 2020 at 10:01)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221123756"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221123756" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221123756">(Dec 29 2020 at 10:04)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221172323"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221172323" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221172323">(Dec 29 2020 at 22:12)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221491204"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221491204" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221491204">(Jan 04 2021 at 05:43)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221491806"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221491806" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221491806">(Jan 04 2021 at 05:58)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221491969"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221491969" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221491969">(Jan 04 2021 at 06:02)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>
<blockquote>
<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>
<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>
<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the "every backend accepts the same IR" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>
<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out "general machine-independent algorithm for 128-bit multiply with 64-bit pieces" from the specific machine backends.</p>
<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>
</blockquote>



<a name="221676960"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232504%20Draft%3A%20I128%20support%20%28partial%29%20on%20x64./near/221676960" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232504.20Draft.3A.20I128.20support.20.28partial.29.20on.20x64.2E.html#221676960">(Jan 05 2021 at 17:40)</a>:</h4>
<p>cfallin closed without merge <a href="https://github.com/bytecodealliance/wasmtime/pull/2504">PR #2504</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>