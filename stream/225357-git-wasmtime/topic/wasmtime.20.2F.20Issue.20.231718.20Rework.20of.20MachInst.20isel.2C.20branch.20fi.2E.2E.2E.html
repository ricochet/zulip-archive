<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #1718 Rework of MachInst isel, branch fi... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html">wasmtime / Issue #1718 Rework of MachInst isel, branch fi...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="197771605"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/197771605" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#197771605">(May 16 2020 at 02:27)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-629575363">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @bnjbvr</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift", "cranelift:area:aarch64", "cranelift:area:isel", "cranelift:area:x64"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>bnjbvr: cranelift</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="197879822"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/197879822" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#197879822">(May 18 2020 at 01:19)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-629895797">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<p>Updated: rebased onto latest master; brought x64 backend up-to-date; updated all aarch64 filetests; and added some more tests for MachBuffer. Should be ready for review now.</p>
</blockquote>



<a name="197923269"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/197923269" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#197923269">(May 18 2020 at 12:02)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-630135435">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<blockquote>
<p>I see debug! calls in potentially hottish places, eg MachBuffer::put1(). Are we sure those become zero cost in release builds?</p>
</blockquote>
<p><code>trace!</code> is probably more appropriate.</p>
</blockquote>



<a name="198006871"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/198006871" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#198006871">(May 18 2020 at 23:15)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-630482986">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<p>Thanks a bunch for the review! Hopefully I've addressed everything. A few responses to the questions below:</p>
<blockquote>
<p>There are a few comments in-line, but I have some larger semantics-level and maintainability questions here:</p>
<div class="codehilite"><pre><span></span><code>* &gt; The MachBuffer also implements branch-island support. [..]



  * How is this tested, considering it is low probability path stuff?  Given that long range jumps are only for &gt; 1 MB on arm64, I feel like there&#39;s a bunch of paths here with very low probability of being taken.  Which is a verification hazard.  Is that the case?  If so, how is this stuff being tested?
    (Later) I see tests at the bottom of machinst/buffer.rs.  Are these adequate?
</code></pre></div>


</blockquote>
<p>The tests at the end of the file are all we have for now, but I had a thought today: another way to exercise this might be to artificially turn down the allowable branch range to force "real" use of islands/veneers in plausibly-large functions, e.g. maybe 1KB or so. Then we could do the usual correctness tests with our benchmarks. I'll have to think a bit about how to automate this; it ties into the idea Dan suggested before of an "evil mode", where we change some target config option(s) to make pessimistic choices everywhere (randomize block order, lower every phi as explicit moves, clobber every callee-save intentionally, etc.) and then fuzz the heck out of things. For now, perhaps I can do this manually and run the spec testsuite?</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>* (Islands-and-Deadlines algorithm further comment): This is clearly a complex bit of machinery.  I didn&#39;t see any single block comment explaining what the whole algorithm is.  Can you add one?  Not every detail, but at least some top level description.
</code></pre></div>


</blockquote>
<p>Yup, added a big block comment -- thanks; more docs are always better!</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>* (revised isel driver): again, this is now more complex than it was.  Question: is lookback past block boundaries still allowed?  And how does this interact with the colouring machinery?  My impression is that lookbacks past block boundaries are still allowed, however the colours always change across block boundaries.  Hence this restricts lookbacks across boundaries to pure value trees.  So it&#39;s correct.  But if that analysis is correct, that&#39;s a non-obvious interaction that it would be good to document.
</code></pre></div>


</blockquote>
<p>Yes, that's right; the predicate for allowing a lookback (which in practice means giving the instruction reference in the result of <code>get_input()</code>) is "same color, or producing op is pure". This is in the doc comment for <code>get_input()</code>, but perhaps I can write more high-level docs as well. I hope to write some sort of "backend writer's guide" that communicates these principles and invariants that one needs to know, eventually...</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>* (revised isel driver more): regarding lookbacks and colouring, I would like to see at least some implementation of movzx/movsx applied to loads, preferably in this patch, or at least very soon in a followup.  This is partly to improve code quality but primarily to demonstrate that the colouring infrastructure is sound (viz, to test it to some extent).
</code></pre></div>


</blockquote>
<p>Sure; perhaps separately from this patch, as that's part of the x64 backend work (and I'm trying to touch it as little as possible in this, to avoid stepping on other ongoing work)?</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>* Is it correct to understand that the new blockorder.rs maintains the old invariant that there are no dead blocks in the output?  Or, at least, that the invariant is maintained by whatever means, that there are no dead blocks in the input to regalloc?
</code></pre></div>


</blockquote>
<p>Yes, exactly: the output of <code>BlockLoweringOrder::new()</code> will never have dead blocks (even if the input CLIF does; the RPO naturally ensures this). Caught a few bugs with the regalloc's liveness checker so I'm somewhat confident this is the case now!</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>* I see debug! calls in potentially hottish places, eg MachBuffer::put1().  Are we sure those become zero cost in release builds?
</code></pre></div>


</blockquote>
<p>Fixed, thanks!</p>
</blockquote>



<a name="198006976"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/198006976" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#198006976">(May 18 2020 at 23:16)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-630482986">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<p>Thanks a bunch for the review! Hopefully I've addressed everything. A few responses to the questions below:</p>
<blockquote>
<p>There are a few comments in-line, but I have some larger semantics-level and maintainability questions here:</p>
<ul>
<li>
<blockquote>
<p>The MachBuffer also implements branch-island support. [..]</p>
</blockquote>
<ul>
<li>How is this tested, considering it is low probability path stuff?  Given that long range jumps are only for &gt; 1 MB on arm64, I feel like there's a bunch of paths here with very low probability of being taken.  Which is a verification hazard.  Is that the case?  If so, how is this stuff being tested?<br>
  (Later) I see tests at the bottom of machinst/buffer.rs.  Are these adequate?</li>
</ul>
</li>
</ul>
</blockquote>
<p>The tests at the end of the file are all we have for now, but I had a thought today: another way to exercise this might be to artificially turn down the allowable branch range to force "real" use of islands/veneers in plausibly-large functions, e.g. maybe 1KB or so. Then we could do the usual correctness tests with our benchmarks. I'll have to think a bit about how to automate this; it ties into the idea Dan suggested before of an "evil mode", where we change some target config option(s) to make pessimistic choices everywhere (randomize block order, lower every phi as explicit moves, clobber every callee-save intentionally, etc.) and then fuzz the heck out of things. For now, perhaps I can do this manually and run the spec testsuite?</p>
<blockquote>
<ul>
<li>(Islands-and-Deadlines algorithm further comment): This is clearly a complex bit of machinery.  I didn't see any single block comment explaining what the whole algorithm is.  Can you add one?  Not every detail, but at least some top level description.</li>
</ul>
</blockquote>
<p>Yup, added a big block comment -- thanks; more docs are always better!</p>
<blockquote>
<ul>
<li>(revised isel driver): again, this is now more complex than it was.  Question: is lookback past block boundaries still allowed?  And how does this interact with the colouring machinery?  My impression is that lookbacks past block boundaries are still allowed, however the colours always change across block boundaries.  Hence this restricts lookbacks across boundaries to pure value trees.  So it's correct.  But if that analysis is correct, that's a non-obvious interaction that it would be good to document.</li>
</ul>
</blockquote>
<p>Yes, that's right; the predicate for allowing a lookback (which in practice means giving the instruction reference in the result of <code>get_input()</code>) is "same color, or producing op is pure". This is in the doc comment for <code>get_input()</code>, but perhaps I can write more high-level docs as well. I hope to write some sort of "backend writer's guide" that communicates these principles and invariants that one needs to know, eventually...</p>
<blockquote>
<ul>
<li>(revised isel driver more): regarding lookbacks and colouring, I would like to see at least some implementation of movzx/movsx applied to loads, preferably in this patch, or at least very soon in a followup.  This is partly to improve code quality but primarily to demonstrate that the colouring infrastructure is sound (viz, to test it to some extent).</li>
</ul>
</blockquote>
<p>Sure; perhaps separately from this patch, as that's part of the x64 backend work (and I'm trying to touch it as little as possible in this, to avoid stepping on other ongoing work)?</p>
<blockquote>
<ul>
<li>Is it correct to understand that the new <a href="http://blockorder.rs">blockorder.rs</a> maintains the old invariant that there are no dead blocks in the output?  Or, at least, that the invariant is maintained by whatever means, that there are no dead blocks in the input to regalloc?</li>
</ul>
</blockquote>
<p>Yes, exactly: the output of <code>BlockLoweringOrder::new()</code> will never have dead blocks (even if the input CLIF does; the RPO naturally ensures this). Caught a few bugs with the regalloc's liveness checker so I'm somewhat confident this is the case now!</p>
<blockquote>
<ul>
<li>I see debug! calls in potentially hottish places, eg MachBuffer::put1().  Are we sure those become zero cost in release builds?</li>
</ul>
</blockquote>
<p>Fixed, thanks!</p>
</blockquote>



<a name="198021808"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231718%20Rework%20of%20MachInst%20isel%2C%20branch%20fi.../near/198021808" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231718.20Rework.20of.20MachInst.20isel.2C.20branch.20fi.2E.2E.2E.html#198021808">(May 19 2020 at 04:42)</a>:</h4>
<p>julian-seward1 <a href="https://github.com/bytecodealliance/wasmtime/pull/1718#issuecomment-630575828">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1718">Issue #1718</a>:</p>
<blockquote>
<p>One other comment (not to block landing):</p>
<blockquote>
<blockquote>
<p>(revised isel driver): again, this is now more complex than it was. Question: is lookback past block boundaries still allowed? [..]</p>
</blockquote>
<p>Yes, that's right; [..]</p>
</blockquote>
<p>FTR, I am still of the opinion that lookback outside the block, even for just pure values, will turn out to be a net loss in the end, in the sense that the extra register pressure will cause much more of a loss than any minor improvements in insn selection that might result. That said, I don't have any Actual Evidence to substantiate my claim, at least currently.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>