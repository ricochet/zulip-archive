<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6876 riscv64: Optimize `bitselect+{i,f}... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html">wasmtime / issue #6876 riscv64: Optimize `bitselect+{i,f}...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="386621338"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386621338" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386621338">(Aug 22 2023 at 14:22)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688286175">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>This might be good for a <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/isa/x64/lower.isle#L1365-L1381">rule like on x64</a> where much of the logic of bitselect can be skipped if the mask is known to have a particular pattern? (e.g. generated by icmp or fcmp)</p>
</blockquote>



<a name="386628203"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386628203" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386628203">(Aug 22 2023 at 14:50)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that</p>
</blockquote>



<a name="386628233"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386628233" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386628233">(Aug 22 2023 at 14:50)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>
</blockquote>



<a name="386628853"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386628853" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386628853">(Aug 22 2023 at 14:52)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>
<p>Edit: Hmm actually I don't think we can quite deduplicate this as neatly since we have different ways of generating a <code>icmp</code> mask and <code>fcmp</code> mask.</p>
</blockquote>



<a name="386629993"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386629993" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386629993">(Aug 22 2023 at 14:58)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>
<p>Edit: Hmm actually I don't think we can quite deduplicate this as neatly since we have different ways of generating a <code>icmp</code> mask and <code>fcmp</code> mask.</p>
<p>Edit2: Wait, now I'm confused. We're already sort of skipping the main bitselect lowering by using <code>vmerge</code> instead, that merges whole lanes instead of bits. We can't skip generating the <code>icmp</code>/<code>fcmp</code> mask since in RISC-V the masks are 1 bit per lane, so we always need to make the conversion from 1 bit per bit, into 1 bit per lane. Is that what you meant?</p>
</blockquote>



<a name="386634301"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386634301" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386634301">(Aug 22 2023 at 15:17)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688393132">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Oh this may not be applicable for riscv64, but on x64 at least there's no bitselect instruction so it uses the and/or/not/etc combo by default, but x64 does have lane-based select so if a bitselect's input mask is a comparison then the and/or/not/etc combo can be skipped in favor of a single lane-based instruction. I figured the same might be possible for riscv64 where bitselect could skip the combo of instructions and generate a single <code>vmerge*</code> (which I interpreted, perhaps mistakenly, as a lane-based instruction) after the normal instruction generated for the comparison. That way the rules for <code>bitselect</code> wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into <code>vmerge</code>. </p>
<blockquote>
<p>since we have different ways of generating a icmp mask and fcmp mask.</p>
</blockquote>
<p>On x64 I believe this is handled by <code>bitselect</code> not actually generating the icmp/fcmp, instead basically calling <code>put_in_reg</code> for the output of the icmp/fcmp which then will later use other lowering rules to generate the icmp/fcmp.</p>
<blockquote>
<p>We can't skip generating the icmp/fcmp mask since in RISC-V the masks are 1 bit per lane, so we always need to make the conversion from 1 bit per bit, into 1 bit per lane. Is that what you meant?</p>
</blockquote>
<p>Right yeah, my thinking was that like on x64 the lowering for <code>bitselect</code> wouldn't generate the cmp, only the <code>vmerge</code>, but because the mask of the <code>bitselect</code> is only pattern-matched on but we don't use the sub-operands that it would still generate the cmp naturally via other lowering rules.</p>
</blockquote>



<a name="386646581"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386646581" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386646581">(Aug 22 2023 at 16:19)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688527263">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Oh, okay so it's pretty much the same on RISC-V. We don't have a direct <code>bitselect</code> equivalent, we lower to <code>and/or/not</code> combo as well by default. <code>vmerge</code> is a lanewise select as you mentioned.</p>
<blockquote>
<p>That way the rules for bitselect wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into vmerge.</p>
</blockquote>
<p>Here's where this diverges. <code>vmerge</code> does not support the regular masks that are fed into <code>bitselect</code>. For a <code>i8x16</code> we need a 16bit mask instead of a 128bit mask. (Or a 8 bit mask for <code>i16x8</code>, etc...)</p>
<p>In the regular <code>icmp</code> and <code>fcmp</code> instruction lowerings we do two things, first we generate the small mask (1 bit per lane), and then we do a second step of expanding that into a big mask.</p>
<p>In this PR <code>gen_icmp_mask</code> and <code>gen_fcmp_mask</code> only generate the small mask, that is compatible with <code>vmerge</code>. But we never expand it, which is what would happen if we let the regular <code>icmp</code> and <code>fcmp</code> instructions get lowered.</p>
<p>Does that make sense? I think I might be missing something, sorry if I am. <br>
</p>
</blockquote>



<a name="386649173"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386649173" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386649173">(Aug 22 2023 at 16:30)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688527263">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>Oh, okay so it's pretty much the same on RISC-V. We don't have a direct <code>bitselect</code> equivalent, we lower to <code>and/or/not</code> combo as well by default. <code>vmerge</code> is a lanewise select as you mentioned.</p>
<blockquote>
<p>That way the rules for bitselect wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into vmerge.</p>
</blockquote>
<p>Here's where this diverges. <code>vmerge</code> does not support the regular masks that are fed into <code>bitselect</code>. For a <code>i8x16</code> we need a 16bit mask instead of a 128bit mask. (Or a 8 bit mask for <code>i16x8</code>, etc...)</p>
<p>In the regular <code>icmp</code> and <code>fcmp</code> instruction lowerings we do two things, first we generate the small mask (1 bit per lane), and then we do a second step of expanding that into a big mask.</p>
<p>In this PR <code>gen_icmp_mask</code> and <code>gen_fcmp_mask</code> only generate the small mask, that is compatible with <code>vmerge</code>. But we never expand it, which is what would happen if we let the regular <code>icmp</code> and <code>fcmp</code> instructions get lowered.</p>
<p>Does that make sense? I think I might be missing something, sorry if I am. </p>
<p>--<br>
Edit:</p>
<p>Yeah I think this is where x64 and RISC-V are different. Reading the spec for the <a href="https://www.felixcloutier.com/x86/blendvpd"><code>blend</code> instruction</a> it looks like it makes a decision based on the MSB on each lane, which allows it to directly use the input for <code>bitselect</code>, if we know its all the same for the entire lane.</p>
<p>On RISC-V our masks are completely different we only use the lowest <code>n</code> bits of the entire register (where <code>n</code> is the lane count). So they are sort of "compressed" masks. But that makes them incompatible with WASM and Cranelift's <code>icmp/fcmp</code>, so we need to pretend that they are the same by expanding them, and that prevents just generating <code>vmerge</code> as part of <code>bitselect</code> even if <em>know</em> that the input is a <code>icmp</code>/<code>fcmp</code>. </p>
</blockquote>



<a name="386660110"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236876%20riscv64%3A%20Optimize%20%60bitselect%2B%7Bi%2Cf%7D.../near/386660110" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236876.20riscv64.3A.20Optimize.20.60bitselect.2B.7Bi.2Cf.7D.2E.2E.2E.html#386660110">(Aug 22 2023 at 17:21)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688615987">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6876">issue #6876</a>:</p>
<blockquote>
<p>A different way to deduplicate these rules would be along the lines of <code>maybe_uextend</code>; riscv could use a <code>maybe_bitcast</code> extractor to have just one bitselect rule for each of icmp and fcmp, instead of two for each.</p>
<p>But I'm not sure that would be more broadly useful so I'm not sure it's worth doing. Just a thought in case it helps with something later.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>