<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5700 Cranelift/ISLE: precise semantics ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html">wasmtime / issue #5700 Cranelift/ISLE: precise semantics ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="325701299"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/325701299" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#325701299">(Feb 03 2023 at 18:44)</a>:</h4>
<p>avanhatt edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>In verification conversations, it’s come up that we don’t have a precise semantics for the underlying <code>u64</code> when a CLIF <code>iconst</code> has a narrow type (i.e., <code>i8</code>). Should the narrow constant be sign-extended, should it be zero-extended, or should the upper bits be semantically unspecified?</p>
<p>For example, for rules that use <code>Imm12</code>:</p>
<div class="codehilite" data-code-language="Common Lisp"><pre><span></span><code><span class="c1">;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.</span><span class="w"></span>
<span class="p">(</span><span class="nv">decl</span><span class="w"> </span><span class="nv">imm12_from_value</span><span class="w"> </span><span class="p">(</span><span class="nv">Imm12</span><span class="p">)</span><span class="w"> </span><span class="nv">Value</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nv">extractor</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">imm12_from_value</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">def_inst</span><span class="w"> </span><span class="p">(</span><span class="nv">iconst</span><span class="w"> </span><span class="p">(</span><span class="nv">u64_from_imm64</span><span class="w"> </span><span class="p">(</span><span class="nv">imm12_from_u64</span><span class="w"> </span><span class="nv">n</span><span class="p">)))))</span><span class="w"></span>
</code></pre></div>
<p>This external extractor is called:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">  </span><span class="sd">/// Compute a Imm12 from raw bits, if possible.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">maybe_from_u64</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Imm12</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0xfff</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0xfff_000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfff</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This seems to assume that constants are sign-extended, since we're comparing against 64-wide constants and because immediate arithmetic instructions do not sign extend (or, at minimum, this assumes the upper bits are not unspecified). </p>
<p>However, <a href="https://github.com/bytecodealliance/wasmtime/commit/244dce93f67b717cb6e77dc8d74d92052be165d8">this bug fix</a> for constant propagation in the midend implies that upper bits are unspecified and that bugs can occur from interpreting them: “this was producing iconsts with set high bits beyond their types' width, which is not legal.”</p>
<p>Because the verifier essentially models these <code>iconsts</code> as zero-extended, the verifier _does not_ find a bug on the code before the bug fix for #5405. That is, <a href="https://github.com/avanhatt/wasmtime/blob/cprop/cranelift/isle/veri/veri_engine/examples/midend/old_cprop.isle">this code</a> verifies successfully even using <code>imm64</code> and not <code>imm64_masked </code>. If using <code>imm64</code> here without masking is a bug, we need to update our the verifier's modeling to find it. </p>
<h4>Benefit</h4>
<p>We need precise semantics for verification. :) </p>
<p>We can also use this as a chance to audit for other bugs where there might be missing masking behavior.</p>
<h4>Implementation</h4>
<p>This doesn’t strictly need to change the implementation; but might be wise to add assertions of this behavior. </p>
<h4>Alternatives</h4>
<p><code>iconst</code> could have a more complicated backing Rust type where different widths are modeled with the correct type (e.g., <code>u8</code>), this is probably infeasible for performance reasons.<br>
</p>
</blockquote>



<a name="325701480"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/325701480" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#325701480">(Feb 03 2023 at 18:45)</a>:</h4>
<p>avanhatt <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1416261399">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Related to: <a href="https://github.com/bytecodealliance/wasmtime/issues/3059">https://github.com/bytecodealliance/wasmtime/issues/3059</a></p>
</blockquote>



<a name="325702368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/325702368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#325702368">(Feb 03 2023 at 18:50)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1416266027">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<blockquote>
<p>However, <a href="https://github.com/bytecodealliance/wasmtime/commit/244dce93f67b717cb6e77dc8d74d92052be165d8">this bug fix</a> for constant propagation in the midend implies that upper bits are unspecified and that bugs can occur from interpreting them: “this was producing iconsts with set high bits beyond their types' width, which is not legal.”</p>
</blockquote>
<p>Indeed. This is the case both at clif ir level and machine code level.</p>
</blockquote>



<a name="325707503"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/325707503" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#325707503">(Feb 03 2023 at 19:19)</a>:</h4>
<p>avanhatt edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>In verification conversations, it’s come up that we don’t have a precise semantics for the underlying <code>u64</code> when a CLIF <code>iconst</code> has a narrow type (e.g., <code>i8</code>). Should the narrow constant be sign-extended, should it be zero-extended, or should the upper bits be semantically unspecified?</p>
<p>For example, for rules that use <code>Imm12</code>:</p>
<div class="codehilite" data-code-language="Common Lisp"><pre><span></span><code><span class="c1">;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.</span><span class="w"></span>
<span class="p">(</span><span class="nv">decl</span><span class="w"> </span><span class="nv">imm12_from_value</span><span class="w"> </span><span class="p">(</span><span class="nv">Imm12</span><span class="p">)</span><span class="w"> </span><span class="nv">Value</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="nv">extractor</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">imm12_from_value</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">def_inst</span><span class="w"> </span><span class="p">(</span><span class="nv">iconst</span><span class="w"> </span><span class="p">(</span><span class="nv">u64_from_imm64</span><span class="w"> </span><span class="p">(</span><span class="nv">imm12_from_u64</span><span class="w"> </span><span class="nv">n</span><span class="p">)))))</span><span class="w"></span>
</code></pre></div>
<p>This external extractor is called:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">  </span><span class="sd">/// Compute a Imm12 from raw bits, if possible.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">maybe_from_u64</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Imm12</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0xfff</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0xfff_000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xfff</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// …</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>This seems to assume that constants are sign-extended, since we're comparing against 64-wide constants and because immediate arithmetic instructions do not sign extend (or, at minimum, this assumes the upper bits are not unspecified). </p>
<p>However, <a href="https://github.com/bytecodealliance/wasmtime/commit/244dce93f67b717cb6e77dc8d74d92052be165d8">this bug fix</a> for constant propagation in the midend implies that upper bits are unspecified and that bugs can occur from interpreting them: “this was producing iconsts with set high bits beyond their types' width, which is not legal.”</p>
<p>Because the verifier essentially models these <code>iconsts</code> as zero-extended, the verifier _does not_ find a bug on the code before the bug fix for #5405. That is, <a href="https://github.com/avanhatt/wasmtime/blob/cprop/cranelift/isle/veri/veri_engine/examples/midend/old_cprop.isle">this code</a> verifies successfully even using <code>imm64</code> and not <code>imm64_masked </code>. If using <code>imm64</code> here without masking is a bug, we need to update our the verifier's modeling to find it. </p>
<h4>Benefit</h4>
<p>We need precise semantics for verification. :) </p>
<p>We can also use this as a chance to audit for other bugs where there might be missing masking behavior.</p>
<h4>Implementation</h4>
<p>This doesn’t strictly need to change the implementation; but might be wise to add assertions of this behavior. </p>
<h4>Alternatives</h4>
<p><code>iconst</code> could have a more complicated backing Rust type where different widths are modeled with the correct type (e.g., <code>u8</code>), this is probably infeasible for performance reasons.<br>
</p>
</blockquote>



<a name="326223547"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326223547" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326223547">(Feb 06 2023 at 19:37)</a>:</h4>
<p>sampsyo <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419641711">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Just to distill some super-high-level facts:</p>
<ul>
<li>In CLIF data structures, all constants of any size and sightedness are recorded as <code>u64</code>s.</li>
<li>To state the obvious, all these actual physical bits are all either 1 or 0! There is no such things as a "don't care" bit in Rust <code>u64</code>s. <span aria-label="zany face" class="emoji emoji-1f92a" role="img" title="zany face">:zany_face:</span></li>
<li>So the question is about how ISLE rules (and other stuff that processes ISLE data structures) should treat these <code>u64</code>s. It seems like there are 3 options:<br>
    1. You can rely on the upper (out-of-range) bits being 0.<br>
    2. You can rely on those upper bits being the sign bit (i.e., sign-extended from the highest "real" bit).<br>
    3. You <em>cannot</em> rely on those bits being anything in particular, and you must expect there to be random junk up there. Which means you should probably mask off the upper bits before you do anything nontrivial with these <code>u64</code>s.</li>
</ul>
<p>It seems like most of the evidence we have (including stuff linked in this thread) points toward option 2. But we are taking something like option 3 in the verifier, which is "conservative" in the sense that it at least doesn't mistakenly <em>reject</em> correct rules that adhere to 1 or 2. But it also limits it from finding bugs in rules that make incorrect assumptions about out-of-range bits.</p>
<p>So therefore, if we think the truth is actually option 1 or 2 above, we should probably "tighten down" the verifier to match those so we can find more bugs.</p>
</blockquote>



<a name="326223699"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326223699" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326223699">(Feb 06 2023 at 19:38)</a>:</h4>
<p>sampsyo edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419641711">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Just to distill some super-high-level facts:</p>
<ul>
<li>In CLIF data structures, all constants of any size and sightedness are recorded as <code>u64</code>s.</li>
<li>To state the obvious, all these actual physical bits are all either 1 or 0! There is no such things as a "don't care" bit in Rust <code>u64</code>s. <span aria-label="zany face" class="emoji emoji-1f92a" role="img" title="zany face">:zany_face:</span></li>
<li>So the question is about how ISLE rules (and other stuff that processes ISLE data structures) should treat these <code>u64</code>s. It seems like there are 3 options:<br>
    1. You can rely on the upper (out-of-range) bits being 0.<br>
    2. You can rely on those upper bits being the sign bit (i.e., sign-extended from the highest "real" bit).<br>
    3. You <em>cannot</em> rely on those bits being anything in particular, and you must expect there to be random junk up there. Which means you should probably mask off the upper bits before you do anything nontrivial with these <code>u64</code>s.</li>
</ul>
<p>It seems like most of the evidence we have (including stuff linked in this thread) points toward option "ii". But we are taking something like option "iii" in the verifier, which is "conservative" in the sense that it at least doesn't mistakenly <em>reject</em> correct rules that adhere to "i" or "ii". But it also limits it from finding bugs in rules that make incorrect assumptions about out-of-range bits.</p>
<p>So therefore, if we think the truth is actually option "i" or "ii" above, we should probably "tighten down" the verifier to match those so we can find more bugs.</p>
</blockquote>



<a name="326223821"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326223821" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326223821">(Feb 06 2023 at 19:39)</a>:</h4>
<p>sampsyo edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419641711">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Just to distill some super-high-level facts:</p>
<ul>
<li>In CLIF data structures, all constants of any size and sightedness are recorded as <code>u64</code>s.</li>
<li>To state the obvious, all these actual physical bits are all either 1 or 0! There is no such things as a "don't care" bit in Rust <code>u64</code>s. <span aria-label="zany face" class="emoji emoji-1f92a" role="img" title="zany face">:zany_face:</span></li>
<li>So the question is about how ISLE rules (and other stuff that processes ISLE data structures) should treat these <code>u64</code>s. It seems like there are 3 options:<br>
    1. You can rely on the upper (out-of-range) bits being 0.<br>
    2. You can rely on those upper bits being copies of the sign bit (i.e., sign-extended from the highest "real" bit).<br>
    3. You <em>cannot</em> rely on those bits being anything in particular, and you must expect there to be random junk up there. Which means you should probably mask off the upper bits before you do anything nontrivial with these <code>u64</code>s.</li>
</ul>
<p>It seems like most of the evidence we have (including stuff linked in this thread) points toward option "ii". But we are taking something like option "iii" in the verifier, which is "conservative" in the sense that it at least doesn't mistakenly <em>reject</em> correct rules that adhere to "i" or "ii". But it also limits it from finding bugs in rules that make incorrect assumptions about out-of-range bits.</p>
<p>So therefore, if we think the truth is actually option "i" or "ii" above, we should probably "tighten down" the verifier to match those so we can find more bugs.</p>
</blockquote>



<a name="326223899"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326223899" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326223899">(Feb 06 2023 at 19:39)</a>:</h4>
<p>sampsyo edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419641711">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Just to distill some super-high-level facts:</p>
<ul>
<li>In CLIF data structures, all constants of any size and sightedness are recorded as <code>u64</code>s.</li>
<li>To state the obvious, all these actual physical bits are all either 1 or 0! There is no such thing as a "don't care" bit in Rust <code>u64</code>s. <span aria-label="zany face" class="emoji emoji-1f92a" role="img" title="zany face">:zany_face:</span></li>
<li>So the question is about how ISLE rules (and other stuff that processes ISLE data structures) should treat these <code>u64</code>s. It seems like there are 3 options:<br>
    1. You can rely on the upper (out-of-range) bits being 0.<br>
    2. You can rely on those upper bits being copies of the sign bit (i.e., sign-extended from the highest "real" bit).<br>
    3. You <em>cannot</em> rely on those bits being anything in particular, and you must expect there to be random junk up there. Which means you should probably mask off the upper bits before you do anything nontrivial with these <code>u64</code>s.</li>
</ul>
<p>It seems like most of the evidence we have (including stuff linked in this thread) points toward option "ii". But we are taking something like option "iii" in the verifier, which is "conservative" in the sense that it at least doesn't mistakenly <em>reject</em> correct rules that adhere to "i" or "ii". But it also limits it from finding bugs in rules that make incorrect assumptions about out-of-range bits.</p>
<p>So therefore, if we think the truth is actually option "i" or "ii" above, we should probably "tighten down" the verifier to match those so we can find more bugs.</p>
</blockquote>



<a name="326227074"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326227074" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326227074">(Feb 06 2023 at 19:58)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419665047">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<blockquote>
<p>In CLIF data structures, all constants of any size and sightedness are recorded as u64s.</p>
</blockquote>
<p>Actually we use i64 (Imm64) and sometimes sign extend and sometimes zero extend, we currently require masking of the high bits in the backend. I would personallt like it to be changed to u64 + requiring zero extension using a clif verifier rule.</p>
</blockquote>



<a name="326227205"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326227205" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326227205">(Feb 06 2023 at 19:59)</a>:</h4>
<p>sampsyo <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419666002">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Got it; thanks for clarifying!</p>
</blockquote>



<a name="326231774"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326231774" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326231774">(Feb 06 2023 at 20:26)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419704186">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Right now my opinion is that we want to follow option 1: unused bits should be 0. I think that's what we've been moving toward producing in the mid-end optimization rules.</p>
<p>But we don't verify that whoever produced the CLIF we're compiling followed that rule, and in that sense we're currently following option 3.</p>
<blockquote>
<p>But we are taking something like option "iii" in the verifier, which is "conservative" in the sense that it at least doesn't mistakenly reject correct rules that adhere to "i" or "ii". But it also limits it from finding bugs in rules that make incorrect assumptions about out-of-range bits.</p>
</blockquote>
<p>I don't understand this. If a backend "cannot rely on those bits being anything in particular", then any rule which does rely on those bits (being all-zero in case 1, or all-sign in case 2, or making some other unspecified assumption) should be rejected by the verifier, right?</p>
</blockquote>



<a name="326239843"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326239843" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326239843">(Feb 06 2023 at 21:15)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419765219">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>I'd also say that option 1 seems most reasonable to me. Elsewhere when we have a variable-width payload we generally try to zero-extend.</p>
<p>Re: current verifier assumptions: I imagine what's going on here is that the verifier is providing the assumption that the upper bits are initialized (sign-extended? zero-extended?) so rules that assume this invariant will work, but is not checking the same assumption at the output side? I guess a consistent approach at either extreme would be better -- either provide and check the bit status, or leave as don't-care on the input (as @jameysharp suggests) and don't verify on output. Former would be consistent with taking option 1 or 2 I guess.</p>
</blockquote>



<a name="326244827"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326244827" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326244827">(Feb 06 2023 at 21:49)</a>:</h4>
<p>sampsyo <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1419816843">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Right; I kinda realized while typing that summary of the verifier's current assumptions that it was a little nonsensical. Its current policy does not _model_ rule semantics under the regime of policy 3; instead, it does the masking/truncation like policy 3 on behalf of the rules. So, in the verifier's world, rules effectively "see" narrow values and never even interact with the out-of-range bits. Therefore, according to the verifier, they can never have bugs that arise from treating the out-of-range bits incorrectly. (As ever, @avanhatt may correct me about this.)</p>
</blockquote>



<a name="326282269"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326282269" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326282269">(Feb 07 2023 at 04:47)</a>:</h4>
<p>avanhatt <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1420196574">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Part of my initial confusion stemmed from that in working from <code>.clif</code> files, the frontend seems to sign extend.</p>
<p>For example running this test:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">run</span>
<span class="n">target</span><span class="w"> </span><span class="n">aarch64</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">a</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span>
<span class="p">}</span>
<span class="p">;</span><span class="w"> </span><span class="n">run</span>: <span class="o">%</span><span class="n">a</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">49</span>
</code></pre></div>
<p>And dumping (via a panic for simplicity) the resulting <code>u64</code> of external extractors triggered by immediate checks (<code>Imm12::maybe_from_u64</code> on <code>aarch64</code>, <code>simm32_from_value</code> on <code>x64</code>) gives the sign-extended constant for <code> iconst.i32 -1</code>:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">FAIL</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="n">clif</span>: <span class="nc">panicked</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">worker</span><span class="w"> </span>#<span class="mi">0</span>: <span class="mh">0xffffffffffffffff</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="326282460"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326282460" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326282460">(Feb 07 2023 at 04:50)</a>:</h4>
<p>avanhatt <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1420197988">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>And yes, essentially what Adrian said: an <code>iconst</code> is modeled as only the narrow value where possible. When it needs to be used as a <code>u64</code>, our current annotations and inference do masking/truncation as necessary, so we don't find bugs in rules that set the upper bits but shouldn't. </p>
</blockquote>



<a name="326282512"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326282512" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326282512">(Feb 07 2023 at 04:51)</a>:</h4>
<p>avanhatt edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1420196574">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Part of my initial confusion stemmed from that in working from <code>.clif</code> files, the frontend seems to sign extend.</p>
<p>For example running this test:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">run</span>
<span class="n">target</span><span class="w"> </span><span class="n">aarch64</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">a</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span>
<span class="p">}</span>
<span class="p">;</span><span class="w"> </span><span class="n">run</span>: <span class="o">%</span><span class="n">a</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">49</span>
</code></pre></div>
<p>And dumping (via a panic for simplicity) the resulting <code>u64</code> of external extractors triggered by immediate checks (<code>Imm12::maybe_from_u64</code> on <code>aarch64</code>, <code>simm32_from_value</code> on <code>x64</code>):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">simm32_from_value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="nc">Value</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">GprMemImm</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lower_ctx</span><span class="p">.</span><span class="n">dfg</span><span class="p">().</span><span class="n">value_def</span><span class="p">(</span><span class="n">val</span><span class="p">).</span><span class="n">inst</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">constant</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lower_ctx</span><span class="p">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="fm">panic!</span><span class="p">(</span><span class="s">"{:#x}"</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>Gives the sign-extended constant for <code> iconst.i32 -1</code>:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">FAIL</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="n">clif</span>: <span class="nc">panicked</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">worker</span><span class="w"> </span>#<span class="mi">0</span>: <span class="mh">0xffffffffffffffff</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="326430187"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326430187" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326430187">(Feb 07 2023 at 18:30)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1421260557">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<p>Ideally we would encapsulate <code>Imm64</code>'s internal value such that you couldn't get/set it without supplying the type of the <code>Imm64</code> and it would handle this however we choose in that one place, and this wouldn't be something we have to uphold all throughout Cranelift.</p>
</blockquote>



<a name="326492009"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235700%20Cranelift/ISLE%3A%20precise%20semantics%20.../near/326492009" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235700.20Cranelift.2FISLE.3A.20precise.20semantics.20.2E.2E.2E.html#326492009">(Feb 08 2023 at 01:54)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/5700#issuecomment-1421834272">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5700">issue #5700</a>:</p>
<blockquote>
<blockquote>
<p>Part of my initial confusion stemmed from that in working from <code>.clif</code> files, the frontend seems to sign extend.</p>
</blockquote>
<p>At the least, we should make cranelift-reader mask constants after parsing them, and maybe also verify that a constant's value doesn't change after narrowing it.</p>
<p>Nick's suggestion of encapsulating <code>Imm64</code> internally is a better and more comprehensive plan, but I think we'd still get a long way just by fixing the parser.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>