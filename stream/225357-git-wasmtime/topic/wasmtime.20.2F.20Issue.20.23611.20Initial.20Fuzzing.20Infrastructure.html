<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #611 Initial Fuzzing Infrastructure · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.23611.20Initial.20Fuzzing.20Infrastructure.html">wasmtime / Issue #611 Initial Fuzzing Infrastructure</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="192892774"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%23611%20Initial%20Fuzzing%20Infrastructure/near/192892774" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.23611.20Initial.20Fuzzing.20Infrastructure.html#192892774">(Apr 04 2020 at 06:21)</a>:</h4>
<p>Hyperion101010 <a href="https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608982293" title="https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608982293">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/611" title="https://github.com/bytecodealliance/wasmtime/issues/611">Issue #611</a>:</p>
<blockquote>
<p>@fitzgen sir this was a gsoc2020 project idea, I worked in the application period and submitted a proposal. Given the time I had at I hand i wasn't able to get complete idea about the different vulnerabilities like ABI abstractions, Heap and Stack safety. I want to voluntarily contribute for the idea, but couldn't do the same before I clear out some doubts. <br>
I would like to start understanding the fuzzing process more closely and contributing by writing fuzzers perhaps. During the application process I wrote mails for the project details, but I never got any reply which is completely fine given the situation we have now. <br>
Is there any way we can do a conversation for the doubts I have, I see that there used to be a IRC channel for wasmtime one year ago, but now they migrated to Matrix which unfortunately doesn't has any such channel. If you are available on any channel of Mozilla/(other open source org) please let me know.<br>
Good day!   </p>
</blockquote>



<a name="192894363"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%23611%20Initial%20Fuzzing%20Infrastructure/near/192894363" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.23611.20Initial.20Fuzzing.20Infrastructure.html#192894363">(Apr 04 2020 at 07:14)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608987915" title="https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608987915">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/611" title="https://github.com/bytecodealliance/wasmtime/issues/611">Issue #611</a>:</p>
<blockquote>
<p><a href="" title="">https://bytecodealliance.zulipchat.com/</a> is the primary discussion channel.</p>
</blockquote>



<a name="225078462"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%23611%20Initial%20Fuzzing%20Infrastructure/near/225078462" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.23611.20Initial.20Fuzzing.20Infrastructure.html#225078462">(Feb 03 2021 at 20:43)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-772810080">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/611">Issue #611</a>:</p>
<blockquote>
<p>I think this can be closed.</p>
</blockquote>



<a name="225079520"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%23611%20Initial%20Fuzzing%20Infrastructure/near/225079520" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.23611.20Initial.20Fuzzing.20Infrastructure.html#225079520">(Feb 03 2021 at 20:51)</a>:</h4>
<p>cfallin closed <a href="https://github.com/bytecodealliance/wasmtime/issues/611">Issue #611</a>:</p>
<blockquote>
<p>I plan on laying out some foundational fuzzing infrastructure for Wasmtime in the next few weeks. I'd like to use this issue as a kind of meta issue to keep track of this work. I'd also appreciate feedback on the plan from anyone with experience fuzzing or domain knowledge of a particular thing we plan on fuzzing.</p>
<h2>Goals</h2>
<ul>
<li>
<p><strong>Find bugs!</strong></p>
<ul>
<li>Bugs that we wouldn't otherwise find until our users hit them.</li>
<li>Bugs that are hard to manually write test cases for, or that you wouldn't even think of testing for.</li>
</ul>
</li>
<li>
<p>Make bugs (fuzzer-found or otherwise) easier to debug via automatic test case reduction.</p>
</li>
</ul>
<h2>Strategy</h2>
<h3>Breadth not Depth</h3>
<p>At least initially, let's build out a few different fuzzing approaches enough that they start identifying bugs, but not spend a ton of time building bespoke tools tailored for exactly the problems we have at hand.</p>
<p>My assumptions are that</p>
<ol>
<li>we have low-hanging fruit available, since we haven't done a <em>ton</em> of fuzzing for a bunch of corners yet, and</li>
<li>different fuzzing approaches tend to uncover different sets of bugs.</li>
</ol>
<p>Therefore, by making a bunch of different just-good-enough fuzzers, we will repeatedly discover new, unique low-hanging fruit bugs.</p>
<p>Additionally, this gives us a nice foundation that we can spring board off of in the future when we decide to go deeper in any particular direction.</p>
<h3>Decouple Generators and Oracles</h3>
<p>A <em>generator</em> creates test cases (usually given an RNG or a random byte stream input). An <em>oracle</em> determines if executing a test case uncovered a bug. In general, it is good software engineering to separate concerns, but separating these two parts specifically allows us to:</p>
<ul>
<li>reuse oracles during automatic test case reduction (a la <code>creduce</code>), and</li>
<li>swap out existing, off-the-shelf generators with more intelligent, custom generators the future.</li>
</ul>
<h2>Implementation</h2>
<p>In general, I recommend that we use <code>libFuzzer</code> to drive our fuzzing. It is coverage-guided, which means it can find interesting code paths more quickly than testing purely random inputs will. It also has a nice Rust interface in the form of <a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a>.</p>
<p>Any custom generators we create should <a href="https://fitzgeraldnick.com/2019/09/04/combining-coverage-guided-and-generation-based-fuzzing.html">take <code>libFuzzer</code>-provided input bytes and then re-interpret that as a sequence of random values to drive choices inside the generator</a>. This lets us combine the benefits of smart, structure-aware generators with those of coverage-guided fuzzing. We can implement this by implementing our custom generators in terms of the <code>arbitrary</code> crate's <code>Arbitrary</code> trait.</p>
<p>As far as test case reduction goes, when a generator is creating Wasm files, it should be relatively easy to use binaryen's <code>wasm-reduce</code> on the Wasm file, or use <code>creduce</code> on the WAT disassembly. We can, however, do some small things to make the process turnkey:</p>
<ul>
<li>[ ] Write glue scripts for running <code>wasm-reduce</code> and/or <code>creduce</code> on a Wasm test case with any of our various oracles</li>
</ul>
<p>For generators that are creating custom in-memory data structures by implementing the <code>Arbitrary</code> trait, test case reduction requires we implement some custom logic. The <code>Arbitrary</code> trait supports defining a custom <code>shrink</code> method that takes <code>&amp;self</code> and returns an iterator of smaller instances of <code>Self</code>. We can use this to create custom test case reduction for each of our custom test case generators.</p>
<p>Finally, any custom generator we create (and any generator we wrap that supports turning the generation of individual test case features on/off) should support <a href="https://www.cs.utah.edu/~regehr/papers/swarm12.pdf">swarm testing</a>. Swarm testing is where we randomly turn on/off the generation of various test case features (such as, should a generator create Wasm test cases that use <code>call_indirect</code> or not?) so that we are more likely to generate pathological test cases where bugs are more likely to be found. This is relatively easy implement and should yield</p>
<h3>Fuzzing Wasmtime's Embedding API</h3>
<p>This is a case where, unfortunately, we can't really use existing off-the-shelf solutions.</p>
<h4>Generators</h4>
<ul>
<li>[x] Build a custom generator that creates a sequence of API calls. It shouldn't perform the calls, just describe them. This generator should have some smarts about knowing how to generate <em>valid</em> API calls.</li>
</ul>
<h4>Oracles</h4>
<ul>
<li>[x] Interpret API call descriptions and perform the actual API call. Find unexpected panics, assertion failures, and segfaults.</li>
</ul>
<h3>Wasm Execution Fuzzing</h3>
<p>We should fuzz our execution of Wasm. Yes, Cranelift has some fuzzing in SpiderMonkey, but we should also make sure that all of our Wasmtime-specific JIT'ing machinery is well fuzzed, as well as our WASI implementation and sandboxing.</p>
<h4>Generators</h4>
<ul>
<li>
<p>[x] Use <code>wasm-opt -ttf</code> to generate random, valid Wasm files.</p>
</li>
<li>
<p>[ ] Write a custom generator that creates Wasm files that make sequences of WASI syscalls.</p>
</li>
</ul>
<h4>Oracles</h4>
<ul>
<li>
<p>[ ] Execute the file and ensure Wasmtime doesn't panic, fail any <code>assert!(..)</code>s, or segfault regardless if executing the Wasm traps.</p>
</li>
<li>
<p>[ ] <code>strace</code> the process or something and ensure it doesn't do any syscalls outside the preopened directory given to the WASI sandbox or something?</p>
</li>
<li>
<p>[x] Differential fuzzing where we compare the observable results of execution between:</p>
<ul>
<li>[x] Cranelift without optimizations</li>
<li>[x] Cranelift with opt=speed</li>
<li>[x] Cranelift with opt=size</li>
<li>[x] Cranelift with opt=speed_and_size</li>
<li>[ ] Cranelift with a warm code cache</li>
<li>[ ] Cranelift with a cold code cache</li>
<li>[x] Lightbeam</li>
</ul>
</li>
</ul>
<h2>More Stuff to Explore in the Future</h2>
<ul>
<li>
<p><a href="https://github.com/bytecodealliance/cranelift/issues/1235">Add support for code-coverage in Cranelift and leverage it to build equivalence-module-inputs testing and coverage-guided fuzzing for Wasmtime</a></p>
<ul>
<li>Alternatively, we could MacGyver some custom code coverage scheme via instrumenting Wasm files with Walrus instead of doing this inside Cranelift at the clif level.</li>
</ul>
</li>
<li>
<p>Create test case generators and oracles for our Wasm interface types support?  What would be involved here is not super clear to me yet.</p>
</li>
</ul>
<h2>Questions</h2>
<ul>
<li>
<p>Should the fuzzing corpus be committed into the git repo? Or perhaps should it be a separate repo that we include as a git submodule?</p>
</li>
<li>
<p>What work here should we prioritize?</p>
<ul>
<li>In particular, what variants would be most valuable to compare / most likely to uncover high-priority bugs in differential fuzzing of Wasm execution?</li>
</ul>
</li>
<li>
<p>Is there anything here you think we should <em>not</em> implement?</p>
</li>
<li>
<p>Are there any other WASI-targeted oracles we can create? The <code>strace</code> idea is pretty half-baked right now. I'd appreciate some more ideas from folks more involved in the WASI side of things than I am...<br>
</p>
</li>
</ul>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>