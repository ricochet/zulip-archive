<html>
<head><meta charset="utf-8"><title>wasmtime / PR #9341 Add support for `funcref`s inside GC ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html">wasmtime / PR #9341 Add support for `funcref`s inside GC ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="473888992"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/473888992" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#473888992">(Oct 01 2024 at 00:01)</a>:</h4>
<p>fitzgen opened <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a> from <code>fitzgen:funcrefs-in-gc-heap</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
</blockquote>



<a name="473888993"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/473888993" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#473888993">(Oct 01 2024 at 00:01)</a>:</h4>
<p><strong>fitzgen</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>.</p>



<a name="473888994"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/473888994" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#473888994">(Oct 01 2024 at 00:01)</a>:</h4>
<p><strong>fitzgen</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>.</p>



<a name="473912697"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/473912697" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#473912697">(Oct 01 2024 at 02:14)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2384645205">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "wasmtime:api", "wasmtime:ref-types"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: wasmtime:ref-types</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="474069039"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474069039" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474069039">(Oct 01 2024 at 15:47)</a>:</h4>
<p>fitzgen updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>.</p>



<a name="474069095"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474069095" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474069095">(Oct 01 2024 at 15:47)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386374293">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<p>Rebased to resolve conflicts.</p>
</blockquote>



<a name="474073990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474073990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474073990">(Oct 01 2024 at 16:13)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#pullrequestreview-2340840947">PR review</a>:</p>
<blockquote>
<p>I think this is all reasonable enough, but this is definitely further amplifying my worries about the cost of GC and runtime performance. Every write of a funcref  now requires at least a hash table lookup and reads can require taking a read lock on a global <code>RwLock</code>. On one hand I realize that the goal is to get GC working, but on the other hand I also have a hard time seeing how this is going to be a suitable performance profile for anyone actually using GC. I do realize though that improving on this is going to be significantly difficult to, for example, expose the slab to jit code or to implement a GC of the slab entries themselves.</p>
<p>In that sense I'm going to go ahead and approve this as-is since I don't believe there are any correctness issues with it. (one minor worry is that the hash map isn't GC'd right now, but that mirrors the behavior of we don't implement instance-level GC within a <code>Store</code> so they're O(N) the same size more-or-less). Do you think it would be useful though to build up a list of the possible performance optimizations we can think of to keep track of things? I do still agree that this is the best route for getting things implemented and to a point where we can measure performance to see what to optimize, but I'm also afraid of losing context on the myriad of possible ways to optimize things as PRs land incrementally</p>
</blockquote>



<a name="474075058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474075058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474075058">(Oct 01 2024 at 16:18)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386445135">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<blockquote>
<p>Do you think it would be useful though to build up a list of the possible performance optimizations we can think of to keep track of things?</p>
</blockquote>
<p>Yeah, I can write up an issue with a list of these.</p>
</blockquote>



<a name="474075974"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474075974" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474075974">(Oct 01 2024 at 16:24)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386456719">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<p>I share your concerns. It certainly is not going to be performant as-is. My most-immediate thoughts are that we would do roughly the following to speed this up:</p>
<ul>
<li>Expose the slab to Wasm, allowing id-to-funcref conversion to happen fully within wasm code</li>
<li>for funcref-to-id conversion, add an LRU/associative cache to the vmctx (or maybe runtime limits) to cache the results of the libcall and allow the happy path to stay within wasm code. the slow path would still fall back to a libcall however (I do not want to implement hashing in wasm code and try to keep it in sync with the Rust hashing)</li>
</ul>
<p>My hope is that the above would result in good enough perf for us to not have to revisit this for quite a while.</p>
</blockquote>



<a name="474078470"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474078470" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474078470">(Oct 01 2024 at 16:38)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386482939">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<p>Two questions actually:</p>
<ul>
<li>On the write side I was hoping we could do something purely in JIT code where it allocates space from the slab itself and the slab slots are managed by the normal GC. Would that be possible? For example during tracing we'd record which slab slots were in use and deallocation would be to iterate over the existing slab slots (and compaction may not be too hard either).</li>
<li>On the read side is there any way to avoid the lock? That seems required currently for our threat model, but I'm basically wondering if there's any way we can get away with just an index comparison as opposed to a full subtype check.</li>
</ul>
</blockquote>



<a name="474081060"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474081060" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474081060">(Oct 01 2024 at 16:51)</a>:</h4>
<p>fitzgen merged <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>.</p>



<a name="474102976"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474102976" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474102976">(Oct 01 2024 at 18:41)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386711548">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<blockquote>
<ul>
<li>On the read side is there any way to avoid the lock?</li>
</ul>
</blockquote>
<p>I think we solve this via the approach that we have talked about previously of having a shared, lock-free arena for the supertypes arrays, so that particular subtyping checks don't need to lock anything.</p>
<p>Will write up an issue about this soon.</p>
</blockquote>



<a name="474103730"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474103730" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474103730">(Oct 01 2024 at 18:46)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386719711">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<blockquote>
<p>On the write side I was hoping we could do something purely in JIT code where it allocates space from the slab itself and the slab slots are managed by the normal GC. Would that be possible? For example during tracing we'd record which slab slots were in use and deallocation would be to iterate over the existing slab slots (and compaction may not be too hard either).</p>
</blockquote>
<p>I think the tracing part is definitely doable. Compaction should also be possible. But the tricky part will be deduplicating funcrefs in the slab (i.e. the reason the hash map is in there now). Without that deduping, I fear that it will be too easy to fill the funcref table, require a GC, and end up thrashing the collector.</p>
</blockquote>



<a name="474112724"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474112724" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474112724">(Oct 01 2024 at 19:32)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386819275">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<ul>
<li>On the read side is there any way to avoid the lock?</li>
</ul>
</blockquote>
<p>I think we solve this via the approach that we have talked about previously of having a shared, lock-free arena for the supertypes arrays, so that particular subtyping checks don't need to lock anything.</p>
<p>Will write up an issue about this soon.</p>
</blockquote>
<p><a href="https://github.com/bytecodealliance/wasmtime/issues/9352">https://github.com/bytecodealliance/wasmtime/issues/9352</a></p>
</blockquote>



<a name="474112754"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239341%20Add%20support%20for%20%60funcref%60s%20inside%20GC%20.../near/474112754" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239341.20Add.20support.20for.20.60funcref.60s.20inside.20GC.20.2E.2E.2E.html#474112754">(Oct 01 2024 at 19:33)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9341#issuecomment-2386822272">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9341">PR #9341</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Do you think it would be useful though to build up a list of the possible performance optimizations we can think of to keep track of things?</p>
</blockquote>
<p>Yeah, I can write up an issue with a list of these.</p>
</blockquote>
<p><a href="https://github.com/bytecodealliance/wasmtime/issues/9351">https://github.com/bytecodealliance/wasmtime/issues/9351</a></p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>