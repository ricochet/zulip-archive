<html>
<head><meta charset="utf-8"><title>wasmtime / PR #2611 Implement limiting WebAssembly execut... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html">wasmtime / PR #2611 Implement limiting WebAssembly execut...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="224258425"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224258425" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224258425">(Jan 27 2021 at 22:32)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224258588"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224258588" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224258588">(Jan 27 2021 at 22:34)</a>:</h4>
<p><strong>alexcrichton</strong> requested <a href="https://github.com/cfallin">cfallin</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a>.</p>



<a name="224259512"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224259512" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224259512">(Jan 27 2021 at 22:44)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224268195"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268195" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268195">(Jan 28 2021 at 00:14)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-577878992">PR Review</a>.</p>



<a name="224268196"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268196" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268196">(Jan 28 2021 at 00:14)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r565726520">PR Review Comment</a>:</p>
<blockquote>
<p>Maybe worth noting somewhere around here that, for the purposes of fuel, we don't care about (implicit) branches due to traps in the middle of a block?</p>
</blockquote>



<a name="224268197"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268197" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268197">(Jan 28 2021 at 00:14)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-577878992">PR Review</a>.</p>



<a name="224268365"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268365" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268365">(Jan 28 2021 at 00:16)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-577874372">PR Review</a>.</p>



<a name="224268366"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268366" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268366">(Jan 28 2021 at 00:16)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-577874372">PR Review</a>.</p>



<a name="224268368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268368">(Jan 28 2021 at 00:16)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r565722540">PR Review Comment</a>:</p>
<blockquote>
<p>Is there any reason we can't add to the existing <code>fuel_adj</code> value here, in order to continue accumulating the consumed-fuel count and return the true total from <code>fuel_consumed()</code>?</p>
<p>(In that case I might also call this <code>add_fuel()</code>, and adjust existing rather than overwrite the fuel-consumed counter...)</p>
</blockquote>



<a name="224268369"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224268369" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224268369">(Jan 28 2021 at 00:16)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r565730365">PR Review Comment</a>:</p>
<blockquote>
<p>Can you say more about the expected way to run this in an executor-loop system with timeslicing (as in Lucet's fuel implementation)?</p>
<p>Specifically, is the common case that we'll run for a timeslice and then unwind here using the trap mechanism back to the Wasm entry point, at which point some higher-level wrapper might yield a future or similar?</p>
<p>My two concerns are:</p>
<ul>
<li>Efficiency: invoking the unwind mechanism and heap-allocating an error is somewhat heavyweight;</li>
<li>Ability to resume: it looks like <code>raise_lib_trap</code> eventually invokes <code>Unwind</code> in wasmtime-runtime's helpers.c, which uses longjmp to escape the Wasm stack frames. Does this mean that we can't resume at the point where fuel was exhausted (i.e., it's a terminating trap rather than a resumable one)?</li>
</ul>
<p>All of my concerns above go away if we have a way to plug in a custom out-of-gas handler; I couldn't find an API that would let one do this (one would need to pass in a custom <code>TrapInfo</code> trait impl I think?) though I may have missed it. Or alternately, is the more complete interface coming with later async work?</p>
</blockquote>



<a name="224339877"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224339877" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224339877">(Jan 28 2021 at 15:15)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578437026">PR Review</a>.</p>



<a name="224339879"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224339879" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224339879">(Jan 28 2021 at 15:15)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566172854">PR Review Comment</a>:</p>
<blockquote>
<p>Oh sure yeah, the "raise a trap" implementation here is primarily just so we can test it in this PR without all the async bits landed yet. Additionally it helps us fuzz the implementation well by ensuring wasm is always consuming fuel when executing. For an async yield-every-so-often implementation my plan is to:</p>
<ul>
<li>Still have this bake into a <code>Store</code> without the ability to register a custom handler (although that's still possible, but fraught with correctness issues on the caller's part)</li>
<li>Instead of raising a trap here this would simply switch off the fiber. With async we are guaranteed that all wasm is always executing on a fiber, so this is possible.</li>
<li>The <code>Store</code> would have some sort of flag/configuration where in async mode you could request that N fuel is used up and when finished it yields to the current future and then injects N more fuel when it comes back.</li>
</ul>
<p>The implementation would be relatively simple, basically <a href="https://github.com/bytecodealliance/wasmtime/blob/64ab442767789571b69a49caacf6aae2967664f6/crates/wasmtime/src/store.rs#L532-L534">calling suspend</a> here aftter notifying ourselves to the future executor saying we're already ready for another <code>poll</code>. I would imagine that this would all be guarded by a basic <code>if</code> in this out-of-gas handler which either traps or yields.</p>
<p>Efficiency-wise I think it should be quite fast because it's a fiber switch and no unwinding happens (not even longjmp). Upon resumption we'd simply return from this function and wasm would keep going. Resumption-wise we should be good as well due to fibers and whatnot. Basically the trap stuff won't happen at for the timeslicing, it's just a way for me to land this PR before the async fiddly bits are here.</p>
</blockquote>



<a name="224340050"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224340050" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224340050">(Jan 28 2021 at 15:16)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578438062">PR Review</a>.</p>



<a name="224340051"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224340051" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224340051">(Jan 28 2021 at 15:16)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566173592">PR Review Comment</a>:</p>
<blockquote>
<p>I was a tiny bit worried that a long-lived store might overflow the <code>i64</code> counter but that may not be too realistic. Do you think that'd be rare enough that we should just switch this to an add instead of a set?</p>
</blockquote>



<a name="224340127"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224340127" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224340127">(Jan 28 2021 at 15:17)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578438690">PR Review</a>.</p>



<a name="224340129"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224340129" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224340129">(Jan 28 2021 at 15:17)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566174086">PR Review Comment</a>:</p>
<blockquote>
<p>Ah indeed, good point!</p>
</blockquote>



<a name="224340815"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224340815" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224340815">(Jan 28 2021 at 15:22)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224374288"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224374288" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224374288">(Jan 28 2021 at 18:52)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224375794"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224375794" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224375794">(Jan 28 2021 at 19:01)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578649697">PR Review</a>.</p>



<a name="224375795"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224375795" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224375795">(Jan 28 2021 at 19:01)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566336666">PR Review Comment</a>:</p>
<blockquote>
<p>IMHO it's nicer to not have the "fuel-used value that we return is only since the last set" property -- it has the potential to become a subtle stats bug later.</p>
<p>Doing some quick math, a 2^63 max count, at 1B Wasm ops per second, gives us 2^33 or 8B seconds of runtime before overflow, which is ~250 years. Sometime before the year 2270 we can come back and upgrade to an <code>i128</code> :-)</p>
</blockquote>



<a name="224376057"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224376057" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224376057">(Jan 28 2021 at 19:03)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578651161">PR Review</a>.</p>



<a name="224376058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224376058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224376058">(Jan 28 2021 at 19:03)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566337752">PR Review Comment</a>:</p>
<blockquote>
<p>Makes sense! Happy to see this go in as-is, then.</p>
</blockquote>



<a name="224396994"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224396994" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224396994">(Jan 28 2021 at 21:46)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224397011"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224397011" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224397011">(Jan 28 2021 at 21:46)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578767746">PR Review</a>.</p>



<a name="224397012"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224397012" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224397012">(Jan 28 2021 at 21:46)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#discussion_r566428622">PR Review Comment</a>:</p>
<blockquote>
<p>Heh good point!</p>
</blockquote>



<a name="224397912"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224397912" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224397912">(Jan 28 2021 at 21:55)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2611#pullrequestreview-578773701">PR Review</a>.</p>



<a name="224400677"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224400677" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224400677">(Jan 28 2021 at 22:10)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a> from <code>fuel</code> to <code>main</code>:</p>
<blockquote>
<p>This PR lifts a feature from Lucet to wasmtime where generated code can count instructions or account for "fuel" during execution. The purpose of this feature is similar to the interrupt support via <code>InterruptHandle</code>, but it mainly allows deterministically interrupting a wasm module instead of relying on a timer. Additionally a future goal of this PR is to extend the <code>async</code> support of wasmtime to leverage fuel to periodically "interrupt" executing wasm code to yield back to the host. This would enable wasmtime futures to never take "too long" in <code>Future::poll</code> since if they would otherwise take awhile they'd yield back to the host and allow preemption and/or other things like future timeouts.</p>
<p>Thee implementation here is nearly copied verbatim from Lucet itself, with tweaks as appropriate for the different vmctx representation in Wasmtime. The main difference is that Wasmtime's fuel counter is two levels of indirection away from the vmctx rather than one in Lucet. To help with this a new <code>Variable</code> stores the <code>VMInterrupts</code> pointer value to avoid reloading the same value each time from the vmctx.</p>
<p>Support for this feature is exposed through a few new APIs:</p>
<ul>
<li><code>Config::consume_fuel</code> - enables codegen options for wasm to consume fuel, and behaves similar to <code>interruptable</code>.</li>
<li><code>Store::set_fuel_remaining</code> - this is how fuel is injected into a <code>Store</code> for execution of wasm. Note that stores always start with 0 fuel so this is required to be called.</li>
<li><code>Store::fuel_consumed</code> - this can be used to check how much fuel has been consumed so far.</li>
</ul>
<p>The current behavior, which cannot be changed, is that when fuel runs out a wasm trap is generated. I hope to make this configurable in the future so that for async stores when fuel runs out it's automatically re-injected with fuel but only after a yield back to the host happens.</p>
<p>I've done a bit of benchmarking with this using criterion and the benchmarks here -- <a href="https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next">https://github.com/bytecodealliance/sightglass/tree/main/benchmarks-next</a>. The benchmarks are relatively limited at this time but were able to produce some useful data in the meantime. This shows to be a 35-45% slowdown on my personal laptop for the runtime execution of the benchmarked porttion of the code for blake3-scalar and shootout-ackermann. At least for ackermann this is somewhat expected because the loops/function calls are all tiny, so the overhead is quite noticeable. For blake3-scalar I assume it's similar but haven't dug in yet. Note that these numbers were with the new backend since the old x86 backend seems significantly worse than the x64 one.</p>
<p>I do think there might be some relatively low-hanging fruit with respect to performance, but further tweaks would require changes to cranelift itself to optimize instruction selection. For example one optimization might be to not have a <code>fuel_var</code> and instead periodically do <code>addq $fuel_consumed, offset(%vminterrupts_ptr)</code> which avoids consuming extra registers. Similarly <code>cmpq $0, offset(%vminterrupts_ptr)</code> could be generated as well. I couldn't get the x64 backend to emit those forms of instructions at this time though. I'm also not 100% certain that it'll be faster.</p>
<p>Note that for now this doesn't depend on the <code>async</code> PR, but I plan on having a future PR after these two land which implements the periodically-yield option.</p>
</blockquote>



<a name="224481262"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232611%20Implement%20limiting%20WebAssembly%20execut.../near/224481262" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232611.20Implement.20limiting.20WebAssembly.20execut.2E.2E.2E.html#224481262">(Jan 29 2021 at 14:57)</a>:</h4>
<p>alexcrichton merged <a href="https://github.com/bytecodealliance/wasmtime/pull/2611">PR #2611</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>