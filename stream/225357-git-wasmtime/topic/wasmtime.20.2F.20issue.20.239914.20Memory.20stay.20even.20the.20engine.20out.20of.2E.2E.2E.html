<html>
<head><meta charset="utf-8"><title>wasmtime / issue #9914 Memory stay even the engine out of... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html">wasmtime / issue #9914 Memory stay even the engine out of...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="491227647"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/491227647" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#491227647">(Dec 30 2024 at 02:34)</a>:</h4>
<p>giteewif opened <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out.</p>
</blockquote>



<a name="491227805"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/491227805" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#491227805">(Dec 30 2024 at 02:36)</a>:</h4>
<p>giteewif edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out. And i also test on engine. Test is like the figure below.<br>
![image](<a href="https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d">https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d</a>)</p>
</blockquote>



<a name="492127661"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492127661" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492127661">(Jan 06 2025 at 15:36)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2573362785">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>Once the <code>Engine</code>, <code>Module</code>, and <code>Store</code> have all been deallocated then the memory is released back to the OS. Could you detail a bit more what statistic syolu're measuring in <code>get_memory_use</code> and <code>get_detailed_memory_info</code> and what they are printing out in your snippet above?</p>
</blockquote>



<a name="492229992"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492229992" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492229992">(Jan 07 2025 at 02:41)</a>:</h4>
<p>giteewif <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">call_engine</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">wasm_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">work_path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_wasm_bytes</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">linker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_engine_linker</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// {</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wasm_bytes</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>


<span class="w">    </span><span class="c1">// get_detailed_memory_info(std::process::id().to_string().as_str()).unwrap();</span>
<span class="w">    </span><span class="c1">// let module3 = load_module(&amp;engine, &amp;wasm_bytes).unwrap();</span>

<span class="w">    </span><span class="c1">// call_fork()?;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_func_call_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linker</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">work_path</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">call_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">"_start"</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// get_memory_use(std::process::id().to_string().as_str()).unwrap();</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">call_engine</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"after"</span><span class="p">);</span>
<span class="w">    </span><span class="n">get_memory_use</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>output<br>
![image](<a href="https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>
</blockquote>



<a name="492230191"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492230191" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492230191">(Jan 07 2025 at 02:43)</a>:</h4>
<p>giteewif edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">call_engine</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">wasm_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">work_path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_wasm_bytes</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">linker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_engine_linker</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// {</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wasm_bytes</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>


<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_func_call_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linker</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">work_path</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">call_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">"_start"</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">call_engine</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"after"</span><span class="p">);</span>
<span class="w">    </span><span class="n">get_memory_use</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>output<br>
![image](<a href="https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>
</blockquote>



<a name="492230218"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492230218" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492230218">(Jan 07 2025 at 02:43)</a>:</h4>
<p>giteewif edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">call_engine</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">wasm_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">work_path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_wasm_bytes</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">linker</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_engine_linker</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>


<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_module</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wasm_bytes</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>


<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_func_call_env</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linker</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">work_path</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">call_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="p">,</span><span class="w"> </span><span class="s">"_start"</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">call_engine</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"after"</span><span class="p">);</span>
<span class="w">    </span><span class="n">get_memory_use</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">get_detailed_memory_info</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">process</span><span class="p">::</span><span class="n">id</span><span class="p">().</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>output<br>
![image](<a href="https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>
</blockquote>



<a name="492353003"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492353003" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492353003">(Jan 07 2025 at 17:20)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2575842176">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I'm not personally super familar with these statistics from Linux, so I don't know exactly what the problem is myself. That being said you might be seeing some side effects of using Tokio as a runtime through <code>wasmtime-wasi</code> which persists data structures and such.</p>
<p>Regardless though I'm not aware of how <code>Engine</code>, <code>Store</code>, <code>Module</code>, etc, could leak something at this time. There's always the possibility of a bug, however.</p>
<p>Can you clarify which of these statistics you're looking at in particular? For example did you expect "Total RSS" to go down to what it was before?</p>
</blockquote>



<a name="492424942"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492424942" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492424942">(Jan 08 2025 at 02:46)</a>:</h4>
<p>giteewif <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2576596574">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I think it is not the problems of the tokio, wasmtime-wasi is created when WasiCtxBuilder call build. </p>
<p>At the begining, the wasmtime only take 4 MB rss,  it increases at 20 MB after loading the Module.In the load_modules func , i just call the func Module::new().</p>
<p>In my aspect, RSS represent the real physical memory the process takes. It seems that Module::new() takes more memory. I think it results from the compilation of a Module. In my expectation it should release the memory, when the module out of time, or engine out of lifetime which means "Total RSS" should go down to 4-10 MB. However, the total rss also in 20MB.</p>
<p>It may results from cranelift compiler? I'm not sure. </p>
<p>Here i give the more concise info<br>
![image](<a href="https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221">https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221</a>)</p>
</blockquote>



<a name="492424972"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492424972" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492424972">(Jan 08 2025 at 02:47)</a>:</h4>
<p>giteewif edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2576596574">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I think it is not the problems of the tokio, wasmtime-wasi is created when WasiCtxBuilder call build. </p>
<p>At the begining, the wasmtime only take 2 MB rss,  it increases at 22 MB after loading the Module.In the load_modules func , i just call the func Module::new().</p>
<p>In my aspect, RSS represent the real physical memory the process takes. It seems that Module::new() takes more memory. I think it results from the compilation of a Module. In my expectation it should release the memory, when the module out of time, or engine out of lifetime which means "Total RSS" should go down to 3-10 MB. However, the total rss also in 20MB.</p>
<p>It may results from cranelift compiler? I'm not sure. </p>
<p>Here i give the more concise info<br>
![image](<a href="https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221">https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221</a>)</p>
</blockquote>



<a name="492531357"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492531357" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492531357">(Jan 08 2025 at 15:44)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2577997854">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>
</blockquote>



<a name="492533046"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492533046" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492533046">(Jan 08 2025 at 15:53)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2578019890">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>
<p>(For what it's worth, this is the standard in C/C++ programs too: one tests for leaks with Valgrind, not by looking at RSS.)</p>
</blockquote>



<a name="492533076"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492533076" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492533076">(Jan 08 2025 at 15:53)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2578019890">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>
<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>
</blockquote>



<a name="492616162"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492616162" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492616162">(Jan 09 2025 at 02:08)</a>:</h4>
<p>giteewif <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579028538">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<blockquote>
<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>
</blockquote>
<p>I have gave it a try. It showed that rss measured is improved. It is associated with the rayon thread pool in some parts.<br>
![image](<a href="https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37">https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37</a>)</p>
<blockquote>
<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>
<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>
</blockquote>
<p>I got it, i would like to test based on the valgrind.</p>
</blockquote>



<a name="492616381"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492616381" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492616381">(Jan 09 2025 at 02:11)</a>:</h4>
<p>giteewif edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579028538">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<blockquote>
<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>
</blockquote>
<p>I have gave it a try. It showed that rss measured is improved. It is associated with the rayon thread pool in some parts.<br>
![image](<a href="https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37">https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37</a>)</p>
<blockquote>
<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>
<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>
</blockquote>
<p>I got it, i would like to test based on the valgrind. And i think the system allocator is the probable reason, cause i see the similar situation in other wasm runtime.</p>
</blockquote>



<a name="492630275"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492630275" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492630275">(Jan 09 2025 at 04:38)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out. And i also test on engine. Test is like the figure below.<br>
![image](<a href="https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d">https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d</a>)</p>
</blockquote>



<a name="492630277"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239914%20Memory%20stay%20even%20the%20engine%20out%20of.../near/492630277" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239914.20Memory.20stay.20even.20the.20engine.20out.20of.2E.2E.2E.html#492630277">(Jan 09 2025 at 04:38)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579166180">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9914">issue #9914</a>:</p>
<blockquote>
<p>Ah ok, nice! Chris also brings up excellent points as well which I would definitely echo too (and completely forgot about at the start of this thread...)</p>
<p>In any case I don't think we have any leaks here in Wasmtime, so I'm going to close this. If you see suspicious behavior though in Valgrind let us know!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>