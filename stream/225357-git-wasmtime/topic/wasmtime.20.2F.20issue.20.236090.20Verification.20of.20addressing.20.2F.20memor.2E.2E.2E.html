<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6090 Verification of addressing / memor... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236090.20Verification.20of.20addressing.20.2F.20memor.2E.2E.2E.html">wasmtime / issue #6090 Verification of addressing / memor...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="343813770"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236090%20Verification%20of%20addressing%20/%20memor.../near/343813770" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236090.20Verification.20of.20addressing.20.2F.20memor.2E.2E.2E.html#343813770">(Mar 23 2023 at 01:40)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/6090">issue #6090</a>:</p>
<blockquote>
<p>I've been working on VeriWasm in Wasmtime the last few weeks, and decided to dump a summary of my investigation so far and ideas for the right approach to take. (I'm doing this partly because I've been asked to context switch back to something else, now that it's clear that VeriWasm proper cannot work and we need a new tool; I estimate it would take ~1 month to build what I describe in the last section below.)</p>
<p>(This may be better as an RFC, and I can clean it up, expand it, and post it as one once I have time to properly do so!)</p>
<h2>Summary</h2>
<p>We should include built-in support in Wasmtime to verify that compiled code from Wasm modules is accessing only the memory that it is supposed to access. Such verification would take the form of ahead-of-time static analysis on the code, so that it would not require dynamic checks; and it should trust as little as possible in the existing compiler stack, to increase the confidence we have in its conclusions.</p>
<p>The ideal would be to verify machine code bytes with no other input, but in practice, Wasmtime will have to tell the tool what to assume about details such as runtime data structures; and certain kinds of analysis, like full recovery of a CFG in the presence of indirect branches, may require whole-program analysis that is too expensive to be practical.</p>
<p>This issue proposes a scheme that embeds a notion of "memory capabilities" in CLIF, along with (static) assertions on values (mostly with respect to ranges), and carries these through to the VCode level in Cranelift. The Wasm lowering would be modified to annotate every load/store with an associated memory capability that permits it; and we can then check the uses of these capabilities at the other end of the pipeline, after instruction selection is done. This is inspired by, but in some sense the dual to, the approach taken by VeriWasm.</p>
<h2>History: VeriWasm</h2>
<p>In Johnson et al.[^1], the VeriWasm tool is described, with an approach that performs a static analysis of disassembled machine code to prove that all heap accesses in AOT-compiled Wasm code are properly to the Wasm heap, and cannot escape the sandbox. (The tool also checks other properties, such as control-flow integrity, but that is outside the scope of this issue.)</p>
<p>[^1]: Evan Johnson et al. "Довер ́яй, но провер ́яй: SFI Safety for native compiled Wasm." In NDSS 2021.  &lt;<a href="https://cseweb.ucsd.edu/~lerner/papers/wasm-sfi-ndss2021.pdf">https://cseweb.ucsd.edu/~lerner/papers/wasm-sfi-ndss2021.pdf</a>&gt;</p>
<p>VeriWasm was designed to verify code produced by <a href="https://github.com/bytecodealliance/lucet">Lucet</a>, another AOT Wasm compiler that has since been subsumed by Wasmtime and EOL'd.</p>
<p>VeriWasm works by <em>lifting</em> machine code to a simple IR that describes the semantics of the code in a partial way -- recovering just enough of the dataflow to be able to see all address computations -- and then performing iterative dataflow analysis over that IR using an analysis lattice.</p>
<p>The analysis values computed to describe program values include:</p>
<ul>
<li><code>HeapBase</code>: this value is the heap base;</li>
<li><code>Bounded4GB</code>: this value is less than 2^32;</li>
<li>and some others (e.g. for RIP-relative constant loads) that we won't discuss here.</li>
</ul>
<p>The basic idea of the analysis is to mark a result of any 32-bit instruction as <code>Bounded4GB</code> in the abstract interpretation, and then allow <em>only</em> memory accesses of the form <code>[HeapBase + Bounded4GB]</code>.</p>
<h2>Issues with porting VeriWasm to Wasmtime</h2>
<p>The obvious next step is to port VeriWasm to work with Wasmtime instead of Lucet. To understand why this is difficult, it may be useful to know how Lucet's generated code differed from Wasmtime's. Both use Cranelift, but there are two key deltas:</p>
<ul>
<li>
<p>Lucet used simpler data structures: its implicit first argument to every Wasm function was a pointer to the start of the (one single) Wasm memory, and this memory was always statically-bounded; there was no separate <code>vmctx</code>, and no multi-memory or multi-table support. Furthermore Lucet was normally used (and VeriWasm only supported) static bounds-checking, i.e., use of guard regions up to 4GiB heap size.</p>
</li>
<li>
<p>The version of Cranelift used at the time that Lucet and VeriWasm were developed was much simpler than what we have today. In particular, the address-mode support was fairly primitive and predictable: heap accesses were always of the form <code>[rBase + rOffset]</code>, where <code>rBase</code> was the heap base and <code>rOffset</code> was the offset (into the Wasm heap), computed separately. In contrast, Wasmtime uses modern Cranelift which can fold more work into addressing modes and perform more clever instruction selection. It also includes Spectre-guard logic, which is difficult to analyze from first principles without pattern-matching the whole thing.</p>
</li>
</ul>
<p>Taken together, these two facts mean that we need a much more general analysis. In principle, we need to be able to:</p>
<ul>
<li>Compute a summary of an accessed memory address that symbolically encodes its base (possibly from a field in a vmctx structure), its offset, and the range of that offset (possibly from another field in a vmctx structure);</li>
<li>Reason about value ranges, additions, and scaling (left-shift/multiply) operations, all on the field of integers modulo 2^32 or 2^64 (i.e., accounting for wraparound);</li>
<li>Solve inequalities, to show that values are within dynamically-defined bounds.</li>
</ul>
<h3>Example</h3>
<p>Here is the simplest possible dynamic bounds-check example, compiled for x86-64 by Wasmtime, with annotations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">_wasm_function_0</span><span class="o">&gt;</span>:
       <span class="mi">0</span>:   <span class="mi">55</span><span class="w">                      </span><span class="n">push</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="w">       </span><span class="mi">1</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">e5</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
<span class="w">       </span><span class="mi">4</span>:   <span class="mi">44</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="n">c2</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">r8d</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">save</span><span class="w"> </span><span class="n">Wasm</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span>
<span class="w">       </span><span class="mi">7</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">c0</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">r8</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span>
<span class="w">       </span><span class="n">a</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">83</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="mi">04</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="cp">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="n">end</span>: <span class="nc">address</span><span class="p">,</span><span class="w"> </span><span class="n">plus</span><span class="w"> </span><span class="mi">4</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="n">size</span>
<span class="w">       </span><span class="n">e</span>:   <span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">83</span><span class="w"> </span><span class="mi">02</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">       </span><span class="n">jae</span><span class="w">    </span><span class="mi">16</span><span class="w"> </span><span class="o">&lt;</span><span class="n">_wasm_function_0</span><span class="o">+</span><span class="mh">0x16</span><span class="o">&gt;</span><span class="w">   </span><span class="p">;;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">overflowed</span><span class="p">,</span><span class="w"> </span><span class="n">trap</span>
<span class="w">      </span><span class="mi">14</span>:   <span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">0</span><span class="n">b</span><span class="w">                   </span><span class="n">ud2</span>
<span class="w">      </span><span class="mi">16</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">57</span><span class="w"> </span><span class="mi">58</span><span class="w">             </span><span class="n">mov</span><span class="w">    </span><span class="mh">0x58</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span><span class="o">%</span><span class="n">rdx</span><span class="w">              </span><span class="p">;;</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="n">memory</span><span class="o">-</span><span class="mi">0</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">vmctx</span><span class="o">+</span><span class="mh">0x58</span>
<span class="w">      </span><span class="mi">1</span><span class="n">a</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="n">c9</span><span class="w">                </span><span class="n">xor</span><span class="w">    </span><span class="o">%</span><span class="n">rcx</span><span class="p">,</span><span class="o">%</span><span class="n">rcx</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="n">rcx</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Spectre</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="n">below</span>
<span class="w">      </span><span class="mi">1</span><span class="n">d</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">03</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="mi">50</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="mh">0x50</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span><span class="o">%</span><span class="n">r8</span><span class="w">               </span><span class="p">;;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">memory</span><span class="o">-</span><span class="mi">0</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="p">(</span><span class="n">loaded</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">vmctx</span><span class="o">+</span><span class="mh">0x50</span><span class="p">)</span>
<span class="w">      </span><span class="mi">21</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">39</span><span class="w"> </span><span class="n">d0</span><span class="w">                </span><span class="n">cmp</span><span class="w">    </span><span class="o">%</span><span class="n">rdx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="n">end</span><span class="o">-</span><span class="n">offset</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">length</span>
<span class="w">      </span><span class="mi">24</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="n">c1</span><span class="w">             </span><span class="n">cmova</span><span class="w">  </span><span class="o">%</span><span class="n">rcx</span><span class="p">,</span><span class="o">%</span><span class="n">r8</span><span class="w">                     </span><span class="p">;;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">bounds</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">zeros</span><span class="w"> </span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">rcx</span><span class="p">)</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">pointer</span><span class="p">;</span><span class="w"> </span><span class="n">Spectre</span><span class="w"> </span><span class="n">guard</span>
<span class="w">      </span><span class="mi">28</span>:   <span class="mi">41</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">00</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="p">(</span><span class="o">%</span><span class="n">r8</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span><span class="w">                   </span><span class="p">;;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">load</span>
<span class="w">      </span><span class="mi">2</span><span class="n">b</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">ec</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="o">%</span><span class="n">rsp</span>
<span class="w">      </span><span class="mi">2</span><span class="n">e</span>:   <span class="mi">5</span><span class="n">d</span><span class="w">                      </span><span class="n">pop</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="w">      </span><span class="mi">2</span><span class="n">f</span>:   <span class="nc">c3</span><span class="w">                      </span><span class="n">ret</span>
</code></pre></div>
<p>This is compiled from</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">module</span>
<span class="w">  </span><span class="p">(</span><span class="n">memory</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">param</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span>
<span class="w">        </span><span class="n">local</span><span class="p">.</span><span class="n">get</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">i32</span><span class="p">.</span><span class="n">load</span><span class="p">))</span>
</code></pre></div>
<p>with <code>wasmtime compile --dynamic-memory-guard-size 0 --static-memory-guard-size 0 --static-memory-maximum-size 0 test.wat</code>.</p>
<p>There are several things going on here that we need to be able to analyze:</p>
<ul>
<li>We need to be able to represent each value symbolically:<ul>
<li>Wasm address, which we know is within 32-bit range (<code>Bounded4GB</code> from VeriWasm's Lucet analysis);</li>
<li>Wasm address plus 4, which we'll connect with the size of the load later;</li>
<li>somehow preserve that property by understanding the jae/ud2 trap sequence and flags output of <code>add</code>;</li>
<li>know that <code>rcx</code> being zero is significant later (so, track either a <code>Zero</code> state or all known constant values);</li>
<li>represent "memory base plus offset known to be up to 4GB plus 4";</li>
<li>understand the comparison between the length and <code>rax</code> (which up to this point is just an arbitrary 32-bit value in the program), and join this with the <code>cmova</code> below ti understand the "clamp to zero if out of bounds" idiom; then represent "pointer to this offset in heap, unless this offset plus 4 is above this other value"... symbolically</li>
<li>use all of the above facts to validate that the load of <code>r8</code> at offset 0x28 is legal.</li>
</ul>
</li>
</ul>
<p>The basic issue here is that we need to (i) build up a massive body of facts about all register values in the program, and (ii) only later pattern-match uses of certain combinations of them to generate legal pointers into dynamically-bounded memory regions. So we need to generally symoblically summarize expressions, and we need some algebraic language of additions, scaling operations, and bounding operations that can be simplified, normalized, and used to do this recognition.</p>
<h3>Dead-end Prototype: Symbolic Expressions</h3>
<p>In <a href="https://github.com/cfallin/veriwasm/tree/wasmtime-integration">this branch</a> of VeriWasm (which goes with <a href="https://github.com/cfallin/wasmtime/tree/veriwasm">this branch</a> of Wasmtime and <a href="https://github.com/cfallin/yaxpeax-core/tree/vw-tweaks-ii">this branch</a> of <code>yaxpeax-core</code>), I prototyped a system that basically attempted the above. It defined an <a href="https://github.com/cfallin/veriwasm/blob/wasmtime-integration/src/lattices/heaplattice.rs">analysis lattice</a> that could represent additions, scaling (multiplication by a constant), <code>umin</code> (unsigned min, a bounding operator, the basic nonlinear element), loads, known constant values, and a few miscellaneous atoms like <code>vmctx</code>, "some pointer into <code>.text</code>", and <code>Unknown</code>.</p>
<p>The analysis used a set of <a href="https://github.com/cfallin/veriwasm/blob/8736c411d11f7aabc51fac69620cf00be84ace5f/src/lattices/heaplattice.rs#L86">rewrite rules</a> to try to simplify expressions: e.g., an arbitrary 32-bit instruction might produce <code>UMin(Unknown, Const(0xffffffff))</code>, then adding <code>4</code> might produce <code>Add(Const(4), UMin(Unknown, Const(0xffffffff)))</code> which simplifies to <code>UMin(Unknown, Const(0x100000003))</code> because <code>Add</code> distributes over <code>UMin</code>. (Wrapping is handl<br>
[message truncated]</p>
</blockquote>



<a name="397313015"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236090%20Verification%20of%20addressing%20/%20memor.../near/397313015" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236090.20Verification.20of.20addressing.20.2F.20memor.2E.2E.2E.html#397313015">(Oct 18 2023 at 13:27)</a>:</h4>
<p>martin-fink <a href="https://github.com/bytecodealliance/wasmtime/issues/6090#issuecomment-1768460391">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6090">issue #6090</a>:</p>
<blockquote>
<p>Hi!<br>
Seeing that you have started to work on this, I just wanted to chime in that I've been working on a 'memory access verifier' too! :)</p>
<p>My approach follows what veriwasm and your prototype do: I build 'symbolic values' that model address computations/bounds checks and solve inequalities on them. As you have mentioned above, that is quite complex and not super scalable.<br>
The code is quite hacky and there's much to be improved in terms of performance and elegance, but it works for static and dynamic heaps (with or without spectre guards) and detects if e.g. <a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a> is reintroduced into the code base when fuzzing with the checker enabled.<br>
You can find it at <a href="https://github.com/martin-fink/wasmtime">https://github.com/martin-fink/wasmtime</a>.</p>
<p>I'm very excited to see how your PCC approach will differ from what I've built. :)<br>
</p>
</blockquote>



<a name="397346097"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236090%20Verification%20of%20addressing%20/%20memor.../near/397346097" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236090.20Verification.20of.20addressing.20.2F.20memor.2E.2E.2E.html#397346097">(Oct 18 2023 at 16:14)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6090#issuecomment-1768876605">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6090">issue #6090</a>:</p>
<blockquote>
<p>Woah, that's really neat -- I wish I had known about this earlier!</p>
<p>Looking it over, I definitely agree that <code>SymbolicValue</code> is close to what I had tried with my first "veriwasm 2.0" branch, an AST of of operator nodes. I'm hopeful that the current PCC approach will be more scalable since the assertions (facts) aren't recursive ASTs but shallow facts instead, and the producer is expected to leave a flattened sequence of assertions along each intermediate value in the CLIF. I've sketched out the dynamic-memories approach I want to take and it should keep to a fairly narrow set of assertion types I think, without a general inequality sublanguage or solver, tailored to the code that cranelift-wasm actually generates.</p>
<p>It's really cool to see a working design point that can validate dynamic memories as well; thanks for this and I'll study it in more detail!</p>
</blockquote>



<a name="400258890"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236090%20Verification%20of%20addressing%20/%20memor.../near/400258890" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236090.20Verification.20of.20addressing.20.2F.20memor.2E.2E.2E.html#400258890">(Nov 04 2023 at 05:52)</a>:</h4>
<p>cfallin closed <a href="https://github.com/bytecodealliance/wasmtime/issues/6090">issue #6090</a>:</p>
<blockquote>
<p>I've been working on VeriWasm in Wasmtime the last few weeks, and decided to dump a summary of my investigation so far and ideas for the right approach to take. (I'm doing this partly because I've been asked to context switch back to something else, now that it's clear that VeriWasm proper cannot work and we need a new tool; I estimate it would take ~1 month to build what I describe in the last section below.)</p>
<p>(This may be better as an RFC, and I can clean it up, expand it, and post it as one once I have time to properly do so!)</p>
<h2>Summary</h2>
<p>We should include built-in support in Wasmtime to verify that compiled code from Wasm modules is accessing only the memory that it is supposed to access. Such verification would take the form of ahead-of-time static analysis on the code, so that it would not require dynamic checks; and it should trust as little as possible in the existing compiler stack, to increase the confidence we have in its conclusions.</p>
<p>The ideal would be to verify machine code bytes with no other input, but in practice, Wasmtime will have to tell the tool what to assume about details such as runtime data structures; and certain kinds of analysis, like full recovery of a CFG in the presence of indirect branches, may require whole-program analysis that is too expensive to be practical.</p>
<p>This issue proposes a scheme that embeds a notion of "memory capabilities" in CLIF, along with (static) assertions on values (mostly with respect to ranges), and carries these through to the VCode level in Cranelift. The Wasm lowering would be modified to annotate every load/store with an associated memory capability that permits it; and we can then check the uses of these capabilities at the other end of the pipeline, after instruction selection is done. This is inspired by, but in some sense the dual to, the approach taken by VeriWasm.</p>
<h2>History: VeriWasm</h2>
<p>In Johnson et al.[^1], the VeriWasm tool is described, with an approach that performs a static analysis of disassembled machine code to prove that all heap accesses in AOT-compiled Wasm code are properly to the Wasm heap, and cannot escape the sandbox. (The tool also checks other properties, such as control-flow integrity, but that is outside the scope of this issue.)</p>
<p>[^1]: Evan Johnson et al. "Довер ́яй, но провер ́яй: SFI Safety for native compiled Wasm." In NDSS 2021.  &lt;<a href="https://cseweb.ucsd.edu/~lerner/papers/wasm-sfi-ndss2021.pdf">https://cseweb.ucsd.edu/~lerner/papers/wasm-sfi-ndss2021.pdf</a>&gt;</p>
<p>VeriWasm was designed to verify code produced by <a href="https://github.com/bytecodealliance/lucet">Lucet</a>, another AOT Wasm compiler that has since been subsumed by Wasmtime and EOL'd.</p>
<p>VeriWasm works by <em>lifting</em> machine code to a simple IR that describes the semantics of the code in a partial way -- recovering just enough of the dataflow to be able to see all address computations -- and then performing iterative dataflow analysis over that IR using an analysis lattice.</p>
<p>The analysis values computed to describe program values include:</p>
<ul>
<li><code>HeapBase</code>: this value is the heap base;</li>
<li><code>Bounded4GB</code>: this value is less than 2^32;</li>
<li>and some others (e.g. for RIP-relative constant loads) that we won't discuss here.</li>
</ul>
<p>The basic idea of the analysis is to mark a result of any 32-bit instruction as <code>Bounded4GB</code> in the abstract interpretation, and then allow <em>only</em> memory accesses of the form <code>[HeapBase + Bounded4GB]</code>.</p>
<h2>Issues with porting VeriWasm to Wasmtime</h2>
<p>The obvious next step is to port VeriWasm to work with Wasmtime instead of Lucet. To understand why this is difficult, it may be useful to know how Lucet's generated code differed from Wasmtime's. Both use Cranelift, but there are two key deltas:</p>
<ul>
<li>
<p>Lucet used simpler data structures: its implicit first argument to every Wasm function was a pointer to the start of the (one single) Wasm memory, and this memory was always statically-bounded; there was no separate <code>vmctx</code>, and no multi-memory or multi-table support. Furthermore Lucet was normally used (and VeriWasm only supported) static bounds-checking, i.e., use of guard regions up to 4GiB heap size.</p>
</li>
<li>
<p>The version of Cranelift used at the time that Lucet and VeriWasm were developed was much simpler than what we have today. In particular, the address-mode support was fairly primitive and predictable: heap accesses were always of the form <code>[rBase + rOffset]</code>, where <code>rBase</code> was the heap base and <code>rOffset</code> was the offset (into the Wasm heap), computed separately. In contrast, Wasmtime uses modern Cranelift which can fold more work into addressing modes and perform more clever instruction selection. It also includes Spectre-guard logic, which is difficult to analyze from first principles without pattern-matching the whole thing.</p>
</li>
</ul>
<p>Taken together, these two facts mean that we need a much more general analysis. In principle, we need to be able to:</p>
<ul>
<li>Compute a summary of an accessed memory address that symbolically encodes its base (possibly from a field in a vmctx structure), its offset, and the range of that offset (possibly from another field in a vmctx structure);</li>
<li>Reason about value ranges, additions, and scaling (left-shift/multiply) operations, all on the field of integers modulo 2^32 or 2^64 (i.e., accounting for wraparound);</li>
<li>Solve inequalities, to show that values are within dynamically-defined bounds.</li>
</ul>
<h3>Example</h3>
<p>Here is the simplest possible dynamic bounds-check example, compiled for x86-64 by Wasmtime, with annotations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">_wasm_function_0</span><span class="o">&gt;</span>:
       <span class="mi">0</span>:   <span class="mi">55</span><span class="w">                      </span><span class="n">push</span><span class="w">   </span><span class="o">%</span><span class="n">rbp</span>
<span class="w">       </span><span class="mi">1</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">e5</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
<span class="w">       </span><span class="mi">4</span>:   <span class="mi">44</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="n">c2</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">r8d</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">save</span><span class="w"> </span><span class="n">Wasm</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">truncate</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span>
<span class="w">       </span><span class="mi">7</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">c0</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">r8</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span>
<span class="w">       </span><span class="n">a</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">83</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="mi">04</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="cp">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="n">end</span>: <span class="nc">address</span><span class="p">,</span><span class="w"> </span><span class="n">plus</span><span class="w"> </span><span class="mi">4</span><span class="o">-</span><span class="n">byte</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="n">size</span>
<span class="w">       </span><span class="n">e</span>:   <span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">83</span><span class="w"> </span><span class="mi">02</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">       </span><span class="n">jae</span><span class="w">    </span><span class="mi">16</span><span class="w"> </span><span class="o">&lt;</span><span class="n">_wasm_function_0</span><span class="o">+</span><span class="mh">0x16</span><span class="o">&gt;</span><span class="w">   </span><span class="p">;;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">overflowed</span><span class="p">,</span><span class="w"> </span><span class="n">trap</span>
<span class="w">      </span><span class="mi">14</span>:   <span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">0</span><span class="n">b</span><span class="w">                   </span><span class="n">ud2</span>
<span class="w">      </span><span class="mi">16</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">57</span><span class="w"> </span><span class="mi">58</span><span class="w">             </span><span class="n">mov</span><span class="w">    </span><span class="mh">0x58</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span><span class="o">%</span><span class="n">rdx</span><span class="w">              </span><span class="p">;;</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="n">memory</span><span class="o">-</span><span class="mi">0</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">vmctx</span><span class="o">+</span><span class="mh">0x58</span>
<span class="w">      </span><span class="mi">1</span><span class="n">a</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="n">c9</span><span class="w">                </span><span class="n">xor</span><span class="w">    </span><span class="o">%</span><span class="n">rcx</span><span class="p">,</span><span class="o">%</span><span class="n">rcx</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="n">rcx</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Spectre</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="n">below</span>
<span class="w">      </span><span class="mi">1</span><span class="n">d</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">03</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="mi">50</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="mh">0x50</span><span class="p">(</span><span class="o">%</span><span class="n">rdi</span><span class="p">),</span><span class="o">%</span><span class="n">r8</span><span class="w">               </span><span class="p">;;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">memory</span><span class="o">-</span><span class="mi">0</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="p">(</span><span class="n">loaded</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">vmctx</span><span class="o">+</span><span class="mh">0x50</span><span class="p">)</span>
<span class="w">      </span><span class="mi">21</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">39</span><span class="w"> </span><span class="n">d0</span><span class="w">                </span><span class="n">cmp</span><span class="w">    </span><span class="o">%</span><span class="n">rdx</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w">                    </span><span class="p">;;</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="n">end</span><span class="o">-</span><span class="n">offset</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">length</span>
<span class="w">      </span><span class="mi">24</span>:   <span class="mi">4</span><span class="n">c</span><span class="w"> </span><span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="n">c1</span><span class="w">             </span><span class="n">cmova</span><span class="w">  </span><span class="o">%</span><span class="n">rcx</span><span class="p">,</span><span class="o">%</span><span class="n">r8</span><span class="w">                     </span><span class="p">;;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">bounds</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="n">zeros</span><span class="w"> </span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">rcx</span><span class="p">)</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">pointer</span><span class="p">;</span><span class="w"> </span><span class="n">Spectre</span><span class="w"> </span><span class="n">guard</span>
<span class="w">      </span><span class="mi">28</span>:   <span class="mi">41</span><span class="w"> </span><span class="mi">8</span><span class="n">b</span><span class="w"> </span><span class="mi">00</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="p">(</span><span class="o">%</span><span class="n">r8</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span><span class="w">                   </span><span class="p">;;</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">load</span>
<span class="w">      </span><span class="mi">2</span><span class="n">b</span>:   <span class="mi">48</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="n">ec</span><span class="w">                </span><span class="n">mov</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span><span class="p">,</span><span class="o">%</span><span class="n">rsp</span>
<span class="w">      </span><span class="mi">2</span><span class="n">e</span>:   <span class="mi">5</span><span class="n">d</span><span class="w">                      </span><span class="n">pop</span><span class="w">    </span><span class="o">%</span><span class="n">rbp</span>
<span class="w">      </span><span class="mi">2</span><span class="n">f</span>:   <span class="nc">c3</span><span class="w">                      </span><span class="n">ret</span>
</code></pre></div>
<p>This is compiled from</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">module</span>
<span class="w">  </span><span class="p">(</span><span class="n">memory</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="n">param</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span>
<span class="w">        </span><span class="n">local</span><span class="p">.</span><span class="n">get</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="kt">i32</span><span class="p">.</span><span class="n">load</span><span class="p">))</span>
</code></pre></div>
<p>with <code>wasmtime compile --dynamic-memory-guard-size 0 --static-memory-guard-size 0 --static-memory-maximum-size 0 test.wat</code>.</p>
<p>There are several things going on here that we need to be able to analyze:</p>
<ul>
<li>We need to be able to represent each value symbolically:<ul>
<li>Wasm address, which we know is within 32-bit range (<code>Bounded4GB</code> from VeriWasm's Lucet analysis);</li>
<li>Wasm address plus 4, which we'll connect with the size of the load later;</li>
<li>somehow preserve that property by understanding the jae/ud2 trap sequence and flags output of <code>add</code>;</li>
<li>know that <code>rcx</code> being zero is significant later (so, track either a <code>Zero</code> state or all known constant values);</li>
<li>represent "memory base plus offset known to be up to 4GB plus 4";</li>
<li>understand the comparison between the length and <code>rax</code> (which up to this point is just an arbitrary 32-bit value in the program), and join this with the <code>cmova</code> below ti understand the "clamp to zero if out of bounds" idiom; then represent "pointer to this offset in heap, unless this offset plus 4 is above this other value"... symbolically</li>
<li>use all of the above facts to validate that the load of <code>r8</code> at offset 0x28 is legal.</li>
</ul>
</li>
</ul>
<p>The basic issue here is that we need to (i) build up a massive body of facts about all register values in the program, and (ii) only later pattern-match uses of certain combinations of them to generate legal pointers into dynamically-bounded memory regions. So we need to generally symoblically summarize expressions, and we need some algebraic language of additions, scaling operations, and bounding operations that can be simplified, normalized, and used to do this recognition.</p>
<h3>Dead-end Prototype: Symbolic Expressions</h3>
<p>In <a href="https://github.com/cfallin/veriwasm/tree/wasmtime-integration">this branch</a> of VeriWasm (which goes with <a href="https://github.com/cfallin/wasmtime/tree/veriwasm">this branch</a> of Wasmtime and <a href="https://github.com/cfallin/yaxpeax-core/tree/vw-tweaks-ii">this branch</a> of <code>yaxpeax-core</code>), I prototyped a system that basically attempted the above. It defined an <a href="https://github.com/cfallin/veriwasm/blob/wasmtime-integration/src/lattices/heaplattice.rs">analysis lattice</a> that could represent additions, scaling (multiplication by a constant), <code>umin</code> (unsigned min, a bounding operator, the basic nonlinear element), loads, known constant values, and a few miscellaneous atoms like <code>vmctx</code>, "some pointer into <code>.text</code>", and <code>Unknown</code>.</p>
<p>The analysis used a set of <a href="https://github.com/cfallin/veriwasm/blob/8736c411d11f7aabc51fac69620cf00be84ace5f/src/lattices/heaplattice.rs#L86">rewrite rules</a> to try to simplify expressions: e.g., an arbitrary 32-bit instruction might produce <code>UMin(Unknown, Const(0xffffffff))</code>, then adding <code>4</code> might produce <code>Add(Const(4), UMin(Unknown, Const(0xffffffff)))</code> which simplifies to <code>UMin(Unknown, Const(0x100000003))</code> because <code>Add</code> distributes over <code>UMin</code>. (Wrapping is handl<br>
[message truncated]</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>