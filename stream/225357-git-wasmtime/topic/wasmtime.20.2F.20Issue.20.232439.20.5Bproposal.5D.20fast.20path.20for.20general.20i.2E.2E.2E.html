<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #2439 [proposal] fast path for general i... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html">wasmtime / Issue #2439 [proposal] fast path for general i...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="217569265"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217569265" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217569265">(Nov 22 2020 at 20:51)</a>:</h4>
<p>MaxGraey opened <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x84/x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register size. Also it doesn't need for ARM.</p>
</blockquote>



<a name="217569326"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217569326" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217569326">(Nov 22 2020 at 20:52)</a>:</h4>
<p>MaxGraey edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x84/x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register size. Also it doesn't need for ARM.</p>
</blockquote>



<a name="217569971"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217569971" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217569971">(Nov 22 2020 at 21:05)</a>:</h4>
<p>MaxGraey edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x84/x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register size. Also it doesn't need for ARM.</p>
</blockquote>



<a name="217569973"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217569973" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217569973">(Nov 22 2020 at 21:05)</a>:</h4>
<p>MaxGraey edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register size. Also it doesn't need for ARM.</p>
</blockquote>



<a name="217574845"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217574845" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217574845">(Nov 22 2020 at 22:58)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731861663">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Hi @MaxGraey, thanks for bringing this up!</p>
<p>From an instruction-selector perspective, this would certainly be possible, though in general I want to be careful about adding complexity without evidence that it will bring benefit in some way. (It's perhaps possible for one case, but if the isel starts growing conditionals for microarchitecture and for optimized cases everywhere, it soon becomes unmaintainable if we don't have a framework for reasoning about machine costs in a more principled way.) Have you seen workloads where division latency in particular became a bottleneck?</p>
</blockquote>



<a name="217575864"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217575864" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217575864">(Nov 22 2020 at 23:22)</a>:</h4>
<p>MaxGraey <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731864704">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<blockquote>
<p>Have you seen workloads where division latency in particular became a bottleneck?</p>
</blockquote>
<p>Div / Rem usually most expensive operations. There are many possibilities to reduce cost of this operations, most often this is done before instruction scheduling. But there is usually very little opportunity to speed up the most general case. In this case, I think this is interesting approach which shouldn't be too complex.</p>
</blockquote>



<a name="217575868"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217575868" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217575868">(Nov 22 2020 at 23:22)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731864704">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<blockquote>
<p>Have you seen workloads where division latency in particular became a bottleneck?</p>
</blockquote>
<p>Div / Rem usually most expensive operations. There are many possibilities to reduce cost of this operations, most often this is done before instruction scheduling. But there is usually very little opportunity to speed up the most general case. In this case, I think this is interesting approach which shouldn't be too complex in term of implementation.</p>
</blockquote>



<a name="217577175"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217577175" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217577175">(Nov 22 2020 at 23:54)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731868843">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Indeed, I agree that division is an expensive instruction! What I'm wondering is whether workloads exist where (i) the presence of divide instructions is a bottleneck, i.e., the latency is not hidden by other operations and is a visible portion of total runtime, and (ii) the workload uses 64-bit divides but values always have zeroed top-32-bits.</p>
<p>That data would show the benefit; the cost, in turn is (i) an additional comparison (logical-or, right-shift, branch-if-zero, so three instructions) in every divide's main code path, (ii) additional code size due to the comparison and the fastpath, (iii) complexity in isel, which imposes maintenance burden and a small compile time increase.</p>
<p>So, basically, I have a better handle on what the cost would be and I'm curious if we have any data points on the potential benefit. I'm hesitant to include something like this, because of the above downsides, but evidence of real upside could convince me :-)</p>
</blockquote>



<a name="217581988"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217581988" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217581988">(Nov 23 2020 at 01:54)</a>:</h4>
<p>MaxGraey <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731890182">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Oh, so you ask about real scenarios which could potentially benefit from this?</p>
<p>I guess all range of modern cryptography which based on modular arithmetic with small primes. For example 64-bit integer modulo intensively used in Montgomery reduction for example in <code>modPow</code> (x1 ^ x2 mod m) part. I guess @jedisct1 could tell much more than me. Another potential user case is multi-precision float points and integers.</p>
</blockquote>



<a name="217582008"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217582008" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217582008">(Nov 23 2020 at 01:54)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731890182">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Oh, so you ask about real scenarios which could potentially benefit from this?</p>
<p>I guess all range of modern cryptography which based on modular arithmetic with small primes. For example 64-bit integer modulo intensively used in Montgomery reduction for example in <code>modPow</code> (x1 ^ x2 mod m) part. I guess @jedisct1 could tell much more than me. Another potential user case is multi-precision float points and integers which also use modular arithmetic</p>
</blockquote>



<a name="217583570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583570">(Nov 23 2020 at 02:33)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731897364">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Fair enough -- I think that we could investigate further. I'm still worried about the impact of the three additional instructions for every divide; so I'd want us to collect data on various numeric benchmarks (compression and media codecs come to mind) to make sure this impact isn't an issue. The benchmarking situation is looking to improve soon (<a href="https://github.com/bytecodealliance/rfcs/issues/4">bytecodealliance/rfcs#4</a>) so we should be able to study this fairly easily!</p>
<p>@MaxGraey would you be willing to prototype it?</p>
</blockquote>



<a name="217583844"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583844" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583844">(Nov 23 2020 at 02:40)</a>:</h4>
<p>MaxGraey <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this was implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys at LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transsformation</a>.</p>
</blockquote>



<a name="217583850"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583850" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583850">(Nov 23 2020 at 02:40)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys from LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transsformation</a>.</p>
</blockquote>



<a name="217583947"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583947" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583947">(Nov 23 2020 at 02:43)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys from LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transsformation</a>.</p>
<blockquote>
<p>The benchmarking situation is looking to improve soon</p>
</blockquote>
<p>Nice!</p>
<blockquote>
<p>@MaxGraey would you be willing to prototype it?</p>
</blockquote>
<p>Thanks for the suggestions, but I think this is a bit tricky case for me)</p>
</blockquote>



<a name="217583990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583990">(Nov 23 2020 at 02:44)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys from LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transsformation</a>.</p>
<blockquote>
<p>The benchmarking situation is looking to improve soon</p>
</blockquote>
<p>Nice!</p>
<blockquote>
<p>@MaxGraey would you be willing to prototype it?</p>
</blockquote>
<p>Thanks for the suggestions, but I think this is a bit tricky and low-level case for me) </p>
</blockquote>



<a name="217583997"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217583997" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217583997">(Nov 23 2020 at 02:44)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys from LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transformation</a>.</p>
<blockquote>
<p>The benchmarking situation is looking to improve soon</p>
</blockquote>
<p>Nice!</p>
<blockquote>
<p>@MaxGraey would you be willing to prototype it?</p>
</blockquote>
<p>Thanks for the suggestions, but I think this is a bit tricky and low-level case for me) </p>
</blockquote>



<a name="217584303"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217584303" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217584303">(Nov 23 2020 at 02:52)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731901163">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>Thanks for the link to the LLVM transform!</p>
<p>Re: overhead, one option would be to add a flag to our CPU-specific backend flags to enable this; then the embedder could enable on platforms where this helps.</p>
<p>I'll see if I can get to this at some point (lots of things on my plate at the moment) but anyone feel free to try this in the meantime!</p>
</blockquote>



<a name="217593522"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217593522" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217593522">(Nov 23 2020 at 06:44)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731960934">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>As an example where division jad disproportionate effects: <a href="https://github.com/gimli-rs/gimli/pull/476">https://github.com/gimli-rs/gimli/pull/476</a> made line debuginfo generation twice as fast by avoiding a division in the common case.</p>
</blockquote>



<a name="217593589"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217593589" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217593589">(Nov 23 2020 at 06:45)</a>:</h4>
<p>bjorn3 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731960934">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>As an example where division had disproportionate effects: <a href="https://github.com/gimli-rs/gimli/pull/476">https://github.com/gimli-rs/gimli/pull/476</a> made line debuginfo generation twice as fast by avoiding a division in the common case.</p>
</blockquote>



<a name="217623684"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217623684" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217623684">(Nov 23 2020 at 12:52)</a>:</h4>
<p>MaxGraey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2439#issuecomment-731898847">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<p>historically, this was implemented exclusively for Intel Atom back in 2013, but later it is already used even for generic x64. I think the guys from LLVM have learned pretty well the specifics of this <a href="https://github.com/llvm/llvm-project/blob/master/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp">BypassSlowDivision transformation</a>.</p>
<blockquote>
<p>The benchmarking situation is looking to improve soon</p>
</blockquote>
<p>Nice!</p>
<blockquote>
<p>@MaxGraey would you be willing to prototype it?</p>
</blockquote>
<p>Thanks for the suggestions, but I think this is a bit tricky and low-level case for me) </p>
</blockquote>



<a name="217624337"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217624337" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217624337">(Nov 23 2020 at 12:59)</a>:</h4>
<p>MaxGraey edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register width. Also it doesn't need for ARM.</p>
</blockquote>



<a name="217624355"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/217624355" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#217624355">(Nov 23 2020 at 12:59)</a>:</h4>
<p>MaxGraey edited <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register's width. Also it doesn't need for ARM.</p>
</blockquote>



<a name="224204191"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/224204191" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#224204191">(Jan 27 2021 at 16:08)</a>:</h4>
<p>bnjbvr labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register's width. Also it doesn't need for ARM.</p>
</blockquote>



<a name="224204193"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/224204193" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#224204193">(Jan 27 2021 at 16:08)</a>:</h4>
<p>bnjbvr labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register's width. Also it doesn't need for ARM.</p>
</blockquote>



<a name="224204194"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232439%20%5Bproposal%5D%20fast%20path%20for%20general%20i.../near/224204194" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232439.20.5Bproposal.5D.20fast.20path.20for.20general.20i.2E.2E.2E.html#224204194">(Jan 27 2021 at 16:08)</a>:</h4>
<p>bnjbvr labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/2439">Issue #2439</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Latency and RCP for division depends on register sizes for most of x64 architectures. So Clang do one interesting trick which may speedup 64-bit division if high parts of operands equal to zero. Pseudocode:</p>
<div class="codehilite" data-code-language="C++"><pre><span></span><code><span class="n">idiv</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">i64</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i64</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// full 64-bit division</span>
  <span class="k">return</span> <span class="nf">i32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">i32</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">as</span> <span class="n">i64</span><span class="p">;</span> <span class="c1">// 32-bit division</span>
<span class="p">}</span>
</code></pre></div>
<p>godbolt: <a href="https://godbolt.org/z/Tqqzs1">https://godbolt.org/z/Tqqzs1</a></p>
<p>Is it make sense apply same optimization for cranelift only for x64 architecture?</p>
<h4>Benefit</h4>
<p>it may speedup div / rem over 2x for arguments without high parts with small constant overhead according to this table:<br>
&lt;img width="525" alt="comparision" src="<a href="https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png">https://user-images.githubusercontent.com/1301959/99916476-0cf5dc80-2d13-11eb-9ffe-7dcfd04eab8e.png</a>"&gt;</p>
<p>But it is worth excluding <strong>Zen1,2,3</strong> architecture due to it uses a more modern scheme for division which doesn't dependent on register's width. Also it doesn't need for ARM.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>