<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4611 Remove the need for inline assembl... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html">wasmtime / issue #4611 Remove the need for inline assembl...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="292023951"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292023951" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292023951">(Aug 04 2022 at 15:29)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>I'm opening this as a loose tracking issue for removing the need to have inline assembly trampolines defined by Wasmtime. Ideally all trampolines necessary could be provided by Cranelift instead of a mixture of what we have today of Rust-defined, inline assembly, and Cranelift-defined trampolines.</p>
<p>Below is a lot of words from <a href="https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127">https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127</a> when I first wrote about this:</p>
<hr>
<p>The stack unwinding in #4431 relies on precisely knowing the stack pointer when we enter WebAssembly along with the frame pointer and last program counter when we exit WebAssembly. This is not generally available in Rust itself so we are relying on handwritten assembly trampolines for these purposes instead. </p>
<h3>Entry into WebAssembly</h3>
<p>Entry into WebAssembly happens via one of two routes:</p>
<ol>
<li>A "typed" route using the <code>wasmtime::TypedFunc</code> API or when invoking an core instance's <code>start</code> function (which has a known fixed signature of no inputs and no outputs). In these cases Rust does an indirect call directly to the Cranelift-generated code for the corresponding wasm function.</li>
<li>An "untyped" route which is used by <code>wasmtime::Func::call</code> as well as <code>wasmtime::component::{Func,TypedFunc}::call</code>. In this situation Rust will call a Cranelift-compiled trampoline. The Cranelift trampoline will load arguments from a stack parameter and then make an indirect call to the actual Cranelift-compiled wasm function which is also supplied as an argument.</li>
</ol>
<p>Today this all records the entry stack pointer via the <code>host_to_wasm_trampoline</code> defined in inline assembly. Concretely Wasmtime will "prepare" an invocation which stores the Cranelift-generated function to call (be it a raw function in case (1) or a trampoline for case (2)) into the <code>VMContext::callee</code> field and then invoke the <code>host_to_wasm_trampoline</code> inline asm symbol.</p>
<p>This entry isn't too relevant to the component model since we're already doing what's necessary for the stack unwinding, recording the sp on entry. Nevertheless I want to describe the situation so I want to describe some oddities here as well:</p>
<ul>
<li>The actual trampoline used in (2) to load arguments from the stack is not actually always defined by Cranelift. Instead sometimes it's a monomorphized Rust function <code>host_to_wasm_trampoline</code> from the <code>Func::wrap</code> API. This means we unfortunately cannot rely on Cranelift to supply all these trampolines which means we can't rely on the trampolines to do things that Rust itself can't do.</li>
<li>The entry trampoline currently requires the ability to tail-call to the actual callee. This is a technical limitation due to using the exact same trampoline for every single entry point, regardless of signature.</li>
</ul>
<p>Ideally we would always enter WebAssembly via a Cranelift-compiled trampoline. That would mean we could do anything in the trampoline that Cranelift would do and ideally remove the need to have inline asm for this. We might still need multiple trampolines for untyped entry points and typed entry points, but overall we should ideally be able to do better here.</p>
<h3>Exiting WebAssembly</h3>
<p>Exiting back to the host happens in a few locations, and this is the focus of this issue where it's missing support in the component model:</p>
<ol>
<li>Exiting from core wasm will either end up in something defined by <code>Func::wrap</code> or <code>Func::new</code> (roughly). Both of these use a <code>VMHostFunctionContext</code> which internally has two function pointers. One is the <code>VMCallerCheckedAnyfunc</code> which wasm actually calls and the other is the actual host function pointer defined in Rust being invoked. The function pointer contained within the <code>VMCallerCheckedAnyfunc</code> is a trampoline written in inline assembly which spills the fp/pc combo into <code>VMRuntimeLimits</code>. The function pointer to invoke contained within the <code>VMHostFunctionContext</code> has the "system-v ABI" since it receives arguments in native platform registers. For <code>Func::wrap</code> this is a Rust function and for <code>Func::new</code> this is a Cranelift-generated trampoline which spills arguments to the stack and then calls a static address specified at compile time (using <code>Func::new</code> requires Cranelift at runtime).</li>
<li>Exiting from a component will always exits via a lowered host function. Concretely what happens is that a <code>VMComponentContext</code> has an array <code>lowering_anyfuncs: [VMCallerCheckedAnyfunc; component.num_lowerings]</code>. This array is what core wasm actually calls and is exclusively populated by Cranelift-compiled trampolines (via <code>compile_lowered_trampoline</code>). These trampolines are similar to the Cranelift-compiled trampolines for <code>Func::new</code> but call a host function of type signature <code>VMLoweringCallee</code>. <strong>This is where fp/pc are not recorded while we exit wasm</strong>. There's not clear way to use the same trick as <code>Func::{wrap,new}</code> which have a singular inline asm trampoline for all signatures since the callee to defer to depends on the <code>LoweringIndex</code>.</li>
<li>Finally exiting wasm can also happen via libcalls implemented in Wasmtime. Currently each libcall gets a unique inline-asm-defined trampoline that records the pc/fp combo and then does a direct tail-call to the actual libcall itself.</li>
</ol>
<h3>Proposal to fix this issue</h3>
<p>Overall I find the current trampoline story as pretty complicated and also pretty inefficient. There's typically at least one extra indirect call for all of these transitions and additionally there's very little cache-locality. The fix I'm going to propose here isn't a silver bullet though and will only solve some issues, but I think is still worth pursuing.</p>
<p>I think we should add few new pseudo-instructions to Cranelift:</p>
<ul>
<li>Something to get the current frame pointer</li>
<li>Something to get the current stack pointer</li>
<li>Something to get the return address of the current function</li>
<li>Something to get the address of a label in a function (this may already exist, not sure)</li>
</ul>
<p>With these tools we can start trying to eventually move all of the trampolines above to Cranelift exclusively and remove both Rust-defined and inline-asm defined trampolines:</p>
<ol>
<li>For components, and this issue, <code>compile_lowered_trampoline</code> could be updated to use the cranelift instructions to record the pc/fp combo into the <code>VMRuntimeLimits</code>. This would remove the need for any extra trampoline when exiting a component and would solve the issue at hand.</li>
<li>For libcalls we could use the cranelift instructions to manually save fp/pc just before a libcall out to the runtime. This would remove all trampolines related to libcalls.</li>
<li>For <code>Func::new</code> the cranelift-generated trampoline could act similar to <code>compile_lowered_trampoline</code> and store the fp/pc combo to <code>VMRuntimeLimits</code> and avoid the need for two trampolines.</li>
<li>Untyped host-to-wasm trampolines could do the sp-saving internally rather than relying on the external trampoline to do so.</li>
</ol>
<p>Those are at least the easy ones we could knock out with more Cranelift features. Otherwise there are still a number of places that we are requiring trampolines:</p>
<ul>
<li>Exit trampolines with <code>Func::wrap</code> could ideally be generated by Cranelift but would still require two indirect calls. One call to get to the trampoline from the original core wasm and then a second call from the trampoline to the host function itself. The main problem here is getting a trampoline. Assuming trampolines are provided by Cranelift then they become available at runtiem when modules are loaded, which means <code>Func::wrap</code> needs to, at some point, dynamically look up a trampoline and find a corresponding one in a previous module's compiled image. This is not trivial.</li>
<li>Entry trampolines to <code>TypedFunc</code> are similarly somewhat nontrivial, but I think surmountable. Today a <code>Store</code> has a registry of untyped trampolines per-function signature, and I think it could also have a registry of typed trampolines per-function signature. This typed trampoline would then be used to enter wasm instead of today's calling the raw wasm function. In this situation the callee would be passed as an argument to the trampoline in the same manner untyped trampolines receive the callee.</li>
</ul>
</blockquote>



<a name="292023969"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292023969" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292023969">(Aug 04 2022 at 15:29)</a>:</h4>
<p>alexcrichton labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>I'm opening this as a loose tracking issue for removing the need to have inline assembly trampolines defined by Wasmtime. Ideally all trampolines necessary could be provided by Cranelift instead of a mixture of what we have today of Rust-defined, inline assembly, and Cranelift-defined trampolines.</p>
<p>Below is a lot of words from <a href="https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127">https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127</a> when I first wrote about this:</p>
<hr>
<p>The stack unwinding in #4431 relies on precisely knowing the stack pointer when we enter WebAssembly along with the frame pointer and last program counter when we exit WebAssembly. This is not generally available in Rust itself so we are relying on handwritten assembly trampolines for these purposes instead. </p>
<h3>Entry into WebAssembly</h3>
<p>Entry into WebAssembly happens via one of two routes:</p>
<ol>
<li>A "typed" route using the <code>wasmtime::TypedFunc</code> API or when invoking an core instance's <code>start</code> function (which has a known fixed signature of no inputs and no outputs). In these cases Rust does an indirect call directly to the Cranelift-generated code for the corresponding wasm function.</li>
<li>An "untyped" route which is used by <code>wasmtime::Func::call</code> as well as <code>wasmtime::component::{Func,TypedFunc}::call</code>. In this situation Rust will call a Cranelift-compiled trampoline. The Cranelift trampoline will load arguments from a stack parameter and then make an indirect call to the actual Cranelift-compiled wasm function which is also supplied as an argument.</li>
</ol>
<p>Today this all records the entry stack pointer via the <code>host_to_wasm_trampoline</code> defined in inline assembly. Concretely Wasmtime will "prepare" an invocation which stores the Cranelift-generated function to call (be it a raw function in case (1) or a trampoline for case (2)) into the <code>VMContext::callee</code> field and then invoke the <code>host_to_wasm_trampoline</code> inline asm symbol.</p>
<p>This entry isn't too relevant to the component model since we're already doing what's necessary for the stack unwinding, recording the sp on entry. Nevertheless I want to describe the situation so I want to describe some oddities here as well:</p>
<ul>
<li>The actual trampoline used in (2) to load arguments from the stack is not actually always defined by Cranelift. Instead sometimes it's a monomorphized Rust function <code>host_to_wasm_trampoline</code> from the <code>Func::wrap</code> API. This means we unfortunately cannot rely on Cranelift to supply all these trampolines which means we can't rely on the trampolines to do things that Rust itself can't do.</li>
<li>The entry trampoline currently requires the ability to tail-call to the actual callee. This is a technical limitation due to using the exact same trampoline for every single entry point, regardless of signature.</li>
</ul>
<p>Ideally we would always enter WebAssembly via a Cranelift-compiled trampoline. That would mean we could do anything in the trampoline that Cranelift would do and ideally remove the need to have inline asm for this. We might still need multiple trampolines for untyped entry points and typed entry points, but overall we should ideally be able to do better here.</p>
<h3>Exiting WebAssembly</h3>
<p>Exiting back to the host happens in a few locations, and this is the focus of this issue where it's missing support in the component model:</p>
<ol>
<li>Exiting from core wasm will either end up in something defined by <code>Func::wrap</code> or <code>Func::new</code> (roughly). Both of these use a <code>VMHostFunctionContext</code> which internally has two function pointers. One is the <code>VMCallerCheckedAnyfunc</code> which wasm actually calls and the other is the actual host function pointer defined in Rust being invoked. The function pointer contained within the <code>VMCallerCheckedAnyfunc</code> is a trampoline written in inline assembly which spills the fp/pc combo into <code>VMRuntimeLimits</code>. The function pointer to invoke contained within the <code>VMHostFunctionContext</code> has the "system-v ABI" since it receives arguments in native platform registers. For <code>Func::wrap</code> this is a Rust function and for <code>Func::new</code> this is a Cranelift-generated trampoline which spills arguments to the stack and then calls a static address specified at compile time (using <code>Func::new</code> requires Cranelift at runtime).</li>
<li>Exiting from a component will always exits via a lowered host function. Concretely what happens is that a <code>VMComponentContext</code> has an array <code>lowering_anyfuncs: [VMCallerCheckedAnyfunc; component.num_lowerings]</code>. This array is what core wasm actually calls and is exclusively populated by Cranelift-compiled trampolines (via <code>compile_lowered_trampoline</code>). These trampolines are similar to the Cranelift-compiled trampolines for <code>Func::new</code> but call a host function of type signature <code>VMLoweringCallee</code>. <strong>This is where fp/pc are not recorded while we exit wasm</strong>. There's not clear way to use the same trick as <code>Func::{wrap,new}</code> which have a singular inline asm trampoline for all signatures since the callee to defer to depends on the <code>LoweringIndex</code>.</li>
<li>Finally exiting wasm can also happen via libcalls implemented in Wasmtime. Currently each libcall gets a unique inline-asm-defined trampoline that records the pc/fp combo and then does a direct tail-call to the actual libcall itself.</li>
</ol>
<h3>Proposal to fix this issue</h3>
<p>Overall I find the current trampoline story as pretty complicated and also pretty inefficient. There's typically at least one extra indirect call for all of these transitions and additionally there's very little cache-locality. The fix I'm going to propose here isn't a silver bullet though and will only solve some issues, but I think is still worth pursuing.</p>
<p>I think we should add few new pseudo-instructions to Cranelift:</p>
<ul>
<li>Something to get the current frame pointer</li>
<li>Something to get the current stack pointer</li>
<li>Something to get the return address of the current function</li>
<li>Something to get the address of a label in a function (this may already exist, not sure)</li>
</ul>
<p>With these tools we can start trying to eventually move all of the trampolines above to Cranelift exclusively and remove both Rust-defined and inline-asm defined trampolines:</p>
<ol>
<li>For components, and this issue, <code>compile_lowered_trampoline</code> could be updated to use the cranelift instructions to record the pc/fp combo into the <code>VMRuntimeLimits</code>. This would remove the need for any extra trampoline when exiting a component and would solve the issue at hand.</li>
<li>For libcalls we could use the cranelift instructions to manually save fp/pc just before a libcall out to the runtime. This would remove all trampolines related to libcalls.</li>
<li>For <code>Func::new</code> the cranelift-generated trampoline could act similar to <code>compile_lowered_trampoline</code> and store the fp/pc combo to <code>VMRuntimeLimits</code> and avoid the need for two trampolines.</li>
<li>Untyped host-to-wasm trampolines could do the sp-saving internally rather than relying on the external trampoline to do so.</li>
</ol>
<p>Those are at least the easy ones we could knock out with more Cranelift features. Otherwise there are still a number of places that we are requiring trampolines:</p>
<ul>
<li>Exit trampolines with <code>Func::wrap</code> could ideally be generated by Cranelift but would still require two indirect calls. One call to get to the trampoline from the original core wasm and then a second call from the trampoline to the host function itself. The main problem here is getting a trampoline. Assuming trampolines are provided by Cranelift then they become available at runtiem when modules are loaded, which means <code>Func::wrap</code> needs to, at some point, dynamically look up a trampoline and find a corresponding one in a previous module's compiled image. This is not trivial.</li>
<li>Entry trampolines to <code>TypedFunc</code> are similarly somewhat nontrivial, but I think surmountable. Today a <code>Store</code> has a registry of untyped trampolines per-function signature, and I think it could also have a registry of typed trampolines per-function signature. This typed trampoline would then be used to enter wasm instead of today's calling the raw wasm function. In this situation the callee would be passed as an argument to the trampoline in the same manner untyped trampolines receive the callee.</li>
</ul>
</blockquote>



<a name="292025509"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292025509" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292025509">(Aug 04 2022 at 15:41)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1205428088">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<blockquote>
<ul>
<li>Something to get the current frame pointer</li>
<li>Something to get the current stack pointer</li>
<li>Something to get the return address of the current function</li>
<li>Something to get the address of a label in a function (this may already exist, not sure)</li>
</ul>
</blockquote>
<p>@fitzgen added the first three already in #4573; I'm curious about the last one (address of a label though) as the semantics of it and the implications to the compiler pipeline are a bit unclear to me. Is it like a second function entry, where we assume no register state is valid? Or is it assumed to be something like a longjmp target where we'll have some state valid from some other point in the function, so it's more like a special control-flow edge?</p>
<p>In other words, I can see a primitive defined one of several ways:</p>
<ul>
<li>Define another block as a second entry-point to the function, and allow getting its address. This breaks all sorts of invariants and assumptions throughout the compiler (no domtree root! func args don't dominate all uses!) and I would strongly push back against it, unless there's a very clear need, then we would need to audit a bunch of code.</li>
<li>Define a "gap in the control flow" primitive of some sort: the user can say "I will eventually transfer control to block B by [some mechanism], and register state will be as-if control came directly from block A"; then it's allowed to get the address of block B and follow that contract. This is more like exceptional edges off of an <code>invoke</code>, in LLVM terms. I would want to model it as a control-flow edge somehow as well.</li>
</ul>
<p>I'm not sure I fully grok the details of what a trampoline would need in this primitive but can you say more about which of the above fits better?</p>
</blockquote>



<a name="292031016"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292031016" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292031016">(Aug 04 2022 at 16:20)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1205476999">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>Ah yeah sure I should expand more on that. The idea for getting the address of a label comes from the desire to remove our libcall trampolines right now. Each of the static set of libcalls has its own custom <code>global_asm!</code> trampoline which saves the fp/pc and then tail-calls to the actual libcall itself. Instead we would ideally save the fp/pc within the wasm function itself just before we enter the libcall, putting the work of saving fp/pc in the caller instead of the callee.</p>
<p>Assuming we do this then getting the current frame pointer is easy enough but for the 'last wasm pc' we actually need the address of the instruction after the call instruction itself. Having a label of sorts was my rough idea to do this because at least instruction-wise I want something like <code>lea %dst, $const(%rip)</code> or something like that to be the lowering. I don't think that this maps well to Cranelift abstractions currently though AFAIK (e.g. we don't really want a control-flow edge or to introduce more basic blocks, just "get the address of the instruction after some future call instruction")</p>
</blockquote>



<a name="292034121"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292034121" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292034121">(Aug 04 2022 at 16:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1205511104">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>Ah, I see! So basically what we need is a "what will the return address be for this call instruction" primitive, is that right?</p>
<p>My first instinct would be to have an instruction that refers to the call instruction, but the problem with that is that it's a forward reference. But we could do the <em>opposite</em> and have the call refer to the "get return address" operator that came earlier. This would work fine with <code>MachBuffer</code> and forward emission order; we create the label first, then bind it just after the call. The CLIF would look something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v1</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">get_call_return_address</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="n">v9</span><span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="n">call_and_provide_return_address</span><span class="w"> </span><span class="n">fn0</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.),</span><span class="w"> </span><span class="n">v1</span><span class="w"></span>
</code></pre></div>
<p>and I can see how to feed it through the pipeline without any problems I think. Does that make sense / fill the need?</p>
</blockquote>



<a name="292055987"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292055987" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292055987">(Aug 04 2022 at 19:12)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1205669172">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>Yeah that looks perfect! </p>
</blockquote>



<a name="292072134"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292072134" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292072134">(Aug 04 2022 at 21:27)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1205786457">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>So I spun on this for a few hours and stopped <a href="https://github.com/cfallin/wasmtime/commit/5e5c4057a522b3e7020584a0fcf637d8ae9732b5">here</a> at around ~500 LoC across 25 files... adding a notion of callsite labels  turns out to be fairly cross-cutting and complex, though it is doable. With another ~4 hours or so I could push it through. I am a little apprehensive about the complexity; this is definitely not worth it for a one-off "avoid a single trampoline" tradeoff IMHO; but if it gets us efficiency improvements and you think it's important enough, I can definitely pick it back up later.</p>
</blockquote>



<a name="292184601"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292184601" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292184601">(Aug 05 2022 at 17:28)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1206683841">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<blockquote>
<p>Instead we would ideally save the fp/pc within the wasm function itself just before we enter the libcall, putting the work of saving fp/pc in the caller instead of the callee.</p>
</blockquote>
<p>Just a thought: does it have to be the exact pc of the call/return site?  Wouldn't a pc anywhere in the calling function be sufficient to provide the correct function name in backtraces?  (For DWARF CFI unwinding we of course need the exact PC, but we're not doing that anymore ...)</p>
</blockquote>



<a name="292188040"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292188040" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292188040">(Aug 05 2022 at 17:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1206709007">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>I don't think performance is critical here (at least not yet) so this isn't urgent to implement, but I would personally still like to cut down our reliance on inline assembly, especially for entry/exit trampolines that requires a "unityped" trampoline for all function signatures. Requiring these trampolines precludes other possible future features like fancier exception handling things, pinned registers, etc.</p>
<blockquote>
<p>does it have to be the exact pc of the call/return site?</p>
</blockquote>
<p>While it doesn't have to be 100% precise per-se it also can't just be anywhere in the function. Libcalls can trigger GC operations which need a precise stack map for where we're at in the function, which is the requirement I know of.</p>
</blockquote>



<a name="292209135"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292209135" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292209135">(Aug 05 2022 at 21:22)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1206882195">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>I have a somewhat related question - now that PR #3606 has been merged, on AArch64 we have to be careful whenever return addresses are moved from registers to memory, which is what the current inline assembly trampolines do, and what Cranelift-compiled trampolines would continue doing in the future. However, as far as I can tell the values saved by the trampolines do not influence control flow in the sense that they are only used to produce backtraces. Is that correct? If yes, then there is no need to sign them before storing to memory.</p>
</blockquote>



<a name="292209568"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/292209568" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#292209568">(Aug 05 2022 at 21:27)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1206888042">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>They don't influence control for now, but when we get around to implementing the Wasm exceptions proposal, then they will.</p>
</blockquote>



<a name="351717462"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/351717462" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#351717462">(Apr 21 2023 at 19:35)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-1518257035">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p><a href="https://github.com/bytecodealliance/wasmtime/pull/6262">https://github.com/bytecodealliance/wasmtime/pull/6262</a> removes most of the hand-written asm trampolines. All that are left after that PR are the wasm-to-libcall trampolines.</p>
</blockquote>



<a name="428409075"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/428409075" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#428409075">(Mar 22 2024 at 21:02)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>I'm opening this as a loose tracking issue for removing the need to have inline assembly trampolines defined by Wasmtime. Ideally all trampolines necessary could be provided by Cranelift instead of a mixture of what we have today of Rust-defined, inline assembly, and Cranelift-defined trampolines.</p>
<p>Below is a lot of words from <a href="https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127">https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127</a> when I first wrote about this:</p>
<hr>
<p>The stack unwinding in #4431 relies on precisely knowing the stack pointer when we enter WebAssembly along with the frame pointer and last program counter when we exit WebAssembly. This is not generally available in Rust itself so we are relying on handwritten assembly trampolines for these purposes instead. </p>
<h3>Entry into WebAssembly</h3>
<p>Entry into WebAssembly happens via one of two routes:</p>
<ol>
<li>A "typed" route using the <code>wasmtime::TypedFunc</code> API or when invoking an core instance's <code>start</code> function (which has a known fixed signature of no inputs and no outputs). In these cases Rust does an indirect call directly to the Cranelift-generated code for the corresponding wasm function.</li>
<li>An "untyped" route which is used by <code>wasmtime::Func::call</code> as well as <code>wasmtime::component::{Func,TypedFunc}::call</code>. In this situation Rust will call a Cranelift-compiled trampoline. The Cranelift trampoline will load arguments from a stack parameter and then make an indirect call to the actual Cranelift-compiled wasm function which is also supplied as an argument.</li>
</ol>
<p>Today this all records the entry stack pointer via the <code>host_to_wasm_trampoline</code> defined in inline assembly. Concretely Wasmtime will "prepare" an invocation which stores the Cranelift-generated function to call (be it a raw function in case (1) or a trampoline for case (2)) into the <code>VMContext::callee</code> field and then invoke the <code>host_to_wasm_trampoline</code> inline asm symbol.</p>
<p>This entry isn't too relevant to the component model since we're already doing what's necessary for the stack unwinding, recording the sp on entry. Nevertheless I want to describe the situation so I want to describe some oddities here as well:</p>
<ul>
<li>The actual trampoline used in (2) to load arguments from the stack is not actually always defined by Cranelift. Instead sometimes it's a monomorphized Rust function <code>host_to_wasm_trampoline</code> from the <code>Func::wrap</code> API. This means we unfortunately cannot rely on Cranelift to supply all these trampolines which means we can't rely on the trampolines to do things that Rust itself can't do.</li>
<li>The entry trampoline currently requires the ability to tail-call to the actual callee. This is a technical limitation due to using the exact same trampoline for every single entry point, regardless of signature.</li>
</ul>
<p>Ideally we would always enter WebAssembly via a Cranelift-compiled trampoline. That would mean we could do anything in the trampoline that Cranelift would do and ideally remove the need to have inline asm for this. We might still need multiple trampolines for untyped entry points and typed entry points, but overall we should ideally be able to do better here.</p>
<h3>Exiting WebAssembly</h3>
<p>Exiting back to the host happens in a few locations, and this is the focus of this issue where it's missing support in the component model:</p>
<ol>
<li>Exiting from core wasm will either end up in something defined by <code>Func::wrap</code> or <code>Func::new</code> (roughly). Both of these use a <code>VMHostFunctionContext</code> which internally has two function pointers. One is the <code>VMCallerCheckedAnyfunc</code> which wasm actually calls and the other is the actual host function pointer defined in Rust being invoked. The function pointer contained within the <code>VMCallerCheckedAnyfunc</code> is a trampoline written in inline assembly which spills the fp/pc combo into <code>VMRuntimeLimits</code>. The function pointer to invoke contained within the <code>VMHostFunctionContext</code> has the "system-v ABI" since it receives arguments in native platform registers. For <code>Func::wrap</code> this is a Rust function and for <code>Func::new</code> this is a Cranelift-generated trampoline which spills arguments to the stack and then calls a static address specified at compile time (using <code>Func::new</code> requires Cranelift at runtime).</li>
<li>Exiting from a component will always exits via a lowered host function. Concretely what happens is that a <code>VMComponentContext</code> has an array <code>lowering_anyfuncs: [VMCallerCheckedAnyfunc; component.num_lowerings]</code>. This array is what core wasm actually calls and is exclusively populated by Cranelift-compiled trampolines (via <code>compile_lowered_trampoline</code>). These trampolines are similar to the Cranelift-compiled trampolines for <code>Func::new</code> but call a host function of type signature <code>VMLoweringCallee</code>. <strong>This is where fp/pc are not recorded while we exit wasm</strong>. There's not clear way to use the same trick as <code>Func::{wrap,new}</code> which have a singular inline asm trampoline for all signatures since the callee to defer to depends on the <code>LoweringIndex</code>.</li>
<li>Finally exiting wasm can also happen via libcalls implemented in Wasmtime. Currently each libcall gets a unique inline-asm-defined trampoline that records the pc/fp combo and then does a direct tail-call to the actual libcall itself.</li>
</ol>
<h3>Proposal to fix this issue</h3>
<p>Overall I find the current trampoline story as pretty complicated and also pretty inefficient. There's typically at least one extra indirect call for all of these transitions and additionally there's very little cache-locality. The fix I'm going to propose here isn't a silver bullet though and will only solve some issues, but I think is still worth pursuing.</p>
<p>I think we should add few new pseudo-instructions to Cranelift:</p>
<ul>
<li>Something to get the current frame pointer</li>
<li>Something to get the current stack pointer</li>
<li>Something to get the return address of the current function</li>
<li>Something to get the address of a label in a function (this may already exist, not sure)</li>
</ul>
<p>With these tools we can start trying to eventually move all of the trampolines above to Cranelift exclusively and remove both Rust-defined and inline-asm defined trampolines:</p>
<ol>
<li>For components, and this issue, <code>compile_lowered_trampoline</code> could be updated to use the cranelift instructions to record the pc/fp combo into the <code>VMRuntimeLimits</code>. This would remove the need for any extra trampoline when exiting a component and would solve the issue at hand.</li>
<li>For libcalls we could use the cranelift instructions to manually save fp/pc just before a libcall out to the runtime. This would remove all trampolines related to libcalls.</li>
<li>For <code>Func::new</code> the cranelift-generated trampoline could act similar to <code>compile_lowered_trampoline</code> and store the fp/pc combo to <code>VMRuntimeLimits</code> and avoid the need for two trampolines.</li>
<li>Untyped host-to-wasm trampolines could do the sp-saving internally rather than relying on the external trampoline to do so.</li>
</ol>
<p>Those are at least the easy ones we could knock out with more Cranelift features. Otherwise there are still a number of places that we are requiring trampolines:</p>
<ul>
<li>Exit trampolines with <code>Func::wrap</code> could ideally be generated by Cranelift but would still require two indirect calls. One call to get to the trampoline from the original core wasm and then a second call from the trampoline to the host function itself. The main problem here is getting a trampoline. Assuming trampolines are provided by Cranelift then they become available at runtiem when modules are loaded, which means <code>Func::wrap</code> needs to, at some point, dynamically look up a trampoline and find a corresponding one in a previous module's compiled image. This is not trivial.</li>
<li>Entry trampolines to <code>TypedFunc</code> are similarly somewhat nontrivial, but I think surmountable. Today a <code>Store</code> has a registry of untyped trampolines per-function signature, and I think it could also have a registry of typed trampolines per-function signature. This typed trampoline would then be used to enter wasm instead of today's calling the raw wasm function. In this situation the callee would be passed as an argument to the trampoline in the same manner untyped trampolines receive the callee.</li>
</ul>
</blockquote>



<a name="428409076"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234611%20Remove%20the%20need%20for%20inline%20assembl.../near/428409076" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234611.20Remove.20the.20need.20for.20inline.20assembl.2E.2E.2E.html#428409076">(Mar 22 2024 at 21:02)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4611#issuecomment-2015907708">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4611">issue #4611</a>:</p>
<blockquote>
<p>Final ones done in <a href="https://github.com/bytecodealliance/wasmtime/pull/8152">https://github.com/bytecodealliance/wasmtime/pull/8152</a> now, so closing.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>