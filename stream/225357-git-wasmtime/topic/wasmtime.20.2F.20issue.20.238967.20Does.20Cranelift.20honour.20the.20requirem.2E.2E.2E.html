<html>
<head><meta charset="utf-8"><title>wasmtime / issue #8967 Does Cranelift honour the requirem... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html">wasmtime / issue #8967 Does Cranelift honour the requirem...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="452003491"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452003491" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452003491">(Jul 17 2024 at 09:15)</a>:</h4>
<p>primoly opened <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>NaNs in IEEE floats are encoded just like infinities, except that at least one of the mantissa bits is set to one. Wasm NaNs in results of float ops (_except_ <code>fabs</code>, <code>fneg</code> and <code>fcopysign</code>) have the additional requirement that the most significant bit of the mantissa must be be one (arithmetic NaN). Is this actually honoured by Cranelift codegen? If NaNs are always canonicalised then this is guaranteed (as the canonical NaN is also an arithmetic one), but if NaNs are simply propagated then this could be an issue.</p>
<p><a href="https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation">https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#syntax-float">https://webassembly.github.io/spec/core/syntax/values.html#syntax-float</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan">https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan</a></p>
</blockquote>



<a name="452012240"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452012240" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452012240">(Jul 17 2024 at 09:46)</a>:</h4>
<p>primoly edited <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>NaNs in IEEE floats are encoded just like infinities, except that at least one of the mantissa bits is set to one. Wasm NaNs in results of float ops (_except_ <code>fabs</code>, <code>fneg</code> and <code>fcopysign</code>) have the additional requirement that the most significant bit of the mantissa must be one (arithmetic NaN). Is this actually honoured by Cranelift codegen? If NaNs are always canonicalised then this is guaranteed (as the canonical NaN is also an arithmetic one), but if NaNs are simply propagated then this could be an issue.</p>
<p><a href="https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation">https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#syntax-float">https://webassembly.github.io/spec/core/syntax/values.html#syntax-float</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan">https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan</a></p>
</blockquote>



<a name="452134567"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452134567" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452134567">(Jul 17 2024 at 17:08)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233790349">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>I believe in theory all Cranelift operations/backends/etc all do what wasm wants. That being said I also wouldn't preclude the existence of a bug somewhere. I haven't read up on the context of #8954 but is there a specific case you're wondering about?</p>
</blockquote>



<a name="452137010"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452137010" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452137010">(Jul 17 2024 at 17:16)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233806682">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>I think this is a question of auditing the backends to ensure that each ISA generates the appropriate kind of NaN. I'm not familiar enough with the FP subsets of our supported ISAs to say for sure; @abrown, @afonso360, @uweigand, others, thoughts on x64, aarch64, riscv64, s390x? Do they always generate arithmetic NaNs?</p>
</blockquote>



<a name="452137451"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452137451" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452137451">(Jul 17 2024 at 17:17)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233810622">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>(As an additional note, I'd be surprised if Wasm were spec'd in such a way that e.g. a <code>f32.add</code> required more than a bare FP add instruction on common ISAs -- that would seem to go against the "predictable performance" design, and I haven't seen "ensure it's an arithmetic NaN" logic in other engines -- but this is good to double-check.)</p>
</blockquote>



<a name="452145511"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452145511" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452145511">(Jul 17 2024 at 17:51)</a>:</h4>
<p>primoly <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233880909">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<blockquote>
<p>(As an additional note, I'd be surprised if Wasm were spec'd in such a way that e.g. a <code>f32.add</code> required more than a bare FP add instruction on common ISAs -- that would seem to go against the "predictable performance" design, and I haven't seen "ensure it's an arithmetic NaN" logic in other engines -- but this is good to double-check.)</p>
</blockquote>
<p>I think you can only observe the exact bits of a float with certain instructions (memory storing, reinterpret bits as int, others?), so if those instructions do some kind of canonicalisation guaranteeing arithmetic NaNs, that would likely be enough. For stores to memory the performance impact should be negligible, because stores are so expensive, the additional conversion to arithmetic NaNs wouldn’t add much.<br>
</p>
</blockquote>



<a name="452146256"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452146256" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452146256">(Jul 17 2024 at 17:54)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233888994">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<blockquote>
<p>(As an additional note, I'd be surprised if Wasm were spec'd in such a way that e.g. a <code>f32.add</code> required more than a bare FP add instruction on common ISAs -- that would seem to go against the "predictable performance" design, and I haven't seen "ensure it's an arithmetic NaN" logic in other engines -- but this is good to double-check.)</p>
</blockquote>
<p>+1 to this; I'd also be very surprised.</p>
</blockquote>



<a name="452154154"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452154154" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452154154">(Jul 17 2024 at 18:21)</a>:</h4>
<p>primoly edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233880909">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<blockquote>
<p>(As an additional note, I'd be surprised if Wasm were spec'd in such a way that e.g. a <code>f32.add</code> required more than a bare FP add instruction on common ISAs -- that would seem to go against the "predictable performance" design, and I haven't seen "ensure it's an arithmetic NaN" logic in other engines -- but this is good to double-check.)</p>
</blockquote>
<p>I think you can only observe the exact bits of a float with certain instructions (memory storing, reinterpret bits as int, others?), so if those instructions do some kind of canonicalisation guaranteeing arithmetic NaNs, that would likely be enough. For stores to memory the performance impact should be negligible, because stores are so expensive, the additional conversion to arithmetic NaNs wouldn’t add much.</p>
<p>Edit: I don’t actually know much about the performance of CPU instructions, maybe with the speed of L1 caches stores are not expensive as I wrote above.</p>
</blockquote>



<a name="452157685"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452157685" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452157685">(Jul 17 2024 at 18:33)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2233992236">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>For RISC-V the behavior is fairly straightforward. (See §21.3. "NaN Generation and Propagation" of the <a href="https://github.com/riscv/riscv-isa-manual/releases/tag/riscv-isa-release-982eac4-2024-07-16">ISA Unprivileged Manual</a>)</p>
<blockquote>
<p>Except when otherwise stated, if the result of a floating-point operation is NaN, it is the canonical<br>
NaN. The canonical NaN has a positive sign and all significand bits clear except the MSB, a.k.a. the<br>
quiet bit. For single-precision floating-point, this corresponds to the pattern 0x7fc00000</p>
</blockquote>
<p>AFAIK the exceptions to this are <code>fmin</code>/<code>fmax</code> and the sign injection instructions.</p>
<p>So I think this is compliant with the WASM Spec directly, and for <code>fmin</code>/<code>fmax</code> we do some corrections. </p>
</blockquote>



<a name="452171810"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452171810" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452171810">(Jul 17 2024 at 19:40)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2234101293">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>The s390x ISA does not use the term "arithmetic NaN".  However, the definition of this term in the WebAssembly spec (most significant payload bit is 1) corresponds exactly to what the s390x ISA calls "quiet NaN":</p>
<blockquote>
<p>There are two types of NaNs, signaling and quiet. A signaling NaN (SNaN) is distinguished from the corresponding quiet NaN (QNaN) by the leftmost fraction bit: zero for the SNaN and one for the QNaN. A special QNaN is supplied as the default result for an IEEE-invalid-operation exception; it has a plus sign and a leftmost fraction bit of one, with the remaining fraction bits being set to zeros.</p>
</blockquote>
<p>The ISA guarantees that the result of any floating-point instruction (except those only manipulating the sign bit) will always be a quiet NaN (if it is a NaN).   More specifically if the output is a NaN, it is either a copy of one of the input operands (possibly transformed from a signaling NaN to a quiet NaN), or else the default NaN described in the quote above (which corresponds to what WebAssembly calls the "canonical NaN").</p>
<p>Given that behavior of the ISA, it seems unlikely that code generated by the wasmtime backend would ever be able to violate the WebAssembly NaN propagation rules on s390x (although I haven't explicitly verified all patterns).<br>
</p>
</blockquote>



<a name="452442198"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452442198" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452442198">(Jul 18 2024 at 21:16)</a>:</h4>
<p>primoly closed <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>NaNs in IEEE floats are encoded just like infinities, except that at least one of the mantissa bits is set to one. Wasm NaNs in results of float ops (_except_ <code>fabs</code>, <code>fneg</code> and <code>fcopysign</code>) have the additional requirement that the most significant bit of the mantissa must be one (arithmetic NaN). Is this actually honoured by Cranelift codegen? If NaNs are always canonicalised then this is guaranteed (as the canonical NaN is also an arithmetic one), but if NaNs are simply propagated then this could be an issue.</p>
<p><a href="https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation">https://webassembly.github.io/spec/core/exec/numerics.html#nan-propagation</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#syntax-float">https://webassembly.github.io/spec/core/syntax/values.html#syntax-float</a><br>
<a href="https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan">https://webassembly.github.io/spec/core/syntax/values.html#arithmetic-nan</a></p>
</blockquote>



<a name="452442201"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238967%20Does%20Cranelift%20honour%20the%20requirem.../near/452442201" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238967.20Does.20Cranelift.20honour.20the.20requirem.2E.2E.2E.html#452442201">(Jul 18 2024 at 21:16)</a>:</h4>
<p>primoly <a href="https://github.com/bytecodealliance/wasmtime/issues/8967#issuecomment-2237632187">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8967">issue #8967</a>:</p>
<blockquote>
<p>Thanks everyone, especially @afonso360 and @uweigand for digging up the RISC-V and s390x specifications. Now that I know of the difference between quiet and singling NaN it became clear to me why Wasm made that choice about the “arithmetic NaN” (quiet NaN). I haven’t checked how this is handled in x86-64 and AArch64 but I presume they either return the canonical NaN (as RISC-V) or some arithmetic NaN (as s390x).</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>