<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4602 cranelift: Sign extend immediates ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html">wasmtime / issue #4602 cranelift: Sign extend immediates ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="292014362"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292014362" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292014362">(Aug 04 2022 at 14:22)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1205327755">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>As I stated in the linked issue, IMHO the CLIF instruction definition should be updated.</p>
</blockquote>



<a name="292018529"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292018529" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292018529">(Aug 04 2022 at 14:53)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1205368342">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<blockquote>
<p>As I stated in the linked issue, IMHO the CLIF instruction definition should be updated.</p>
</blockquote>
<p>You are right, I didn't read your comment properly, ill mark this as draft until we make that decision.</p>
</blockquote>



<a name="292018570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292018570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292018570">(Aug 04 2022 at 14:53)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1205368342">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<blockquote>
<p>As I stated in the linked issue, IMHO the CLIF instruction definition should be updated.</p>
</blockquote>
<p>You are right, I didn't read your comment properly (sorry!), ill mark this as draft until we make that decision.</p>
</blockquote>



<a name="292642921"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292642921" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292642921">(Aug 09 2022 at 19:27)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1209788150">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>@akirilov-arm I've updated the documentation, is this all you meant, or did I miss something else?</p>
<p>Also, cc @cfallin since I can't request reviews.</p>
</blockquote>



<a name="292753468"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292753468" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292753468">(Aug 10 2022 at 13:21)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1210666744">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>I also think zero extending the unsigned operations is probably the better choice.</p>
<p>However, what if we instead altered the type of the instruction to accept the full <code>Imm128</code>?</p>
<p>I don't think this would grow the size of <code>InstructionData</code> since we already have <code>Shuffle</code> which also stores a <code>Imm128</code>. However <code>Shuffle</code> stores the immediate in the <code>DataFlowGraph</code>, we could do the same, and in this legalization pass emit the appropriate <code>iconst</code> / <code>iconcat</code> / <code>sextend</code> depending on what the constant is.</p>
<p>Would storing the Imm in the DFG for these operations cause performance issues?</p>
</blockquote>



<a name="292801716"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292801716" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292801716">(Aug 10 2022 at 17:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1211044612">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>Actually that would be the ideal design: from first principles one would expect "with immediate" variants of 128-bit ops to carry 128-bit (16-byte) immediates.</p>
<p>However we can't carry that inline in the instruction, as you're hinting, because <code>InstructionData</code> is 16 bytes total (and we want to keep it that way).</p>
<p>I suspect that indirecting for all constants would have some nontrivial overhead, though it might be a bit of work to measure (a lot of refactoring).</p>
<p>I had another thought, though, that may be more "honest" about the costs: what if we (i) limited <code>op_imm</code> instructions and the <code>iconst</code> instruction to work for up to 64 bits only? Producers that want to emit full 128-bit values already produce two <code>iconst</code>s and <code>iconcat</code> them. In some sense, trying to allow <code>iconst.i128 -1</code> or the <code>op_imm</code> folded variant is lulling producers into a false sense of what's supported. As soon as one writes <code>iconst.i128 -0x8000_0000_0000_0001</code> one finds out that there are only half as many bits in the immediate field as the type otherwise implies.</p>
<p>Thoughts on that?</p>
</blockquote>



<a name="292801824"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292801824" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292801824">(Aug 10 2022 at 17:44)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1211044612">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>Actually that would be the ideal design: from first principles one would expect "with immediate" variants of 128-bit ops to carry 128-bit (16-byte) immediates.</p>
<p>However we can't carry that inline in the instruction, as you're hinting, because <code>InstructionData</code> is 16 bytes total (and we want to keep it that way).</p>
<p>I suspect that indirecting for all constants would have some nontrivial overhead, though it might be a bit of work to measure (a lot of refactoring).</p>
<p>I had another thought, though, that may be more "honest" about the costs: what if we limited (i) <code>op_imm</code> instructions and (ii) the <code>iconst</code> instruction to work for up to 64 bits only? Producers that want to emit full 128-bit values already produce two <code>iconst</code>s and <code>iconcat</code> them. In some sense, trying to allow <code>iconst.i128 -1</code> or the <code>op_imm</code> folded variant is lulling producers into a false sense of what's supported. As soon as one writes <code>iconst.i128 -0x8000_0000_0000_0001</code> one finds out that there are only half as many bits in the immediate field as the type otherwise implies.</p>
<p>Thoughts on that?</p>
</blockquote>



<a name="292814869"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292814869" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292814869">(Aug 10 2022 at 19:02)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1211139200">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<blockquote>
<p>I suspect that indirecting for all constants would have some nontrivial overhead, though it might be a bit of work to measure (a lot of refactoring).</p>
</blockquote>
<p>I was proposing that only for <code>*_imm</code> variants. The way I see it, these instructions are already just sort of "helpers" in the sense that they just construct a pattern that we recognize (i.e. <code>iadd</code> + <code>iconst</code>), they could just emit more advanced patterns to support i128 (i.e. <code>iadd+iconst+sext</code> or <code>iadd+iconst+iconcat</code> all in 64bits).</p>
<p>Having more operations only work up to <code>i64</code> to me feels like <code>i128</code> is a second class citizen, which is sort of true for the current backends, but I don't really like it at the lang level.</p>
<p>I don't know, I'm a bit undecided on this, I'd like to hear what other people think.<br>
</p>
</blockquote>



<a name="292815676"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292815676" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292815676">(Aug 10 2022 at 19:07)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1211144015">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<p>Generally I agree at an IR-design level: it would be nice to have orthogonality here, and allow all types up through <code>i128</code> in all places where integers are allowed.</p>
<p>This compromise feels similar to "small immediates" in RISC ISAs though: we have a relatively small struct size for instructions, and its size is critical for performance, and its entire width would be taken by just the <code>i128</code> immediate (hence it would need to grow). So in that sense I don't think we can have an <em>inline</em> <code>Imm128</code>.</p>
<p>I would be curious to see the overhead of a "every immediate is indirect" approach, if you're up for prototyping that. If it's actually negligible, then I think it's a reasonable change to make.</p>
</blockquote>



<a name="292978302"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234602%20cranelift%3A%20Sign%20extend%20immediates%20.../near/292978302" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234602.20cranelift.3A.20Sign.20extend.20immediates.20.2E.2E.2E.html#292978302">(Aug 11 2022 at 17:52)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/4602#issuecomment-1212299750">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4602">issue #4602</a>:</p>
<blockquote>
<blockquote>
<p>I would be curious to see the overhead of a "every immediate is indirect" approach, if you're up for prototyping that. If it's actually negligible, then I think it's a reasonable change to make.</p>
</blockquote>
<p>Me too, and I think we could mitigate some of the cost (if it is non-negligible) by having two const <code>InstructionData</code> variants, one inline up to 64bits and one in the DFG for larger values, and choose between them when the user emits a <code>iconst</code> (can we do this?).</p>
<p>Although right now I don't have a lot of time to try this out. </p>
<p>I'm planning on addressing the feedback above and getting this merged, is that okay, or would you prefer restricting the types that we accept?</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>