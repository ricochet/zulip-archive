<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4636 Treat edge blocks as cold if they ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html">wasmtime / issue #4636 Treat edge blocks as cold if they ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="292515480"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292515480" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292515480">(Aug 09 2022 at 00:42)</a>:</h4>
<p>mchesser <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers).</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure that the values.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained for the incoming edge.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292515492"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292515492" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292515492">(Aug 09 2022 at 00:42)</a>:</h4>
<p>mchesser edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue (but forgot) - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers).</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure that the values.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained for the incoming edge.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292515718"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292515718" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292515718">(Aug 09 2022 at 00:47)</a>:</h4>
<p>mchesser edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue (but forgot) - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers), but the results of which are effectively unused by the hot path.</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure that the values.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained for the incoming edge.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292515784"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292515784" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292515784">(Aug 09 2022 at 00:48)</a>:</h4>
<p>mchesser edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue (but forgot) - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers), but the results of which are effectively unused by the hot path.</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure that the values.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained any move operations for incoming edges to cold blocks.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292515812"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292515812" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292515812">(Aug 09 2022 at 00:49)</a>:</h4>
<p>mchesser edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue (but forgot) - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers), but the results of which are effectively unused by the hot path.</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure that the values.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained any move operations for incoming edges to cold blocks.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292516567"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292516567" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292516567">(Aug 09 2022 at 01:01)</a>:</h4>
<p>mchesser edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208763316">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I had intended to write a follow up comment to discuss this issue (but forgot) - here it is now:</p>
<p>There are two main uses of cold blocks I can think of:</p>
<ol>
<li>
<p>Cases where there is code that needs to be executed in rare circumstances (e.g., error handlers), but the results of which are effectively unused by the hot path.</p>
</li>
<li>
<p>Situations where a value is obtained via two (or more) different paths of code, one significantly rarer than the other (in my case, this corresponds to a fast path from a cache hit, and a slow path that needs to recompute the value).</p>
</li>
</ol>
<p>These have different behaviour with respect to the edge blocks they generate (Note: overall Cranelift seems to do a decent job at avoiding extra edge blocks in many cases):</p>
<p>In 1., the cold block might be shared (e.g., a common return for all error cases), and so might require an edge block along the incoming edge. However, simple cases may never need to jump back to a shared block, so don’t require an edge-block on outgoing edges.</p>
<p>In 2., the cold block only as a single incoming edge so doesn’t require any moves to occur along the incoming edge (at least as well as I can understand). However, since the cold path rejoins the hot path, it frequently requires an edge block on the outgoing edge to ensure the values are in the same place as the hot path.</p>
<p>Admittedly, I was only thinking of 2. when I changed the heuristic (to attempt to solve the issue below), so my intuition was that there would never be an edge-block that contained any move operations for incoming edges to cold blocks.</p>
<p>An issue I observed (as a result of the existing cold-blocks test: <code>isa::x64::test::test_cold_blocks</code>), is that there is a subtle interaction of this change with trivial edges (i.e., edges without any moves) that occur when the cold path is reached as part of an untaken branch.</p>
<p>e.g., if we have:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>If block1 is shared, then Cranelift seems to generate something equivalent to the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">block0</span>:
    <span class="nc">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block0_to_block1_edge</span><span class="w"></span>

<span class="n">block0_to_block1_edge</span>:
    <span class="nc">jump</span><span class="w"> </span><span class="n">block1</span><span class="w"></span>

<span class="n">block1</span><span class="w"> </span><span class="n">cold</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">....</span><span class="w"></span>

<span class="n">block2</span>:
    <span class="p">;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>Normally the redundant <code>block0_to_block1_edge</code> jump is eliminated because it acts as a "fallthrough" to the next block, however if it gets marked as cold then it is no longer a fallthrough block and we end up with a redundant jump, e.g., see the branch at 0x23 below:</p>
<div class="codehilite" data-code-language="GAS"><pre><span></span><code><span class="nl">.00:</span><span class="w">  </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.01:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>
<span class="nl">.04:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.0a:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.0c:</span><span class="w">  </span><span class="nf">je</span><span class="w">      </span><span class="mi">0x2e</span><span class="w"></span>

<span class="nl">.12:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.15:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.18:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.1e:</span><span class="w">  </span><span class="nf">sub</span><span class="w">     </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.21:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">edi</span><span class="w"></span>
<span class="nl">.23:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x46</span><span class="w"></span>

<span class="nl">.29:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2c:</span><span class="w">  </span><span class="nf">pop</span><span class="w">     </span><span class="no">rbp</span><span class="w"></span>
<span class="nl">.2d:</span><span class="w">  </span><span class="nf">ret</span><span class="w"></span>

<span class="nl">.2e:</span><span class="w">  </span><span class="nf">mov</span><span class="w">     </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w"></span>
<span class="nl">.31:</span><span class="w">  </span><span class="nf">add</span><span class="w">     </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1234</span><span class="w"></span>
<span class="nl">.38:</span><span class="w">  </span><span class="nf">test</span><span class="w">    </span><span class="no">r8d</span><span class="p">,</span><span class="w"> </span><span class="no">r8d</span><span class="w"></span>
<span class="nl">.3b:</span><span class="w">  </span><span class="nf">jne</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
<span class="nl">.41:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x15</span><span class="w"></span>

<span class="nl">.46:</span><span class="w">  </span><span class="nf">jmp</span><span class="w">     </span><span class="mi">0x2e</span><span class="w"></span>
</code></pre></div>
<p>I originally slightly misunderstood what was going on and believe that removing the heuristic that propagated the cold annotation to incoming edges would fix the redundant branch (in combination with my assumption that all edges to cold blocks would not contain any moves). However, this is not really the case, and the same issue can crop up in the cold-&gt;hot edge case as well.</p>
<p>In summary: I think it makes sense to re-enable the heuristic for edges with cold blocks as successors, however in both cases we can end up with a redundant edge in some cases.</p>
</blockquote>



<a name="292525140"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292525140" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292525140">(Aug 09 2022 at 04:18)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208892472">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>OK, I see; it would be helpful to see the actual CLIF that generates the disassembly (the edge block 0x46 being placed <em>after</em> the block it leads into at 0x2e is very surprising; RPO sort should place preds to the block before the block itself, absent any cycles among the cold blocks, and assuming the pred edge block and main cold block are both marked cold and sunk accordingly). If you want to dig into it further, in addition to the RPO sort you see in <a href="http://blockorder.rs">blockorder.rs</a>, <a href="https://github.com/bytecodealliance/wasmtime/blob/0b1f51f80427a79fbd7d77849f7e2301a1d128f5/cranelift/codegen/src/machinst/vcode.rs#L768-L778">this</a> code does the actual sinking at the last second, during emission (we do it this way because we need to generate vcode in postorder to see uses before defs).</p>
<p>In the meantime I'd be happy to merge this with the heuristic returned to "edge is cold if pred or succ is cold"; that seems pretty reasonable and robust to me.</p>
</blockquote>



<a name="292525976"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292525976" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292525976">(Aug 09 2022 at 04:38)</a>:</h4>
<p>mchesser <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208903799">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>I've reverted the commit back to the "edge is cold if pred or succ is cold" heuristic.</p>
<hr>
<p>The assembly code came from the test here: <a href="https://github.com/bytecodealliance/wasmtime/blob/0b1f51f80427a79fbd7d77849f7e2301a1d128f5/cranelift/codegen/src/isa/x64/mod.rs#L219">https://github.com/bytecodealliance/wasmtime/blob/0b1f51f80427a79fbd7d77849f7e2301a1d128f5/cranelift/codegen/src/isa/x64/mod.rs#L219</a></p>
<p>I translated it to CLIF:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">test_cold</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="n">block0</span><span class="p">(</span><span class="n">v10</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mh">0x1234</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v10</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
<span class="w">    </span><span class="n">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>

<span class="n">block1</span><span class="p">(</span><span class="n">v20</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isub</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v20</span><span class="w"></span>
<span class="w">    </span><span class="n">brnz</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block3</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span><span class="w"></span>

<span class="n">block2</span><span class="w"> </span><span class="n">cold</span>:
    <span class="nc">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
<span class="w">    </span><span class="n">brnz</span><span class="w"> </span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="w"></span>
<span class="w">    </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="p">(</span><span class="n">v4</span><span class="p">)</span><span class="w"></span>

<span class="n">block3</span><span class="p">(</span><span class="n">v30</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">return</span><span class="w"> </span><span class="n">v30</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Looks like there is a cycle.</p>
</blockquote>



<a name="292527402"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234636%20Treat%20edge%20blocks%20as%20cold%20if%20they%20.../near/292527402" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234636.20Treat.20edge.20blocks.20as.20cold.20if.20they.20.2E.2E.2E.html#292527402">(Aug 09 2022 at 05:09)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4636#issuecomment-1208921448">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4636">issue #4636</a>:</p>
<blockquote>
<p>@mchesser I fixed the redundant-jump issue over in #4652 just now -- thanks for noticing this!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>