<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #2295 Instantiation performance improvement · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html">wasmtime / Issue #2295 Instantiation performance improvement</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="213572158"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213572158" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213572158">(Oct 16 2020 at 15:03)</a>:</h4>
<p>bkolobara opened <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>I'm working on an application where I create one Wasm Instance per HTTP request.</p>
<p>Now I have run into a performance issue where most of the response time is spent on instance creation. I'm not sure how I could structure my app to improve this.</p>
<p>I run a profiler to measure where time is spent exactly and here are some results:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">47</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">func</span>::<span class="n">Func</span>::<span class="n">wrap</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">trampoline</span>::<span class="n">generate_raw_func_export</span><span class="w"></span>
<span class="mi">16</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime_runtime</span>::<span class="n">instance</span>::<span class="n">InstanceHandle</span>::<span class="n">dealloc</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">core</span>::<span class="n">ptr</span>::<span class="n">drop_in_place</span><span class="w"></span>
<span class="mi">16</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">linker</span>::<span class="n">Linker</span>::<span class="n">instantiate</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">instance</span>::<span class="n">Instance</span>::<span class="n">new</span><span class="w"></span>
<span class="w"> </span><span class="mi">7</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">externals</span>::<span class="n">Memory</span>::<span class="n">new</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">externals</span>::<span class="n">Memory</span>::<span class="n">new</span><span class="w"></span>
<span class="w">      </span><span class="o">-</span><span class="n">wasmtime</span>::<span class="n">trampline</span>::<span class="n">generate_memory_export</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>

<p>My biggest issue is the almost 50% of time spent wrapping closures for the Linker (Linker::func). But I don't see a way around this as every Linker is connected to a Store, and because I need to create a Store per Instance I can't reuse the Linker (or they would belong to different Stores). Also, I'm capturing some per request environment in the closures and re-using Linkers would be hard in this case.</p>
<p>For now it's still ok, but as I keep adding functionality I'm afraid this is going to be a big issue. Is there a way I could improve this?</p>
<p>Also the 16% dealloc seems a bit big, but I'm not sure where this is exactly coming from.</p>
</blockquote>



<a name="213578202"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213578202" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213578202">(Oct 16 2020 at 15:51)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710128274">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>This kind of use case would indeed be great to make faster! While for all I know there might be some low-hanging fruit left in the operations showing up in your profile, I wonder if a different approach might not be better:</p>
<p>Instead of actually creating a new instance for each request, might it also be possible to reset existing instances, or more specifically their Memory, stack, and tables?</p>
<p>You mention capturing per-request data in closures, so that part might need a different solution. Perhaps you could store that as instance-associated data?</p>
<p>@alexcrichton can you comment on how difficult it'd be to do this kind of instance-resetting?</p>
</blockquote>



<a name="213580464"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213580464" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213580464">(Oct 16 2020 at 16:09)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710151810">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<blockquote>
<p>Instead of actually creating a new instance for each request, might it also be possible to reset existing instances, or more specifically their Memory, stack, and tables?</p>
</blockquote>
<p>This was the first idea I also came up with. Having an <code>Instance::reset()</code> would be ideal. Then I just could run a pool of ready Instances and save a lot of work.  Zeroing out the memory could be <a href="https://stackoverflow.com/questions/49896578/fastest-way-to-zero-pages-in-linux">potentially much faster</a> than creating new linear memories. But I'm not sure how hard it would be to implement such a thing.</p>
<blockquote>
<p>You mention capturing per-request data in closures, so that part might need a different solution. Perhaps you could store that as instance-associated data?</p>
</blockquote>
<p>I can work around this by capturing a structure that I internally change for each request. In some way this would be "instance-associated data".</p>
</blockquote>



<a name="213581653"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213581653" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213581653">(Oct 16 2020 at 16:19)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710165506">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Ok, great! I guess this would be about resetting the store, specifically, so that should probably be reflected in the name.</p>
<p>If this turns out not to require deep architectural changes, would you potentially be interested in working on adding this to Wasmtime, @bkolobara?</p>
</blockquote>



<a name="213583267"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213583267" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213583267">(Oct 16 2020 at 16:32)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710184434">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Yes, this is an important issue to me and I'm able to dedicate some time to it.</p>
</blockquote>



<a name="213583481"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213583481" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213583481">(Oct 16 2020 at 16:33)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710187112">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Excellent! Let's wait for Alex to weigh in then.</p>
</blockquote>



<a name="213586614"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213586614" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213586614">(Oct 16 2020 at 17:01)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710227593">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Resetting memories, globals, and tables shouldn't be too hard as long as there aren't any frames on the stack. This way we wouldn't need to reset the stack, which has bigger implications (like spec deviance, for one).</p>
</blockquote>



<a name="213591711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213591711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213591711">(Oct 16 2020 at 17:44)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710297921">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Thanks for the report here @bkolobara! This is definitely a situation we'd like to be quite fast, and it sounds like it's not quite up to par at the moment!</p>
<p>Would it be possible to share some code you're using? I'd love to dig in a bit more into a microbenchmark or something like that  to see if there's any low hanging fruit.</p>
<p>For resetting the <code>Store</code>, I'm not sure how easy that would be. It could be very tricky to pull off safely and I'd prefer to go the route of optimizing what we have there already first if possible (not a ton of optimization effort has gone in just yet). I think my ideal solution if optimization doesn't work though would be to somehow reuse the <code>Linker</code> so you don't have to recreate the entire host environment each time, but you could instead create it once globally or once per thread maybe (or something like that).</p>
</blockquote>



<a name="213601211"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213601211" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213601211">(Oct 16 2020 at 19:03)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710439442">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<blockquote>
<p>Would it be possible to share some code you're using? I'd love to dig in a bit more into a microbenchmark or something like that to see if there's any low hanging fruit.</p>
</blockquote>
<p>To not dump the whole unrelated project here, I will just c/p the part handling instantiation here (it is mostly straight forward code):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Linker</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MemoryChoice</span>::<span class="n">Existing</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">memory</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">MemoryChoice</span>::<span class="n">New</span><span class="p">(</span><span class="n">min_memory</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory_ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span>::<span class="n">new</span><span class="p">(</span><span class="n">Limits</span>::<span class="n">new</span><span class="p">(</span><span class="n">min_memory</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">Memory</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_ty</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">ProcessEnvironment</span>::<span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="n">memory</span><span class="p">.</span><span class="n">data_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">other_args</span><span class="p">);</span><span class="w"></span>

<span class="n">linker</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="c1">// A lot of</span>
<span class="kd">let</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environment</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="n">linker</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"func1"</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">index</span>: <span class="kt">u32</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">env</span><span class="p">.</span><span class="n">something</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environment</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="n">linker</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"func2"</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">index</span>: <span class="kt">u32</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">env</span><span class="p">.</span><span class="n">something</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">})</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_func</span><span class="p">(</span><span class="s">"response"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="n">func</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">Val</span>::<span class="n">from</span><span class="p">(</span><span class="n">arg1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w"> </span><span class="n">Val</span>::<span class="n">from</span><span class="p">(</span><span class="n">arg2</span><span class="p">)])</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>If I wrap this code inside <code>std::time::Instant::now()</code> &amp; <code>now.elapsed().as_micros()</code> I get around 900us on average on my machine. This is not that bad, but considering that the <code>func.call</code> finishes really fast for simple endpoints most of the time is spent on instantiating.</p>
<blockquote>
<p>... would be to somehow reuse the <code>Linker</code> so you don't have to recreate the entire host environment each time, but you could instead create it once globally or once per thread maybe (or something like that).</p>
</blockquote>
<p>I attempted to do something like this, but got stuck on the fact that each <code>Linker</code> is created from a <code>Store</code> and can't be used with others. So I need to keep a <code>Linker</code> &amp; <code>Store</code> pair preserved. But if I don't drop the <code>Store</code> I can't drop the <code>Instances</code> associated with it.</p>
</blockquote>



<a name="213604348"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213604348" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213604348">(Oct 16 2020 at 19:32)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710485102">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Thanks for the info! That should be plenty good for investigating. As one other piece of info, how many functions are you defining via <code>linker.func</code>?</p>
<p>Also yeah, you can't reuse <code>Linker</code> across a <code>Store</code> today. You're using <code>wasmtime</code> how it's intended, we just need to make it faster or tweak the  recommended idioms and APIs to make it faster :)</p>
</blockquote>



<a name="213606591"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/213606591" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#213606591">(Oct 16 2020 at 19:54)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-710518680">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<blockquote>
<p>how many functions are you defining via <code>linker.func</code>?</p>
</blockquote>
<p>16, but I will need much more as I keep adding features.</p>
</blockquote>



<a name="216927939"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/216927939" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#216927939">(Nov 16 2020 at 20:32)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-728309634">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>@bkolobara hey wanted to let you know that I haven't forgotten about this (although this is a bit delayed). I've done some small work here and there to optimize this use case, but I wanted to drill a bit more into the numbers that you were seeing. I <a href="https://gist.github.com/alexcrichton/638502ab212acdbd8d7f9b8a5f9adcda">whipped up a small benchmark</a> with a number of functions of differing signatures, and on my computer that's taking ~50us per iteration. You mentioned you were getting 900us, so I was wondering if you could run that locally and see how much time it's taking for you?</p>
<p>I'd ideally like to get a gauge on what the expected scaling factor is in the difference between these two environments.</p>
</blockquote>



<a name="216988194"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/216988194" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#216988194">(Nov 17 2020 at 10:49)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-728848174">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Thanks a lot for looking into this @alexcrichton! Running your benchmark produces also a result of around ~60us on my machine. This got me curious so I just dumped the part I was previously benchmarking with a <code>let now = std::time::Instant::now()</code>  &amp; <code>let elapsed = now.elapsed().as_micros()</code> wrapper into citerion and now I'm getting <strong>~120us</strong> for the same code.</p>
<p>I wasn't sure why the difference was so big, so I went ahead and wrapped the same code block again with <code>Instant::now()</code> inside my app. This resulted in:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">395</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">1123</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">281</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">939</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">306</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">925</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">486</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">517</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">418</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">411</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">329</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">484</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">506</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>I'm using multiple threads to create the instances and handle the requests. If I limit the execution to only 1 thread I'm getting more consistent results:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">160</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">154</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">188</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">223</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">182</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">156</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">155</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">152</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">183</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">152</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">151</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="n">Elapsed</span>: <span class="mi">150</span><span class="w"> </span><span class="n">us</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>This is much closer to the citerion results.</p>
<p>I assume that I'm getting a big performance hit from cache locality? Or maybe the shared <code>Module</code> &amp; <code>Engine</code> become a bottleneck? Nothing else is shared between the threads.</p>
<p>I will try to investigate this further and report back, but I'm not sure how to exactly pinpoint this kind of issues.</p>
</blockquote>



<a name="217021851"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/217021851" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#217021851">(Nov 17 2020 at 16:00)</a>:</h4>
<p>bkolobara <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-729025666">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>@alexcrichton I have created <a href="https://gist.github.com/bkolobara/5f0c946115900fb3eec0ba6cf28eff45">a modified version of your benchmark</a> using Rayon to instantiate in parallel.</p>
<p>Using <code>into_par_iter()</code> or <code>into_iter()</code> doesn't see to make any difference. I would expect the parallel one to take less time as the CPU utilisation is much higher during the benchmark. I could also be doing something obviously wrong <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>.</p>
</blockquote>



<a name="217120274"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/217120274" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#217120274">(Nov 18 2020 at 11:00)</a>:</h4>
<p>bkolobara edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-729025666">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>@alexcrichton I have created <a href="https://gist.github.com/bkolobara/5f0c946115900fb3eec0ba6cf28eff45">a modified version of your benchmark</a> using Rayon to instantiate in parallel.</p>
<p>Using <code>into_par_iter()</code> or <code>into_iter()</code> doesn't seem to make any difference. I would expect the parallel one to take less time as the CPU utilisation is much higher during the benchmark. I could also be doing something obviously wrong <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>.</p>
</blockquote>



<a name="217150435"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/217150435" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#217150435">(Nov 18 2020 at 15:33)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-729758992">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>Hm interesting! What plaform are you running on and what does the cpu count look like? I'm not sure if this means that there's high contention, though, it sort of makes sense that the per-iteration time doesn't change too too much in parallel vs non-parallel because there <em>shouldn't</em> be contention. I don't really understand the math behind criterion though to understand whether this is an expected result or not.</p>
<p>It is interesting though that with a threaded version of your application you're seeing higher overheads than without. That may point to a threading overhead though rather than a wasmtime overhead?</p>
<p>In any case though we're always looking for ways to improve instantiation time and with new work underway to merge lucet and wasmtime I suspect we'll continue to drive this number down.</p>
</blockquote>



<a name="231072330"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/231072330" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#231072330">(Mar 19 2021 at 18:50)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/2295#issuecomment-803041228">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>With <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/shared-host-functions.md">this rfc</a> merged and implemented I think this is now fixed.</p>
</blockquote>



<a name="231072331"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%232295%20Instantiation%20performance%20improvement/near/231072331" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.232295.20Instantiation.20performance.20improvement.html#231072331">(Mar 19 2021 at 18:50)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/2295">Issue #2295</a>:</p>
<blockquote>
<p>I'm working on an application where I create one Wasm Instance per HTTP request.</p>
<p>Now I have run into a performance issue where most of the response time is spent on instance creation. I'm not sure how I could structure my app to improve this.</p>
<p>I run a profiler to measure where time is spent exactly and here are some results:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="mi">47</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">func</span>::<span class="n">Func</span>::<span class="n">wrap</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">trampoline</span>::<span class="n">generate_raw_func_export</span><span class="w"></span>
<span class="mi">16</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime_runtime</span>::<span class="n">instance</span>::<span class="n">InstanceHandle</span>::<span class="n">dealloc</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">core</span>::<span class="n">ptr</span>::<span class="n">drop_in_place</span><span class="w"></span>
<span class="mi">16</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">linker</span>::<span class="n">Linker</span>::<span class="n">instantiate</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">instance</span>::<span class="n">Instance</span>::<span class="n">new</span><span class="w"></span>
<span class="w"> </span><span class="mi">7</span><span class="o">%</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">externals</span>::<span class="n">Memory</span>::<span class="n">new</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">externals</span>::<span class="n">Memory</span>::<span class="n">new</span><span class="w"></span>
<span class="w">      </span><span class="o">-</span><span class="n">wasmtime</span>::<span class="n">trampline</span>::<span class="n">generate_memory_export</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>My biggest issue is the almost 50% of time spent wrapping closures for the Linker (Linker::func). But I don't see a way around this as every Linker is connected to a Store, and because I need to create a Store per Instance I can't reuse the Linker (or they would belong to different Stores). Also, I'm capturing some per request environment in the closures and re-using Linkers would be hard in this case.</p>
<p>For now it's still ok, but as I keep adding functionality I'm afraid this is going to be a big issue. Is there a way I could improve this?</p>
<p>Also the 16% dealloc seems a bit big, but I'm not sure where this is exactly coming from.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>