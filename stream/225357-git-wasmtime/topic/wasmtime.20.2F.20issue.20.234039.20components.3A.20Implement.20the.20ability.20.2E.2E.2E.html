<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4039 components: Implement the ability ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html">wasmtime / issue #4039 components: Implement the ability ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="279117027"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/279117027" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#279117027">(Apr 15 2022 at 19:54)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1100338128">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<p>Note that procedurally this is based on <a href="https://github.com/bytecodealliance/wasmtime/pull/4005">https://github.com/bytecodealliance/wasmtime/pull/4005</a> so the first few commits aren't relevant to this PR itself. Additionally as with #4005 there are no tests, and this one definitely can't land without tests.</p>
</blockquote>



<a name="279118558"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/279118558" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#279118558">(Apr 15 2022 at 20:09)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1100364702">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @peterhuene</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "wasmtime:api", "wasmtime:config"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>peterhuene: wasmtime:api</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="279118579"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/279118579" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#279118579">(Apr 15 2022 at 20:10)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1100364816">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<h4>Label Messager: wasmtime:config</h4>
<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>
complete this check list:</p>
<ul>
<li>
<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>
      it.</p>
<p>&lt;details&gt;</p>
<p>Our documentation should be of the following form:</p>
<p>```text<br>
Short, simple summary sentence.</p>
<p>More details. These details can be multiple paragraphs. There should be<br>
information about not just the method, but its parameters and results as<br>
well.</p>
<p>Is this method fallible? If so, when can it return an error?</p>
<p>Can this method panic? If so, when does it panic?</p>
<h1>Example</h1>
<p>Optional example here.<br>
```</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>
  ensured that this configuration is exercised by the fuzz targets.</p>
<p>&lt;details&gt;</p>
<p>For example, if you expose a new strategy for allocating the next instance<br>
slot inside the pooling allocator, you should ensure that at least one of our<br>
fuzz targets exercises that new strategy.</p>
<p>Often, all that is required of you is to ensure that there is a knob for this<br>
configuration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>
of its nested <code>struct</code>s).</p>
<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>
configuration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you are enabling a configuration option by default, make sure that it<br>
  has been fuzzed for at least two weeks before turning it on by default.</p>
</li>
</ul>
<p>[fuzzing-config]: <a href="https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>
[fuzzing-docs]: <a href="https://docs.wasmtime.dev/contributing-fuzzing.html">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>
<hr>
<p>&lt;details&gt;</p>
<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>
<p>To add new label messages or remove existing label messages, edit the<br>
&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/label-messager-action">Learn more.</a></p>
<p>&lt;/details&gt;</p>
</blockquote>



<a name="279413054"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/279413054" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#279413054">(Apr 19 2022 at 14:02)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1102695917">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<blockquote>
<p>What if there were two ways to go from Value to Cursor? </p>
</blockquote>
<p>The reason I haven't gone with something like this is that the idiomatic thing to do is then the slow thing, which I've been trying to avoid. Existence of a <code>Value&lt;T&gt;</code> doesn't lock memory to a particular state or prevent mutations, so validation of a <code>Value&lt;T&gt;</code> must always be re-done. </p>
<p>It's also less-so validation and more just reading all the memory. Even if we were to somehow do ahead-of-time validation it means that when you read something like <code>list&lt;my-enum&gt;</code> that does all the decoding a second time which is also something we should be shooting to avoid for performant cases. Basically I think it's required that we interleave validation and decoding for performance, but to be strictly standards compliant we probably need to figure out how to force those two to happen given any <code>Value&lt;T&gt;</code></p>
</blockquote>



<a name="283125638"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/283125638" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#283125638">(May 20 2022 at 20:58)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1133368119">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<p>Still needs tests, so nothing new here, but I would like to confirm with other the subtyping store because that may or may not invalidate everything in this PR.</p>
</blockquote>



<a name="283785218"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/283785218" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#283785218">(May 24 2022 at 18:14)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1136283130">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<p>Ok I have written a mess of tests for this which indeed found some issues in the previous code. I've also opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4185">https://github.com/bytecodealliance/wasmtime/issues/4185</a> to track various items to make sure I don't forget them. Otherwise I think this is probably good to land now.</p>
<p>Currently I have not added support to <code>*.wast</code> for actually invoking component functions. I could do that (inventing some syntax for this along the way) along with statically listing "these are the signatures which can be called" or something like that. I opted to instead use custom embedding tests, but eventually I think it will be more useful to get <code>*.wast</code> support as well (but it's always limited in the sense that the callable signatures must be statically listed internally). If @fitzgen you or others have thoughts on how to improve the tests here I'm happy to change things up as well.</p>
</blockquote>



<a name="283788381"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/283788381" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#283788381">(May 24 2022 at 18:40)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1136307989">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<p>Ah let me write my thoughts on subtyping here as well.</p>
<p>I realized relatively late in the design process for  this feature that we did not factor in subtyping when crossing between the host and wasm. The major problem here is that the API designed here is where the host statically asserts the signature of a wasm componet function and then attempts to call it with that signature. Given subtyping, though, one might suspect that subtyping relationships would be respected in this typecheck. Implementation-wise, this is not supported.</p>
<p>For example if a wasm function export takes zero parameters, then the host could declare that it in fact takes 2 parameters. According to the subtyping rules these type signatures are compatible and this function call should be executed. If the parameters were strings though the host would copy in results to the module when calling it when it shouldn't do that.</p>
<p>A naive fix for this issue would be to always lower values in the context of a type. For example the <code>ComponentValue</code> trait would have a type added to the <code>lower</code> method where a value is lowered into a particular type (or stored as one). This means though that all layers of lowering are constantly performing typechecks to see if subtyping conversions are necessary. It's roughly predicted that the cost of this will be prohibitive and as such we wouldn't want to do that.</p>
<p>A much more advanced fix would be to generate trampolines. Compilation of a component would now also involve specifying the interface that an embedder would be using (e.g. the signature it expects for exports and the signatures for the imports). Appropriate trampolines would be generated and the host would call the trampolines which would "do the right thing". The problem with this strategy is that the host loses all flexibility of the layout of host data. Instead now everything has to be in a format that the trampoline understands. Additionally throwing in complexity of things like host destructors makes this much more complex as well.</p>
<p>Overall after talking with Luke the current thinking is to do this:</p>
<ul>
<li>Do not implement subtyping in host imports/exports. Everything has to have an exact signature match.</li>
<li>If subtyping is necessary, the component is wrapped in another component which uses the right signatures.</li>
</ul>
<p>The (hopeful) idea is that hosts can detect mismatches in type relationships. Hosts ideally have <code>*.wit</code> files or similar describing imports and exports, and that can be used to preprocess a component from a consumer to either verify that the types all line up or whether a second component is needed to perform the subtyping relationship. This component-to-component communication would then handle subtyping via the Cranelift-generated trampolines because type representation is all fixed with the canonical ABI and it's much easier to generate a trampoline. </p>
</blockquote>



<a name="283792968"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234039%20components%3A%20Implement%20the%20ability%20.../near/283792968" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234039.20components.3A.20Implement.20the.20ability.20.2E.2E.2E.html#283792968">(May 24 2022 at 19:17)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4039#issuecomment-1136340452">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4039">issue #4039</a>:</p>
<blockquote>
<blockquote>
<p>Overall after talking with Luke the current thinking is to do this:</p>
<div class="codehilite"><pre><span></span><code>* Do not implement subtyping in host imports/exports. Everything has to have an exact signature match.

* If subtyping is necessary, the component is wrapped in another component which uses the right signatures.
</code></pre></div>

<p>The (hopeful) idea is that hosts can detect mismatches in type relationships. Hosts ideally have <code>*.wit</code> files or similar describing imports and exports, and that can be used to preprocess a component from a consumer to either verify that the types all line up or whether a second component is needed to perform the subtyping relationship. This component-to-component communication would then handle subtyping via the Cranelift-generated trampolines because type representation is all fixed with the canonical ABI and it's much easier to generate a trampoline.</p>
</blockquote>
<p>This seems like a very reasonable path for us to go down.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>