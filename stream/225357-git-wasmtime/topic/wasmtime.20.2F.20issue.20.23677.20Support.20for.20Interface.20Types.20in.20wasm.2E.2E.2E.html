<html>
<head><meta charset="utf-8"><title>wasmtime / issue #677 Support for Interface Types in wasm... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html">wasmtime / issue #677 Support for Interface Types in wasm...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="238722622"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/238722622" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#238722622">(May 14 2021 at 06:02)</a>:</h4>
<p>Cypher1 <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-841029346">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>Status update?<br>
</p>
</blockquote>



<a name="262954690"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/262954690" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#262954690">(Nov 28 2021 at 23:35)</a>:</h4>
<p>yuhr <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-981174796">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>Is this project relevant here?</p>
<ul>
<li><a href="https://github.com/bytecodealliance/wai-bindgen">https://github.com/bytecodealliance/wai-bindgen</a></li>
</ul>
</blockquote>



<a name="269702697"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/269702697" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#269702697">(Jan 28 2022 at 08:38)</a>:</h4>
<p>tqwewe <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-1023997715">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>When running wasmtime in Rust I get an error saying support for interface types has been temorarily removed.</p>
<blockquote>
<p>for re-adding support for interface types you can see this issue</p>
</blockquote>
<p>I had a scan through the comments here on how to re-add support, but didn't see any solution.<br>
Is there any way of adding support back, or do we just need to wait?</p>
</blockquote>



<a name="269715516"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/269715516" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#269715516">(Jan 28 2022 at 10:34)</a>:</h4>
<p>tschneidereit <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-1024087373">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>Native support for Interface Types will be re-added to Wasmtime together<br>
with support for WebAssembly Components in the not-too-distant future. For<br>
now, wit-bindgen &lt;<a href="https://github.com/bytecodealliance/wit-bindgen">https://github.com/bytecodealliance/wit-bindgen</a>&gt;<br>
(formerly known as wai-bindgen / witx-bindgen) is the right way to use<br>
Interface Types, though note that the details of the IDL and the bindings<br>
are still changing in breaking ways.</p>
<p>@radu-matei recently published an excellent blog post<br>
&lt;<a href="https://radu-matei.com/blog/intro-wasm-components/">https://radu-matei.com/blog/intro-wasm-components/</a>&gt; describing how<br>
Components work and how to use wit-bindgen and other tools to work with<br>
them.</p>
</blockquote>



<a name="297659179"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/297659179" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#297659179">(Sep 07 2022 at 19:28)</a>:</h4>
<p>kushaldas <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-1239788583">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>Can someone please write some example on how to use <code>wit-bindgen</code> and write a module in Rust and then use it say from Python?</p>
</blockquote>



<a name="297694187"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/297694187" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#297694187">(Sep 08 2022 at 00:43)</a>:</h4>
<p>coderedart <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-1240064180">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<blockquote>
<p>Can someone please write some example on how to use <code>wit-bindgen</code> and write a module in Rust and then use it say from Python?</p>
</blockquote>
<p>I dont think you can do that yet because component model implementation is still ongoing <a href="https://github.com/bytecodealliance/wasmtime/issues/4185">https://github.com/bytecodealliance/wasmtime/issues/4185</a></p>
</blockquote>



<a name="398323865"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/398323865" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#398323865">(Oct 24 2023 at 16:28)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/677#issuecomment-1777599724">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>This is quite an old issue at this point and the component model is effectively fully supported in Wasmtime right now, so I'm going to close this.</p>
</blockquote>



<a name="398323866"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23677%20Support%20for%20Interface%20Types%20in%20wasm.../near/398323866" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23677.20Support.20for.20Interface.20Types.20in.20wasm.2E.2E.2E.html#398323866">(Oct 24 2023 at 16:28)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/677">issue #677</a>:</p>
<blockquote>
<p>I'd like to open this as a sort of meta-issue about supporting <a href="https://github.com/webassembly/interface-types">WebAssembly Interface Types</a> in the <code>wasmtime</code> crate and API. The current support via the <code>crates/interface-types</code> crate for the purpose of this issue can be basically ignored. It doesn't fit into the <code>wasmtime </code>crate API at all, it's outdated, and it's not how I think we want the API to look long-term.</p>
<p>The Interface Types proposal has settled a bit more on design lately, where the general idea is that there are a set of adapter types which adapter functions can use. The actual interface of a wasm module will be the adapter functions imported/exported, rather than the core wasm imports/exports.</p>
<p>For some more background, I've got a number of Rust projects supporting the current snapshot of the wasm interface types proposal:</p>
<ul>
<li><a href="https://crates.io/crates/wit-parser"><code>wit-parser</code></a> - an analogue of <code>wasmparser</code> but for the interface types binary format.</li>
<li><a href="https://crates.io/crates/wit-text"><code>wit-text</code></a> - an analogue of <code>wat</code>, but for the interface types text format.</li>
<li><a href="https://crates.io/crates/wit-validator"><code>wit-validator</code></a> - a crate which performs simple validation of the wasm interface types section of a module, if present</li>
<li><a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a> has now been updated to use these crates and emit wasm interface types modules compatible with the current proposal. This support hasn't been published, though, and I'd like to hold off until there's support in <code>wasmtime</code> itself.</li>
</ul>
<p>I've been thinking today about how best to integrate interface types into the <code>wasmtime</code> set of crates. There's a lot of moving pieces and lot of possibilities for how this can work, but I'd like to make a concrete proposal about how this could be integrated. This is going to be a pretty big change, though, so I'd want to be sure to get buy-in from relevant folks before moving forward.</p>
<p>The general gist of what I'm thinking is:</p>
<ul>
<li>The <code>wasmtime</code> crate doesn't actually change a whole lot, but the <a href="https://docs.rs/wasmtime/0.8.0/wasmtime/enum.ValType.html"><code>ValType</code></a> and <a href="https://docs.rs/wasmtime/0.8.0/wasmtime/enum.Val.html"><code>Val</code></a> enumerations are extended with all types from the interface types proposal. This namely means signed/unsigned 8-64 bit integers as well as a string type will show up. </li>
<li>The exports listed by <code>wasmtime</code> modules/instances change depending on the presence of the wasm interface types section.<ul>
<li>If not present, then everything is the same as it is today</li>
<li>If present, the core module exports are ignored and the only exported items are the items listed in the wasm interface types section.</li>
</ul>
</li>
<li>The imports taken during instantiation are a bit tricky. Today they're a list of imports which correspond 1-to-1 with the list of imports reported from a module. I think we'll still want this 1-to-1 matching, but the list of imports reported from a module will be modified as follows:<ul>
<li>If no interface types section is present, everything is the same as it is today.</li>
<li>If the interface types section is present, then some of the imports of the core module may be satisfied by the adapter functions. To handle this the list of imports required to instantiate the module will first be the set of core wasm imports, in order, that do not have adapters hooked up to them. Then the adapter imports will be listed.</li>
</ul>
</li>
<li>The C API would receive similar updates. The <a href="https://docs.rs/wasmtime/0.8.0/wasmtime/wasm/struct.wasm_val_t.html"><code>wasm_val_t</code></a> type would have a few new codes for <code>wasm_valkind_t</code> and the union would have a few more items packed inside of it. I haven't thought a huge amount about the ownership of strings and such, but I'm assuming that we can think of something pretty reasonable here.</li>
<li>As a minor change, the <code>wasmtime</code> executable would use the <code>wit_text</code> crate to parse input files, which would parse any of <code>*.wat</code>, <code>*.wasm</code>, or <code>*.wit</code> files. </li>
</ul>
<p>After these changes are implemented then the <code>crates/interface-types</code> crate would just be deleted, since it is no longer needed. The Python/Rust extensions would be updated to use the <code>wasmtime</code> crate directly, and would provide all necessary mappings for strings/etc. Additionally the .NET extension could be updated with more support since this would all be present in the C API.</p>
<p>Some questions I've wanted to make sure we've got covered when landing all this are:</p>
<h2>How will future interface types changes affect this design?</h2>
<p>Given this setup the only public-facing change to the design of interface types will be the set of supported types/values. Otherwise I think everything else can be internal changes (yay!) which we take care of one way or another.</p>
<h2>How will adapters get implemented today?</h2>
<p>I'm thinking that we'll basically just have an "interpreter" for all adapter instructions. Eventually we can get fancier with more JIT-like support but I'd like to get the bare-bones up and running first.</p>
<h2>What about the laziness of types?</h2>
<p>One of the ideas in the interface types proposal is that adapter instructions are often lazy to minimize copying data between various locations. This'll all boil down to the <code>Val::String</code> representation I think. For now I'm imagaining something like <code>Val::String</code> holding a memory reference, pointer, and length. That way when requested you can read off the entire string, or if you want you could get raw access and peek at the bytes yourself. I'm not really 100% sure how this will work though, but I'm also assuming that it's ok to "cop out" in the interim and "just use <code>String</code>" to see how far it gets us.</p>
<p>This is something I'm particularly curious to hear feedback on though. Especially as more and more types come into the interface types proposal, this is going to get more and more important. For example it'd be pretty awesome if we could start <strong>now</strong> defining wasi APIs in terms of interface types, but this is all likely a good ways off so perhaps a bit premature to worry about this.</p>
<h2>What about linking modules together?</h2>
<p>I'm not even gonna try to approach this in a first pass. The main interesting thing here is that if you link together two wasm modules using wasm interface types you can ideally create a highly-optimized adapter function in the middle of the two. I don't plan to tackle this in our initial support though, and while this should work one way or another, it'll likely be relatively slow and copy/allocation-heavy.</p>
<h2>Is <code>wasmtime</code> the right crate to put this in wrt stability?</h2>
<p>Interface types and its proposal are pretty unstable, with lots going to change now and in the future. Is it ok to <em>now</em> hook up the interface types proposal into the public API of <code>wasmtime</code>? That will be a continued source of instability for consumers of the API (new type variants basically). I'm hoping that new types don't come along all that often, and I'm also hoping that stability isn't necessarily paramount in the <code>wasmtime</code> crate yet that this is ok.</p>
<p>I don't really have many other alternatives though of how to integrate interface types into the wasmtime project. So if others think that interface types are too unstable to go into the <code>wasmtime</code> crate, now would be a good time to discuss that, as well as possible mitigations :)</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>