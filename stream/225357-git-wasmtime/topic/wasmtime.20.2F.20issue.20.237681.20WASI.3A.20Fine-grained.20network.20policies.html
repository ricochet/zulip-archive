<html>
<head><meta charset="utf-8"><title>wasmtime / issue #7681 WASI: Fine-grained network policies · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html">wasmtime / issue #7681 WASI: Fine-grained network policies</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="407754211"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/407754211" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#407754211">(Dec 13 2023 at 15:40)</a>:</h4>
<p>badeend opened <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>#7662 is a good first step towards letting users of the wasmtime library customize network behavior. After that change, library users have two options: either use <code>inherit_network</code> which grants access to everything, or use <code>socket_addr_check</code> which allows the user to define arbitrarily complex rules. The upside of that last one is also its downside: the user _must_ define everything themself. On the command-line, the available choices are quite limiting: everything or nothing at all. Guess which one users will pick :P</p>
<p>I would like to add a middle ground option for both library &amp; CLI users. This option should provide a default "good enough" option for the majority of users, while still allowing to fall back to fully customized control. My objective is to be able to declare network policies based on:</p>
<ul>
<li>Domain name</li>
<li>Initiator (client vs server)</li>
<li>Protocol (TCP, UDP, HTTP(S))</li>
</ul>
<p>I tried to capture the gist of it in pseudo code:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// A single network permission</span>
<span class="k">enum</span> <span class="nc">Grant</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to connect to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">TcpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to listen on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">TcpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to initiate flows to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">UdpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to handle incoming flows on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">UdpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allows the component to make outgoing HTTP connections</span>
<span class="w">    </span><span class="n">HttpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scheme</span>: <span class="nc">Http</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Https</span><span class="p">,</span>
<span class="w">        </span><span class="n">host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>


<span class="c1">// "*"             -&gt; RemoteHostPattern::Any</span>
<span class="c1">// "localhost"     -&gt; RemoteHostPattern::Loopback</span>
<span class="c1">// "example.com"   -&gt; RemoteHostPattern::Domain(DomainPattern::Single("example.com"))</span>
<span class="c1">// "*.example.com" -&gt; RemoteHostPattern::Domain(DomainPattern::Wildcard("example.com"))</span>
<span class="c1">// "192.0.2.0"     -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "192.0.2.0/24"  -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0/24".into())</span>
<span class="k">enum</span> <span class="nc">RemoteHostPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="w">    </span><span class="n">Domain</span><span class="p">(</span><span class="n">DomainPattern</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; RemotePortPattern::Range(1..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; invalid</span>
<span class="c1">// "80"          -&gt; RemotePortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; RemotePortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">RemotePortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"         -&gt; LocalInterfacePattern::Any</span>
<span class="c1">// "localhost" -&gt; LocalInterfacePattern::Loopback</span>
<span class="c1">// "192.0.2.0" -&gt; LocalInterfacePattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "::"        -&gt; LocalInterfacePattern::Ip(IpRange("::".into())</span>
<span class="k">enum</span> <span class="nc">LocalInterfacePattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `0.0.0.0` and `::`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; LocalPortPattern::Range(0..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; LocalPortPattern::Ephemeral</span>
<span class="c1">// "80"          -&gt; LocalPortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; LocalPortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">LocalPortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Ephemeral</span><span class="p">,</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>



<span class="k">type</span> <span class="nc">PortRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Can also represent single ports by storing an identical `start` and `end` port.</span>

<span class="k">struct</span> <span class="nc">IpRange</span><span class="p">(</span><span class="n">ipnet</span>::<span class="n">IpNet</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can also represent a single address</span>

<span class="k">struct</span> <span class="nc">Domain</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span>

<span class="k">enum</span> <span class="nc">DomainPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Single</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span>
<span class="w">    </span><span class="n">Wildcard</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span><span class="w"> </span><span class="c1">// Allows the domain itself, along with every subdomain.</span>
<span class="p">}</span>
</code></pre></div>
<h2>Domain-based policy strategy</h2>
<p>THe IP and Port-based patterns above should speak for themselves. The domain name policies might need to explanation: the idea is to hook into <code>ip-name-lookup::resolve-addresses</code> to keep track of which IP address belongs to which domain names at runtime:<br>
- In <code>ip-name-lookup::resolve-addresses</code>:<br>
    - Before making the syscall: validate that any TcpOutbound or UdpOutbound grant exists with a <code>Any</code> or matching <code>Domain</code> host pattern.<br>
    - After making the syscall: if the previous step matched any <code>Domain</code>-based grants: register the resolved addresses in <code>DynamicPolicy::resolved_names</code> (see below)<br>
- In <code>tcp-socket::bind</code>: validate that any TcpOutbound or TcpInbound grant exists with a matching <code>local_interface</code> and <code>local_port</code><br>
- In <code>tcp-socket::connect</code>, validate that any TcpOutbound grant matches the <code>local_interface</code> &amp; <code>local_port</code>. Also match the <code>remote_host</code> &amp; <code>remote_port</code>:<br>
    - first by the IP address passed to the connect call. If none found:<br>
    - then by all <code>resolved_names</code> for that IP.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicyConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Shared across many component instances.</span>
<span class="w">    </span><span class="n">grants</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Grant</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Instantiated once per component</span>
<span class="w">    </span><span class="c1">// Reference to the "static" rules:</span>
<span class="w">    </span><span class="n">config</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">DynamicPolicyConfig</span><span class="o">&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Mapping between resolved IP addresses and the queried domain names.</span>
<span class="w">    </span><span class="n">resolved_names</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// (Recently) active UDP flows</span>
<span class="w">    </span><span class="n">udp_flows</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="p">(</span><span class="cm">/*local*/</span><span class="n">SocketAddr</span><span class="p">,</span><span class="w"> </span><span class="cm">/*remote*/</span><span class="n">SocketAddr</span><span class="p">),</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<h2>UDP directionality</h2>
<p>UDP has no traditional notion of "client" and "server". However, in practice many UDP applications do fit that model. I've modeled the grant types above based on what stateful firewall do. In order to know the directionality (inbound vs outbound) we need to keep track of "who talked first".</p>
<h2>CLI syntax</h2>
<p>Inbound syntax, inspired by Docker:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="w">                      </span><span class="c1">// Grant::TcpInbound(...) &amp; Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">tcp</span><span class="w">                  </span><span class="c1">// Grant::TcpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">                  </span><span class="c1">// Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mf">127.0.0.1</span>:<span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">        </span><span class="c1">// Grant::UdpInbound(..., local_interface: "127.0.0.1")</span>
</code></pre></div>
<p>Outbound syntax:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">tcp</span>:<span class="c1">//example.com:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">udp</span>:<span class="c1">//192.168.0.1:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">http</span>:<span class="c1">//*.example.com/   // Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//example.com/    // Grant::HttpOutbound(...)</span>
</code></pre></div>
<p>Let me know what you think.<br>
</p>
</blockquote>



<a name="407755161"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/407755161" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#407755161">(Dec 13 2023 at 15:45)</a>:</h4>
<p>badeend edited <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>#7662 is a good first step towards letting users of the wasmtime library customize network behavior. After that change, library users have two options: either use <code>inherit_network</code> which grants access to everything, or use <code>socket_addr_check</code> which allows the user to define arbitrarily complex rules. The upside of that last one is also its downside: the user _must_ define everything themself. On the command-line, the available choices are quite limited: everything or nothing at all. Guess which one users will pick :P</p>
<p>I would like to add a middle ground option for both library &amp; CLI users. This option should provide a default "good enough" option for the majority of users, while still allowing to fall back to fully customized control. My objective is to be able to declare network policies based on:</p>
<ul>
<li>Domain name</li>
<li>Initiator (client vs server)</li>
<li>Protocol (TCP, UDP, HTTP(S))</li>
</ul>
<p>I tried to capture the gist of it in pseudo code:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// A single network permission</span>
<span class="k">enum</span> <span class="nc">Grant</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to connect to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">TcpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to listen on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">TcpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to initiate flows to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">UdpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to handle incoming flows on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">UdpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allows the component to make outgoing HTTP connections</span>
<span class="w">    </span><span class="n">HttpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scheme</span>: <span class="nc">Http</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Https</span><span class="p">,</span>
<span class="w">        </span><span class="n">host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>


<span class="c1">// "*"             -&gt; RemoteHostPattern::Any</span>
<span class="c1">// "localhost"     -&gt; RemoteHostPattern::Loopback</span>
<span class="c1">// "example.com"   -&gt; RemoteHostPattern::Domain(DomainPattern::Single("example.com"))</span>
<span class="c1">// "*.example.com" -&gt; RemoteHostPattern::Domain(DomainPattern::Wildcard("example.com"))</span>
<span class="c1">// "192.0.2.0"     -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "192.0.2.0/24"  -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0/24".into())</span>
<span class="k">enum</span> <span class="nc">RemoteHostPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="w">    </span><span class="n">Domain</span><span class="p">(</span><span class="n">DomainPattern</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; RemotePortPattern::Range(1..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; invalid</span>
<span class="c1">// "80"          -&gt; RemotePortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; RemotePortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">RemotePortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"         -&gt; LocalInterfacePattern::Any</span>
<span class="c1">// "localhost" -&gt; LocalInterfacePattern::Loopback</span>
<span class="c1">// "192.0.2.0" -&gt; LocalInterfacePattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "::"        -&gt; LocalInterfacePattern::Ip(IpRange("::".into())</span>
<span class="k">enum</span> <span class="nc">LocalInterfacePattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `0.0.0.0` and `::`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; LocalPortPattern::Range(0..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; LocalPortPattern::Ephemeral</span>
<span class="c1">// "80"          -&gt; LocalPortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; LocalPortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">LocalPortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Ephemeral</span><span class="p">,</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>



<span class="k">type</span> <span class="nc">PortRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Can also represent single ports by storing an identical `start` and `end` port.</span>

<span class="k">struct</span> <span class="nc">IpRange</span><span class="p">(</span><span class="n">ipnet</span>::<span class="n">IpNet</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can also represent a single address</span>

<span class="k">struct</span> <span class="nc">Domain</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span>

<span class="k">enum</span> <span class="nc">DomainPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Single</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span>
<span class="w">    </span><span class="n">Wildcard</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span><span class="w"> </span><span class="c1">// Allows the domain itself, along with every subdomain.</span>
<span class="p">}</span>
</code></pre></div>
<h2>Domain-based policy strategy</h2>
<p>THe IP and Port-based patterns above should speak for themselves. The domain name policies might need to explanation: the idea is to hook into <code>ip-name-lookup::resolve-addresses</code> to keep track of which IP address belongs to which domain names at runtime:<br>
- In <code>ip-name-lookup::resolve-addresses</code>:<br>
    - Before making the syscall: validate that any TcpOutbound or UdpOutbound grant exists with a <code>Any</code> or matching <code>Domain</code> host pattern.<br>
    - After making the syscall: if the previous step matched any <code>Domain</code>-based grants: register the resolved addresses in <code>DynamicPolicy::resolved_names</code> (see below)<br>
- In <code>tcp-socket::bind</code>: validate that any TcpOutbound or TcpInbound grant exists with a matching <code>local_interface</code> and <code>local_port</code><br>
- In <code>tcp-socket::connect</code>, validate that any TcpOutbound grant matches the <code>local_interface</code> &amp; <code>local_port</code>. Also match the <code>remote_host</code> &amp; <code>remote_port</code>:<br>
    - first by the IP address passed to the connect call. If none found:<br>
    - then by all <code>resolved_names</code> for that IP.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicyConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Shared across many component instances.</span>
<span class="w">    </span><span class="n">grants</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Grant</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Instantiated once per component</span>
<span class="w">    </span><span class="c1">// Reference to the "static" rules:</span>
<span class="w">    </span><span class="n">config</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">DynamicPolicyConfig</span><span class="o">&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Mapping between resolved IP addresses and the queried domain names.</span>
<span class="w">    </span><span class="n">resolved_names</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// (Recently) active UDP flows</span>
<span class="w">    </span><span class="n">udp_flows</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="p">(</span><span class="cm">/*local*/</span><span class="n">SocketAddr</span><span class="p">,</span><span class="w"> </span><span class="cm">/*remote*/</span><span class="n">SocketAddr</span><span class="p">),</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<h2>UDP directionality</h2>
<p>UDP has no traditional notion of "client" and "server". However, in practice many UDP applications do fit that model. I've modeled the grant types above based on what stateful firewall do. In order to know the directionality (inbound vs outbound) we need to keep track of "who talked first".</p>
<h2>CLI syntax</h2>
<p>Inbound syntax, inspired by Docker:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="w">                      </span><span class="c1">// Grant::TcpInbound(...) &amp; Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">tcp</span><span class="w">                  </span><span class="c1">// Grant::TcpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">                  </span><span class="c1">// Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mf">127.0.0.1</span>:<span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">        </span><span class="c1">// Grant::UdpInbound(..., local_interface: "127.0.0.1")</span>
</code></pre></div>
<p>Outbound syntax:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">tcp</span>:<span class="c1">//example.com:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">udp</span>:<span class="c1">//192.168.0.1:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">http</span>:<span class="c1">//*.example.com/   // Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//example.com/    // Grant::HttpOutbound(...)</span>
</code></pre></div>
<p>Let me know what you think.<br>
</p>
</blockquote>



<a name="407755972"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/407755972" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#407755972">(Dec 13 2023 at 15:49)</a>:</h4>
<p>badeend edited <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>#7662 is a good first step towards letting users of the wasmtime library customize network behavior. After that change, library users have two options: either use <code>inherit_network</code> which grants access to everything, or use <code>socket_addr_check</code> which allows the user to define arbitrarily complex rules. The upside of that last one is also its downside: the user _must_ define everything themself. On the command-line, the available choices are quite limited: everything or nothing at all. Guess which one users will pick :P</p>
<p>I would like to add a middle ground option for both library &amp; CLI users. This option should provide a default "good enough" option for the majority of users, while still allowing to fall back to fully customized control. My objective is to be able to declare network policies based on:</p>
<ul>
<li>Domain name</li>
<li>Initiator (client vs server)</li>
<li>Protocol (TCP, UDP, HTTP(S))</li>
</ul>
<p>I tried to capture the gist of it in pseudo code:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// A single network permission</span>
<span class="k">enum</span> <span class="nc">Grant</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to connect to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">TcpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to listen on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">TcpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to initiate flows to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">UdpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to handle incoming flows on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">UdpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allows the component to make outgoing HTTP connections</span>
<span class="w">    </span><span class="n">HttpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scheme</span>: <span class="nc">Http</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Https</span><span class="p">,</span>
<span class="w">        </span><span class="n">host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>


<span class="c1">// "*"             -&gt; RemoteHostPattern::Any</span>
<span class="c1">// "localhost"     -&gt; RemoteHostPattern::Loopback</span>
<span class="c1">// "example.com"   -&gt; RemoteHostPattern::Domain(DomainPattern::Single("example.com"))</span>
<span class="c1">// "*.example.com" -&gt; RemoteHostPattern::Domain(DomainPattern::Wildcard("example.com"))</span>
<span class="c1">// "192.0.2.0"     -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "192.0.2.0/24"  -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0/24".into())</span>
<span class="k">enum</span> <span class="nc">RemoteHostPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="w">    </span><span class="n">Domain</span><span class="p">(</span><span class="n">DomainPattern</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; RemotePortPattern::Range(1..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; invalid</span>
<span class="c1">// "80"          -&gt; RemotePortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; RemotePortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">RemotePortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"         -&gt; LocalInterfacePattern::Any</span>
<span class="c1">// "localhost" -&gt; LocalInterfacePattern::Loopback</span>
<span class="c1">// "192.0.2.0" -&gt; LocalInterfacePattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "::"        -&gt; LocalInterfacePattern::Ip(IpRange("::".into())</span>
<span class="k">enum</span> <span class="nc">LocalInterfacePattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `0.0.0.0` and `::`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; LocalPortPattern::Range(0..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; LocalPortPattern::Ephemeral</span>
<span class="c1">// "80"          -&gt; LocalPortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; LocalPortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">LocalPortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Ephemeral</span><span class="p">,</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>



<span class="k">type</span> <span class="nc">PortRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Can also represent single ports by storing an identical `start` and `end` port.</span>

<span class="k">struct</span> <span class="nc">IpRange</span><span class="p">(</span><span class="n">ipnet</span>::<span class="n">IpNet</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can also represent a single address</span>

<span class="k">struct</span> <span class="nc">Domain</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span>

<span class="k">enum</span> <span class="nc">DomainPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Single</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span>
<span class="w">    </span><span class="n">Wildcard</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span><span class="w"> </span><span class="c1">// Allows the domain itself, along with every subdomain.</span>
<span class="p">}</span>
</code></pre></div>
<h2>Domain-based policy strategy</h2>
<p>THe IP and Port-based patterns above should speak for themselves. The domain name policies might need to explanation: the idea is to hook into <code>ip-name-lookup::resolve-addresses</code> to keep track of which IP address belongs to which domain names at runtime:<br>
- In <code>ip-name-lookup::resolve-addresses</code>:<br>
    - Before making the syscall: validate that any TcpOutbound or UdpOutbound grant exists with a <code>Any</code> or matching <code>Domain</code> host pattern.<br>
    - After making the syscall: if the previous step matched any <code>Domain</code>-based grants: register the resolved addresses in <code>DynamicPolicy::resolved_names</code> (see below)<br>
- In <code>tcp-socket::bind</code>: validate that any TcpOutbound or TcpInbound grant exists with a matching <code>local_interface</code> and <code>local_port</code><br>
- In <code>tcp-socket::connect</code>, validate that any TcpOutbound grant matches the <code>local_interface</code> &amp; <code>local_port</code>. Also match the <code>remote_host</code> &amp; <code>remote_port</code>:<br>
    - first by the IP address passed to the connect call. If none found:<br>
    - then by all <code>resolved_names</code> for that IP.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicyConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Shared across many component instances.</span>
<span class="w">    </span><span class="n">grants</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Grant</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Instantiated once per component</span>
<span class="w">    </span><span class="c1">// Reference to the "static" rules:</span>
<span class="w">    </span><span class="n">config</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">DynamicPolicyConfig</span><span class="o">&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Mapping between resolved IP addresses and the queried domain names.</span>
<span class="w">    </span><span class="n">resolved_names</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// (Recently) active UDP flows</span>
<span class="w">    </span><span class="n">udp_flows</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="p">(</span><span class="cm">/*local*/</span><span class="n">SocketAddr</span><span class="p">,</span><span class="w"> </span><span class="cm">/*remote*/</span><span class="n">SocketAddr</span><span class="p">),</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<h2>UDP directionality</h2>
<p>UDP has no traditional notion of "client" and "server". However, in practice many UDP applications do fit that model. I've modeled the grant types above based on what stateful firewall do. In order to know the directionality (inbound vs outbound) we need to keep track of "who talked first".</p>
<h2>CLI syntax</h2>
<p>Inbound syntax, inspired by Docker:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="w">                      </span><span class="c1">// Grant::TcpInbound(...) &amp; Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">tcp</span><span class="w">                  </span><span class="c1">// Grant::TcpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">                  </span><span class="c1">// Grant::UdpInbound(...)</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mf">127.0.0.1</span>:<span class="mi">80</span><span class="o">/</span><span class="n">udp</span><span class="w">        </span><span class="c1">// Grant::UdpInbound(..., local_interface: "127.0.0.1")</span>
</code></pre></div>
<p>Outbound syntax:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">tcp</span>:<span class="c1">//example.com:80    // Grant::TcpOutbound(...) &amp; Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">udp</span>:<span class="c1">//192.168.0.1:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">http</span>:<span class="c1">//*.example.com/   // Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//example.com/    // Grant::HttpOutbound(...)</span>
</code></pre></div>
<p>Let me know what you think.<br>
</p>
</blockquote>



<a name="407756751"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/407756751" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#407756751">(Dec 13 2023 at 15:54)</a>:</h4>
<p>badeend edited <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>#7662 is a good first step towards letting users of the wasmtime library customize network behavior. After that change, library users have two options: either use <code>inherit_network</code> which grants access to everything, or use <code>socket_addr_check</code> which allows the user to define arbitrarily complex rules. The upside of that last one is also its downside: the user _must_ define everything themself. On the command-line, the available choices are quite limited: everything or nothing at all. Guess which one users will pick :P</p>
<p>I would like to add a middle ground option for both library &amp; CLI users. This option should provide a default "good enough" option for the majority of users, while still allowing to fall back to fully customized control. My objective is to be able to declare network policies based on:</p>
<ul>
<li>Domain name</li>
<li>Initiator (client vs server)</li>
<li>Protocol (TCP, UDP, HTTP(S))</li>
</ul>
<p>I tried to capture the gist of it in pseudo code:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// A single network permission</span>
<span class="k">enum</span> <span class="nc">Grant</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to connect to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">TcpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow TCP sockets to listen on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">TcpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to initiate flows to remote_host/port, optionally using a specific local_interface/port</span>
<span class="w">    </span><span class="n">UdpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">remote_host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">remote_port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalPortPattern::Ephemeral</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allow UDP sockets to handle incoming flows on a local port, optionally using a specific local_interface too</span>
<span class="w">    </span><span class="n">UdpInbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_port</span>: <span class="nc">LocalPortPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">local_interface</span>: <span class="nc">LocalInterfacePattern</span><span class="p">,</span><span class="w"> </span><span class="c1">// default = LocalInterfacePattern::Any</span>
<span class="w">    </span><span class="p">},</span>

<span class="w">    </span><span class="c1">// Allows the component to make outgoing HTTP connections</span>
<span class="w">    </span><span class="n">HttpOutbound</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">scheme</span>: <span class="nc">Http</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Https</span><span class="p">,</span>
<span class="w">        </span><span class="n">host</span>: <span class="nc">RemoteHostPattern</span><span class="p">,</span>
<span class="w">        </span><span class="n">port</span>: <span class="nc">RemotePortPattern</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">}</span>


<span class="c1">// "*"             -&gt; RemoteHostPattern::Any</span>
<span class="c1">// "localhost"     -&gt; RemoteHostPattern::Loopback</span>
<span class="c1">// "example.com"   -&gt; RemoteHostPattern::Domain(DomainPattern::Single("example.com"))</span>
<span class="c1">// "*.example.com" -&gt; RemoteHostPattern::Domain(DomainPattern::Wildcard("example.com"))</span>
<span class="c1">// "192.0.2.0"     -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "192.0.2.0/24"  -&gt; RemoteHostPattern::Ip(IpRange("192.0.2.0/24".into())</span>
<span class="k">enum</span> <span class="nc">RemoteHostPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="w">    </span><span class="n">Domain</span><span class="p">(</span><span class="n">DomainPattern</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; RemotePortPattern::Range(1..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; invalid</span>
<span class="c1">// "80"          -&gt; RemotePortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; RemotePortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">RemotePortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"         -&gt; LocalInterfacePattern::Any</span>
<span class="c1">// "localhost" -&gt; LocalInterfacePattern::Loopback</span>
<span class="c1">// "192.0.2.0" -&gt; LocalInterfacePattern::Ip(IpRange("192.0.2.0".into())</span>
<span class="c1">// "::"        -&gt; LocalInterfacePattern::Ip(IpRange("::".into())</span>
<span class="k">enum</span> <span class="nc">LocalInterfacePattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Any</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `0.0.0.0` and `::`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Loopback</span><span class="p">,</span><span class="w"> </span><span class="c1">// Effectively `127.0.0.0/8` and `::1`, but without committing to a specific address family.</span>
<span class="w">    </span><span class="n">Ip</span><span class="p">(</span><span class="n">IpRange</span><span class="p">),</span>
<span class="p">}</span>


<span class="c1">// "*"           -&gt; LocalPortPattern::Range(0..=u16::MAX))</span>
<span class="c1">// "0"           -&gt; LocalPortPattern::Ephemeral</span>
<span class="c1">// "80"          -&gt; LocalPortPattern::Range(80..=80))</span>
<span class="c1">// "35000-35999" -&gt; LocalPortPattern::Range(35000..=35999))</span>
<span class="k">enum</span> <span class="nc">LocalPortPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Ephemeral</span><span class="p">,</span>
<span class="w">    </span><span class="n">Range</span><span class="p">(</span><span class="n">PortRange</span><span class="p">),</span>
<span class="p">}</span>



<span class="k">type</span> <span class="nc">PortRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Can also represent single ports by storing an identical `start` and `end` port.</span>

<span class="k">struct</span> <span class="nc">IpRange</span><span class="p">(</span><span class="n">ipnet</span>::<span class="n">IpNet</span><span class="p">);</span><span class="w"> </span><span class="c1">// Can also represent a single address</span>

<span class="k">struct</span> <span class="nc">Domain</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span>

<span class="k">enum</span> <span class="nc">DomainPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Single</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span>
<span class="w">    </span><span class="n">Wildcard</span><span class="p">(</span><span class="n">Domain</span><span class="p">),</span><span class="w"> </span><span class="c1">// Allows the domain itself, along with every subdomain.</span>
<span class="p">}</span>
</code></pre></div>
<h2>Domain-based policy strategy</h2>
<p>THe IP and Port-based patterns above should speak for themselves. The domain name policies might need to explanation: the idea is to hook into <code>ip-name-lookup::resolve-addresses</code> to keep track of which IP address belongs to which domain names at runtime:<br>
- In <code>ip-name-lookup::resolve-addresses</code>:<br>
    - Before making the syscall: validate that any TcpOutbound or UdpOutbound grant exists with a <code>Any</code> or matching <code>Domain</code> host pattern.<br>
    - After making the syscall: if the previous step matched any <code>Domain</code>-based grants: register the resolved addresses in <code>DynamicPolicy::resolved_names</code> (see below)<br>
- In <code>tcp-socket::bind</code>: validate that any TcpOutbound or TcpInbound grant exists with a matching <code>local_interface</code> and <code>local_port</code><br>
- In <code>tcp-socket::connect</code>, validate that any TcpOutbound grant matches the <code>local_interface</code> &amp; <code>local_port</code>. Also match the <code>remote_host</code> &amp; <code>remote_port</code>:<br>
    - first by the IP address passed to the connect call. If none found:<br>
    - then by all <code>resolved_names</code> for that IP.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicyConfig</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Shared across many component instances.</span>
<span class="w">    </span><span class="n">grants</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Grant</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DynamicPolicy</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Instantiated once per component</span>
<span class="w">    </span><span class="c1">// Reference to the "static" rules:</span>
<span class="w">    </span><span class="n">config</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">DynamicPolicyConfig</span><span class="o">&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Mapping between resolved IP addresses and the queried domain names.</span>
<span class="w">    </span><span class="n">resolved_names</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="p">,</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;&gt;</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// (Recently) active UDP flows</span>
<span class="w">    </span><span class="n">udp_flows</span>: <span class="nc">LruCache</span><span class="o">&lt;</span><span class="p">(</span><span class="cm">/*local*/</span><span class="n">SocketAddr</span><span class="p">,</span><span class="w"> </span><span class="cm">/*remote*/</span><span class="n">SocketAddr</span><span class="p">),</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div>
<h2>UDP directionality</h2>
<p>UDP has no traditional notion of "client" and "server". However, in practice many UDP applications do fit that model. I've modeled the grant types above based on what stateful firewall do. In order to know the directionality (inbound vs outbound) we need to keep track of "who talked first".</p>
<h2>CLI syntax</h2>
<p>Inbound syntax:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mi">80</span><span class="w">                      </span><span class="c1">// Grant::TcpInbound(...) &amp; Grant::UdpInbound(...) // Shorthand inspired by Docker</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="mf">127.0.0.1</span>:<span class="mi">80</span><span class="w">            </span><span class="c1">// Grant::TcpInbound(..., local_interface: "127.0.0.1") &amp; Grant::UdpInbound(..., local_interface: "127.0.0.1")</span>
<span class="o">--</span><span class="n">expose</span><span class="w"> </span><span class="n">udp</span>:<span class="c1">//127.0.0.1:80      // Grant::UdpInbound(..., local_interface: "127.0.0.1")</span>
</code></pre></div>
<p>Outbound syntax:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">tcp</span>:<span class="c1">//example.com:80    // Grant::TcpOutbound(...) &amp; Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">udp</span>:<span class="c1">//192.168.0.1:80    // Grant::TcpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">http</span>:<span class="c1">//*.example.com/   // Grant::HttpOutbound(...)</span>
<span class="o">--</span><span class="n">connect</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//example.com/    // Grant::HttpOutbound(...)</span>
</code></pre></div>
<p>Let me know what you think.<br>
</p>
</blockquote>



<a name="408469442"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/408469442" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#408469442">(Dec 17 2023 at 18:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1859248072">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>This all sounds like a great idea to me, thanks for writing this up @badeend! </p>
<p>One comment I would have is that I think it would be best to implement this in a way that's not baked-in to <code>wasmtime-wasi</code> itself, e.g. baking it into the <code>WasiCtx</code>. You've seen already (but for others reading this too) discussion at <a href="https://github.com/bytecodealliance/wasmtime/issues/7694">https://github.com/bytecodealliance/wasmtime/issues/7694</a> about ways we might achieve that, and I think it would be good if we could fit this model into that extension. Put another way this could be one implementation of <code>socket_addr_check</code> (more-or-less, I realize that single callback isn't enough) that embedders could opt-in to.</p>
<p>I think this is pretty reasonable syntax to add to the CLI though and I definitely agree it'd be best to have more than just an "everything on" switch!</p>
</blockquote>



<a name="408582500"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/408582500" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#408582500">(Dec 18 2023 at 10:45)</a>:</h4>
<p>rylev <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1860089025">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>This all looks really great! Seems like we're headed in the right direction. A few small thoughts and questions:</p>
<ul>
<li>I see that <code>tcp://example.com:80</code> implies allowing <code>wasi:http</code> usage. I'm not sure this is a good idea. For example, this does not make sense in an HTTP/3 world.</li>
<li>For the CLI syntax, we might want to consider always requiring a port. So if the user does not care about which port, they must opt into that through like so <code>tcp://example.com:*</code></li>
<li>What do port ranges look like on the CLI look like? I would imagine we would support a syntax that mirrors Rust exclusive range syntax like <code>5000..6000</code> and <code>1023..</code>.</li>
<li>Will we allow lists of domains? Something like <code>https:{example.com, google.com}:*</code> or do we expect those always to be listed out separately? I think I would lean towards requiring they be listed separately.</li>
<li>This isn't really related to this change since it's a result of the way they wasi interfaces line up, but I'm slightly worried about user confusion due to HTTP being treated differently. If users do HTTP but that traffic happens to go over a normal <code>wasi:sockets</code> instead of <code>wasi:http</code>, they may be confused by the difference in behavior. I don't think there's much we can do about that, but it's something that's on my mind.</li>
</ul>
</blockquote>



<a name="408615575"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/408615575" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#408615575">(Dec 18 2023 at 13:53)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1860560055">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>@alexcrichton </p>
<blockquote>
<p>One comment I would have is that I think it would be best to implement this in a way that's not baked-in to wasmtime-wasi itself</p>
</blockquote>
<p>I agree. Continuing on #7694 , I have the following in mind:</p>
<ul>
<li>Extract the actual syscalls out of <code>preview2/host/*.rs</code> and into distinct types.</li>
<li>Delegate the actual invocation of those new types to newly introduced "intercept" methods.</li>
</ul>
<p>This example is for TCP Bind only, but you can imagine the same for other operations.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">WasiTcpView</span>: <span class="nc">WasiView</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Custom state maintained per socket instance.</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Socket</span><span class="p">;</span>

<span class="w">    </span><span class="sd">/// Create new custom socket state. Guaranteed to be called at most once per WASI socket resource.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Socket</span><span class="p">;</span>

<span class="w">    </span><span class="sd">/// Called at the moment the actual syscall would have been called. So _after_ the WASI-specific state &amp; input validations.</span>
<span class="w">    </span><span class="sd">/// The `bind` parameter represents the actual sycall implementation that can be executed (or ignored) by the interceptor.</span>
<span class="w">    </span><span class="sd">/// With this general design, the interceptor:</span>
<span class="w">    </span><span class="sd">/// - has full control of what to execute before &amp; after the syscall,</span>
<span class="w">    </span><span class="sd">/// - may conditionally execute or reject the syscall depending on the parameters,</span>
<span class="w">    </span><span class="sd">/// - can keep track of additional state per socket, that would otherwise not be maintained by wasmtime-wasi itself</span>
<span class="w">    </span><span class="sd">/// - (not in this example, but:) maybe manipulate parameters and return values. For example:</span>
<span class="w">    </span><span class="sd">///   rewrite the address parameter from port 80 ("inside wasm") to 8080 ("outside wasm")</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">intercept_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">bind</span>: <span class="nc">TcpBind</span><span class="p">);</span>
<span class="p">}</span>



<span class="cp">#[must_use=</span><span class="s">"For clarity, explicitly drop it using one of the consuming methods."</span><span class="cp">]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">TcpBind</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">impl</span><span class="w"> </span><span class="n">TcpBind</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// The address passed in by the user.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">requested_address</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">SocketAddr</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="sd">/// Consume self and perform the bind on the requested address. Returns the actually bound address.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">execute</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">SocketAddr</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Call rustix::bind etc.</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// Consume self and abort the bind with an error code.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">error</span>: <span class="nc">TcpBindError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// The typical consuming methods will be `execute` and `fail`.</span>
<span class="w">    </span><span class="c1">// But `UdpSend` could have an `skip` method as well, that pretends to have sent the message, but actually it was dropped.</span>
<span class="p">}</span>

<span class="sd">/// Subset of all wasi-sockets errors that are appropriate for `bind` to return.</span>
<span class="cp">#[non_exhaustive]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">TcpBindError</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AccessDenied</span><span class="p">,</span>
<span class="w">    </span><span class="n">AddressInUse</span><span class="p">,</span>
<span class="w">    </span><span class="n">AddressNotBindable</span><span class="p">,</span>
<span class="p">}</span>






<span class="c1">// Example implementations</span>
<span class="k">impl</span><span class="w"> </span><span class="n">WasiTcpView</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WasiCtx</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="c1">// Example #1: allow everything</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">intercept_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">bind</span>: <span class="nc">TcpBind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">bind</span><span class="p">.</span><span class="n">execute</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Example #2: deny everything</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">intercept_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">bind</span>: <span class="nc">TcpBind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">bind</span><span class="p">.</span><span class="n">fail</span><span class="p">(</span><span class="n">TcpBindError</span>::<span class="n">AccessDenied</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Example #3: arbitrary logic</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">intercept_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">bind</span>: <span class="nc">TcpBind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">bind</span><span class="p">.</span><span class="n">requested_address</span><span class="p">().</span><span class="n">ip</span><span class="p">().</span><span class="n">is_loopback</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">bind</span><span class="p">.</span><span class="n">execute</span><span class="p">()</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">bind</span><span class="p">.</span><span class="n">fail</span><span class="p">(</span><span class="n">TcpBindError</span>::<span class="n">AccessDenied</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<p>@rylev </p>
<blockquote>
<ul>
<li>I see that tcp://example.com:80 implies allowing wasi:http usage. I'm not sure this is a good idea. For example, this does not make sense in an HTTP/3 world.</li>
<li>This isn't really related to this change since it's a result of the way they wasi interfaces line up, but I'm slightly worried about user confusion due to HTTP being treated differently. If users do HTTP but that traffic happens to go over a normal wasi:sockets instead of wasi:http, they may be confused by the difference in behavior. I don't think there's much we can do about that, but it's something that's on my mind.</li>
</ul>
</blockquote>
<p>Ah, yes. The classical "user experience" vs. "security" tradeoff. From an end-user's perspective I don't care how a specific Wasm module decided to implement their network requests. I.e. I want to say "you're allowed to fetch <a href="https://example.com/hi.txt">https://example.com/hi.txt</a>" without knowing having to care whether that will be done using TCP/UDP directly or using a wasi-http client. To properly guard this off would effectively be a man-in-the-middle attack.<br>
However, I think the other way around is perfectly reasonable, and more importantly: _feasible_ <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span> . Allowing TCP traffic to a specific endpoint should also allow HTTP(1&amp;2) traffic to that endpoint. Same for UDP and HTTP3. </p>
<p>That being said, none of this is really essential for to this issue, so I'm happy to postpone all "implying" to a future iteration.<br>
I we allow wildcards in the protocol (e.g. <code>*://example.com:443</code>) that should be good enough for now.</p>
<hr>
<blockquote>
<ul>
<li>For the CLI syntax, we might want to consider always requiring a port. So if the user does not care about which port, they must opt into that through like so tcp://example.com:*</li>
</ul>
</blockquote>
<p>I agree. At least for TCP and UDP.<br>
For HTTP(S), the port _should_ be inferred IMO</p>
<hr>
<blockquote>
<ul>
<li>What do port ranges look like on the CLI look like? I would imagine we would support a syntax that mirrors Rust exclusive range syntax like 5000..6000 and 1023...</li>
<li>Will we allow lists of domains? Something like https:{example.com, google.com}:* or do we expect those always to be listed out separately? I think I would lean towards requiring they be listed separately.</li>
</ul>
</blockquote>
<p>A mix of "TBD" and "I don't care" <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span> </p>
</blockquote>



<a name="408680299"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/408680299" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#408680299">(Dec 18 2023 at 20:07)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1861509496">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>Coming back on my previous comment:</p>
<p>Even though the initial refactor may be more work, I think it's more straightforward to forget about "interceptors" completely and put the entire socket implementation behind traits whose implementations can be swapped out. My current train of thought is to create a "vanilla Rust" trait that loosely follows the wasi-sockets interface. With "vanilla" I mean:</p>
<ul>
<li><code>async</code> instead of <code>start_/finish_</code></li>
<li><code>std::net::SocketAddr</code> instead of <code>bindings::sockets::network::IpSocketAddress</code></li>
<li><code>std::io::Result</code> instead of <code>SocketResult</code></li>
<li><code>tokio::io::AsyncRead</code> instead of <code>preview2::stream::HostInputStream</code></li>
<li>etc..</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[async_trait]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">TcpSocket</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">InputStream</span>: <span class="nc">AsyncRead</span><span class="p">;</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">OutputStream</span>: <span class="nc">AsyncWrite</span><span class="p">;</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">AcceptStream</span>: <span class="nc">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">addr</span>: <span class="nc">SocketAddr</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="nc">SocketAddr</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="nc">SocketAddr</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">InputStream</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">OutputStream</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">listen</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">AcceptStream</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">local_address</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">SocketAddr</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">remote_address</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">SocketAddr</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">keep_alive_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">set_keep_alive_enabled</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<p>Besides defining that trait, <code>wasmtime_wasi</code> should also provide a default implementation for it. Containing much of our current implementation. Custom implementations can then reuse that default implementation:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">RestrictedTcpSocket</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inner</span>: <span class="nc">SystemTcpSocket</span><span class="p">,</span><span class="w"> </span><span class="c1">// The default, native implementation</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="cp">#[async_trait]</span>
<span class="k">impl</span><span class="w"> </span><span class="n">TcpSocket</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">RestrictedTcpSocket</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span>: <span class="kp">&amp;</span><span class="nc">SocketAddr</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">addr</span><span class="p">.</span><span class="n">ip</span><span class="p">().</span><span class="n">is_loopback</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">inner</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">PermissionDenied</span><span class="p">,</span><span class="w"> </span><span class="s">"Nope."</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<p>With that in place, <code>impl&lt;T: WasiView&gt; crate::preview2::host::tcp::tcp::HostTcpSocket for T</code> can focus fully on WASI stuff:<br>
- Enforcing WASI-specific state invariants and parameter requirements<br>
- Looking up resources from tables<br>
- Mapping std errors into WASI error codes.<br>
- Converting Rust's async &amp; IO primitives into their WASI counterparts</p>
<p><code>WasiTcpView</code> becomes a bit simpler too:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">WasiTcpView</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Socket</span>: <span class="nc">TcpSocket</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="413069298"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/413069298" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#413069298">(Jan 16 2024 at 02:51)</a>:</h4>
<p>Greensue <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1892993542">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>@badeend hi, excuse me , do you have plan to achieve this fine-grained network plolices?  Is there a specific timestone?</p>
</blockquote>



<a name="413107254"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/413107254" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#413107254">(Jan 16 2024 at 08:57)</a>:</h4>
<p>rylev <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1893314152">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>This is being worked on in <a href="https://github.com/bytecodealliance/wasmtime/pull/7705">https://github.com/bytecodealliance/wasmtime/pull/7705</a>. Hoping that it shouldn't be too much longer before this is ready to merge. </p>
</blockquote>



<a name="415934718"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/415934718" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#415934718">(Jan 17 2024 at 01:56)</a>:</h4>
<p>Greensue <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1894809956">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>@rylev thanks, but I did not found a "grant" struct as  badeend described use pseudo code。 would this be achieve in 7705 in the future?  if there is a plan？for now, define a "socket_addr_check" func it's  complexing。<br>
![image](<a href="https://github.com/bytecodealliance/wasmtime/assets/23025897/9afdacb2-50cd-448a-9c8b-a2cd2554aa86">https://github.com/bytecodealliance/wasmtime/assets/23025897/9afdacb2-50cd-448a-9c8b-a2cd2554aa86</a>)</p>
</blockquote>



<a name="416534586"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237681%20WASI%3A%20Fine-grained%20network%20policies/near/416534586" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237681.20WASI.3A.20Fine-grained.20network.20policies.html#416534586">(Jan 18 2024 at 09:53)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/7681#issuecomment-1898148629">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7681">issue #7681</a>:</p>
<blockquote>
<p>#7705 contains the preparational work discussed further in this issue. We haven't started on the design in the initial comment</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>