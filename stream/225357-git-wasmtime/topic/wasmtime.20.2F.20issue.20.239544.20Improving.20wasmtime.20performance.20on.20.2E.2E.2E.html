<html>
<head><meta charset="utf-8"><title>wasmtime / issue #9544 Improving wasmtime performance on ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html">wasmtime / issue #9544 Improving wasmtime performance on ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="480197977"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480197977" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480197977">(Nov 02 2024 at 08:37)</a>:</h4>
<p>sunshowers opened <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, we need to create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me, but as I said in the beginning I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480198078"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480198078" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480198078">(Nov 02 2024 at 08:39)</a>:</h4>
<p>sunshowers edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, we need to create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me -- particularly the <code>Box&lt;dyn RuntimeLinearMemory&gt;</code> abstracting over both owned and borrowed memory mappings -- but as I said in the beginning, I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480198653"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480198653" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480198653">(Nov 02 2024 at 08:47)</a>:</h4>
<p>sunshowers edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that anonymous <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, we need to create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me -- particularly the <code>Box&lt;dyn RuntimeLinearMemory&gt;</code> abstracting over both owned and borrowed memory mappings -- but as I said in the beginning, I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480198726"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480198726" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480198726">(Nov 02 2024 at 08:48)</a>:</h4>
<p>sunshowers edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that anonymous <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me -- particularly the <code>Box&lt;dyn RuntimeLinearMemory&gt;</code> abstracting over both owned and borrowed memory mappings -- but as I said in the beginning, I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480201982"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480201982" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480201982">(Nov 02 2024 at 09:35)</a>:</h4>
<p>sunshowers edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that anonymous <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me -- particularly the <code>Box&lt;dyn RuntimeLinearMemory&gt;</code> abstracting over both owned and borrowed memory mappings -- but as I said in the beginning, I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Move <code>Mmap</code> into an <code>Arc</code> and store weak refs to it where needed.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480202086"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480202086" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480202086">(Nov 02 2024 at 09:37)</a>:</h4>
<p>sunshowers edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>(I'm still a novice to the wasmtime code so please let me know if I've made any mistakes. Thanks!)</p>
<h2>Motivation</h2>
<p>In #9535 we added initial support for illumos. (Thanks!) As noted there, we did notice some performance issues, particularly around freeing memory at shutdown.</p>
<p>Some of my colleagues and I investigated the situation today, and we have a pretty good sense of what's going on (some of my colleagues will be writing up the related illumos issues at some point, but it's essentially that anonymous <code>MAP_NORESERVE</code> allocations of size N take up O(N) CPU, rather than apparently O(1) as on some other platforms. The constant factor is very small, but wasmtime allocates enough memory that it is noticeable.)</p>
<p>However, we've found that there's an alternative mmapping strategy that works well, bringing illumos perf to within the same ballpark as Linux (at least as far as the wast test suite goes). The alternative strategy is:</p>
<ul>
<li>For <code>PROT_NONE</code> mappings, rather than creating a large amount of _anonymous_ memory, create a map to <code>/dev/null</code>.</li>
<li>When a particular part of memory needs to be made accessible in any way, create an anonymous mmap. Accessible memory is a very small portion of the overall address space map, so this is fine.</li>
<li>The regions that have "real" anonymous mmaps associated with them need to be tracked via a data structure, ideally an interval tree. Essentially, some of the bookkeeping the kernel currently does makes its way into userspace.</li>
</ul>
<p>I have a quick and dirty prototype that shows how <code>/dev/null</code> mapping might work, though it needs a lot of work to be made shippable. The prototype is at <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> -- <code>mmap.rs</code> has the meaty interval tree logic if you're interested.</p>
<p>With this PR,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="o">%</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="o">+</span><span class="n">beta</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">wast</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">threads</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">Cranelift</span><span class="o">/</span><span class="n">pooling</span><span class="o">/</span><span class="n">tests</span><span class="o">/</span><span class="n">spec_testsuite</span><span class="o">/</span><span class="n">load</span><span class="p">.</span><span class="n">wast</span>
<span class="o">&lt;</span><span class="n">snip</span><span class="o">&gt;</span>
<span class="n">test</span><span class="w"> </span><span class="n">result</span><span class="p">:</span><span class="w"> </span><span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">2491</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.08</span><span class="n">s</span>
</code></pre></div>
<p>(Note that this strategy doesn't work on Linux -- <code>mmap</code>ing <code>/dev/null</code> produces <code>ENODEV</code>. Naturally, if we go this route, this will be a platform-specific impl of mmapping on illumos, and possibly other systems where <code>/dev/null</code>-based mapping might be faster.)</p>
<h2>Challenges</h2>
<p>The most important implication of this approach is that all memory management <em>must</em> go through the mmap. This means that nothing outside the mmap code should call <code>mmap</code>, <code>mmap_anonymous</code> or <code>mprotect</code> directly.</p>
<p>This turns out to be a bit of a sticking point, sadly. Several parts of the wasmtime VM store pointers to base addresses and operate on them directly.</p>
<ul>
<li>For example, <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/cow.rs#L686"><code>cow.rs</code></a> calls <code>expose_existing_mapping</code> directly, which on Unix <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/sys/unix/vm.rs#L10">calls <code>mprotect</code></a>. With <code>/dev/null</code>-based mapping, that would no longer be possible -- that code must go through <code>Mmap</code> instead.</li>
</ul>
<p>While some components that currently store addresses can be passed a <code>&amp;Mmap</code>, this turns out to be more challenging for other parts -- particularly the <code>RuntimeLinearMemory</code> API, which is generic over both an <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L175">owned <code>MmapMemory</code></a> and a logically-borrowed <a href="https://github.com/bytecodealliance/wasmtime/blob/f305ef5214d998f9a7ea07ea48a61d92077d19ee/crates/wasmtime/src/runtime/vm/memory.rs#L438"><code>StaticMemory</code></a>.</p>
<p>In my prototype I just decided to store a <code>SendSyncPtr&lt;Mmap&gt;</code> inside <code>StaticMemory</code>, with the hope/promise that the <code>Mmap</code> outlives the <code>StaticMemory</code>. I don't think that's hugely worse than storing a raw <code>*mut u8</code> as we do today where there's the same implicit promise, but it is arguably not great.</p>
<p>I'll also say that in general, this change leads to some nice internal improvements. For example, there are currently at least three different implementations of decommitting memory in the kernel, and only one of them does <code>MADV_DONTNEED</code> on Linux. With my prototype, all of that lives in one spot.</p>
<h2>Possible solutions</h2>
<p>So given that we've established the benefits of changing out the style of mapping, at least on illumos -- and given the challenges I encountered, I think there are a few approaches we could take:</p>
<ol>
<li>Do nothing. Wasmtime continues to use the current strategy and continues to have performance issues on illumos, though at least we now know what's going on. It is certainly fair to say that the illumos kernel shouldn't take O(N) time for NORESERVE mappings, but my understanding is that fixing that is likely going to take a while. <code>/dev/null</code>-based mapping is also the <a href="https://illumos.org/man/4D/null">officially recommended way</a> to do this on illumos.</li>
<li>In the spots that currently store <code>*mut u8</code>, if it is too inconvenient to pass in a <code>&amp;Mmap</code>, store a pointer to the <code>Mmap</code> instead. If I understand correctly, these spots all already have an implicit requirement that the <code>Mmap</code> outlives them, so this would probably not be _worse_ than today. But it is new unsafe Rust.</li>
<li>Refactor wasmtime to change APIs and add lifetimes to various spots as needed, so that they can all hold on to an <code>&amp;'map Mmap</code> or similar. This seemed a bit daunting to me -- particularly the <code>Box&lt;dyn RuntimeLinearMemory&gt;</code> abstracting over both owned and borrowed memory mappings -- but as I said in the beginning, I'm a novice so it's probably a lot easier for an experienced wasmtime dev.</li>
<li>Move <code>Mmap</code> into an <code>Arc</code> and store (strong? weak?) refs to it where needed.</li>
<li>Other ideas?</li>
</ol>
<p>I'd love to hear y'all's thoughts on this!</p>
</blockquote>



<a name="480241588"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480241588" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480241588">(Nov 02 2024 at 18:44)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9544#issuecomment-2453090794">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>Thanks for writing this up and investigating! I really like the patch you have passing around <code>&amp;Mmap</code> to various locations. That feels like a great design not only from a safety point of view but also the portability point of view too. In terms of what's the best road to take here at least from our side we can help out with reviews and design feedback but the implementation will be up to you/others for sending PRs/handling feedback/tests/etc. I personally would love to see this fixed without waiting for illumos kernel changes.</p>
<p>For a bit of history all our VM apis are a bit of a mish mash of organically evolved "abstractions" over time. The abstractions keep changing because we keep not being able to pin down exactly what we want. In that sense you're more than welcome to apply refactorings to shuffle things around (e.g. having one decommit instead of 3) and don't place too much weight on the current design.</p>
<p>What I might recommend for landing these changes if you're up for it is incremental progress towards the refactoring here. The memory-related bits are notoriously tricky in Wasmtime so we ideally prefer to change only small bits at a time to ensure thorough review and everything. In that sense:</p>
<ul>
<li>Perhaps the first change could be to thread around <code>&amp;Mmap</code> in more locations. That would remove the need for a bunch of raw pointers in places and VM operations would be "obviously based on an existing mmap" by construction.</li>
<li>Next VM operations could be pushed onto methods of <code>Mmap</code> which could include things like bounds checks assertions to ensure it's all in-range.</li>
<li>Next we could have an illumos-specific implementation of <code>Mmap</code> which does the <code>/dev/null</code> truck as you've implemented with trees too.</li>
</ul>
<p>Those could all be separate PRs, but separate commits in the same PR is something I'd personally be ok with too. (would primarily prefer to not lump it all into one though). And if you feel there's better divisions of commits/PRs definitely feel free to slice/dice further too.</p>
<p>How's that all sound?</p>
</blockquote>



<a name="480241811"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480241811" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480241811">(Nov 02 2024 at 18:47)</a>:</h4>
<p>sunshowers <a href="https://github.com/bytecodealliance/wasmtime/issues/9544#issuecomment-2453092576">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>My worry with passing around &amp;Mmap just is about the complexity of that growing out of hand. Do you have a sense of how difficult the refactoring would be?</p>
<p>I'll give it a shot as time permits.</p>
<p>(I would absolutely split this up into several PRs. I'm one of the biggest stacked PR proponents around :) )</p>
</blockquote>



<a name="480242165"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480242165" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480242165">(Nov 02 2024 at 18:52)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9544#issuecomment-2453093851">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>Personally I thought <a href="https://github.com/sunshowers/wasmtime/pull/1">https://github.com/sunshowers/wasmtime/pull/1</a> looked pretty reasonable. I'm notoriously bad at judging ahead of time whether something will work out, so I'm happy to leave it to your discretion too as to whether the refactoring feels right/wrong. Any difficult parts I  or others can help out with during review too. </p>
<p>One thing I think is ok is to store <code>Arc&lt;Mmap&gt;</code> in more places. That shouldn't really be all that expensive since adding a (hypothetical) atomic increment/decrement to VM operations shouldn't really break the bank.</p>
</blockquote>



<a name="480242423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239544%20Improving%20wasmtime%20performance%20on%20.../near/480242423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239544.20Improving.20wasmtime.20performance.20on.20.2E.2E.2E.html#480242423">(Nov 02 2024 at 18:56)</a>:</h4>
<p>sunshowers <a href="https://github.com/bytecodealliance/wasmtime/issues/9544#issuecomment-2453095184">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9544">issue #9544</a>:</p>
<blockquote>
<p>In the PR I do store raw pointers to an Mmap in a couple of spots, because I found it a bit complex to change the APIs. I could probably replace those with Arc&lt;Mmap&gt;.</p>
<p>I'll also try doing a more aggressive refactor (eg introducing lifetimes in a few places) now that you're on board with the general approach.</p>
<p>Thanks!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>