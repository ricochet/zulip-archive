<html>
<head><meta charset="utf-8"><title>wasmtime / PR #1329 [wasi-common] add custom FdSet contai... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html">wasmtime / PR #1329 [wasi-common] add custom FdSet contai...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="190758859"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190758859" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190758859">(Mar 16 2020 at 17:56)</a>:</h4>
<p>kubkon opened <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190758860"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190758860" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190758860">(Mar 16 2020 at 17:56)</a>:</h4>
<p><strong>kubkon</strong> requested <a href="https://github.com/alexcrichton" target="_blank" title="https://github.com/alexcrichton">alexcrichton</a>, <a href="https://github.com/pchickey" target="_blank" title="https://github.com/pchickey">pchickey</a>, and <a href="https://github.com/sunfishcode" target="_blank" title="https://github.com/sunfishcode">sunfishcode</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a>.</p>



<a name="190758861"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190758861" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190758861">(Mar 16 2020 at 17:56)</a>:</h4>
<p><strong>kubkon</strong> requested <a href="https://github.com/alexcrichton" target="_blank" title="https://github.com/alexcrichton">alexcrichton</a>, <a href="https://github.com/pchickey" target="_blank" title="https://github.com/pchickey">pchickey</a>, and <a href="https://github.com/sunfishcode" target="_blank" title="https://github.com/sunfishcode">sunfishcode</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a>.</p>



<a name="190758862"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190758862" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190758862">(Mar 16 2020 at 17:56)</a>:</h4>
<p><strong>kubkon</strong> requested <a href="https://github.com/alexcrichton" target="_blank" title="https://github.com/alexcrichton">alexcrichton</a>, <a href="https://github.com/pchickey" target="_blank" title="https://github.com/pchickey">pchickey</a>, and <a href="https://github.com/sunfishcode" target="_blank" title="https://github.com/sunfishcode">sunfishcode</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a>.</p>



<a name="190758967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190758967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190758967">(Mar 16 2020 at 17:57)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190766209"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190766209" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190766209">(Mar 16 2020 at 19:05)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190766807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190766807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190766807">(Mar 16 2020 at 19:10)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190770498"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190770498" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190770498">(Mar 16 2020 at 19:44)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190784716"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190784716" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190784716">(Mar 16 2020 at 21:53)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<a name="190821881"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231329%20%5Bwasi-common%5D%20add%20custom%20FdSet%20contai.../near/190821881" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231329.20.5Bwasi-common.5D.20add.20custom.20FdSet.20contai.2E.2E.2E.html#190821881">(Mar 17 2020 at 09:08)</a>:</h4>
<p>kubkon updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1329" target="_blank" title="https://github.com/bytecodealliance/wasmtime/pull/1329">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>
<blockquote>
<p>This PR adds a custom <code>FdSet</code> container which is intended<br>
for use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>
main aim for this container is to abstract away the current<br>
approach of spawning new handles</p>
<div class="codehilite"><pre><span></span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(...)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>and to make it possible to reuse unused/reclaimed handles<br>
which currently is not done.</p>
<p>The struct offers 3 methods to manage its functionality:</p>
<ul>
<li>
<p><code>FdSet::new</code> initialises the internal data structures,<br>
  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>
  worth of handles in such a way that we always start popping<br>
  from the "smallest" handle (think of it as of reversed stack,<br>
  I guess; it's not a binary heap since we don't really care<br>
  whether internally the handles are sorted in some way, just that<br>
  the "largets" handle is at the bottom. Why will become clear<br>
  when describing <code>allocate</code> method.)</p>
</li>
<li>
<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>
  The tricky bit here is that, if we run out of handles, we preallocate<br>
  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>
  latest popped handle (i.e., the "largest" handle). This<br>
  works only because we make sure to only ever pop and push already<br>
  existing handles from the back, and push _new_ handles (from the<br>
  preallocation step) from the front. When we ultimately run out<br>
  of _all_ available handles, we then return <code>None</code> for the client<br>
  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>
  or whatnot).</p>
</li>
<li>
<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>
  the pool for further reuse.</p>
</li>
</ul>
<p>When figuring out the internals, I've tried to optimise for both<br>
alloc and dealloc performance, and I believe we've got an amortised<br>
<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>
well not be, so please verify!).</p>
<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>
it for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>
representing WASI handle), but rather, any type which wants to be managed<br>
by <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>
it only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>
is quite a powerful assumption here!), and a custom method</p>
<div class="codehilite"><pre><span></span><span class="n">Fd</span>::<span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>which is there to encapsulate creating another handle from the given one.<br>
In the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>
When <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>
similar to</p>
<div class="codehilite"><pre><span></span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">Self</span>::<span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>