<html>
<head><meta charset="utf-8"><title>wasmtime / PR #9078 Cranelift: add stack_switch CLIF inst... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html">wasmtime / PR #9078 Cranelift: add stack_switch CLIF inst...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="456600254"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456600254" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456600254">(Aug 05 2024 at 14:57)</a>:</h4>
<p>frank-emrich opened <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a> from <code>frank-emrich:stack_switch</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>This PR adds a new CLIF instruction for switching stacks. While the primary motivation is to support the <a href="https://github.com/WebAssembly/stack-switching">Wasm stack switching proposal</a> currently under development, the CLIF instruction here is lower level and thus intended to be useful for general-purpose stackful context switching (such as implementing coroutines, fibers, etc independently from the Wasm stack switching proposal).<br>
This PR only adds support for the instruction on x64 Linux, but I'm planning to add support for more platforms over time. The design of the instruction should be sufficiently abstract to support all the other platforms.</p>
<p>While work is currently under way to implement Wasm stack switching <a href="https://github.com/wasmfx/wasmfxtime">here</a> and indeed uses the CLIF instruction introduced by this PR successfully, it seems worthwhile just upstreaming the CLIF instruction by itself. The proposal is not fully finalized yet, and this CLIF instruction seems useful on its own and independent from the remainder of the Wasm proposal.</p>
<p>Concretely, the CLIF instruction looks as follows:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">out_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack_switch</span><span class="p">(</span><span class="n">store_context_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">load_context_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">in_payload</span><span class="p">)</span>
</code></pre></div>
<p>This causes the following to happen:</p>
<ol>
<li>The current execution context is saved: The current frame pointer, stack pointer and PC <em>after</em> the <code>stack_switch</code> instruction are stored at <code>store_context_ptr</code>. All other registers are marked as clobbered and thus spilled by regalloc as needed.</li>
<li>We load a new <code>(SP, FP, PC)</code> triple from <code>load_context_ptr</code>, indicating the stack/context to switch to. We assume that we are either switching to a stack that was either previously switched away from by another <code>stack_switch</code>, or it's a newly initialized stack.</li>
<li>The value <code>in_payload</code> is passed over to the other stack. In other words, if the instruction above switches from some stack A to another stack B, then the return value of the <code>stack_switch</code> instruction previously executed on B will be <code>in_payload</code>.</li>
<li>Execution continues on stack B.</li>
<li>If we ever switch back to stack A, the value <code>out_payload</code> above (i.e., the return value of the <code>stack_switch</code> executed when leaving stack <code>A</code>) is the payload argument passed to the corresponding switch.</li>
</ol>
<p>A few additional notes:</p>
<ul>
<li><code>store_context_ptr</code> and <code>load_context_ptr</code> can be seen as pointers to what is conceptually a three-element struct, containing SP, FP, PC.</li>
<li>The pointers <code>store_context_ptr</code> and <code>load_context_ptr</code> are allowed to be equal. In particular, in steps 1 and 2 above, we ensure to actually load all required data from <code>load_context_ptr</code> before storing to <code>store_context_ptr</code>.</li>
<li>As mentioned above, there are two cases in step 2: We either switch to code where a matching <code>stack_switch</code> was executed, or to a new stack<ul>
<li>If we switch back to (right behind) a previous <code>stack_switch</code> instruction, then regalloc has spilled all subsequently needed SSA values for us, no need to manually restore any context besides SP, FP, PC.</li>
<li>If we are executing on a new stack, we assume that execution starts inside a stack-switch aware trampoline</li>
</ul>
</li>
<li>Payloads are currently hard-coded to be a single, word-sized value. That may seem arbitrary, but it's simply what's needed for our current implementation of Wasm stack switching on top of this CLIF instruction. It could later be extended to more general cases, if necessary.</li>
<li>The stack switching implemented here is "one-shot": If you execute a <code>stack_switch</code> to switch from a stack A to a stack B, we can only switch back to A once (unless we subsequently execute another <code>stack_switch</code> on A again).<br>
  This is different from <code>setjmp</code>/<code>longjmp</code>, where we may store the context once using <code>setjmp</code> and then return to it multiple times using <code>longjmp</code> without needing to call <code>setjmp</code> again.</li>
</ul>
</blockquote>



<a name="456626926"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456626926" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456626926">(Aug 05 2024 at 15:22)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="456628342"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456628342" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456628342">(Aug 05 2024 at 15:26)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2269342967">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>I'm marking this as "ready for review" now, but I have a few questions about things that will probably require additional fixes before this is actually ready:</p>
<ol>
<li>
<p>Currently, the instruction is lowered by very simple rules in <code>codegen/src/isa/x64/lower.isle</code>. However, the emitted code is only valid for x64 Linux, not x64 Windows.<br>
   This means that I should probably do something similar to function calls, where my instruction is lowered using an external <code>gen_stack_switch</code> function. What's the cleanest way to simply refuse lowering on x64 Windows for the time being?</p>
</li>
<li>
<p>The layout of the data read and written by the instruction is described in the new file <code>codegen/src/isa/x64/inst/stack_switch.rs</code>, given that the information in that file is platform-specific. However, I'm not sure if that's the right place for that file. I imagine that the content of that file will either be split up in the future, or move somewhere else to collect the layout information for all platforms.</p>
</li>
<li>When emitting code for the new instruction on x64, we need two temporary registers. Currently, this is done without regalloc (see my comment in <code>emit.rs</code>): If I try to add any early def to my <code>StackSwitch</code> <code>MInst</code> to get temporary registers, <code>regalloc2</code> fails with <code>TooManyLiveRegs</code>. I suspect this is just a result of the rather unique set of constraints on <code>StackSwitch</code>. I'm curious if there's an existing issue I could mention, a more elegant workaround than what I'm currently doing, or if I should open a new issue regarding this in the <code>regalloc2</code> repo.</li>
<li>
<p>In <code>instructions.rs</code>, I'm giving <code>stack_switch</code> all kinds of scary side effects (namely, <code>.other_side_effects()</code>, <code>.can_load()</code>, <code>.can_store()</code>), given that it continues execution elsewhere, where arbitrary things may happen.<br>
  I'm wondering what a more accurate description of the side effects would be. The <code>.call()</code> side effect seems related, but I was unsure if using that would have unintended consequences.</p>
</li>
<li>
<p>I've added a filetest for the new instruction but it turned out quite monstrous: It uses <code>stack_switch</code> in two functions where we create enough SSA values to exceed the number of available registers before the switch, and then use all of them after the stack switch. I've manually verified the generated assembly, but I'm wondering if people prefer having a shorter test case that makes it easier to verify the assembly for the stack switching itself.</p>
</li>
<li>My <code>StackSwitch</code> <code>MInst</code> takes its inputs as <code>Gpr</code>s. These values all end up in registers during code emission anyway, but I was wondering if it would be more idiomatic to make the <code>MInst</code> use <code>GprMem</code> or <code>RegMem</code>, then deal with moving things into registers during emission.<br>
</li>
</ol>
</blockquote>



<a name="456628623"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456628623" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456628623">(Aug 05 2024 at 15:27)</a>:</h4>
<p><strong>frank-emrich</strong> has marked <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a> as ready for review.</p>



<a name="456628629"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456628629" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456628629">(Aug 05 2024 at 15:27)</a>:</h4>
<p><strong>frank-emrich</strong> requested <a href="https://github.com/abrown">abrown</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="456628630"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456628630" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456628630">(Aug 05 2024 at 15:27)</a>:</h4>
<p><strong>frank-emrich</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers">wasmtime-compiler-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="456630712"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456630712" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456630712">(Aug 05 2024 at 15:33)</a>:</h4>
<p>frank-emrich edited <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>This PR adds a new CLIF instruction for switching stacks. While the primary motivation is to support the <a href="https://github.com/WebAssembly/stack-switching">Wasm stack switching proposal</a> currently under development, the CLIF instruction here is lower level and thus intended to be useful for general-purpose stackful context switching (such as implementing coroutines, fibers, etc independently from the Wasm stack switching proposal).<br>
This PR only adds support for the instruction on x64 Linux, but I'm planning to add support for more platforms over time. The design of the instruction should be sufficiently abstract to support all the other platforms.</p>
<p>While work is currently under way to implement Wasm stack switching in Wasmtime <a href="https://github.com/wasmfx/wasmfxtime">here</a> and indeed uses the CLIF instruction introduced by this PR successfully, it seems worthwhile just upstreaming the CLIF instruction by itself. The proposal is not fully finalized yet, and this CLIF instruction seems useful on its own and independent from the remainder of the Wasm proposal.</p>
<p>Concretely, the CLIF instruction looks as follows:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">out_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack_switch</span><span class="p">(</span><span class="n">store_context_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">load_context_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">in_payload</span><span class="p">)</span>
</code></pre></div>
<p>This causes the following to happen:</p>
<ol>
<li>The current execution context is saved: The current frame pointer, stack pointer and PC <em>after</em> the <code>stack_switch</code> instruction are stored at <code>store_context_ptr</code>. All other registers are marked as clobbered and thus spilled by regalloc as needed.</li>
<li>We load a new <code>(SP, FP, PC)</code> triple from <code>load_context_ptr</code>, indicating the stack/context to switch to. We assume that we are either switching to a stack that was either previously switched away from by another <code>stack_switch</code>, or it's a newly initialized stack.</li>
<li>The value <code>in_payload</code> is passed over to the other stack. In other words, if the instruction above switches from some stack A to another stack B, then the return value of the <code>stack_switch</code> instruction previously executed on B will be <code>in_payload</code>.</li>
<li>Execution continues on stack B.</li>
<li>If we ever switch back to stack A, the value <code>out_payload</code> above (i.e., the return value of the <code>stack_switch</code> executed when leaving stack <code>A</code>) is the payload argument passed to the corresponding switch.</li>
</ol>
<p>A few additional notes:</p>
<ul>
<li><code>store_context_ptr</code> and <code>load_context_ptr</code> can be seen as pointers to what is conceptually a three-element struct, containing SP, FP, PC.</li>
<li>The pointers <code>store_context_ptr</code> and <code>load_context_ptr</code> are allowed to be equal. In particular, in steps 1 and 2 above, we ensure to actually load all required data from <code>load_context_ptr</code> before storing to <code>store_context_ptr</code>.</li>
<li>As mentioned above, there are two cases in step 2: We either switch to code where a matching <code>stack_switch</code> was executed, or to a new stack<ul>
<li>If we switch back to (right behind) a previous <code>stack_switch</code> instruction, then regalloc has spilled all subsequently needed SSA values for us, no need to manually restore any context besides SP, FP, PC.</li>
<li>If we are executing on a new stack, we assume that execution starts inside a stack-switch aware trampoline</li>
</ul>
</li>
<li>Payloads are currently hard-coded to be a single, word-sized value. That may seem arbitrary, but it's simply what's needed for our current implementation of Wasm stack switching on top of this CLIF instruction. It could later be extended to more general cases, if necessary.</li>
<li>The stack switching implemented here is "one-shot": If you execute a <code>stack_switch</code> to switch from a stack A to a stack B, we can only switch back to A once (unless we subsequently execute another <code>stack_switch</code> on A again).<br>
  This is different from <code>setjmp</code>/<code>longjmp</code>, where we may store the context once using <code>setjmp</code> and then return to it multiple times using <code>longjmp</code> without needing to call <code>setjmp</code> again.</li>
</ul>
</blockquote>



<a name="456891450"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/456891450" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#456891450">(Aug 06 2024 at 15:54)</a>:</h4>
<p><strong>fitzgen</strong> requested <a href="https://github.com/fitzgen">fitzgen</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="457151642"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457151642" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457151642">(Aug 07 2024 at 16:32)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2273869774">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>Super excited for this! Haven't taken a look at the actual code yet, but here are some answers to the questions in your comment above.</p>
<blockquote>
<p>However, the emitted code is only valid for x64 Linux, not x64 Windows. ... What's the cleanest way to simply refuse lowering on x64 Windows for the time being?</p>
</blockquote>
<p>Will the lowering work for all posix right now or only Linux? Will macos work, for example? We should be precise about the correctness condition here.</p>
<p>Cranelift doesn't generally care what OS it is targeting beyond calling conventions and a few other ABI details here and there, and AFAIK we've never needed OS-specific lowering rules before, so this is sort of untrodded ground.</p>
<p>A <code>TargetIsa</code> does have a <code>triple</code> method, which returns a <code>target_lexicon::Triple</code>, which in turn has an <code>operating_system</code> member. You could try plumbing that stuff through to an external partial constructor for use in ISLE <code>if-let</code>s.</p>
<blockquote>
<p>The layout of the data read and written by the instruction is described in the new file <code>codegen/src/isa/x64/inst/stack_switch.rs</code>, given that the information in that file is platform-specific. However, I'm not sure if that's the right place for that file. I imagine that the content of that file will either be split up in the future, or move somewhere else to collect the layout information for all platforms.</p>
</blockquote>
<p>I think describing the layout of that data would be best done in the documentation for the new instruction itself.</p>
<p>I haven't looked at the actual code in this PR, but I'd expect that the only platform-specific bits would be pointer size, and otherwise we are always saving SP, optionally FP when frame pointers are enabled, and PC. Is that assumption incorrect? Are we, or will we be, saving more/fewer values on different platforms?</p>
<p>I also would expect that we wouldn't actually need to explicitly define all the details of this data and its layout. I'd imagine we would only say that it has a given size and alignment, and is otherwise only valid to be manipulated via the <code>stack_switch</code> instruction. That is, it should be opaque to the host.</p>
<p>But maybe something like stack walking means that the runtime needs to be able to peek inside this data, and we can't keep it opaque to the host?</p>
<blockquote>
<p>When emitting code for the new instruction on x64, we need two temporary registers. Currently, this is done without regalloc (see my comment in <code>emit.rs</code>): If I try to add any early def to my <code>StackSwitch</code> <code>MInst</code> to get temporary registers, <code>regalloc2</code> fails with <code>TooManyLiveRegs</code>. I suspect this is just a result of the rather unique set of constraints on <code>StackSwitch</code>. I'm curious if there's an existing issue I could mention, a more elegant workaround than what I'm currently doing, or if I should open a new issue regarding this in the <code>regalloc2</code> repo.</p>
</blockquote>
<p>I think we've had similar-ish issues opened in the past for <code>regalloc2</code>. None the less, I'd recommend opening an issue there and we can dedupe it if necessary. That will also get eyes on the problem from folks who are more familiar with our register allocator than I am.</p>
<blockquote>
<p>In <code>instructions.rs</code>, I'm giving <code>stack_switch</code> all kinds of scary side effects (namely, <code>.other_side_effects()</code>, <code>.can_load()</code>, <code>.can_store()</code>), given that it continues execution elsewhere, where arbitrary things may happen.<br>
I'm wondering what a more accurate description of the side effects would be. The <code>.call()</code> side effect seems related, but I was unsure if using that would have unintended consequences.</p>
</blockquote>
<p>I think we also want to have the <code>call()</code> side effect because, for these instructions, we will want to do <code>call</code>-related things like</p>
<ul>
<li>clear all memory aliasing info, assuming that external code we "call" could alias anything</li>
<li>treat the instruction as a GC safepoint, spill GC refs to the stack, and emit a stack map for this location</li>
<li>etc...</li>
</ul>
<blockquote>
<p>I've added a filetest for the new instruction but it turned out quite monstrous: It uses <code>stack_switch</code> in two functions where we create enough SSA values to exceed the number of available registers before the switch, and then use all of them after the stack switch. I've manually verified the generated assembly, but I'm wondering if people prefer having a shorter test case that makes it easier to verify the assembly for the stack switching itself.</p>
</blockquote>
<p>I don't think having a big filetest is a problem in itself per se, but I think we should also have a very basic filetest that is effectively just the <code>stack_switch</code> instruction and its disassembly. Basically, a function that takes all the <code>stack_switch</code> operands as arguments and returns the <code>out_payload</code>, and is just a single basic block with a single <code>stack_switch</code> instruction. This gives us a smoke test for the basic lowering and its disassembly.</p>
<blockquote>
<p>My <code>StackSwitch</code> <code>MInst</code> takes its inputs as <code>Gpr</code>s. These values all end up in registers during code emission anyway, but I was wondering if it would be more idiomatic to make the <code>MInst</code> use <code>GprMem</code> or <code>RegMem</code>, then deal with moving things into registers during emission.</p>
</blockquote>
<p>Things like <code>GprMem</code> are useful for x64 instructions like <code>add</code> where one of the operands can naturally be either in memory or a register. When we are lowering an <code>add</code> with a memory operand, we don't force the memory into a register during emission, we emit an instruction that operates directly on the memory. It wouldn't make sense to take a <code>GprMem</code> operand for <code>add</code> if the x64 instruction(s) we emit can't operate directly on memory.</p>
<p>So for the x64 <code>MInst.StackSwitch</code> instruction, my questions would be:</p>
<ol>
<li>Can the instruction sequence it emits operate directly on memory, or must they have the operand in a register?</li>
<li>Is the emitted instruction sequence accessing the value once or multiple times?</li>
</ol>
<p>If the answer to these questions are "can operate directly on memory" and "accessing the value once" then I'd say a <code>GprMem</code> makes sense. Otherwise, I think a <code>Gpr</code> is the way to go.</p>
<p>FWIW, it is also fine to start with just <code>Gpr</code> operands and then investigate whether it makes sense to upgrade to a <code>GprMem</code> in follow up PRs.</p>
</blockquote>



<a name="457161382"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161382" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161382">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2225713179">PR review</a>:</p>
<blockquote>
<p>Looking good! I think that, with the guard rails where we only lower this instruction on target OSes for which it will work, and the various nitpicks below addressed, this will be good to merge.</p>
</blockquote>



<a name="457161383"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161383" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161383">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2225713179">PR review</a>:</p>
<blockquote>
<p>Looking good! I think that, with the guard rails where we only lower this instruction on target OSes for which it will work, and the various nitpicks below addressed, this will be good to merge.</p>
</blockquote>



<a name="457161384"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161384" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161384">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1707442699">PR review comment</a>:</p>
<blockquote>
<p>Somewhere in here we should mention the one-shottedness of this instruction, and how resuming a context twice can result in UB due to spilled values being overwritten by the first resumption, etc...</p>
<p>It might even be worth naming this instruction <code>one_shot_stack_switch</code>.</p>
<p>I think we should also clarify that, while this instruction performs loads and stores, those memory operations are always assumed to be aligned, non-trapping, and otherwise valid. This instruction performs no validation itself. It is as if these memory operations had <code>MemFlags::trusted()</code> attached to them. Therefore, it is the user's responsibility to ensure that these assumptions are upheld.</p>
</blockquote>



<a name="457161385"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161385" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161385">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1707523401">PR review comment</a>:</p>
<blockquote>
<p>Is there any reason <code>rdi</code> was chosen in particular? Not that it is a bad choice or anything, I'm just wondering if there are constraints on the register we choose (or even if we <em>have</em> to choose a fixed register?) that we should document here in case we ever want to change it.</p>
</blockquote>



<a name="457161386"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161386" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161386">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1707468443">PR review comment</a>:</p>
<blockquote>
<p>This is a fantastic hack</p>
</blockquote>



<a name="457161387"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457161387" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457161387">(Aug 07 2024 at 17:37)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1707528610">PR review comment</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="suggestion"><pre><span></span><code>            Err(PccError::UnimplementedInst)
</code></pre></div><br>
</p>
</blockquote>



<a name="457181962"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/457181962" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#457181962">(Aug 07 2024 at 19:18)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2274180787">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>Thanks for your answers and looking at the code! I'll look into the things you suggested.</p>
<p>In the meantime, some more thoughts regarding the layout of the contexts: On most platforms, the context can indeed look like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ControlContext</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">stack_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">frame_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">instruction_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>However, there are two reasons for why the layout may be different somewhere:</p>
<h3>1. Additional info needed on Windows</h3>
<p>On Windows, I think we would have to update data inside the "Thread Information Block" (the stuff we briefly talked about with Ryan Hunt at the Pittsburgh CG meeting). I haven't looked too deeply into it, but it looks like it contains pointers to the beginning and end of the currently active stack, which we would need to update when switching. That means that I suspect we would have to add these to the <code>ControlContext</code> on Windows.</p>
<p>In any case, it looks like we would need Windows-specific lowering rules for <code>x64</code>, just to emit the logic for updating the Thread Information Block.</p>
<h3>2. Frame pointer walking</h3>
<p>There's another issue that I've briefly mentioned in a comment in the new file <code>stack_switch.rs</code>, but haven't provided much detail on (mostly because it requires dumping a bunch of extra info on you, sorry!):</p>
<p>I made sure that the <code>ControlContext</code> above is laid out in a way so that it can appear inside a frame pointer chain. This is so that for stack switching approaches where you do have parent-child relationships between stacks, these are reflected in the stack trace you get just from frame pointer walking, by creating a single continuous chain crossing stacks. In other words, tools like <code>lldb</code> show you the frames of the active stack, but also the frames in its parent.<br>
(There's been a recent development in the Wasm stack switching subgroup making it very likely that at least for <em>Wasm</em> stack switching, we will end up with a proposal where there are parent-child relationships between all the active stacks.)</p>
<p>Concretely, in our implementation of Wasm stack switching, this is achieved like this:<br>
Imagine we have allocated memory from <code>0x1000</code> to <code>0xB000</code> which we want to use for a new stack <code>S</code>. We store a <code>ControlContext</code> at the very top of that allocation at <code>0xAFE8</code>, with the actual stack space starting below it. When starting execution in the new stack, we will then have <code>RSP = 0xAFE0</code> in the trampoline that kicks off execution inside stack <code>S</code> (e.g., the trampoline calls the Wasm function that we actually want to run inside that stack).</p>
<p>The main idea is now that we make sure that the <code>ControlContext</code> at <code>0xAFE8</code> always contains the information about the <em>parent</em> of stack <code>S</code>, meaning that whenever we switch from some other stack <code>X</code> to <code>S</code>, we write information about stack <code>X</code> (which then becomes the parent of <code>S</code>) into the <code>ControlContext</code> at <code>0xAFE8</code>.</p>
<p>The last missing ingredient for creating the frame pointer chain is that when  we are running the trampoline that kicks of execution inside stack S, we set <code>RBP</code> to <code>0xAFF0</code>, which is the address of the frame pointer field inside the control context.<br>
This means that while the trampoline is the bottom-most stack frame inside <code>S</code>, when passing the trampoline while walking the frame pointer chain we actually get to where <code>X</code> <code>stack_switch</code>-ed to <code>S</code>: At <code>0xAFF0</code> we stored the frame pointer of <code>X</code>, and the layout of <code>ControlContext</code> puts the PC saved for <code>X</code> right next to it, exactly where <code>lldb</code> and friends would expect it.</p>
<p><strong>Long story short</strong>: It's quite neat to make sure that <code>ControlContext</code> has just the right layout to enable this trick. It allows users of the <code>stack_switch</code> instruction to get frame pointer walking across stacks entirely for free "simply" by carefully laying out where the contexts are actually stored and setting <code>RBP</code> correctly. If they don't care  or implement a stack switching approach where there are no parents, nothing is lost. But to make this possible, the layout of the <code>ControlContext</code> suddenly depends on not just the ISA, but whatever your platform dictates about stack layout (in particular, where to find the return address relative to the frame pointer).</p>
<p>Luckily, the layout above (i.e., frame pointer right next to PC) works on all platforms supported by Cranelift, except s390x: On the latter, there's an offset of 14 words between where the FP and PC are stored.<br>
So on that platform my plan was to make the <code>ControlContext</code> look like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S390XControlContext</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">frame_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">stack_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="n">padding</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">instruction_pointer</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>(Or just give up on frame pointer walking there)</p>
<p>So at least it seems that within the same ISA, all OSes sufficiently agree on the stack layout so that the frame pointer walking causes no extra hassle.</p>
<h2>Documenting the layout</h2>
<blockquote>
<p>I also would expect that we wouldn't actually need to explicitly define all the details of this data and its layout. I'd imagine we would only say that it has a given size and alignment, and is otherwise only valid to be manipulated via the <code>stack_switch</code> instruction. That is, it should be opaque to the host.</p>
<p>But maybe something like stack walking means that the runtime needs to be able to peek inside this data, and we can't keep it opaque to the host?</p>
</blockquote>
<p>Yes, the layout of the <code>ControlContext</code> can be kept mostly opaque, except for stack creation. As long as you only create and consume these contexts with <code>stack_switch</code>, you really don't need to know anything about them besides their size and (boring) alignment requirements. </p>
<p>The only situation where you <em>do</em> need to know about the layout is when initializing a new stack:  You need to create a corresponding <code>ControlContext</code> that when <code>stack_switch</code>-ed to executes the right trampoline on the new stack. That's why my idea was basically to leave details about the layout of the context out of the documentation of the instruction in <code>instruction.rs</code>, but at least have some platform-specific documentation elsewhere.</p>
<p>Alternatively, we could add a <code>stack_init</code> instruction, or instructions that act like getters and setters on the context.</p>
</blockquote>



<a name="459469270"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459469270" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459469270">(Aug 09 2024 at 13:05)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="459488441"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459488441" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459488441">(Aug 09 2024 at 14:26)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="459490367"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459490367" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459490367">(Aug 09 2024 at 14:35)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2230363974">PR review</a>.</p>



<a name="459490372"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459490372" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459490372">(Aug 09 2024 at 14:35)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711584216">PR review comment</a>:</p>
<blockquote>
<p>Ha, good question! I've added a few comments now about why this needs to be a fixed register: We only have a single payload and pass it in a register when doing a <code>stack_switch</code> to another <code>stack_switch</code> on another stack. But in order for that to work, the two involved <code>stack_switch</code> instructions need to agree on the register used for this, similar to a calling convention.</p>
<p>(In a perfect world I would extend the payload handling to arbitrarily many values of different types and make sure that the "calling convention" for that is exactly the same as for functions. If you do that, you don't have to reshuffle any arguments when switching to a new stack where the payloads given to the <code>stack_switch</code> become the arguments of the function to run on the new stack. But that would drastically increase the complexity and it's questionable how big the performance benefit would be)<br>
</p>
</blockquote>



<a name="459490798"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459490798" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459490798">(Aug 09 2024 at 14:36)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2230366778">PR review</a>.</p>



<a name="459490800"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459490800" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459490800">(Aug 09 2024 at 14:36)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711586379">PR review comment</a>:</p>
<blockquote>
<p>I've extended the documentation of this instruction now. Still not specifying the actual layout itself, but mentioned the one-shottedness and the fact that the instruction does not check the pointers or data.</p>
</blockquote>



<a name="459495471"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459495471" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459495471">(Aug 09 2024 at 14:52)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2278136189">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>I've implemented the restriction to only lower <code>stack_switch</code> on Linux now: Strictly speaking, it's each individual OS rather than the ISA that may require additional things needing to be done when switching stacks (see my remarks on Windows in my huge previous comment). I do believe that my current implementation would actually work on x64 macOS, but haven't tested it. So I would just stay on the safe side and make the support OS-dependent (instead of, say, allowing anything Unix-like), with the only allowed one being Linux for now.</p>
<p>I've implemented this using a partial constructor <code>on_linux</code>. The controversial bit may be that I'm now copying the <code>Triple</code> into every <code>machinst::Callee</code>. Is that acceptable?</p>
</blockquote>



<a name="459538563"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459538563" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459538563">(Aug 09 2024 at 17:59)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2230770506">PR review</a>.</p>



<a name="459538564"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459538564" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459538564">(Aug 09 2024 at 17:59)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711901967">PR review comment</a>:</p>
<blockquote>
<p>Gotcha, that makes sense. Thanks!</p>
</blockquote>



<a name="459538795"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459538795" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459538795">(Aug 09 2024 at 18:00)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2278462905">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<blockquote>
<p>only allowed one being Linux for now.</p>
</blockquote>
<p>SGTM</p>
<blockquote>
<p>The controversial bit may be that I'm now copying the <code>Triple</code> into every <code>machinst::Callee</code>. Is that acceptable?</p>
</blockquote>
<p>It doesn't seem ideal. Do we not already have access to a <code>&amp;dyn TargetIsa</code> in the <code>LowerContext</code>?</p>
</blockquote>



<a name="459540039"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459540039" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459540039">(Aug 09 2024 at 18:04)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2278471753">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<blockquote>
<p>Do we not already have access to a <code>&amp;dyn TargetIsa</code> in the <code>LowerContext</code>?</p>
</blockquote>
<p>The <code>IsleContext</code> contains a <code>B: LowerBackend</code> which for x64 is a <code>X64Backend</code> which contains a <code>Triple</code> already, and all the other <code>LowerBackend</code> implementations also contain a <code>Triple</code>. I think we could add a <code>fn triple(&amp;self) -&gt; &amp;Triple</code> trait method to <code>LowerBackend</code> and then reuse that in the <code>IsleContext</code>'s implementation of the partial constructor.</p>
</blockquote>



<a name="459550153"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459550153" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459550153">(Aug 09 2024 at 18:42)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2230843604">PR review</a>.</p>



<a name="459550154"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459550154" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459550154">(Aug 09 2024 at 18:42)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711981410">PR review comment</a>:</p>
<blockquote>
<p>There is no other place in Cranelift that looks at the target OS when determining how to lower clif ir. Even TLS handling chooses the right variant for the target OS using a codegen flag rather than by looking at the OS in the triple. Using the right calling conventions is done by the producer of the clif ir. </p>
</blockquote>



<a name="459551026"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459551026" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459551026">(Aug 09 2024 at 18:49)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2230852356">PR review</a>.</p>



<a name="459551027"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459551027" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459551027">(Aug 09 2024 at 18:49)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711990548">PR review comment</a>:</p>
<blockquote>
<p>I think I agree here: philosophically, this is if not quite literally calling-convention related, certainly like an OS-interface detail that should be "baked into" the CLIF as CLIF is ordinarily explicit about such details. Can we check the triple in the Wasm translation (i.e., the wasmtime <code>FuncEnvironment</code> hook called by <code>cranelift-wasm</code>, or wherever else this instruction is generated) and fail if on the wrong platform?</p>
<p>This is also a little more future-looking in the sense that there may be <em>Wasmtime</em> details at some future point related to stack-switching (e.g., what if we add our own stack-protection mitigations or have some custom kind of stack-growth scheme or ...) -- we wouldn't want to hardcode that into Cranelift lowering in the same way OS details are here.</p>
</blockquote>



<a name="459551063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/459551063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#459551063">(Aug 09 2024 at 18:49)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1711990548">PR review comment</a>.</p>



<a name="461029109"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461029109" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461029109">(Aug 12 2024 at 17:43)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2233679825">PR review</a>.</p>



<a name="461029110"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461029110" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461029110">(Aug 12 2024 at 17:43)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1714163558">PR review comment</a>:</p>
<blockquote>
<p>Just to recap the context sprinkled through this PR: The reason why we need to do something platform/OS-specific here eventually is that Windows requires us to update parts of the <a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Information Block</a> when switching stacks. Unfortunately, what exactly needs to be done is undocumented, so I've not done it, yet. The "plain" stack switching I implemented in this PR was supposed to work only on Linux, but from what I can tell should work on x64 macOS, too.</p>
<p>@bjorn3:</p>
<p>Following what you said, I guess one approach would be to make the lowering of <code>stack_switch</code> more similar to that of <code>tls_value</code>. I'd imagine this would look as follows:</p>
<ul>
<li>Create a <code>StackSwitchMode</code> enum with <code>Default</code> and  <code>UpdateTib</code> variants.</li>
<li>Encode a value of that type in <code>shared_settings::Flags</code> and also add it as a field to the <code>StackSwitch</code> <code>MInst</code>.</li>
<li>When emitting code for <code>StackSwitch</code>, check the value of the <code>StackSwitchMode</code> flag and act accordingly.</li>
</ul>
<p>I'm also happy to have more than one <code>MInst</code> for stack switching, and lower the <code>stack_switch</code> CLIF instruction to one of them, based on the value of <code>StackSwitchMode</code>. That would mirror <code>tls_value</code> more closely, but I'm inclined to avoid that: The core stack switching code is always the same, we just sometimes need to emit some extra code on top of that.</p>
<p>Finally, what I described above would be the medium-term solution once I've implemented Windows support. For the time being I would just add a <code>None</code> variant to <code>StackSwitchMode</code>, use that on Windows, and panic if we see it when emitting code for <code>StackSwitch</code>.</p>
<p>@cfallin:</p>
<blockquote>
<p>Can we check the triple in the Wasm translation (i.e., the wasmtime <code>FuncEnvironment</code> hook called by <code>cranelift-wasm</code>, or wherever else this instruction is generated) and fail if on the wrong platform?</p>
</blockquote>
<p>Did you mean for this to be just a solution for the current issue of me wanting to fail if not on Linux? Or did you mean to also use this approach (i.e., resolving differences at the Wasm -&gt; CLIF stage) in the future when we want to generate slightly different code on different OS-es?</p>
<p>In the latter case, are you suggesting to have multiple stack switching CLIF instructions, for the case with and without the TIB update, then choose between them during the Wasm translation? Or are you suggesting to have a single CLIF instruction for the stack switching itself, but then emit some additional CLIF on Windows (say, some additional loads and stores) around the <code>stack_switch</code> during the Wasm translation?</p>
<p>I fully agree that for things like stack growing there's a good chance that in the future, we'd need some more customization of the generated code (e.g., customize stack probing, function preludes, ...).</p>
</blockquote>



<a name="461029306"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461029306" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461029306">(Aug 12 2024 at 17:44)</a>:</h4>
<p>frank-emrich edited <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1714163558">PR review comment</a>.</p>



<a name="461031327"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461031327" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461031327">(Aug 12 2024 at 17:57)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2233704146">PR review</a>.</p>



<a name="461031330"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461031330" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461031330">(Aug 12 2024 at 17:57)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1714178594">PR review comment</a>:</p>
<blockquote>
<blockquote>
<p>Did you mean for this to be just a solution for the current issue of me wanting to fail if not on Linux? Or did you mean to also use this approach (i.e., resolving differences at the Wasm -&gt; CLIF stage) in the future when we want to generate slightly different code on different OS-es?</p>
</blockquote>
<p>Both, I think -- basically, any sort of difference of behavior on that level should be reified in the CLIF, rather than implicit; that's how we've handled things like TLS and other platform dependencies.</p>
<blockquote>
<p>In the latter case, are you suggesting to have multiple stack switching CLIF instructions, for the case with and without the TIB update, then choose between them during the Wasm translation? Or are you suggesting to have a single CLIF instruction for the stack switching itself, but then emit some additional CLIF on Windows (say, some additional loads and stores) around the <code>stack_switch</code> during the Wasm translation?</p>
</blockquote>
<p>One or the other, depending on what is actually needed? I don't have enough context to actually specify the full design; that's something we can discuss further; only that we should make it explicit <em>somehow</em>. If one platform requires a superset of the work that another platform does, factoring out the common bit as one instruction and adding more logic at the CLIF level seems reasonable. On the other hand it's totally reasonable to have <code>stack_switch_windows</code> and <code>stack_switch_sysv</code> instructions IMHO; again see how we did TLS, with separate instructions for ELF and Mach-O cases.</p>
</blockquote>



<a name="461034400"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461034400" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461034400">(Aug 12 2024 at 18:15)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2233736591">PR review</a>.</p>



<a name="461034401"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/461034401" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#461034401">(Aug 12 2024 at 18:15)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1714197624">PR review comment</a>:</p>
<blockquote>
<blockquote>
<p>On the other hand it's totally reasonable to have <code>stack_switch_windows</code> and <code>stack_switch_sysv</code> instructions IMHO; again see how we did TLS, with separate instructions for ELF and Mach-O cases.</p>
</blockquote>
<p>Ah, I think that's where my confusion came from: For TLS, there is a single CLIF instruction, which is then lowered one of  several per-platform <code>MInst</code>s (but based on a flag in the backend, not some ad hoc OS check like I did). I'm happy to do it like that, which would be similar to what I described in my response to @bjorn3.</p>
<p>I'd prefer that over moving the TIB update out of the <code>stack_switch</code> (CLIF) instruction itself.</p>
</blockquote>



<a name="462337407"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/462337407" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#462337407">(Aug 14 2024 at 12:42)</a>:</h4>
<p><strong>frank-emrich</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="462337408"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/462337408" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#462337408">(Aug 14 2024 at 12:42)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="462337409"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/462337409" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#462337409">(Aug 14 2024 at 12:42)</a>:</h4>
<p><strong>frank-emrich</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="462338537"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/462338537" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#462338537">(Aug 14 2024 at 12:48)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2288651950">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>I've reworked the platform dependence logic based now, inspired by what happens for TLS:<br>
There's a new enum <code>StackSwitchModel</code> with values <code>None</code>, <code>Basic</code>, and <code>UpdateWindowsTib</code>. A value of that is saved in the backend <code>Flags</code>.<br>
This value is then used when lowering a <code>stack_switch</code> CLIF instruction: If <code>None</code>, we cannot lower them. If <code>Basic</code>, we lower to <code>stack_switch_basic</code>. In the future, it will be the case that  <code>UpdateWindowsTib</code> causes lowering to a new dedicated <code>MInst</code> (like <code>StackSwitchUpdateWindowsTib</code>), but currently this will behave like <code>None</code> (i.e., we fail to lower).<br>
</p>
</blockquote>



<a name="462339430"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/462339430" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#462339430">(Aug 14 2024 at 12:53)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2288662056">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>@alexcrichton For some reason the automated reviewer assignment was triggered again, maybe because this PR is now touching a non-Cranelift file.</p>
</blockquote>



<a name="463795202"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/463795202" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#463795202">(Aug 20 2024 at 19:45)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2299638359">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>Do others have more thoughts on this? This all looks reaosnable enough to me to land, but I'd want to be sure to run by others too.</p>
</blockquote>



<a name="463806036"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/463806036" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#463806036">(Aug 20 2024 at 20:28)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2249035461">PR review</a>:</p>
<blockquote>
<p>LGTM with one final nitpick below</p>
</blockquote>



<a name="463806037"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/463806037" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#463806037">(Aug 20 2024 at 20:28)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1723940274">PR review comment</a>:</p>
<blockquote>
<p>Rather than making this an extractor from a type, can we make it a partial constructor?</p>
<p>Then the use would look like</p>
<p><div class="codehilite" data-code-language="Common Lisp"><pre><span></span><code><span class="p">(</span><span class="nv">lower</span><span class="w"> </span><span class="p">(</span><span class="nv">stack_switch</span><span class="w"> </span><span class="nv">store_context_ptr</span><span class="w"> </span><span class="nv">load_context_ptr</span><span class="w"> </span><span class="nv">in_payload</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nv">if-let</span><span class="w"> </span><span class="p">(</span><span class="nv">stack_switch_model</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">StackSwitchModel.Basic</span><span class="p">))</span>
<span class="w">       </span><span class="o">...</span><span class="p">)</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="464012805"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464012805" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464012805">(Aug 21 2024 at 10:49)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="464013433"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464013433" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464013433">(Aug 21 2024 at 10:53)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2250469558">PR review</a>.</p>



<a name="464013435"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464013435" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464013435">(Aug 21 2024 at 10:53)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1724851866">PR review comment</a>:</p>
<blockquote>
<p>Done, but you meant <code>(if-let (StackSwitchModel.Basic) (stack_switch_model))</code>, right?</p>
<p>Is there a particular reason for making it a <em>partial</em> constructor? Following what's happening for TLS I gave my <code>StackSwitchModel</code> enum a <code>None</code> variant to indicate that no model was set, but that means that the <code>stack_switch_model</code> constructor can be total, or am I missing something?</p>
</blockquote>



<a name="464168169"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464168169" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464168169">(Aug 21 2024 at 20:59)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2251935303">PR review</a>.</p>



<a name="464168172"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464168172" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464168172">(Aug 21 2024 at 20:59)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1725748973">PR review comment</a>:</p>
<blockquote>
<p>I might be wrong, but I had thought that you can only use partial constructors in <code>if-let</code>s. Might be worth removing the <code>None</code> variant from <code>StackSwitchModel</code>, if so.</p>
</blockquote>



<a name="464174889"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464174889" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464174889">(Aug 21 2024 at 21:36)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2251985190">PR review</a>.</p>



<a name="464174944"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464174944" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464174944">(Aug 21 2024 at 21:37)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2303054235">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>I think this is in a good enough place that we can land it and then continue with any further improvements in follow ups. Thanks @frank-emrich!</p>
</blockquote>



<a name="464175219"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464175219" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464175219">(Aug 21 2024 at 21:39)</a>:</h4>
<p>frank-emrich updated <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<a name="464175241"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464175241" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464175241">(Aug 21 2024 at 21:39)</a>:</h4>
<p>frank-emrich submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#pullrequestreview-2251989154">PR review</a>.</p>



<a name="464175242"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464175242" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464175242">(Aug 21 2024 at 21:39)</a>:</h4>
<p>frank-emrich created <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#discussion_r1725783586">PR review comment</a>:</p>
<blockquote>
<p>I tried it, and turning <code>stack_switch_model</code> into a total constructor seems to just work.<br>
I don't understand the magic mechanism for configuring what goes into the backend  <code>Flags</code> in detail, but from what I can tell it does not allow you to store something logically equivalent to <code>Option&lt;StackSwitchModel&gt;</code> in there, so keeping the <code>None</code> variant in <code>StackSwitchModel</code> itself seems like the way to go.</p>
</blockquote>



<a name="464176196"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464176196" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464176196">(Aug 21 2024 at 21:43)</a>:</h4>
<p>frank-emrich <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2303061725">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>Oops, it looks like I responded to your comment and added a new commit in parallel to you approving things. But I think it should be uncontroversial, I kept <code>None</code> and made <code>stack_switch_model</code> total.</p>
</blockquote>



<a name="464176659"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464176659" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464176659">(Aug 21 2024 at 21:45)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/9078#issuecomment-2303064129">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>:</p>
<blockquote>
<p>Yeah, LGTM</p>
</blockquote>



<a name="464177621"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%239078%20Cranelift%3A%20add%20stack_switch%20CLIF%20inst.../near/464177621" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.239078.20Cranelift.3A.20add.20stack_switch.20CLIF.20inst.2E.2E.2E.html#464177621">(Aug 21 2024 at 21:52)</a>:</h4>
<p>fitzgen merged <a href="https://github.com/bytecodealliance/wasmtime/pull/9078">PR #9078</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>