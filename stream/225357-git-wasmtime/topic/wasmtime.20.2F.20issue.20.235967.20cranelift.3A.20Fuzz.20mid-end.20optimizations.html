<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5967 cranelift: Fuzz mid-end optimizations · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html">wasmtime / issue #5967 cranelift: Fuzz mid-end optimizations</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="340464109"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340464109" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340464109">(Mar 08 2023 at 21:05)</a>:</h4>
<p>jameysharp opened <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Currently, the <code>cranelift-fuzzgen</code> fuzz target performs differential fuzzing between our Cranelift interpreter and the native backend for the host. The native backend may be configured to run various mid-end optimizations before lowering, but as far as I can tell the interpreter is never configured to run any optimizations.</p>
<p>I think it might be useful to also differentially fuzz the interpreter without optimizations against the interpreter with various optimizations applied.</p>
<h4>Benefit</h4>
<p>This should give us an additional source of confidence that our mid-end optimization rules are not changing the behavior of generated code in observable ways.</p>
<h4>Implementation</h4>
<p>I think <code>cranelift-fuzzgen</code> can choose at random whether to use the native backend or the interpreter as the second implementation. I'm not sure how difficult it'll be to feed the interpreter the results of mid-end optimization, but I suspect the infrastructure we have for optimization filetests indicates that we have all the pieces we should need.</p>
<h4>Alternatives</h4>
<p>We could add a new fuzz target that's specifically for differentially fuzzing the interpreter against itself, but I think it would mostly duplicate infrastructure that's already in the cranelift-fuzzgen target.</p>
</blockquote>



<a name="340464743"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340464743" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340464743">(Mar 08 2023 at 21:09)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Currently, the <code>cranelift-fuzzgen</code> fuzz target performs differential fuzzing between our Cranelift interpreter and the native backend for the host. The native backend may be configured to run various mid-end optimizations before lowering, but as far as I can tell the interpreter is never configured to run any optimizations.</p>
<p>I think it might be useful to also differentially fuzz the interpreter without optimizations against the interpreter with various optimizations applied.</p>
<h4>Benefit</h4>
<p>This should give us an additional source of confidence that our mid-end optimization rules are not changing the behavior of generated code in observable ways.</p>
<h4>Implementation</h4>
<p>I think <code>cranelift-fuzzgen</code> can choose at random whether to use the native backend or the interpreter as the second implementation. I'm not sure how difficult it'll be to feed the interpreter the results of mid-end optimization, but I suspect the infrastructure we have for optimization filetests indicates that we have all the pieces we should need.</p>
<h4>Alternatives</h4>
<p>We could add a new fuzz target that's specifically for differentially fuzzing the interpreter against itself, but I think it would mostly duplicate infrastructure that's already in the cranelift-fuzzgen target.</p>
</blockquote>



<a name="340464744"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340464744" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340464744">(Mar 08 2023 at 21:09)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Currently, the <code>cranelift-fuzzgen</code> fuzz target performs differential fuzzing between our Cranelift interpreter and the native backend for the host. The native backend may be configured to run various mid-end optimizations before lowering, but as far as I can tell the interpreter is never configured to run any optimizations.</p>
<p>I think it might be useful to also differentially fuzz the interpreter without optimizations against the interpreter with various optimizations applied.</p>
<h4>Benefit</h4>
<p>This should give us an additional source of confidence that our mid-end optimization rules are not changing the behavior of generated code in observable ways.</p>
<h4>Implementation</h4>
<p>I think <code>cranelift-fuzzgen</code> can choose at random whether to use the native backend or the interpreter as the second implementation. I'm not sure how difficult it'll be to feed the interpreter the results of mid-end optimization, but I suspect the infrastructure we have for optimization filetests indicates that we have all the pieces we should need.</p>
<h4>Alternatives</h4>
<p>We could add a new fuzz target that's specifically for differentially fuzzing the interpreter against itself, but I think it would mostly duplicate infrastructure that's already in the cranelift-fuzzgen target.</p>
</blockquote>



<a name="340464768"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340464768" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340464768">(Mar 08 2023 at 21:09)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Currently, the <code>cranelift-fuzzgen</code> fuzz target performs differential fuzzing between our Cranelift interpreter and the native backend for the host. The native backend may be configured to run various mid-end optimizations before lowering, but as far as I can tell the interpreter is never configured to run any optimizations.</p>
<p>I think it might be useful to also differentially fuzz the interpreter without optimizations against the interpreter with various optimizations applied.</p>
<h4>Benefit</h4>
<p>This should give us an additional source of confidence that our mid-end optimization rules are not changing the behavior of generated code in observable ways.</p>
<h4>Implementation</h4>
<p>I think <code>cranelift-fuzzgen</code> can choose at random whether to use the native backend or the interpreter as the second implementation. I'm not sure how difficult it'll be to feed the interpreter the results of mid-end optimization, but I suspect the infrastructure we have for optimization filetests indicates that we have all the pieces we should need.</p>
<h4>Alternatives</h4>
<p>We could add a new fuzz target that's specifically for differentially fuzzing the interpreter against itself, but I think it would mostly duplicate infrastructure that's already in the cranelift-fuzzgen target.</p>
</blockquote>



<a name="340954859"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340954859" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340954859">(Mar 10 2023 at 20:05)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1464353467">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>A little more detail:</p>
<p>The file which I think needs to be modified here is <code>fuzz/fuzz_targets/cranelift-fuzzgen.rs</code>, which you can run by installing <a href="https://rust-fuzz.github.io/book/cargo-fuzz/setup.html">cargo fuzz</a> and running <code>cargo +nightly fuzz run cranelift-fuzzgen</code>.</p>
<p>Currently, that file calls <code>run_in_interpreter</code> first, and if that succeeds then for the same program and input it calls <code>run_in_host</code>. The idea here is that instead of calling <code>run_in_host</code>, we'd call <code>run_in_interpreter</code> a second time, but the CLIF we'd pass it would be the result of running mid-end optimizations.</p>
<p>For <code>cranelift-fuzzgen</code> to decide whether to use <code>run_in_host</code> or to optimize and run in the interpreter instead, we need to add a <code>bool</code> field to <code>TestCase</code>, and set that in <code>TestCase::generate</code> from the result of calling <code>gen.u.arbitrary()</code>.</p>
<p>To get the optimized functions, we need something like this, which I've more or less borrowed from <code>cranelift/filetests/src/test_optimize.rs</code>:</p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">optimized</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testcase</span>
<span class="w">        </span><span class="p">.</span><span class="n">functions</span>
<span class="w">        </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">func</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">comp_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">Context</span>::<span class="n">for_function</span><span class="p">(</span><span class="n">function</span><span class="p">.</span><span class="n">clone</span><span class="p">);</span>
<span class="w">            </span><span class="n">comp_ctx</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">testcase</span><span class="p">.</span><span class="n">isa</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="n">comp_ctx</span><span class="p">.</span><span class="n">func</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="340990425"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/340990425" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#340990425">(Mar 11 2023 at 00:21)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1464716718">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>I was talking with @jacarte the other day as well and he had a similar idea: do the <code>wasm-mutate</code> e-graphs thing (select a random e-node from the e-class rather than the best e-node). I guess this would also fit in with the chaos mode work.</p>
</blockquote>



<a name="341170830"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/341170830" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#341170830">(Mar 11 2023 at 18:34)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1464977081">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>We have bugpoint which already implements some shrinking mutations, we can make that a library. Some of them are not semantics preserving, but can maybe also help with the chaos mode work! (CC:  #4799)</p>
</blockquote>



<a name="341171848"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/341171848" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#341171848">(Mar 11 2023 at 18:43)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1464979566">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>Most mutations in bugpoint are written to cut away big chunks of the ir by eg replacing instructions with a constant or a trap. None of them are meant to be semantics preserving and I don't think they are useful for fuzzing either. Just for reducing a test case.</p>
</blockquote>



<a name="341566614"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/341566614" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#341566614">(Mar 13 2023 at 20:25)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1466907390">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>I love the idea of using random semantics-preserving mutations as part of cranelift-fuzzgen. @Jacarte or @fitzgen, could one of you write up an issue for that?</p>
<p>Thanks for reminding me of #4799, @afonso360. Re-reading the history there, I still think my comment was right and your idea was good: for the <code>cranelift-icache</code> target, bugpoint could potentially reflect a lot of edits that are useful for validating that the incremental cache doesn't reuse old compile results for functions which have changed.</p>
<p>For <code>cranelift-fuzzgen</code> though, I think @bjorn3 is right because we need to preserve semantics since we're going to compare the results of actually running the functions.</p>
<p>At any rate, that is all a topic for another issue. I think #5998 will address this current issue nicely.</p>
</blockquote>



<a name="341570570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/341570570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#341570570">(Mar 13 2023 at 20:49)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1466935902">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<p>Filed #6009 </p>
</blockquote>



<a name="342465847"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/342465847" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#342465847">(Mar 17 2023 at 03:46)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Currently, the <code>cranelift-fuzzgen</code> fuzz target performs differential fuzzing between our Cranelift interpreter and the native backend for the host. The native backend may be configured to run various mid-end optimizations before lowering, but as far as I can tell the interpreter is never configured to run any optimizations.</p>
<p>I think it might be useful to also differentially fuzz the interpreter without optimizations against the interpreter with various optimizations applied.</p>
<h4>Benefit</h4>
<p>This should give us an additional source of confidence that our mid-end optimization rules are not changing the behavior of generated code in observable ways.</p>
<h4>Implementation</h4>
<p>I think <code>cranelift-fuzzgen</code> can choose at random whether to use the native backend or the interpreter as the second implementation. I'm not sure how difficult it'll be to feed the interpreter the results of mid-end optimization, but I suspect the infrastructure we have for optimization filetests indicates that we have all the pieces we should need.</p>
<h4>Alternatives</h4>
<p>We could add a new fuzz target that's specifically for differentially fuzzing the interpreter against itself, but I think it would mostly duplicate infrastructure that's already in the cranelift-fuzzgen target.</p>
</blockquote>



<a name="342605168"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235967%20cranelift%3A%20Fuzz%20mid-end%20optimizations/near/342605168" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235967.20cranelift.3A.20Fuzz.20mid-end.20optimizations.html#342605168">(Mar 17 2023 at 16:05)</a>:</h4>
<p>Jacarte <a href="https://github.com/bytecodealliance/wasmtime/issues/5967#issuecomment-1474063860">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5967">issue #5967</a>:</p>
<blockquote>
<blockquote>
<p>I love the idea of using random semantics-preserving mutations as part of cranelift-fuzzgen. @Jacarte or @fitzgen, could one of you write up an issue for that?</p>
<p>Thanks for reminding me of #4799, @afonso360. Re-reading the history there, I still think my comment was right and your idea was good: for the <code>cranelift-icache</code> target, bugpoint could potentially reflect a lot of edits that are useful for validating that the incremental cache doesn't reuse old compile results for functions which have changed.</p>
<p>For <code>cranelift-fuzzgen</code> though, I think @bjorn3 is right because we need to preserve semantics since we're going to compare the results of actually running the functions.</p>
<p>At any rate, that is all a topic for another issue. I think #5998 will address this current issue nicely.</p>
</blockquote>
<p>Actually, It does not need to be semantizally equivalent. The rewriting rule can be, in theory, wathever transformation. For example <code>x =&gt; x + 1</code> is not semantically equivalent but still the e-graph will be constructed on that. </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>