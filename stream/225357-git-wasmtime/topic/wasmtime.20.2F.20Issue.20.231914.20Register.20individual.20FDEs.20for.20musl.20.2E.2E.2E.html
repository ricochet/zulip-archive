<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #1914 Register individual FDEs for musl ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html">wasmtime / Issue #1914 Register individual FDEs for musl ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="201782873"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201782873" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201782873">(Jun 23 2020 at 21:04)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648421790">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>FWIW I did a mild amount of poking with this, but I'm not sure if this works for the purposes of backtrace because <code>cargo test --target x86_64-unknown-linux-musl</code> was still failing. </p>
<p>Also I think the logic may be a bit clearer inverted for glibc-specific bits perhaps? I'm not sure how prevalent libgcc's logic is, but the "write a 0 length at the end of the table" on line 94 above these changes I think is only relevant for glibc.</p>
</blockquote>



<a name="201784473"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201784473" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201784473">(Jun 23 2020 at 21:16)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648432714">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>It is only relevant for libgcc's implementation, but doesn't really hurt to put it in the entire frame table and just skip it for the libunwind iteration.</p>
<p>You're right, it appears the tracing isn't working even with <code>__register_frame</code> appearing to properly register the individual FDEs with these changes.</p>
<p>Let me dig into that before we merge this.</p>
</blockquote>



<a name="201784845"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201784845" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201784845">(Jun 23 2020 at 21:19)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648432714">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>It is only relevant for libgcc's implementation, but doesn't really hurt to put it in the entire frame table and just skip it for the libunwind iteration.</p>
<p>You're right, it appears stack tracing isn't working even with <code>__register_frame</code> appearing to properly register the individual FDEs with these changes.</p>
<p>Let me dig into that before we merge this.</p>
</blockquote>



<a name="201795888"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201795888" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201795888">(Jun 23 2020 at 23:10)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648474729">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I've verified that each frame does get added to libunwind's DwarfFDECache:</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span><code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::add(mh=37745720, ip_start=140737351909383, ip_end=140737351909406, fde=37745720)
</code></pre></div>


<p>Those are the valid ranges of one of our function JITs and the FDE pointer is correct.</p>
<p>What I don't see is any calls to <code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> from <code>_Unwind_Backtrace</code>.  I see calls to <code>libunwind::EHHeaderParser&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> which are presumably for the ELF .eh_frame data.</p>
<p>Still debugging.</p>
</blockquote>



<a name="201795896"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201795896" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201795896">(Jun 23 2020 at 23:10)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648474729">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I've verified that each frame does get added to libunwind's <code>DwarfFDECache</code>:</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span><code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::add(mh=37745720, ip_start=140737351909383, ip_end=140737351909406, fde=37745720)
</code></pre></div>


<p>Those are the valid ranges of one of our function JITs and the FDE pointer is correct.</p>
<p>What I don't see is any calls to <code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> from <code>_Unwind_Backtrace</code>.  I see calls to <code>libunwind::EHHeaderParser&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> which are presumably for the ELF .eh_frame data.</p>
<p>Still debugging.</p>
</blockquote>



<a name="201797144"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201797144" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201797144">(Jun 23 2020 at 23:29)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648474729">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I've verified that each frame does get added to libunwind's <code>DwarfFDECache</code>:</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span><code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::add(mh=37745720, ip_start=140737351909383, ip_end=140737351909406, fde=37745720)
</code></pre></div>


<p>Those are the valid ranges of one of our function JITs and the FDE pointer is correct.</p>
<p><del>What I don't see is any calls to <code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> from <code>_Unwind_Backtrace</code></del> Function was inlined hence no breakpoint.  I see calls to <code>libunwind::EHHeaderParser&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> which are presumably for the ELF .eh_frame data.</p>
<p>Still debugging.</p>
</blockquote>



<a name="201803117"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201803117" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201803117">(Jun 24 2020 at 01:11)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648523695">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>It looks like the unwind cursor can't get past the signal handler trampoline frame and hence doesn't even get to the Wasm frames.</p>
<p>From lldb trace:</p>
<div class="codehilite"><pre><span></span><code>(lldb) bt
...
    frame #17: 0x0000000001af8ca0 wasmtime`__restore_rt
    frame #18: 0x00007ffff7de0075  &lt;--- faulting wasm frame with a simple unreachable trap
...
(lldb) di -a 0x0000000001af8ca0
wasmtime`__restore_rt:
    0x1af8ca0 &lt;+0&gt;: movq   $0xf, %rax
    0x1af8ca7 &lt;+7&gt;: syscall
</code></pre></div>


<p><a href="https://github.com/llvm/llvm-project/blob/64ec505dd46832880350e8b45316eaed30b458dc/lldb/source/Plugins/Platform/Linux/PlatformLinux.cpp#L383">lldb appears to special case the signal handler function names</a> and hence can walk past this frame.</p>
<p>However, <code>libunwind::UnwindCursor&lt;A, R&gt;::setInfoBasedOnIPRegister</code> with <code>pc=0x0000000001af8ca0</code> results in <a href="https://github.com/llvm/llvm-project/blob/2d865ccbd8c47fe94af04a6cffd02c45a24e2ffb/libunwind/src/UnwindCursor.hpp#L1988">_unwindInfoMissing being set to true for the frame</a>.  Note that it did search our dynamically registered frames for this one, except it isn't one of ours so that search was fruitless.</p>
<p>There's a <code>nop</code> instruction prior to this trampoline which is important as the PC is subtracted by 1 for the FDE search (it assumes there's been a call to create a frame, after all), so the FDE start for this function would actually be 0x0000000001af8c9f.  <a href="http://git.musl-libc.org/cgit/musl/commit/?id=54991729fd1e3d3a0cb71884d758d86afe6da9e0">Without the nop</a>, the adjusted PC would actually be in a different function.</p>
<p>I think this may work from glib rather than musl because it appears an <a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/sigaction.c.html#83">FDE is emitted for <code>__restore_rt</code></a>.</p>
<p>I'm leaning towards this being a musl bug where no FDE is emitted for <code>__restore_rt</code>.</p>
</blockquote>



<a name="201803184"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201803184" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201803184">(Jun 24 2020 at 01:12)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648524033">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I'd thus expect <code>libunwind::_Unwind_Backtrace</code> to be busted on musl for any walk from a signal handler.  I'll see if I can create a small repro in C.</p>
</blockquote>



<a name="201803225"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201803225" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201803225">(Jun 24 2020 at 01:13)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648523695">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>It looks like the unwind cursor can't get past the signal handler trampoline frame and hence doesn't even get to the Wasm frames.</p>
<p>From lldb trace:</p>
<div class="codehilite"><pre><span></span><code>(lldb) bt
...
    frame #17: 0x0000000001af8ca0 wasmtime`__restore_rt
    frame #18: 0x00007ffff7de0075  &lt;--- faulting wasm frame with a simple unreachable trap
...
(lldb) di -a 0x0000000001af8ca0
wasmtime`__restore_rt:
    0x1af8ca0 &lt;+0&gt;: movq   $0xf, %rax
    0x1af8ca7 &lt;+7&gt;: syscall
</code></pre></div>


<p><a href="https://github.com/llvm/llvm-project/blob/64ec505dd46832880350e8b45316eaed30b458dc/lldb/source/Plugins/Platform/Linux/PlatformLinux.cpp#L383">lldb appears to special case the signal handler function names</a> and hence can walk past this frame.</p>
<p>However, <code>libunwind::UnwindCursor&lt;A, R&gt;::setInfoBasedOnIPRegister</code> with <code>pc=0x0000000001af8ca0</code> results in <a href="https://github.com/llvm/llvm-project/blob/2d865ccbd8c47fe94af04a6cffd02c45a24e2ffb/libunwind/src/UnwindCursor.hpp#L1988">_unwindInfoMissing being set to true for the frame</a>.  Note that it did search Wasmtime's dynamically registered JIT frames for this one, except it isn't one of ours so that search was fruitless.</p>
<p>There's a <code>nop</code> instruction prior to this trampoline which is important as the PC is subtracted by 1 for the FDE search (it assumes there's been a call to create a frame, after all), so the FDE start for this function would actually be 0x0000000001af8c9f.  <a href="http://git.musl-libc.org/cgit/musl/commit/?id=54991729fd1e3d3a0cb71884d758d86afe6da9e0">Without the nop</a>, the adjusted PC would actually be in a different function.</p>
<p>I think this may work from glib rather than musl because it appears an <a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/sigaction.c.html#83">FDE is emitted for <code>__restore_rt</code></a>.</p>
<p>I'm leaning towards this being a musl bug where no FDE is emitted for <code>__restore_rt</code>.</p>
</blockquote>



<a name="201803264"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201803264" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201803264">(Jun 24 2020 at 01:14)</a>:</h4>
<p>peterhuene deleted a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648474729">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I've verified that each frame does get added to libunwind's <code>DwarfFDECache</code>:</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span><code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::add(mh=37745720, ip_start=140737351909383, ip_end=140737351909406, fde=37745720)
</code></pre></div>


<p>Those are the valid ranges of one of our function JITs and the FDE pointer is correct.</p>
<p><del>What I don't see is any calls to <code>libunwind::DwarfFDECache&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> from <code>_Unwind_Backtrace</code></del> Function was inlined hence no breakpoint.  I see calls to <code>libunwind::EHHeaderParser&lt;libunwind::LocalAddressSpace&gt;::findFDE</code> which are presumably for the ELF .eh_frame data.</p>
<p>Still debugging.</p>
</blockquote>



<a name="201803323"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201803323" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201803323">(Jun 24 2020 at 01:15)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648523695">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>It looks like the unwind cursor can't get past the signal handler trampoline frame and hence doesn't even get to the Wasm frames.</p>
<p>From lldb trace:</p>
<div class="codehilite"><pre><span></span><code>(lldb) bt
...
    frame #17: 0x0000000001af8ca0 wasmtime`__restore_rt
    frame #18: 0x00007ffff7de0075  &lt;--- faulting wasm frame with a simple unreachable trap
...
(lldb) di -a 0x0000000001af8ca0
wasmtime`__restore_rt:
    0x1af8ca0 &lt;+0&gt;: movq   $0xf, %rax
    0x1af8ca7 &lt;+7&gt;: syscall
</code></pre></div>


<p><a href="https://github.com/llvm/llvm-project/blob/64ec505dd46832880350e8b45316eaed30b458dc/lldb/source/Plugins/Platform/Linux/PlatformLinux.cpp#L383">lldb appears to special case the signal handler function names</a> and hence can walk past this frame.</p>
<p>However, <code>libunwind::UnwindCursor&lt;A, R&gt;::setInfoBasedOnIPRegister</code> with <code>pc=0x0000000001af8ca0</code> results in <a href="https://github.com/llvm/llvm-project/blob/2d865ccbd8c47fe94af04a6cffd02c45a24e2ffb/libunwind/src/UnwindCursor.hpp#L1988">_unwindInfoMissing being set to true for the frame</a>.  Note that it did search Wasmtime's dynamically registered JIT frames for this one, except it isn't one of ours so that search was fruitless.</p>
<p>There's a <code>nop</code> instruction prior to this trampoline which is important as the PC is subtracted by 1 for the FDE search (it assumes there's been a call to create a frame, after all), so the FDE start for this function would actually be 0x0000000001af8c9f.  <a href="http://git.musl-libc.org/cgit/musl/commit/?id=54991729fd1e3d3a0cb71884d758d86afe6da9e0">Without the nop</a>, the adjusted PC would actually be in a different function.</p>
<p>I think this may work from glib rather than musl because it appears an <a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/sigaction.c.html#83">FDE is emitted for <code>__restore_rt</code></a>.</p>
<p>I'm leaning towards this being a musl bug where no FDE is emitted for <code>__restore_rt</code>.</p>
</blockquote>



<a name="201814855"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201814855" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201814855">(Jun 24 2020 at 06:26)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>, but it doesn't start have a preceding <code>nop</code> instruction:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> contains PC <code>0000000000413599</code> (recall that the FDE search is PC-1).</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"> </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


</blockquote>



<a name="201814986"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201814986" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201814986">(Jun 24 2020 at 06:29)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> contains PC <code>0000000000413599</code> (recall that the FDE search is PC-1).</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"> </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


</blockquote>



<a name="201815433"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201815433" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201815433">(Jun 24 2020 at 06:38)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code> (clang 10):</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> contains PC <code>0000000000413599</code> (recall that the FDE search is PC-1).</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


<p>@alexcrichton any insights into why the Rust toolchain might be missing this FDE?  This repros with stable (llvm 9) and nightly (llvm 10).</p>
</blockquote>



<a name="201815995"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201815995" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201815995">(Jun 24 2020 at 06:50)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code> (clang 10):</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> is the "nearest" function to PC <code>0000000000413599</code>, which is the <code>nop</code> instruction (recall that the FDE search is PC-1).</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


<p>@alexcrichton any insights into why the Rust toolchain might be missing this FDE?  This repros with stable (llvm 9) and nightly (llvm 10).</p>
</blockquote>



<a name="201816357"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201816357" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201816357">(Jun 24 2020 at 06:59)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code> (clang 10):</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>, but the starting PC is not the <code>nop</code> instruction:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> is the "nearest" function to PC <code>0000000000413599</code>, which is the <code>nop</code> instruction (recall that the FDE search is PC-1).</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


<p>@alexcrichton any insights into why the Rust toolchain might be missing this FDE?  This repros with stable (llvm 9) and nightly (llvm 10).</p>
</blockquote>



<a name="201817541"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201817541" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201817541">(Jun 24 2020 at 07:17)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>A simple test program compiled with <code>clang test.c -static -lunwind -llzma</code> (clang 10):</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#define UNW_LOCAL_ONLY</span>
<span class="cp">#include</span> <span class="cpf">&lt;libunwind.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">backtrace</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span> <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
  <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>
    <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
    <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;ip = %lx, sp = %lx: %s + %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">sp</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">backtrace</span><span class="p">();</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">crash</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>Interestingly, this does create an FDE for <code>__restore_rt</code>, but the starting PC is not the <code>nop</code> instruction:</p>
<div class="codehilite"><pre><span></span><code>$ ldd a.out
/lib/ld-musl-x86_64.so.1: a.out: Not a valid dynamic program

$ readelf --debug-dump=frames -a a.out | grep 000000000041359a
   471: 000000000041359a     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
00001540 000000000000001c 00001528 FDE cie=00001528 pc=000000000041359a..00000000004135a3
</code></pre></div>


<p>As a result, this program is able to walk the stack, albeit it showing <code>sigaction+27</code> for <code>__restore_rt</code> as <code>sigaction</code> is the nearest non-hidden symbol.</p>
<div class="codehilite"><pre><span></span><code>$ ./a.out
ip = 401270, sp = 7ffc962fbba0: handler + 10
ip = 41359a, sp = 7ffc962fbbc0: sigaction + 27
ip = 4012a9, sp = 7ffc962fbbd0: bar + 9
ip = 4012b9, sp = 7ffc962fc180: foo + 9
ip = 4012e2, sp = 7ffc962fc190: main + 22
ip = 40f8eb, sp = 7ffc962fc1b0: libc_start_main_stage2 + 27
</code></pre></div>


<p>A Rust port of the program:</p>
<div class="codehilite"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">backtrace</span>::<span class="n">Backtrace</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">nix</span>::<span class="n">sys</span>::<span class="n">signal</span><span class="p">;</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">handler</span><span class="p">(</span><span class="n">_</span>: <span class="nc">nix</span>::<span class="n">libc</span>::<span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Backtrace</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">crash</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">crash</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">signal</span>::<span class="n">signal</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">Signal</span>::<span class="n">SIGSEGV</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">signal</span>::<span class="n">SigHandler</span>::<span class="n">Handler</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>However, no FDE was emitted for <code>__restore_rt</code>:</p>
<div class="codehilite"><pre><span></span><code>$ ldd test
/lib/ld-musl-x86_64.so.1: test: Not a valid dynamic program

$ readelf --debug-dump=frames -a test | grep 0000000000507047
  6473: 0000000000507047     9 FUNC    GLOBAL HIDDEN     2 __restore_rt
</code></pre></div>


<p>As a result, it only prints the top frame:</p>
<div class="codehilite"><pre><span></span><code>$ ./test
   0: test::handler
             at /test/src/main.rs:5
</code></pre></div>


<p>@alexcrichton any insights into why the Rust toolchain might be missing this FDE?  This repros with stable (llvm 9) and nightly (llvm 10).</p>
</blockquote>



<a name="201857017"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201857017" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201857017">(Jun 24 2020 at 14:47)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648867325">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>Oh wow awesome investigation!</p>
<p>In your <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648618710">C example</a> you're compiling with <code>clang</code> but are you sure that's linking to musl? By default I'd imagine that links to glibc and I think <code>-static</code> works for simple-ish programs with glibc.</p>
<p>I tried your program in an alpine container and I can't seem to get good results, but I'm not the best at investigating this too. There's two libunwind implementations (<code>libunwind-dev</code> and <code>llvm-libunwind-dev</code>), and I'm pretty sure the one we ship with Rust is the latter (the LLVM one). AFAICT the Rust toolchain ships with a musl built with <a href="https://github.com/richfelker/musl-cross-make">musl-cross-make</a> and it may be pulling in a too-old version? In any case in Alpine the results I'm getting are:</p>
<ul>
<li><code>libunwind</code> - backtrace works</li>
<li><code>libunwind</code> plus <code>-static</code> - backtrace works</li>
<li><code>llvm-libunwind</code> - backtrace doesn't get past the first frame</li>
<li><code>llvm-libunwind</code> plus <code>-static</code> - doesn't get past the first frame</li>
</ul>
<p>The odd part is that with llvm-libunwind I can see a CIE for the <code>backtrace</code> function, so I don't know why it can't get past the first frame. I wonder if this is maybe just a bug with llvm-libunwind?</p>
<p>In any case I think this is pretty far afield from what changes we should make to wasmtime itself. It seems clear here that we should register individual FDEs rather than the whole set at once like we do with glibc. In terms of changes to this PR, it seems like we now have 2/3 platforms (macos, musl) which require individual FDEs so it seems like glibc is the outlier taking the whole set at once. In that case could the code be restructured to have the individual FDE be the general case and the glibc path is just an optimization for glibc? For example the zero-length push at the end is only needed for glibc, and I think the <code>cfg_if!</code> can probably be removed in favor of just a simple <code>if cfg!(linux_gnu) { ... }</code></p>
</blockquote>



<a name="201857126"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201857126" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201857126">(Jun 24 2020 at 14:48)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-648867670">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>Oh and to make matters worse I don't know <a href="https://git.musl-libc.org/cgit/musl/tree/src/signal/x86_64/restore.s#n5">how the source of <code>__restore_rt</code></a> uses <code>eh_frame</code> anywhere...</p>
</blockquote>



<a name="201898183"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201898183" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201898183">(Jun 24 2020 at 20:16)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649047386">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I can confirm that my test cases are linking against musl libc (it's an alpine image using a musl-libc targeted clang).</p>
<p>I've been comparing the implementations between <code>llvm-libunwind</code> and <code>libunwind</code> for stack walking.  Both support having an <code>S</code> augmentation in the CIE to mark related FDE entries as "signal handler frames".  Unfortunately, the CIE for <code>__restore_rt</code> has no augmentations in these test executables.</p>
<p>For <code>llvm-libunwind</code>, that appears to be the only way to determine signal handler frames.  Even so, the walking algorithm doesn't seem to do anything for special for these frames (such as skipping over them).  This appears to be the crux of Rust's inability to walk the stack from a signal handler.</p>
<p>On the other hand, <code>libunwind</code>, about 10 years ago, <a href="https://github.com/libunwind/libunwind/blob/250382c56d2c84fc3976cf8a4c834433bb68990d/src/x86_64/Gos-linux.c#L47-L52">used to detect <code>__restore_rt</code> by checking the bytes of the trampoline</a> directly.  It would explicitly know how to unwind that frame and skip over it, hence giving more reliable walks.  Today a comment claims it uses <a href="https://github.com/libunwind/libunwind/blob/6a9e8725d52c66d17a2dcbf5be3685469934dbd2/src/x86_64/Gos-linux.c#L90-L94">"kernel provided information for the trampoline"</a>, but I haven't yet figured out where it does that.</p>
<p>Regarding <code>if cfg!(linux_gnu) { ... }</code> (are there docs on this variable somewhere? my googlefu is weak), my concern is that there might be non-linux glibc platforms (e.g. kfreebsd, etc.) we'd be doing the wrong thing for in the future.  But if you're comfortable with libunwind's <code>__register_frame</code> implementation being the default, I'm good with it too.</p>
</blockquote>



<a name="201898367"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201898367" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201898367">(Jun 24 2020 at 20:18)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649047386">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I can confirm that my test cases are linking against musl libc (it's an alpine image using a musl-libc targeted clang).</p>
<p>I've been comparing the implementations between <code>llvm-libunwind</code> and <code>libunwind</code> for stack walking.  Both support having an <code>S</code> augmentation in the CIE to mark related FDE entries as "signal handler frames".  Unfortunately, the CIE for <code>__restore_rt</code> has no augmentations in these test executables.</p>
<p>For <code>llvm-libunwind</code>, that appears to be the only way to determine signal handler frames.  Even so, the walking algorithm doesn't seem to do anything for special for these frames (such as skipping over them).  This appears to be the crux of Rust's (or the C program linked against <code>llvm-libunwind</code>'s) inability to walk the stack from a signal handler.</p>
<p>On the other hand, <code>libunwind</code>, about 10 years ago, <a href="https://github.com/libunwind/libunwind/blob/250382c56d2c84fc3976cf8a4c834433bb68990d/src/x86_64/Gos-linux.c#L47-L52">used to detect <code>__restore_rt</code> by checking the bytes of the trampoline</a> directly.  It would explicitly know how to unwind that frame and skip over it, hence giving more reliable walks.  Today a comment claims it uses <a href="https://github.com/libunwind/libunwind/blob/6a9e8725d52c66d17a2dcbf5be3685469934dbd2/src/x86_64/Gos-linux.c#L90-L94">"kernel provided information for the trampoline"</a>, but I haven't yet figured out where it does that.</p>
<p>Regarding <code>if cfg!(linux_gnu) { ... }</code> (are there docs on this variable somewhere? my googlefu is weak), my concern is that there might be non-linux glibc platforms (e.g. kfreebsd, etc.) we'd be doing the wrong thing for in the future.  But if you're comfortable with libunwind's <code>__register_frame</code> implementation being the default, I'm good with it too.</p>
</blockquote>



<a name="201900014"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201900014" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201900014">(Jun 24 2020 at 20:33)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649055743">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>That comment was introduced in <a href="https://github.com/libunwind/libunwind/commit/dac2d001afb1fa7040ca7d8ae57032f684d7023e">https://github.com/libunwind/libunwind/commit/dac2d001afb1fa7040ca7d8ae57032f684d7023e</a></p>
</blockquote>



<a name="201906010"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201906010" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201906010">(Jun 24 2020 at 21:26)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649081491">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>Oh geez that's quite a lot of history... Anyway definitely sounds like fuel for the fire of "not something we can fix in wasmtime". That being said this is also more fuel to the fire of "we should not rely on the native system unwinder to generate a backtrace on every single platform" since this mean wasm traps on musl will always be wrong.</p>
<p>@peterhuene were you able to reproduce how libunwind was working better than llvm-libunwind?</p>
<p>Oh also for <code>cfg!(linux_gnu)</code> that's not actually a thing, it's bad shorthand for <code>cfg!(all(target_os = "linux", target_env = "gnu"))</code>. In general it just seems like frame registration is pretty likely to be different per platform and we just have it where 2/3 platforms (musl/macos out of those plus linux) require iteration rather than whole-chunk registration. Ideally we'd have a clause here  which says "you're on an unknown platform, please test this and see what's right"</p>
</blockquote>



<a name="201909836"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201909836" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201909836">(Jun 24 2020 at 22:08)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649098943">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>I'll update the PR to use <code>cfg!(all(target_os = "linux", target_env = "gnu"))</code> and limit the push of the ending record marker in that case too.</p>
<p>I agree we can declare the inability to walk the stack for musl targets using llvm-libunwind an external issue to Wasmtime.  I think we should be somehow limiting our walks to sections of the stack that contain Wasm frames (as discussed in #1832) as it would both address this issue and #1845.</p>
</blockquote>



<a name="201916035"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201916035" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201916035">(Jun 24 2020 at 23:27)</a>:</h4>
<p>peterhuene <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649126027">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>@alexcrichton PR updated.</p>
</blockquote>



<a name="201916112"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231914%20Register%20individual%20FDEs%20for%20musl%20.../near/201916112" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231914.20Register.20individual.20FDEs.20for.20musl.20.2E.2E.2E.html#201916112">(Jun 24 2020 at 23:28)</a>:</h4>
<p>peterhuene edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/1914#issuecomment-649126027">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/1914">Issue #1914</a>:</p>
<blockquote>
<p>@alexcrichton PR updated.</p>
<p>I added a check for <code>target_env = ""</code> <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_env">based on the docs</a>.  I can remove it if that's not correct.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>