<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6126 Cranelift: GVN depends on value de... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html">wasmtime / issue #6126 Cranelift: GVN depends on value de...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="345758830"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345758830" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345758830">(Mar 30 2023 at 18:34)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>If the input CLIF does not define values in increasing numeric order, then the egraph GVN map may not recognize that two instructions are the same.</p>
<h3><code>.clif</code> Test Case</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span><span class="w"> </span><span class="n">precise</span><span class="o">-</span><span class="n">output</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">identical</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">between</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">that</span><span class="o">'</span><span class="na">s</span><span class="w"> </span><span class="n">added</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GVN</span><span class="w"> </span><span class="n">map</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">Finally</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">unify</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">}</span>

<span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<p>Run the above test with <code>cargo run -p cranelift-tools test</code>.</p>
<h3>Expected Results</h3>
<p>The above test should pass, with both <code>iadd</code> instructions merged into one.</p>
<h3>Actual Results</h3>
<p>The <code>iadd</code> instructions are not merged:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Versions and Environment</h3>
<p>Cranelift version or commit: main (94f2ff092)</p>
<p>Operating system: Linux</p>
<p>Architecture: x86-64</p>
<h3>Extra Info</h3>
<p>The hash key and equality definition in the GVN map are based on the set representative returned by the union-find data structure. So once we've added an instruction to the GVN map, every value it uses must have a stable set representative.</p>
<p>This union-find implementation always returns the minimum <code>Value</code> from the set as the set's representative. So a value has a stable set representative if it is never unioned with another set having a smaller set representative.</p>
<p>Most of the time we satisfy this condition. Any newly-created instructions from ISLE rules have value numbers greater than all existing instructions, and within a basic block frontends normally allocate value numbers at the same time that they insert instructions.</p>
<p>As this test case demonstrates though, it's easy to produce a different value order by writing CLIF by hand. I think the same bug can also be triggered if the frontend builds basic blocks in a different order than we visit them during equality saturation, which I suspect is not uncommon.</p>
<p>If the only consequence of this bug is that we sometimes fail to merge identical instructions, then it's not a correctness bug, just a missed optimization. I'm concerned though because this means the hash value for a key in the GVN map can change over time, which violates a hash-map invariant, and I'm not certain of the consequences of that. I don't think we'll trigger undefined behavior or panics, but clearly we can fail to find keys which are already in the map, and insert duplicate keys.</p>
<p>I'm not sure how to fix this.</p>
<p>One half-baked idea: when building the union tree of all results from <code>simplify</code>, if exactly one of the results was already in the GVN map, we use its representative as the representative of the new set. I suspect there can be more than one such result though, so I think that just delays the problem. Also it's a rather invasive change to how we build nodes from ISLE rules.</p>
<p>I think when we're about to union two values together we have enough information to notice that one of them will have its set representative changed. But the only thing I can think to do with that information is to find all the other instructions in the GVN map that refer to the changed value, and remove and reinsert them. That sounds awful.</p>
<p>Another option I don't like is to renumber all the values in the function so that they're in increasing order with respect to the order we're actually going to visit the blocks in.</p>
<p>A variant of renumbering is to keep a map of the values we've seen so far, mapping them to sequentially increasing integers, and use those integers as the union-find IDs. I think that might work, but I haven't followed the idea through far enough to be sure.</p>
<p>cc: @cfallin</p>
</blockquote>



<a name="345758831"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345758831" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345758831">(Mar 30 2023 at 18:34)</a>:</h4>
<p>jameysharp opened <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>If the input CLIF does not define values in increasing numeric order, then the egraph GVN map may not recognize that two instructions are the same.</p>
<h3><code>.clif</code> Test Case</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span><span class="w"> </span><span class="n">precise</span><span class="o">-</span><span class="n">output</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">identical</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">between</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">that</span><span class="o">'</span><span class="na">s</span><span class="w"> </span><span class="n">added</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GVN</span><span class="w"> </span><span class="n">map</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">Finally</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">unify</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">}</span>

<span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<p>Run the above test with <code>cargo run -p cranelift-tools test</code>.</p>
<h3>Expected Results</h3>
<p>The above test should pass, with both <code>iadd</code> instructions merged into one.</p>
<h3>Actual Results</h3>
<p>The <code>iadd</code> instructions are not merged:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Versions and Environment</h3>
<p>Cranelift version or commit: main (94f2ff092)</p>
<p>Operating system: Linux</p>
<p>Architecture: x86-64</p>
<h3>Extra Info</h3>
<p>The hash key and equality definition in the GVN map are based on the set representative returned by the union-find data structure. So once we've added an instruction to the GVN map, every value it uses must have a stable set representative.</p>
<p>This union-find implementation always returns the minimum <code>Value</code> from the set as the set's representative. So a value has a stable set representative if it is never unioned with another set having a smaller set representative.</p>
<p>Most of the time we satisfy this condition. Any newly-created instructions from ISLE rules have value numbers greater than all existing instructions, and within a basic block frontends normally allocate value numbers at the same time that they insert instructions.</p>
<p>As this test case demonstrates though, it's easy to produce a different value order by writing CLIF by hand. I think the same bug can also be triggered if the frontend builds basic blocks in a different order than we visit them during equality saturation, which I suspect is not uncommon.</p>
<p>If the only consequence of this bug is that we sometimes fail to merge identical instructions, then it's not a correctness bug, just a missed optimization. I'm concerned though because this means the hash value for a key in the GVN map can change over time, which violates a hash-map invariant, and I'm not certain of the consequences of that. I don't think we'll trigger undefined behavior or panics, but clearly we can fail to find keys which are already in the map, and insert duplicate keys.</p>
<p>I'm not sure how to fix this.</p>
<p>One half-baked idea: when building the union tree of all results from <code>simplify</code>, if exactly one of the results was already in the GVN map, we use its representative as the representative of the new set. I suspect there can be more than one such result though, so I think that just delays the problem. Also it's a rather invasive change to how we build nodes from ISLE rules.</p>
<p>I think when we're about to union two values together we have enough information to notice that one of them will have its set representative changed. But the only thing I can think to do with that information is to find all the other instructions in the GVN map that refer to the changed value, and remove and reinsert them. That sounds awful.</p>
<p>Another option I don't like is to renumber all the values in the function so that they're in increasing order with respect to the order we're actually going to visit the blocks in.</p>
<p>A variant of renumbering is to keep a map of the values we've seen so far, mapping them to sequentially increasing integers, and use those integers as the union-find IDs. I think that might work, but I haven't followed the idea through far enough to be sure.</p>
<p>cc: @cfallin</p>
</blockquote>



<a name="345758833"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345758833" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345758833">(Mar 30 2023 at 18:34)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>If the input CLIF does not define values in increasing numeric order, then the egraph GVN map may not recognize that two instructions are the same.</p>
<h3><code>.clif</code> Test Case</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span><span class="w"> </span><span class="n">precise</span><span class="o">-</span><span class="n">output</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">identical</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">between</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">that</span><span class="o">'</span><span class="na">s</span><span class="w"> </span><span class="n">added</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GVN</span><span class="w"> </span><span class="n">map</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">Finally</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">unify</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">}</span>

<span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<p>Run the above test with <code>cargo run -p cranelift-tools test</code>.</p>
<h3>Expected Results</h3>
<p>The above test should pass, with both <code>iadd</code> instructions merged into one.</p>
<h3>Actual Results</h3>
<p>The <code>iadd</code> instructions are not merged:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Versions and Environment</h3>
<p>Cranelift version or commit: main (94f2ff092)</p>
<p>Operating system: Linux</p>
<p>Architecture: x86-64</p>
<h3>Extra Info</h3>
<p>The hash key and equality definition in the GVN map are based on the set representative returned by the union-find data structure. So once we've added an instruction to the GVN map, every value it uses must have a stable set representative.</p>
<p>This union-find implementation always returns the minimum <code>Value</code> from the set as the set's representative. So a value has a stable set representative if it is never unioned with another set having a smaller set representative.</p>
<p>Most of the time we satisfy this condition. Any newly-created instructions from ISLE rules have value numbers greater than all existing instructions, and within a basic block frontends normally allocate value numbers at the same time that they insert instructions.</p>
<p>As this test case demonstrates though, it's easy to produce a different value order by writing CLIF by hand. I think the same bug can also be triggered if the frontend builds basic blocks in a different order than we visit them during equality saturation, which I suspect is not uncommon.</p>
<p>If the only consequence of this bug is that we sometimes fail to merge identical instructions, then it's not a correctness bug, just a missed optimization. I'm concerned though because this means the hash value for a key in the GVN map can change over time, which violates a hash-map invariant, and I'm not certain of the consequences of that. I don't think we'll trigger undefined behavior or panics, but clearly we can fail to find keys which are already in the map, and insert duplicate keys.</p>
<p>I'm not sure how to fix this.</p>
<p>One half-baked idea: when building the union tree of all results from <code>simplify</code>, if exactly one of the results was already in the GVN map, we use its representative as the representative of the new set. I suspect there can be more than one such result though, so I think that just delays the problem. Also it's a rather invasive change to how we build nodes from ISLE rules.</p>
<p>I think when we're about to union two values together we have enough information to notice that one of them will have its set representative changed. But the only thing I can think to do with that information is to find all the other instructions in the GVN map that refer to the changed value, and remove and reinsert them. That sounds awful.</p>
<p>Another option I don't like is to renumber all the values in the function so that they're in increasing order with respect to the order we're actually going to visit the blocks in.</p>
<p>A variant of renumbering is to keep a map of the values we've seen so far, mapping them to sequentially increasing integers, and use those integers as the union-find IDs. I think that might work, but I haven't followed the idea through far enough to be sure.</p>
<p>cc: @cfallin</p>
</blockquote>



<a name="345758886"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345758886" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345758886">(Mar 30 2023 at 18:34)</a>:</h4>
<p>jameysharp labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>If the input CLIF does not define values in increasing numeric order, then the egraph GVN map may not recognize that two instructions are the same.</p>
<h3><code>.clif</code> Test Case</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span><span class="w"> </span><span class="n">precise</span><span class="o">-</span><span class="n">output</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">identical</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">between</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">that</span><span class="o">'</span><span class="na">s</span><span class="w"> </span><span class="n">added</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GVN</span><span class="w"> </span><span class="n">map</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">Finally</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">unify</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">}</span>

<span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<p>Run the above test with <code>cargo run -p cranelift-tools test</code>.</p>
<h3>Expected Results</h3>
<p>The above test should pass, with both <code>iadd</code> instructions merged into one.</p>
<h3>Actual Results</h3>
<p>The <code>iadd</code> instructions are not merged:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Versions and Environment</h3>
<p>Cranelift version or commit: main (94f2ff092)</p>
<p>Operating system: Linux</p>
<p>Architecture: x86-64</p>
<h3>Extra Info</h3>
<p>The hash key and equality definition in the GVN map are based on the set representative returned by the union-find data structure. So once we've added an instruction to the GVN map, every value it uses must have a stable set representative.</p>
<p>This union-find implementation always returns the minimum <code>Value</code> from the set as the set's representative. So a value has a stable set representative if it is never unioned with another set having a smaller set representative.</p>
<p>Most of the time we satisfy this condition. Any newly-created instructions from ISLE rules have value numbers greater than all existing instructions, and within a basic block frontends normally allocate value numbers at the same time that they insert instructions.</p>
<p>As this test case demonstrates though, it's easy to produce a different value order by writing CLIF by hand. I think the same bug can also be triggered if the frontend builds basic blocks in a different order than we visit them during equality saturation, which I suspect is not uncommon.</p>
<p>If the only consequence of this bug is that we sometimes fail to merge identical instructions, then it's not a correctness bug, just a missed optimization. I'm concerned though because this means the hash value for a key in the GVN map can change over time, which violates a hash-map invariant, and I'm not certain of the consequences of that. I don't think we'll trigger undefined behavior or panics, but clearly we can fail to find keys which are already in the map, and insert duplicate keys.</p>
<p>I'm not sure how to fix this.</p>
<p>One half-baked idea: when building the union tree of all results from <code>simplify</code>, if exactly one of the results was already in the GVN map, we use its representative as the representative of the new set. I suspect there can be more than one such result though, so I think that just delays the problem. Also it's a rather invasive change to how we build nodes from ISLE rules.</p>
<p>I think when we're about to union two values together we have enough information to notice that one of them will have its set representative changed. But the only thing I can think to do with that information is to find all the other instructions in the GVN map that refer to the changed value, and remove and reinsert them. That sounds awful.</p>
<p>Another option I don't like is to renumber all the values in the function so that they're in increasing order with respect to the order we're actually going to visit the blocks in.</p>
<p>A variant of renumbering is to keep a map of the values we've seen so far, mapping them to sequentially increasing integers, and use those integers as the union-find IDs. I think that might work, but I haven't followed the idea through far enough to be sure.</p>
<p>cc: @cfallin</p>
</blockquote>



<a name="345760532"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345760532" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345760532">(Mar 30 2023 at 18:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1490759347">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>Hmm, interesting -- thanks for finding this!</p>
<p>I think that there actually may be a much simpler fix than any of the proposals (none of which feel very good to me -- they all mix invariants across subsystems/data structures somehow, or feel otherwise brittle). The idea is: when we union, always make the right-hand side point to the left-hand side as parent (so representative value is always the leftmost of the unioned values, however the union ops reassociate), and then be careful in our <code>union</code> usage that new values that are added as the right-hand side of the union.</p>
<p>This seems to me to be philosophically most aligned with the rest of the aegraph strategy -- new items always point to old items, never vice-versa.</p>
<p>There may be something I'm missing in the interactions with GVN'ing though...</p>
</blockquote>



<a name="345760831"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345760831" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345760831">(Mar 30 2023 at 18:45)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1490761157">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>Ah, sure enough, I see one issue with my proposal at least: rewrite rule hits in the GVN map and returns an old ID as the target of the rewrite; then when we union that in, we alter its representative value...</p>
</blockquote>



<a name="345761451"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345761451" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345761451">(Mar 30 2023 at 18:48)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1490767309">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>Yeah, exactly. I think there's no way to guarantee that we're only unioning with a value that isn't used by any other instructions in the GVN map.</p>
</blockquote>



<a name="345762422"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345762422" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345762422">(Mar 30 2023 at 18:53)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1490776800">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>I think I've convinced myself at least that this falls into a "missed optimization" category rather than "broken hashmap invariants" category:</p>
<ul>
<li>The hashcode is cached in the bucket in the CtxHashMap (<a href="https://github.com/bytecodealliance/wasmtime/blob/83d00fea4a881ab1160bf0a609ac463643bc0821/cranelift/codegen/src/ctxhash.rs#L55">here</a>), so it never changes past insertion (for the <em>bucket</em> at least, but that's all the <code>RawTable</code> sees) by construction.</li>
<li>The equality check <a href="https://github.com/bytecodealliance/wasmtime/blob/83d00fea4a881ab1160bf0a609ac463643bc0821/cranelift/codegen/src/egraph.rs#L632">uses the union-find to re-normalized to the latest representative</a>, so equality is always accurate.</li>
</ul>
<p>A value thus may become equal to new items over time as unions occur, but its hashcode (as seen by the table!) will never change; so I think the invariants are maintained.</p>
</blockquote>



<a name="345763207"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/345763207" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#345763207">(Mar 30 2023 at 18:57)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1490781594">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>FWIW, an alternative that we can always fall back to, as well, is to not hash/eq according to representative values but according to the literal (latest) values. With eager rewriting, this may not even miss very many opportunities; it might be worth testing this. It could result in a compile-time speedup too.</p>
</blockquote>



<a name="346702832"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/346702832" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#346702832">(Apr 04 2023 at 00:23)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1495166666">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>I'm not sure I understand what you mean by "latest" values. Do you mean whatever is currently in the <code>value_to_opt_value</code> map? I agree that's worth trying. I _think_ it should fix the test case I wrote for this issue, at least.</p>
<p>When you say "eager rewriting", I'm guessing you mean ensuring that, any time we index into the GVN map, we have already updated the instruction's arguments. Since we only use the GVN map inside <code>insert_pure_enode</code>, we can always do that there, like in #6135. But I think whenever we have a new instruction we might have constructed it using only normalized Values, so it might only be necessary when looking up existing instructions in <code>remove_pure_and_optimize</code>.</p>
<p>If we can look up instructions which have already been normalized before we hash them and we don't use union-find to pick a set representative, then I believe we can entirely delete this union-find implementation.</p>
<p>At that point we're only using <code>CtxHashMap</code> to look up the contents of value lists. But I think there might aren't any pure or idempotent instructions which use value lists, so maybe we can switch to a plain <code>HashMap</code> and delete <code>CtxHashMap</code> as well…</p>
</blockquote>



<a name="346705625"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/346705625" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#346705625">(Apr 04 2023 at 00:51)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1495188315">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<blockquote>
<p>I'm not sure I understand what you mean by "latest" values. Do you mean whatever is currently in the <code>value_to_opt_value</code> map? I agree that's worth trying. I _think_ it should fix the test case I wrote for this issue, at least.</p>
</blockquote>
<p>Yep, exactly: latest with respect to the "append-only immutable data structure" view. My mental image of an eclass in the aegraph is roughly that there are two pointers that we hold -- the "latest", after we've done all rewriting, which can reach all members of the eclass via the tree of union nodes; and the "canonical", which (until you found this discrepancy) was meant to be the earliest. This append-only-log view with nominally increasing value numbers is I think also why we didn't see this bug earlier: creating values with out-of-order numbers is <em>unusual</em>, at least, though it's perfectly legal.</p>
<p>At one point I had considered making all args in nodes actually keep this dual view (two pointers, canonical and latest) but quickly abandoned that thought because of the size implications; and that was how the context-hash with normalizing behavior was born...</p>
<blockquote>
<p>When you say "eager rewriting", I'm guessing you mean ensuring that, any time we index into the GVN map, we have already updated the instruction's arguments. Since we only use the GVN map inside <code>insert_pure_enode</code>, we can always do that there, like in #6135. But I think whenever we have a new instruction we might have constructed it using only normalized Values, so it might only be necessary when looking up existing instructions in <code>remove_pure_and_optimize</code>.</p>
</blockquote>
<p>Not quite; by "eager rewriting" I am referring to our rewriting strategy, namely that we invoke <code>simplify</code> right away when creating nodes, so the "latest" is quickly built and then won't change later. So any later references to the eclass, arrived at via mapping through <code>value_to_opt_value</code> or via hits in the GVN-map, will use the same "latest" value, most likely. In other words, I'm not suggesting that we ensure anything via new logic; I'm hypothesizing that a property of our existing implementation makes a strategy ("just look up based on the values that we have") likely good enough (and that we should test this!).</p>
<p>A subtle but important detail here too is that when we recursively create new nodes via rewrites' RHSes, we optimize those nodes <em>and then</em> insert them into the GVN map (and likewise for toplevel nodes). This means that the GVN-map entry for every value in a chain of rewrites will point to the "latest", because the insertions happen as we return up the stack after all the union-nodes are built.</p>
<blockquote>
<p>If we can look up instructions which have already been normalized before we hash them and we don't use union-find to pick a set representative, then I believe we can entirely delete this union-find implementation.</p>
</blockquote>
<p>Possibly! I haven't fully thought through this; it may be the case that during elaboration we still want to track things by canonical ID...</p>
<blockquote>
<p>At that point we're only using <code>CtxHashMap</code> to look up the contents of value lists. But I think there might aren't any pure or idempotent instructions which use value lists, so maybe we can switch to a plain <code>HashMap</code> and delete <code>CtxHashMap</code> as well…</p>
</blockquote>
<p>Yup, that would be great; it's the ugliest part of the implementation. It also would have a nice side-benefit of removing the only <code>unsafe</code> in the impl (to wrap the <code>RawTable</code> usage).</p>
</blockquote>



<a name="346713899"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/346713899" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#346713899">(Apr 04 2023 at 02:07)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1495237054">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>So I just came up with the (obvious in hindsight) counterexample that I think led me to come up with the existing scheme in the first place:</p>
<ul>
<li>Some value <code>v1</code> exists (it can even be a large eclass after lots of rewrites; we have its "latest" value <code>v1</code> and we hope we'll always be able to refer to it by this!);</li>
<li>We see <code>v2 = expensive_op v1</code>. Into the GVN-map it goes. Hopefully all other such <code>expensive_op</code>s on this eclass will reuse its work!</li>
<li>We see <code>v3 = iconst 0</code>, <code>v4 = iadd v1, v3</code>. We union this into the original eclass for <code>v1</code> and update the "latest" accordingly.</li>
<li>We now see <code>v5 = expensive_op v4</code>. <code>v4</code> is in the same eclass as <code>v1</code> so we should reuse the value above and GVN onto the same node... except we don't, anymore, if we take my suggestion above, because we added the map entry when <code>v1</code> was the latest and again when <code>v4</code> is the latest.</li>
</ul>
<p>(Sorry for just paging in / rediscovering the canonical bad case now; it's been a while!)</p>
<p>This case I suspect will actually be fairly common, because it's common for ops to optimize to some inner subexpression (<code>x + 0</code>, <code>x | 0</code> and the like). So, I retract my hypothesis above!</p>
<p>I think, in addition to your possibilities above, there are a few other possible solutions:</p>
<ul>
<li>(you'll hate me for this) <code>subsume</code> in such opt rules, in combination with hash-on-latest. This has the advantage of keeping to the strict hashtable invariant of "keys never change", allowing us to delete <code>CtxHashMap</code> and maybe the union-find too. It's conceptually fairly simple (I argue) and we can lay out clear rules for when to subsume: when returning a subexpression of the original (<code>x + 0 -&gt; x</code>) or a constant only.</li>
<li>adopt the "two keys may become equal" semantics of keys explicitly, and make whatever changes we need to convince ourselves this is OK: either audit <code>hashbrown::RawTable</code>, or...<ul>
<li>I stated above I was fairly comfortable with this, and will argue a little more explicitly here (albeit without a formal audit) that <code>hashbrown::RawTable</code> should work in a context where keys that were not equal start to compare equal:<ul>
<li>The <code>RawTable::insert</code> interface takes only a hashcode, and a closure to hash existing buckets; it does not require equality definitions at all. We cache hashcodes in nodes and they never change. Now imagine the thought-experiment where we always insert and never query: the hashtable cannot be ill-formed because we have never exposed any equality information.</li>
<li>The <code>RawTable::get</code> interface takes a hashcode and an equality comparator, but only compares the query key to buckets, never bucket-to-bucket. (It also is not given a way to query hashcodes of buckets.) Thus it is constrained to some form of "iterate over possible matches and return the match if found" implementation. Now in this list we'll either encounter a key that was originally equal to our query key, or one that became equal due to UF-merging, or one that is still not equal. In the first and last cases we'll do as we would without this weird comparison definition; nothing is changed. In the middle case, we would not have returned this match before, but that's OK: the equality doesn't lie, and this is a true match!</li>
<li>In other words, correctness rests on the fact that (i) equality can <em>grow</em> but never <em>shrink</em> (we never split eclasses) so incidental contact with another bucket that just became equal is a "happy accident"; and (ii) insertion cares only about hashcodes, and hashcodes never change.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>I'm sort of leaning toward accepting the latter and moving on, but I could be convinced of something better too! I think the only door that's really closed is some sort of "rehash on merge" approach, because that's just going to be too expensive.</p>
</blockquote>



<a name="346718299"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/346718299" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#346718299">(Apr 04 2023 at 02:57)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1495271915">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>Last thought that paged itself back in (I was trying to think about something else, I promise!): the union-find and canonical/representative IDs are necessary during elaboration as well because this is how scoped elaboration answers the question "do I already have this value?". If we give that up, we'll likely have more redundant elaboration when we see examples of the form above as well. So I think I'm reasoning myself back to the current design and becoming slightly more convinced (still open to ideas though!) that the most reasonable answer here is "leave as-is".</p>
</blockquote>



<a name="393944279"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/393944279" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#393944279">(Sep 29 2023 at 14:39)</a>:</h4>
<p>meithecatte <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1741001404">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>I would like to propose another bad example:</p>
<ol>
<li>We process the following instructions, and nothing very interesting happens:</li>
</ol>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_op</span><span class="w"> </span><span class="n">v1</span>
<span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar_op</span><span class="w"> </span><span class="n">v1</span>
<span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expensive_op</span><span class="w"> </span><span class="n">v3</span>
</code></pre></div>
<ol start="2">
<li>We encounter <code>v5 = weird_op v1</code>. Due to some special form of <code>v1</code> just out of view, two optimizations trigger: one rewrites to <code>foo_op v1</code>, the other to <code>bar_op v1</code>. We union <code>v2</code>, <code>v3</code> and <code>v5</code> together. Necessarily, the canonical representative of either <code>v2</code> or <code>v3</code> will change. Let's assume it's <code>v3</code>, as that's what would happen with today's strategy.</li>
<li>We encounter <code>v6 = expensive_op v3</code>. Even though this would be trivially deduplicated with <code>v4</code> by classic GVN, we'd miss this, since the canonical representative changed.</li>
</ol>
<p>Now, I'm not sure how realistic this is, but it definitely makes things more difficult to reason about. I've actually been looking into acyclic e-graphs for a project unrelated to cranelift, and bounced off a few times with "I must be misunderstanding something" when the shape of the code asked "what should happen in this case".</p>
<p>Essentially, we would like <code>eclasses.union</code> to have the precondition of "this won't ever change the canonical id for anything in the GVN map", but there's no way to actually ensure that, short of a global correctness condition on the whole body of rewrite rules. I do agree, however, that this seems to be, at worst, missed-optimisation severity, unless there are situation where we look something up in the GVN map with "we must've inserted it already, therefore the case where it's not present in the GVN map is unreachable".</p>
</blockquote>



<a name="393972819"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/393972819" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#393972819">(Sep 29 2023 at 17:06)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1741231092">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>@meithecatte indeed, I think that would still be a <em>correct</em> compilation, just not an <em>optimal</em> one.</p>
<p>In a little more detail, I think it's unlikely to happen if one keeps a sort of "transitive equality" principle in mind when writing the rewrite rules: here we have <code>A -&gt; B</code> and <code>A -&gt; C</code>, but there are no rules that rewrite <code>B -&gt; C</code> or <code>C -&gt; B</code>. Ideally we have a full enough set of identities that if <code>A</code> rewrites to both <code>B</code> and <code>C</code>, we already know the latter two are equivalent. Or perhaps we write only one of the rewrites out of <code>A</code> (say, to <code>B</code>), and then trust other rules to optimize that further. I guess there is sort of a stratification in my mind here: <code>A</code> is some complex thing we're decomposing, and <code>B</code> and <code>C</code> are "simple" ops in some lower level of complexity; that lower layer itself should ideally be fairly "rewrite-complete" so we don't have "indirect equalities" like this exposed.</p>
<p>That's a little handwavy, and again the worst that happens is that we miss a GVN, so it's not the end of the world -- part of the tradeoff we accept in not doing the full recanonicalization, which is much more expensive in the common case :-)</p>
</blockquote>



<a name="395928466"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/395928466" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#395928466">(Oct 10 2023 at 17:29)</a>:</h4>
<p>meithecatte <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1755918425">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>I have some thoughts on how to fix this. The general idea is that the union-find should support "pinning" a value, such that it then does its best to keep that particular value as the canonical representative. You would then pin the value ids that get put into the <code>gvn_map</code>.</p>
<p>Implementation-wise, this could be done with an augmented <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank">union-by-rank</a> strategy – pinning simply sets the rank to <code>u8::MAX</code>. Trying to union two pinned values together should then issue a warning, to alert the compiler engineer that optimization rules are probably missing (and then give up on maintaining one of the pins). Is there an appropriate logging framework in place for this sort of thing?</p>
</blockquote>



<a name="395932128"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/395932128" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#395932128">(Oct 10 2023 at 17:56)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/6126#issuecomment-1755953108">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>That's a really interesting idea; if you're interested in prototyping this, I think we'd at least be very interested in data (does it cause any regressions in compile time?) and confirming it doesn't alter generated code.</p>
<p>Such a warning could probably be emitted with the usual logging framework (<code>log::info!()</code> or <code>log::warn!()</code>, depending on how noisy we want to be -- we've had embedders complain before about verbosity of our logs at higher levels so we may want to be a little careful). Or alternately, we have the stats framework already, and we could count the number of such cases. At some point we want to use those stats to detect issues and drive optimizations/improvements ourselves and having a "should be zero, potential issue if not" stat could be a supported observation mode...</p>
</blockquote>



<a name="421082919"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236126%20Cranelift%3A%20GVN%20depends%20on%20value%20de.../near/421082919" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236126.20Cranelift.3A.20GVN.20depends.20on.20value.20de.2E.2E.2E.html#421082919">(Feb 12 2024 at 17:00)</a>:</h4>
<p>cfallin closed <a href="https://github.com/bytecodealliance/wasmtime/issues/6126">issue #6126</a>:</p>
<blockquote>
<p>If the input CLIF does not define values in increasing numeric order, then the egraph GVN map may not recognize that two instructions are the same.</p>
<h3><code>.clif</code> Test Case</h3>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">test</span><span class="w"> </span><span class="n">optimize</span><span class="w"> </span><span class="n">precise</span><span class="o">-</span><span class="n">output</span>
<span class="n">set</span><span class="w"> </span><span class="n">opt_level</span><span class="o">=</span><span class="n">speed</span>
<span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span>
<span class="n">target</span><span class="w"> </span><span class="n">x86_64</span>

<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">identical</span><span class="w"> </span><span class="n">iconst</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">between</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">that</span><span class="o">'</span><span class="na">s</span><span class="w"> </span><span class="n">added</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GVN</span><span class="w"> </span><span class="n">map</span><span class="p">.</span>
<span class="p">;</span><span class="w"> </span><span class="n">Finally</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">unify</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
    <span class="nc">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">}</span>

<span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<p>Run the above test with <code>cargo run -p cranelift-tools test</code>.</p>
<h3>Expected Results</h3>
<p>The above test should pass, with both <code>iadd</code> instructions merged into one.</p>
<h3>Actual Results</h3>
<p>The <code>iadd</code> instructions are not merged:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">%</span><span class="n">unordered</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;</span><span class="w"> </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;</span><span class="w">     </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="p">;</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<h3>Versions and Environment</h3>
<p>Cranelift version or commit: main (94f2ff092)</p>
<p>Operating system: Linux</p>
<p>Architecture: x86-64</p>
<h3>Extra Info</h3>
<p>The hash key and equality definition in the GVN map are based on the set representative returned by the union-find data structure. So once we've added an instruction to the GVN map, every value it uses must have a stable set representative.</p>
<p>This union-find implementation always returns the minimum <code>Value</code> from the set as the set's representative. So a value has a stable set representative if it is never unioned with another set having a smaller set representative.</p>
<p>Most of the time we satisfy this condition. Any newly-created instructions from ISLE rules have value numbers greater than all existing instructions, and within a basic block frontends normally allocate value numbers at the same time that they insert instructions.</p>
<p>As this test case demonstrates though, it's easy to produce a different value order by writing CLIF by hand. I think the same bug can also be triggered if the frontend builds basic blocks in a different order than we visit them during equality saturation, which I suspect is not uncommon.</p>
<p>If the only consequence of this bug is that we sometimes fail to merge identical instructions, then it's not a correctness bug, just a missed optimization. I'm concerned though because this means the hash value for a key in the GVN map can change over time, which violates a hash-map invariant, and I'm not certain of the consequences of that. I don't think we'll trigger undefined behavior or panics, but clearly we can fail to find keys which are already in the map, and insert duplicate keys.</p>
<p>I'm not sure how to fix this.</p>
<p>One half-baked idea: when building the union tree of all results from <code>simplify</code>, if exactly one of the results was already in the GVN map, we use its representative as the representative of the new set. I suspect there can be more than one such result though, so I think that just delays the problem. Also it's a rather invasive change to how we build nodes from ISLE rules.</p>
<p>I think when we're about to union two values together we have enough information to notice that one of them will have its set representative changed. But the only thing I can think to do with that information is to find all the other instructions in the GVN map that refer to the changed value, and remove and reinsert them. That sounds awful.</p>
<p>Another option I don't like is to renumber all the values in the function so that they're in increasing order with respect to the order we're actually going to visit the blocks in.</p>
<p>A variant of renumbering is to keep a map of the values we've seen so far, mapping them to sequentially increasing integers, and use those integers as the union-find IDs. I think that might work, but I haven't followed the idea through far enough to be sure.</p>
<p>cc: @cfallin</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>