<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5881 cranelift-interpreter: Implement `... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html">wasmtime / issue #5881 cranelift-interpreter: Implement `...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="337987356"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/337987356" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#337987356">(Feb 25 2023 at 12:01)</a>:</h4>
<p>afonso360 opened <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
</blockquote>



<a name="337987360"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/337987360" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#337987360">(Feb 25 2023 at 12:01)</a>:</h4>
<p>afonso360 labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
</blockquote>



<a name="337987361"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/337987361" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#337987361">(Feb 25 2023 at 12:01)</a>:</h4>
<p>afonso360 labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
</blockquote>



<a name="337987362"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/337987362" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#337987362">(Feb 25 2023 at 12:01)</a>:</h4>
<p>afonso360 labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
</blockquote>



<a name="337987608"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/337987608" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#337987608">(Feb 25 2023 at 12:03)</a>:</h4>
<p>afonso360 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
<p>If anyone needs help working on this feel free to reach out!</p>
</blockquote>



<a name="338169063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338169063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338169063">(Feb 26 2023 at 15:43)</a>:</h4>
<p>jan-justin <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445392587">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I am having a look into this and kindly wanted some clarification on what was intended by:</p>
<blockquote>
<p>This is probably as simple as passing the MemFlags from the original load...</p>
</blockquote>
<p>My confusion is regarding where to get the <code>MemFlags</code> from, as not all instruction implementations that end up calling <code>State::checked_{load,store}</code> will have the relevant flags retrievable from <code>InstructionData::memflags</code>.</p>
<p>I do not see any other obvious way to obtain the <code>MemFlags</code>. Did I miss something?</p>
</blockquote>



<a name="338170238"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338170238" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338170238">(Feb 26 2023 at 15:52)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445394404">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>I had a look, I think we don't have <code>MemFlags</code> in <code>Stack{Load,Store}</code> right? I think in those cases we should be able to use <code>MemFlags::trusted()</code>, which creates a native endian access.</p>
<p>Similarly it looks like we emit a checked_load when loading GlobalValues, we should also be able to use <code>MemFlags::trusted()</code> for those.</p>
<p>Is there any other? We might not always be able to use <code>MemFlags::trusted()</code>, If the access may trap or may be unaligned we should use <code>MemFlags::new()</code>.</p>
</blockquote>



<a name="338170368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338170368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338170368">(Feb 26 2023 at 15:52)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445394404">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>I had a look, I think we don't have <code>MemFlags</code> in <code>stack_{load,store}</code> right? I think in those cases we should be able to use <code>MemFlags::trusted()</code>, which creates a native endian access.</p>
<p>Similarly it looks like we emit a checked_load when loading GlobalValues, we should also be able to use <code>MemFlags::trusted()</code> for those.</p>
<p>Is there any other? We might not always be able to use <code>MemFlags::trusted()</code>, If the access may trap or may be unaligned we should use <code>MemFlags::new()</code>.</p>
</blockquote>



<a name="338170635"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338170635" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338170635">(Feb 26 2023 at 15:54)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445394404">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>I had a look, I think we don't have <code>MemFlags</code> in <code>stack_{load,store}</code> right? I think in those cases we should be able to use <code>MemFlags::trusted()</code>, which creates a native endian access. (This is <a href="https://github.com/bytecodealliance/wasmtime/blob/66cb13cb4bf467ea4b6f0efa4c9078c4ea7e665d/cranelift/codegen/src/legalizer/mod.rs#L85-L87">what we do in the legalizer</a>)</p>
<p>Similarly it looks like we emit a checked_load when loading GlobalValues, we should also be able to use <code>MemFlags::trusted()</code> for those. (This is also <a href="https://github.com/bytecodealliance/wasmtime/blob/66cb13cb4bf467ea4b6f0efa4c9078c4ea7e665d/cranelift/codegen/src/legalizer/globalvalue.rs#L120">what we do in the legalizer</a>)</p>
<p>Is there any other? We might not always be able to use <code>MemFlags::trusted()</code>, If the access may trap or may be unaligned we should use <code>MemFlags::new()</code>.</p>
</blockquote>



<a name="338188122"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338188122" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338188122">(Feb 26 2023 at 18:14)</a>:</h4>
<p>jan-justin <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445424900">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>Thanks! That helps. I will take that under advisement.</p>
<p>You are correct regarding the <code>MemFlags</code> for <code>stack_{load,store}</code>.</p>
<p>I saw the <code>checked_load</code> for the loading of <code>GlobalValues</code>, but I was going to have the flags passed in. Good thing you spotted it first!</p>
<p>So then the only question that remains for me is whether or not some inconsistency may arise from relying on the default endianness in the above cases? What happens when say the flag is explicitly set for big endian when doing a <code>load</code>, but the default endianness is little endian and used for say <code>atomic_cas</code> which now relies on default endianness? Can this even happen, or is it a non-issue?</p>
</blockquote>



<a name="338189943"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338189943" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338189943">(Feb 26 2023 at 18:31)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1445429345">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>That... Is a big can of worms. We've been discussing how to make CLIF endianness independent for a while in #3369.</p>
<p>There is more to this than that thread, I don't quite remember the full scope of the discussion, But we've talked about it a lot. I think last time we did reach some sort of conclusion about how to fix it, but I can't remember. (cc: @cfallin)</p>
<p>I think a good middle term right now would be to have a "native" endianness property in the interpreter that we can change, and defaults to the host's endianness. I think that correctly represents the current way of dealing with things and should be fairly easy to remove once we no longer need it.</p>
</blockquote>



<a name="338289632"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338289632" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338289632">(Feb 27 2023 at 10:33)</a>:</h4>
<p>jan-justin <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446082169">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>I see, that is indeed a big can of worms.</p>
<p>In a feeble attempt to stuff those worms back into the can, what can be done for this particular issue? The steps you initially described no longer seem relevant, or am I mistaken? Is the middle ground solution, as you described it, something that is relatively straightforward for me to pursue?</p>
</blockquote>



<a name="338300342"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338300342" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338300342">(Feb 27 2023 at 11:22)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446158771">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<blockquote>
<p>The steps you initially described no longer seem relevant, or am I mistaken? Is the middle ground solution, as you described it, something that is relatively straightforward for me to pursue?</p>
</blockquote>
<p>I think they still are. Here's how we can model this in the interpreter.</p>
<ul>
<li>The interpreter itself now has a notion of "native" endianness. Probably some property in the <code>Interpreter</code> struct. It <em>can</em> differ from the host endianness but by default they should match.</li>
<li>When doing memory accesses in <code>State::checked_{load,store}</code> we can first query the memflags. If they have an explicit endianness we use that, if they rely on the native endianness we use the one in the interpreter struct. (we can query this using <a href="https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.endianness"><code>MemFlags::endianness</code></a>)</li>
<li>Now, as you've discovered we still have two places in CLIF where we rely on native endianness. GlobalValue loads, and <code>stack_{loads,stores}</code>. The only thing we really need is some <code>MemFlags</code> that we can pass into <code>State::checked_{load,store}</code> and those should be <code>MemFlags::trusted()</code></li>
</ul>
<p>I think this should be fairly straight forward, and pretty much matches up with the original plan, we were only missing the default  "native endianness" in the interpreter.</p>
<hr>
<p>By the way, in hindsight this probably shouldn't have been marked as E-Easy <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> , sorry about that! Also feel free to reach out on zulip if you want, I might give you a faster answer there.</p>
</blockquote>



<a name="338300386"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338300386" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338300386">(Feb 27 2023 at 11:23)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446158771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<blockquote>
<p>The steps you initially described no longer seem relevant, or am I mistaken? Is the middle ground solution, as you described it, something that is relatively straightforward for me to pursue?</p>
</blockquote>
<p>I think they still are. Here's how we can model this in the interpreter.</p>
<ul>
<li>The interpreter itself now has a notion of "native" endianness. Probably some property in the <code>Interpreter</code> struct. It <em>can</em> differ from the host endianness but by default they should match.</li>
<li>When doing memory accesses in <code>State::checked_{load,store}</code> we can first query the memflags. If they have an explicit endianness we use that, if they rely on the native endianness we use the one in the interpreter struct. (we can query this using <a href="https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.endianness"><code>MemFlags::endianness</code></a>)</li>
<li>Now, as you've discovered we still have two places in CLIF where we rely on native endianness. GlobalValue loads, and <code>stack_{loads,stores}</code>. The only thing we really need is some <code>MemFlags</code> that we can pass into <code>State::checked_{load,store}</code> and those should be <code>MemFlags::trusted()</code></li>
</ul>
<p>I think this should be fairly straight forward, and pretty much matches up with the original plan, we were only missing the default  "native endianness" in the interpreter.</p>
<hr>
<p>By the way, in hindsight this probably shouldn't have been marked as E-Easy <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> , sorry about that! Also feel free to reach out on zulip if you want, I might give you a faster answer there.</p>
</blockquote>



<a name="338302929"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338302929" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338302929">(Feb 27 2023 at 11:35)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446158771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<blockquote>
<p>The steps you initially described no longer seem relevant, or am I mistaken? Is the middle ground solution, as you described it, something that is relatively straightforward for me to pursue?</p>
</blockquote>
<p>I think they still are. Here's how we can model this in the interpreter.</p>
<ul>
<li>We should add some sort of "native" endianness to the interpreter. Probably some property in the <code>Interpreter</code> struct. It <em>can</em> differ from the host endianness but by default they should match.</li>
<li>When doing memory accesses in <code>State::checked_{load,store}</code> we can first query the memflags. If they have an explicit endianness we use that, if they rely on the native endianness we use the one in the interpreter struct. (we can query this using <a href="https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.endianness"><code>MemFlags::endianness</code></a>)</li>
<li>Now, as you've discovered we still have two places in CLIF where we rely on native endianness. GlobalValue loads, and <code>stack_{loads,stores}</code>. The only thing we really need is some <code>MemFlags</code> that we can pass into <code>State::checked_{load,store}</code> and those should be <code>MemFlags::trusted()</code></li>
</ul>
<p>I think this should be fairly straight forward, and pretty much matches up with the original plan, we were only missing the default  "native endianness" in the interpreter.</p>
<hr>
<p>By the way, in hindsight this probably shouldn't have been marked as E-Easy <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> , sorry about that! Also feel free to reach out on zulip if you want, I might give you a faster answer there.</p>
</blockquote>



<a name="338303189"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338303189" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338303189">(Feb 27 2023 at 11:36)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446158771">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<blockquote>
<p>The steps you initially described no longer seem relevant, or am I mistaken? Is the middle ground solution, as you described it, something that is relatively straightforward for me to pursue?</p>
</blockquote>
<p>I think they still are. Here's how we can model this in the interpreter.</p>
<ul>
<li>We should add some sort of "native" endianness to the interpreter. Probably some property in the <code>Interpreter</code> struct. It <em>can</em> differ from the host endianness but by default they should match.<ul>
<li>This is only used as a last resort, when we are performing some operation, and the CLIF behaviour was unclear about the endianness. Such as when <code>MemFlags</code> don't specify an endianness.</li>
</ul>
</li>
<li>When doing memory accesses in <code>State::checked_{load,store}</code> we can first query the memflags. If they have an explicit endianness we use that, if they rely on the native endianness we use the one in the interpreter struct. (we can query this using <a href="https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.endianness"><code>MemFlags::endianness</code></a>)</li>
<li>Now, as you've discovered we still have two places in CLIF where we rely on native endianness. GlobalValue loads, and <code>stack_{loads,stores}</code>. The only thing we really need is some <code>MemFlags</code> that we can pass into <code>State::checked_{load,store}</code> and those should be <code>MemFlags::trusted()</code></li>
</ul>
<p>I think this should be fairly straight forward, and pretty much matches up with the original plan, we were only missing the default  "native endianness" in the interpreter.</p>
<hr>
<p>By the way, in hindsight this probably shouldn't have been marked as E-Easy <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> , sorry about that! Also feel free to reach out on zulip if you want, I might give you a faster answer there.</p>
</blockquote>



<a name="338309242"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/338309242" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#338309242">(Feb 27 2023 at 12:07)</a>:</h4>
<p>jan-justin <a href="https://github.com/bytecodealliance/wasmtime/issues/5881#issuecomment-1446213039">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p>Thanks for the clarification, I really do appreciate it!</p>
<p>That sounds like a plan to me and I will have a look at it.</p>
<hr>
<p>It's not a problem <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span> . I will definitely reach out to you on zulip at some point, however, I figured my questions were better placed here for the sake of anyone else who could potentially take over, if it came to that.</p>
</blockquote>



<a name="339085418"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235881%20cranelift-interpreter%3A%20Implement%20%60.../near/339085418" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235881.20cranelift-interpreter.3A.20Implement.20.60.2E.2E.2E.html#339085418">(Mar 02 2023 at 12:31)</a>:</h4>
<p>afonso360 closed <a href="https://github.com/bytecodealliance/wasmtime/issues/5881">issue #5881</a>:</p>
<blockquote>
<p><span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span> Hey,</p>
<h4>Feature</h4>
<p>Currently the interpreter always does <code>native</code> endianness memory loads and stores. This is the default and its the most common option. However they can also be tagged <code>little</code> and <code>big</code>. In those cases we should implement the correct memory accesses.</p>
<h4>Benefit</h4>
<p>This makes our interpreter slightly more complete! And paves the way for us to get better fuzzing support on s390x since we can start issuing these memflags.</p>
<h4>Implementation</h4>
<ol>
<li>We need to update our <a href="https://github.com/bytecodealliance/wasmtime/blob/67e2e57b02cd244c004379690aa56d3d5e187153/cranelift/interpreter/src/interpreter.rs#L311-L347"><code>State::checked_{load,store}</code></a> implementation to be endianness aware. This is probably as simple as passing the <code>MemFlags</code> from the original load, that contain that information and a few other bits that will probably be useful in the future.</li>
<li><code>checked_load</code> just calls <code>DataValue::read_from_slice</code>, which always works on the native endianness. We probably need some form of <code>Datavalue::read_from_slice_ne</code>/<code>Datavalue::read_from_slice_le</code> or something along those lines?</li>
<li>
<p>We have a bunch of tests for endianness (Thanks s390x!)</p>
<ul>
<li><a href="http://atomic-rmw-subword-big.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-big.clif</a></li>
<li><a href="http://atomic-rmw-subword-little.clif">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/atomic-rmw-subword-little.clif</a></li>
<li>It might be worth <code>Ctrl-F</code>'ing the runtests folder for <code>little</code> or <code>big</code> and checking if the interpreter already supports those operations</li>
</ul>
</li>
</ol>
<p>If anyone needs help working on this feel free to reach out!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>