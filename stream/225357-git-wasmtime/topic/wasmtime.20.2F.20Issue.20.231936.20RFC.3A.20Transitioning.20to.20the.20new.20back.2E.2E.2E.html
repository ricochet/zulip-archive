<html>
<head><meta charset="utf-8"><title>wasmtime / Issue #1936 RFC: Transitioning to the new back... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html">wasmtime / Issue #1936 RFC: Transitioning to the new back...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="202305716"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202305716" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202305716">(Jun 29 2020 at 13:04)</a>:</h4>
<p>bnjbvr labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[ ] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[ ] debugging support for generated code.</li>
<li>[ ] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[ ] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="202305717"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202305717" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202305717">(Jun 29 2020 at 13:04)</a>:</h4>
<p>bnjbvr opened <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[ ] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[ ] debugging support for generated code.</li>
<li>[ ] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[ ] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="202305740"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202305740" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202305740">(Jun 29 2020 at 13:05)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651107362">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @bnjbvr</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>bnjbvr: cranelift</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="202307011"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202307011" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202307011">(Jun 29 2020 at 13:16)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651113960">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<blockquote>
<p>enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</p>
</blockquote>
<h3>Must have</h3>
<p>The main thing missing in all new style backends is 128bit integer support. It is very very hard to support 128bit integers in cg_clif without Cranelift support and it is impossible to even compile libcore without 128bit integer support in cg_clif.</p>
<h3>Nice to have</h3>
<p>Other than that having System-V struct argument support (<a href="https://github.com/bytecodealliance/wasmtime/pull/1559">https://github.com/bytecodealliance/wasmtime/pull/1559</a> for the old style x86 backend) would be really nice. That PR is not yet merged though, but supporting proc-macros depends on it to prevent an abi incompatibility between cg_clif (the proc macro) and cg_llvm (the rustc loading the proc-macro).</p>
<blockquote>
<p>as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</p>
</blockquote>
<p>Those are nice convenience functions. Maybe they could just be that functions that emit a <code>iconst</code> and an <code>iadd</code>, etc?</p>
</blockquote>



<a name="202318550"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202318550" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202318550">(Jun 29 2020 at 14:36)</a>:</h4>
<p>julian-seward1 <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651162890">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>One possibility for 128 bit math is to add an i128 type to CLIR, and let the individual target instruction selectors lower them down to the relevant sequences of machine instructions.  I know this isn't the "traditional" way that CL currently uses.  There's an argument to be made that having condition codes exposed in the CLIR -- as required by the old-backend handling for multiword arithmetic -- is more trouble than it's worth.  Exposed condition codes mean we have to have extra logic to ensure we don't put any flag-setting insns in between generation and use; they are non-register-allocatable, and we have to jump through hoops to try and avoid materialising them unnecessarily in registers.  </p>
</blockquote>



<a name="202319247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202319247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202319247">(Jun 29 2020 at 14:40)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651165435">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<blockquote>
<p>One possibility for 128 bit math is to add an i128 type to CLIR, and let the individual target instruction selectors lower them down to the relevant sequences of machine instructions. I know this isn't the "traditional" way that CL currently uses.</p>
</blockquote>
<p>There is already an <a href="https://docs.rs/cranelift-codegen/0.65.0/cranelift_codegen/ir/types/constant.I128.html"><code>i128</code> type</a>. 128 bit math is currently handled is using legalizations though.</p>
</blockquote>



<a name="202330440"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202330440" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202330440">(Jun 29 2020 at 15:59)</a>:</h4>
<p>bjorn3 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651113960">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<blockquote>
<p>enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</p>
</blockquote>
<h3>Must have</h3>
<p>The main thing missing in all new style backends is 128bit integer support. It is very very hard to support 128bit integers in cg_clif without Cranelift support and it is impossible to even compile libcore without 128bit integer support in cg_clif.</p>
<p>edit: TLS support is also essential for multi-threading support.</p>
<h3>Nice to have</h3>
<p>Other than that having System-V struct argument support (<a href="https://github.com/bytecodealliance/wasmtime/pull/1559">https://github.com/bytecodealliance/wasmtime/pull/1559</a> for the old style x86 backend) would be really nice. That PR is not yet merged though, but supporting proc-macros depends on it to prevent an abi incompatibility between cg_clif (the proc macro) and cg_llvm (the rustc loading the proc-macro).</p>
<blockquote>
<p>as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</p>
</blockquote>
<p>Those are nice convenience functions. Maybe they could just be that functions that emit a <code>iconst</code> and an <code>iadd</code>, etc?</p>
</blockquote>



<a name="202330480"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202330480" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202330480">(Jun 29 2020 at 15:59)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651211660">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>I forgot to add TLS support to the must have section. Added it now.</p>
</blockquote>



<a name="202336429"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/202336429" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#202336429">(Jun 29 2020 at 16:40)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-651234153">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>Thanks for writing this up @bnjbvr! Very thorough.</p>
<p>One thing not mentioned explicitly, and which Wasmtime relies upon, is support for the target's native calling conventions, as opposed to SpiderMonkey's.</p>
</blockquote>



<a name="203323909"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/203323909" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#203323909">(Jul 08 2020 at 21:12)</a>:</h4>
<p>pchickey <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-655760020">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>Sorry that I forgot to respond on this. The Lucet team can start running tests against the new backend once x86_64 support is sufficient for Wasm MVP support.</p>
</blockquote>



<a name="203324243"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/203324243" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#203324243">(Jul 08 2020 at 21:15)</a>:</h4>
<p>pchickey edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-655760020">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>Sorry that I forgot to respond on this. The Lucet team can start running tests against the new backend once x86_64 support is sufficient for Wasm MVP support.</p>
<p>The lucet-wasi-fuzz crate uses csmith and clang to explore a subset of Wasm programs. This approach has found some bugs in Lucet before but I don't believe it has ever discovered Cranelift bugs. We can apply it to the new backend and see if anything shakes out.</p>
</blockquote>



<a name="216416063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/216416063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#216416063">(Nov 12 2020 at 00:58)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-725752041">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>I'll be actively working on this; for tracking purposes, this depends on at least #2079, #2372, #2272, <code>u128</code> support, and a solid round of testing.</p>
<p>Since the issue was created, we've got reftypes support in the Cranelift backend itself, though not in the <code>wasmtime</code> embedding; I'll look at this soon. We've also got unwind info; @yurydelendik, are you aware of any other missing debug-related bits in the new backend?</p>
</blockquote>



<a name="216478284"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/216478284" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#216478284">(Nov 12 2020 at 14:55)</a>:</h4>
<p>yurydelendik <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-726127914">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<blockquote>
<p>@yurydelendik, are you aware of any other missing debug-related bits in the new backend?</p>
</blockquote>
<p>To generate DWARF's .debug_info, you will also need <code>ValueLabelsRanges</code> data and implement TODOs for unwind info in epilogues (when possible).</p>
</blockquote>



<a name="216645649"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/216645649" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#216645649">(Nov 13 2020 at 17:37)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[ ] debugging support for generated code.</li>
<li>[ ] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[ ] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228815773"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228815773" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228815773">(Mar 04 2021 at 17:32)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-790794306">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>@cfallin, if we want to still take a look at a performance comparison here, the new sightglass CLI should get us almost to the place where we can easily compare both compile times and run times. It supports a bunch of metrics now--cycles, instructions retired, cache hits/misses, etc. I think we need to talk about the final few pieces: do we need more benchmarks? How to aggregate the results? Essentially, what do we want to see from the tool to make this decision?</p>
</blockquote>



<a name="228818130"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818130" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818130">(Mar 04 2021 at 17:46)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-790803437">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>@abrown, this could be useful yes! However I think the higher-level question is: what are the thresholds for performance and do we want to have a hard-gate on them, or is this simply a nice-to-have input? (The above issue describes it as the former, but I think it would be worth getting recent input from folks.) In general my tests have shown the new backend to be faster (compile time and runtime) but we've seen large inputs where that's not the case; will we hold back the transition until we can address such issues (by e.g. working on <a href="http://regalloc.rs">regalloc.rs</a> more) or will we move forward given the general balance of benefits vs remaining issues?</p>
</blockquote>



<a name="228818286"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818286" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818286">(Mar 04 2021 at 17:47)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[ ] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[ ] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228818293"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818293" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818293">(Mar 04 2021 at 17:47)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[ ] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228818311"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818311" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818311">(Mar 04 2021 at 17:47)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[ ] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228818323"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818323" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818323">(Mar 04 2021 at 17:47)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[ ] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[x] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228818337"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818337" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818337">(Mar 04 2021 at 17:47)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[x] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[x] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[ ] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228818404"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228818404" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228818404">(Mar 04 2021 at 17:48)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[x] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[x] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[ ] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[x] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228832259"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228832259" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228832259">(Mar 04 2021 at 19:11)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-790860082">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>Greetings all -- so we've been checking off the remaining boxes needed to make the transition, but I haven't done a good job of keeping this up to date. We now have almost full feature-completeness (modulo a few things below) and several stakeholders -- Lucet (<a href="https://github.com/bytecodealliance/lucet/issues/646">bytecodealliance/lucet#646</a>) and rustc_codegen_cranelift (<a href="https://github.com/bjorn3/rustc_codegen_cranelift/issues/1127">bjorn3/rustc_codegen_cranelift#1127</a> and <a href="https://github.com/bjorn3/rustc_codegen_cranelift/issues/1140">bjorn3/rustc_codegen_cranelift#1140</a>) have already switched to the new x86-64 backend, and Wasmtime is largest remaining stakeholder on the old x86-64 backend by default, to my knowledge.</p>
<h2>Remaining work: implementation</h2>
<p>There are a few tasks remaining before we can switch Wasmtime's backend:</p>
<ul>
<li>We need various Windows support bits: fastcall ABI support (#2678) and unwind-info generation. I plan to get both of these in soon.</li>
<li>And I think that's it!</li>
</ul>
<p>Switching the default backend for the <code>cranelift-codegen</code> crate is technically a separate decision but IMHO can and should happen at the same time. To do so:</p>
<ul>
<li>We need to update filetests: there are a number of golden-output tests that should be updated, and there are many tests that make assertions about old-backend-specific results (e.g. encodings) or using old-backend-specific functionality (e.g. regalloc constraints on CLIF values). A first pass at this would be to just label all tests that rely on the old backend with a feature flag, like <code>experimental_x64</code> tests have now, and continue running them with the old backend on CI for now. We could then look at which of these should be ported, if we lack any test coverage on the new backend.</li>
<li>There are probably other unit tests throughout the codebase that make some assumptions based on the old backend's output.</li>
</ul>
<h2>Making the switch</h2>
<p>My proposed course of action is to (i) finish the Windows-specific implementation, then (ii) put together a PR that makes the switch and look at where CI shows issues. A single PR can switch the default for Wasmtime, cranelift-codegen, and fix up unit tests/filetests at the same time.</p>
<p>We should talk about what happens to the old backend as well, though that can be a separate discussion after the default-switch occurs. (I can create an issue to track this when the switch occurs.) Until we remove it, we can maintain the ability to select it with a non-default feature, and we can continue to run CI tests for it, just as we run tests for the new backend today.</p>
<p>To make the switch, though, we should ensure that we have the appropriate sign-offs and that there will be no unforeseen issues. IMHO we should allow some time to hear from the community and consider any concerns or overlooked issues. Hopefully maintaining the ability to use the old backend at least in the medium-term will address any severe concerns, but switching the default does still have an impact that we want to consider.</p>
<h2>Open questions</h2>
<p>So, all that said, a few questions for folks here:</p>
<ul>
<li>Are there any other issues I've missed above that require implementation before we switch?</li>
<li>Is there general agreement that (i) we should switch the default for <code>cranelfit-codegen</code> at the same time as Wasmtime, (ii) maintain the ability to use the old backend under a feature flag, and (iii) test the old backend on CI at least for a while?</li>
<li>Are there major stakeholders we should ping before this happens?</li>
<li>It may be good to use the BA RFC process to get a formal sign-off on the switch; I would tend toward this, to ensure everyone's on board. Do folks agree? If so, I'll go ahead and draft something (it will be pretty short as most of the work has already happened!)</li>
</ul>
</blockquote>



<a name="228832577"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228832577" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228832577">(Mar 04 2021 at 19:13)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[x] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[x] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[x] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[x] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<a name="228920695"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/228920695" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#228920695">(Mar 05 2021 at 09:05)</a>:</h4>
<p>bnjbvr <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-791277067">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<blockquote>
<p>We should talk about what happens to the old backend as well, though that can be a separate discussion after the default-switch occurs.</p>
</blockquote>
<p>+1; in the short run, I strongly think it would be nice to keep the old backend around, for a release or two, behind a switch, so that if some users  run into crashes/issues with the new backend, they have a way to revert it locally, report back the issues, so we can fix it before a following release (and in the absolute worst case, revert to the old backend).</p>
<blockquote>
<p>Are there any other issues I've missed above that require implementation before we switch?</p>
</blockquote>
<p>It would be really nice to have some performance numbers before/after, just so people can consider if 1. there are speedups/slowdowns, 2. if there are slowdowns, how bad/acceptable they are and should require blocking the transition.</p>
<blockquote>
<p>Is there general agreement that (i) we should switch the default for cranelfit-codegen at the same time as Wasmtime, (ii) maintain the ability to use the old backend under a feature flag, and (iii) test the old backend on CI at least for a while?</p>
</blockquote>
<p>Doing the opposite (i.e. switching default backend in Cranelift and in Wasmtime at different times) would only be valuable if there were a lot of Cranelift embedders who could report back to us in the time window between the two switches. Since we've collaborated closely with the cg_clif backend, which is probably the second largest user of Cranelift, and there aren't many others, I tend towards switching both at the same time.</p>
<blockquote>
<p>It may be good to use the BA RFC process to get a formal sign-off on the switch; I would tend toward this, to ensure everyone's on board. Do folks agree? If so, I'll go ahead and draft something (it will be pretty short as most of the work has already happened!)</p>
</blockquote>
<p>+1, this issue predated the existence of RFCs in the Bytecode Alliance, so it even could be moved in the RFC repository as a background discussion.</p>
</blockquote>



<a name="233201783"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/233201783" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#233201783">(Apr 05 2021 at 17:21)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/1936#issuecomment-813516346">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>For the record, this discussion was continued and merged as an RFC in <a href="https://github.com/bytecodealliance/rfcs/issues/10">bytecodealliance/rfcs#10</a>.</p>
<p>And, as of today, it was fixed in #2718 :-) Closing!</p>
</blockquote>



<a name="233201785"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20Issue%20%231936%20RFC%3A%20Transitioning%20to%20the%20new%20back.../near/233201785" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20Issue.20.231936.20RFC.3A.20Transitioning.20to.20the.20new.20back.2E.2E.2E.html#233201785">(Apr 05 2021 at 17:21)</a>:</h4>
<p>cfallin closed <a href="https://github.com/bytecodealliance/wasmtime/issues/1936">Issue #1936</a>:</p>
<blockquote>
<p>TL;DR: what would it take to deprecate the “old” backend in favor of the “new” backend for code generation?</p>
<h1>Context</h1>
<p>The compilation pipeline in Cranelift currently does instruction selection (through legalizations) before optimizing the intermediate representation (IR), applying register allocation on it, and then generating the machine code. From the point of view of Cranelift, these last steps can be seen as a “backend” that generates machine code for different target architectures.</p>
<p>The previous backend was a bit complicated to work with: it was using the DSL from the codegen/meta crate, with concepts hard to approach and explain (like Recipes), it generated Rust code that could get out of sync with the non-meta crate or contain compile errors, etc. (see also <a href="https://github.com/bytecodealliance/wasmtime/issues/1141">https://github.com/bytecodealliance/wasmtime/issues/1141</a>). A decision was made to work on a new backend (sometimes referred to as the “machinst” backend). This was presented in <a href="https://github.com/bytecodealliance/wasmtime/issues/1174">https://github.com/bytecodealliance/wasmtime/issues/1174</a> and has landed since then, as an alternative backend (viz., in addition to the existing one).</p>
<p>As of today, the old backend supports generating machine code for (some subset of) RISC-V, x86 64 bits and 32 bits. The new backend supports generating machine code for aarch64, and has a work-in-progress backend for x86_64. The duplication of x86_64 in both the old and new backends imply that both backends move ahead in parallel. This makes it harder for the new backend to catch up with the old one as new features are being added, and can generate frustration as different teams with different priorities work on different backends.</p>
<p>The Mozilla Spidermonkey team has enough confidence in the new backend, which we consider to be pleasant to work with (developer ergonomics), fast enough for our use case (both compile-time and generated code throughput), and it has the potential for more compile-time and code quality optimizations in the long run, so we think it is a good time to start this discussion.</p>
<h1>The proposal</h1>
<p>We propose that at some point in the future, we entirely move away from the “old” backend (that is, remove it, as well as all the associated code in the meta language), and use the “new” backend, for all target architectures, and that the only possible way to implement a new target is to do it through the new backend. Notably, since x86 is the main target in the old backend, this means removing the old x86 backend.</p>
<p>Of course, this can’t be done until all the primarily involved stakeholders are satisfied with this idea and don’t have any strong objections in moving forward. This RFC is a first step at identifying what the acceptance criterias would be to make it possible to transition, and what a plan would be to make this realistic.</p>
<p>What this is not about: removing the entire meta language. This may or may not be done in the future (if we want to do it, then moving over to the new backend is a first step).</p>
<h1>Acceptance criteria</h1>
<p>Note that these criteria are not definite and could evolve over time, based on our discussions here.</p>
<ul>
<li>Features: the new backend should support all the features that are effectively used by all the stakeholders, including all the WebAssembly (wasm) features that have been implemented so far in the old backend.<ul>
<li>Target-independent features:<ul>
<li>[x] support wasm MVP features + lightweight extensions (mutable globals, bulk memory ops)</li>
<li>[x] support wasm reftypes</li>
<li>[x] support wasm multi-value</li>
<li>[x] debugging support for generated code.</li>
<li>[x] implement enough of x86_64 to support these features.</li>
</ul>
</li>
<li>Performance: since the new backend came with its own instruction selection and with a new register allocation, its performance characteristics are likely to be different from those of the old backend.<ul>
<li>[ ] <em>CLIR compile time</em>: the new backend should compile code as fast as or faster than the old backend, for a set of wasm benchmarks (to be determined).</li>
<li>[ ] <em>generated code quality</em>: the new backend should generate code that runs at least as fast as or faster than the code generated by the old backend, for a set of wasm benchmarks (to be determined).</li>
</ul>
</li>
</ul>
</li>
<li>Security and quality:<ul>
<li>[x] <em>CL testing</em>: pass all the existing CLIF tests</li>
<li>[ ] Major stakeholders/embedders pass tests</li>
<li>[x] <em>fuzzing</em> should run for some time and fuzz bugs should be fixed</li>
</ul>
</li>
<li>Stakeholders supported:<ul>
<li>[x] <em>Wasmtime testing</em>: pass all the existing wasmtime tests using Cranelift as the compiler</li>
<li>[x] <em>SpiderMonkey testing</em>: pass all the existing SpiderMonkey tests using Cranelift as the compiler</li>
<li>Other Bytecode Alliance stakeholders give their “go” (see below).</li>
</ul>
</li>
</ul>
<p>Feel free to comment about other things that are important to you, and please explain why (if it is not obvious)! Good criteria tend to be objectively quantifiable, measurable and/or bimodal (done or not done).</p>
<h2>Potential additions to this list</h2>
<p>These are additions to the above list, and need to be discussed as a group:</p>
<ul>
<li>[x] enough support to not break cg_clif, a Rust backend initiative using Cranelift for code generation. It is hard to make a guess about the amount of work that will be required to keep cg_clif working, while it is our hope that most of it should be covered by our work, and the rest could be a community-supported effort.</li>
<li>[ ] porting the x86 32-bits platform. While most of the code could be reused between x86_64 and x86 32-bits, it may not be a primary target right now, and we might or might not want to block the transition for this.</li>
</ul>
<h1>Proposed planning</h1>
<h2>Step 1: agree on the proposal</h2>
<p>This is the current step that’s being done as part of this issue. See below.</p>
<h2>Step 2: get to a point where we can try the new backend in real-world settings</h2>
<p>Once we get to a point where we can compile code for large wasm programs mostly using wasm MVP features, we’ll be able to do a performance analysis, comparing on the two axis presented above. This will give us confidence in how fast we can move forward with this plan, or if we should revisit some implementation decisions, and chase more performance first.</p>
<h2>Step 3: finish implementation of remaining features</h2>
<p>This means implementing all the Features mentioned in the above list of criteria, as well as passing tests from all the test suites. At this point, we could put up an official depreciation notice for the old backend, and encourage people to use the new backend in general.</p>
<h2>Step 4: do a final approval and switch</h2>
<p>Based on an evaluation of performance, as well as feedback from the different stakeholders, we can eventually decide to enable the new backend by default. Removal of the code supporting the old backend may or may not happen at the same time; deferring its removal for a short period of time allows to switch the default back to the old backend, in case of unexpected consequences.</p>
<h1>Future work</h1>
<p>There is future work that is going to be enabled by switching to the new backend. At this point, these are mostly ideas, and it is not the point of this issue to discuss the design / feasibility / interest aspects of these ideas.</p>
<ul>
<li>Code removal in the meta language as well as in the codegen crate may lower the overall build time of Cranelift, see also <a href="https://github.com/bytecodealliance/cranelift/issues/1318">https://github.com/bytecodealliance/cranelift/issues/1318</a> which shows that large functions in the encodings/recipes system take some time to compile (and they generate large functions too).</li>
<li>After removal of the old backend, since the instruction selection really happens at the MachInst IR (Vcode) level, then all the CLIF instructions which were present for the sole benefit of being available in the backend can be removed. This includes CLIF instructions that are target-specific (e.g. x86_udivmodx), as well as instructions which offer alternative operand modes (e.g. iadd_imm is an alternate operand mode for iadd, allowing to express an “int add with immediate” with two different CL instructions, making pattern-matching more complex).</li>
<li>Translating from wasm to target-independent Vcode directly (and then adapting the lowering machinery to use this) is something we would like to investigate. In an even longer horizon, we could get back to having a single IR container again (parameterized by instruction/opcode-space) and carry over optimizations onto it, while avoiding some of the pitfalls of the current CLIF design (such as performance impact of in-place editing).</li>
</ul>
<h1>Thoughts?</h1>
<p>If you have any comments, questions, alternative proposals, objections, please feel free to write them down here. Note that we’re looking for consensus here, which is gained not when everybody agrees about all the details, but when nobody has strong objections anymore. So please carefully discuss objections and assume good intent from everyone involved in the process :-) Thanks!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>