<html>
<head><meta charset="utf-8"><title>wasmtime / PR #2539 Support for I128 operations in x64 ba... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html">wasmtime / PR #2539 Support for I128 operations in x64 ba...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="221492187"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492187" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492187">(Jan 04 2021 at 06:08)</a>:</h4>
<p><strong>cfallin</strong> requested <a href="https://github.com/abrown">abrown</a>, <a href="https://github.com/bnjbvr">bnjbvr</a> and <a href="https://github.com/julian-seward1">julian-seward1</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a>.</p>



<a name="221492188"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492188" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492188">(Jan 04 2021 at 06:08)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.<br>
</p>
</blockquote>



<a name="221492189"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492189" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492189">(Jan 04 2021 at 06:08)</a>:</h4>
<p><strong>cfallin</strong> requested <a href="https://github.com/abrown">abrown</a>, <a href="https://github.com/bnjbvr">bnjbvr</a> and <a href="https://github.com/julian-seward1">julian-seward1</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a>.</p>



<a name="221492190"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492190" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492190">(Jan 04 2021 at 06:08)</a>:</h4>
<p><strong>cfallin</strong> requested <a href="https://github.com/abrown">abrown</a>, <a href="https://github.com/bnjbvr">bnjbvr</a> and <a href="https://github.com/julian-seward1">julian-seward1</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a>.</p>



<a name="221492665"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492665" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492665">(Jan 04 2021 at 06:21)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.<br>
</p>
</blockquote>



<a name="221492730"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221492730" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221492730">(Jan 04 2021 at 06:23)</a>:</h4>
<p>cfallin edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="221579144"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221579144" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221579144">(Jan 04 2021 at 20:54)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="221579767"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221579767" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221579767">(Jan 04 2021 at 20:59)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="221726156"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221726156" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221726156">(Jan 06 2021 at 02:05)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="221800202"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/221800202" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#221800202">(Jan 06 2021 at 18:01)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="222345952"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345952" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345952">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-565644841">PR Review</a>.</p>



<a name="222345953"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345953" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345953">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-565644841">PR Review</a>.</p>



<a name="222345954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345954">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r555268037">PR Review Comment</a>:</p>
<blockquote>
<p>I don't think I picked up why these need to be <code>Copy</code> now?</p>
</blockquote>



<a name="222345955"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345955" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345955">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r555266774">PR Review Comment</a>:</p>
<blockquote>
<p>You could save yourself some code with: </p>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">run</span>: <span class="o">%</span><span class="n">ctz</span><span class="p">(</span><span class="mh">0x00000000_00000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000000_00000000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x96</span><span class="w"></span>
<span class="p">;</span><span class="w"> </span><span class="n">run</span>: <span class="o">%</span><span class="n">ctz</span><span class="p">(</span><span class="mh">0x00000000_00010000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00000001_00000000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x16</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div><br>
</p>
</blockquote>



<a name="222345956"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345956" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345956">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r555282080">PR Review Comment</a>:</p>
<blockquote>
<p>It seems preferable to me to just have <code>AluRmiROpcode::And</code> and avoid this special-casing if possible. Do you agree? If yes, I wonder if there is a way to standardize register sizes throughout <code>lower.rs</code> using <code>OperandSize</code> and trying to clarify/simplify all of the special logic related to variables like <code>is64</code>, <code>is_64</code>, <code>is_8bit</code>, etc.</p>
</blockquote>



<a name="222345957"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222345957" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222345957">(Jan 11 2021 at 19:32)</a>:</h4>
<p>abrown created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r555285178">PR Review Comment</a>:</p>
<blockquote>
<p>I think this is the type of logic that is tricky to understand later: where is <code>is_8bit</code> coming from? It's sort of hidden that the registers used, if encoded in the range 4..7, should always emit a REX prefix. I'm not suggesting a great alternative here (sorry!), just noting that this is the type of thing that will make the lowering code tricky to troubleshoot and extend.</p>
</blockquote>



<a name="222346063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222346063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222346063">(Jan 11 2021 at 19:33)</a>:</h4>
<p>abrown submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-565644841">PR Review</a>.</p>



<a name="222788979"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222788979" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222788979">(Jan 14 2021 at 21:46)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a> from <code>x64-i128</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a followup to #2538 and is dependent on it.</p>
<p>x64 backend: implement 128-bit ops and misc fixes.</p>
<p>This implements all of the ops on I128 that are implemented by the<br>
legacy x86 backend, and includes all that are required by at least one<br>
major use-case (cg_clif rustc backend).</p>
<p>The sequences are open-coded where necessary; for e.g. the bit<br>
operations, this can be somewhat complex, but these sequences have been<br>
tested carefully. This PR also includes a drive-by fix of clz/ctz for 8-<br>
and 16-bit cases where they were incorrect previously.</p>
<p>Also includes ridealong fixes developed while bringing up cg_clif<br>
support, because they are difficult to completely separate due to<br>
other refactors that occurred in this PR:</p>
<ul>
<li>
<p>fix REX prefix logic for some 8-bit instructions.</p>
<p>When using an 8-bit register in 64-bit mode on x86-64, the REX prefix<br>
semantics are somewhat subtle: without the REX prefix, register numbers<br>
4--7 correspond to the second-to-lowest byte of the first four registers<br>
(AH, CH, BH, DH), whereas with the REX prefix, these register numbers<br>
correspond to the usual encoding (SPL, BPL, SIL, DIL). We could always<br>
emit a REX byte for instructions with 8-bit cases (this is harmless even<br>
if unneeded), but this would unnecessarily inflate code size; instead,<br>
the usual approach is to emit it only for these registers.</p>
<p>This logic was present in some cases but missing for some other<br>
instructions: divide, not, negate, shifts.</p>
<p>Fixes #2508.</p>
</li>
<li>
<p>avoid unaligned SSE loads on some f64 ops.</p>
<p>The implementations of several FP ops, such as fabs/fneg, used SSE<br>
instructions. This is not a problem per-se, except that load-op merging<br>
did not take <em>alignment</em> into account. Specifically, if an op on an f64<br>
loaded from memory happened to merge that load, and the instruction into<br>
which it was merged was an SSE instruction, then the SSE instruction<br>
imposes stricter (128-bit) alignment requirements than the load.f64 did.</p>
<p>This PR simply forces any instruction lowerings that could use SSE<br>
instructions to implement non-SIMD operations to take inputs in<br>
registers only, and avoid load-op merging.</p>
<p>Fixes #2507.</p>
</li>
<li>
<p>two bugfixes exposed by cg_clif: urem/srem.i8, select.b1.</p>
<ul>
<li>
<p>urem/srem.i8: the 8-bit form of the DIV instruction on x86-64 places<br>
  the remainder in AH, not RDX, different from all the other width-forms<br>
  of this instruction.</p>
</li>
<li>
<p>select.b1: we were not recognizing selects of boolean values as<br>
  integer-typed operations, so we were generating XMM moves instead (!).</p>
</li>
</ul>
</li>
</ul>
</blockquote>



<a name="222789017"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789017" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789017">(Jan 14 2021 at 21:46)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-568651616">PR Review</a>.</p>



<a name="222789018"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789018" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789018">(Jan 14 2021 at 21:46)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r557718802">PR Review Comment</a>:</p>
<blockquote>
<p>Much better, thanks!</p>
</blockquote>



<a name="222789062"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789062" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789062">(Jan 14 2021 at 21:46)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-568651961">PR Review</a>.</p>



<a name="222789063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789063">(Jan 14 2021 at 21:46)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r557719074">PR Review Comment</a>:</p>
<blockquote>
<p>Ah, I had added that for convenience in several spots but the <code>clone()</code> is no big deal; reverted.</p>
</blockquote>



<a name="222789209"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789209" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789209">(Jan 14 2021 at 21:47)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-568652947">PR Review</a>.</p>



<a name="222789210"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789210" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789210">(Jan 14 2021 at 21:47)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r557719855">PR Review Comment</a>:</p>
<blockquote>
<p>In general I would agree, except that we don't use 8-bit ops elsewhere for CLIF-level 8-bit instructions so I went for the limited-in-scope approach here. I'm totally open to a future refactor that centralizes <code>OperandSize</code> for all instructions, though -- that would remove a lot of the ad-hoc conditionals, as you note!</p>
</blockquote>



<a name="222789341"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789341" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789341">(Jan 14 2021 at 21:48)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#pullrequestreview-568653527">PR Review</a>.</p>



<a name="222789343"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222789343" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222789343">(Jan 14 2021 at 21:48)</a>:</h4>
<p>cfallin created <a href="https://github.com/bytecodealliance/wasmtime/pull/2539#discussion_r557720311">PR Review Comment</a>:</p>
<blockquote>
<p>Perhaps the <code>RexFlags</code> could take an <code>OperandSize</code> with its constructor, if we centralize use of <code>OperandSize</code>; that would at least enforce the need to think about it. OK if we defer to a later refactor?</p>
</blockquote>



<a name="222796363"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232539%20Support%20for%20I128%20operations%20in%20x64%20ba.../near/222796363" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232539.20Support.20for.20I128.20operations.20in.20x64.20ba.2E.2E.2E.html#222796363">(Jan 14 2021 at 22:45)</a>:</h4>
<p>cfallin merged <a href="https://github.com/bytecodealliance/wasmtime/pull/2539">PR #2539</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>