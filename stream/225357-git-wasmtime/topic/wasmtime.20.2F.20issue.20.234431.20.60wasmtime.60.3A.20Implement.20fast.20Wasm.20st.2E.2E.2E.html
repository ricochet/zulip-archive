<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4431 `wasmtime`: Implement fast Wasm st... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html">wasmtime / issue #4431 `wasmtime`: Implement fast Wasm st...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="289241737"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289241737" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289241737">(Jul 11 2022 at 19:52)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[ ] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[ ] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[ ] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[ ] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[ ] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="289243102"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289243102" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289243102">(Jul 11 2022 at 20:04)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180814741">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen, @peterhuene</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "wasmtime:api", "wasmtime:ref-types"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: wasmtime:ref-types</li>
<li>peterhuene: wasmtime:api</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="289268120"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289268120" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289268120">(Jul 12 2022 at 01:09)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1181202350">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "fuzzing"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: fuzzing</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="289288868"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289288868" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289288868">(Jul 12 2022 at 07:42)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1181427361">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>I still need to have a closer look.   But just one comment on this:</p>
<blockquote>
<p>Within a sequence of Wasm-to-Wasm calls, we can use<br>
frame pointers (which Cranelift preserves) to find the next older Wasm frame on<br>
the stack, and we keep doing this until we reach the entry stack pointer,<br>
meaning that the next older frame will be a host frame.</p>
</blockquote>
<p>Actually, the Cranelift s390x back end does not maintain frame pointers at all in Wasm code - frame pointers are really only necessary in our ABI for frames that use dynamic stack allocation, and that never happens in Wasm, so right now we don't ever use frame pointers ...   I guess it would be possible to add (the equivalent of) frame pointers, but that would incur a runtime overhead for all Wasm code.</p>
</blockquote>



<a name="289525140"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289525140" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289525140">(Jul 13 2022 at 21:43)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1183707765">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Thanks for responding @uweigand.</p>
<blockquote>
<p>Actually, the Cranelift s390x back end does not maintain frame pointers at all in Wasm code - frame pointers are really only necessary in our ABI for frames that use dynamic stack allocation, and that never happens in Wasm, so right now we don't ever use frame pointers ... I guess it would be possible to add (the equivalent of) frame pointers, but that would incur a runtime overhead for all Wasm code.</p>
</blockquote>
<p>Hm, I didn't realize this, since our other backends preserve frame pointers (other than leaf functions on aarch64).</p>
<p>So I guess our options are to</p>
<ol>
<li>preserve frame pointers in s390x (or equivalent; unsure what you meant by "or equivalent of" since I'm not very familiar with s390x nor its calling conventions),</li>
<li>continue to depend on the <code>backtrace</code> crate and the system unwinder on s390x, or</li>
<li>write a custom stack walker for s390x that is not based on frame pointers (and is instead based on... DWARF/eh_frame? something else?)</li>
</ol>
<p>I think (1) would be simplest, although it will incur some slight overhead to Wasm execution, but we pay this overhead on other architectures and it is generally considered acceptable. We could definitely make (2) work, but it wouldn't be as tidy as I'd like, since we would need to add more <code>cfg</code>s in more places than just choosing which bits of global assembly or frame pointer recovery code we'd like to compile with. Option (3) is the most nebulous to me, and if we are talking about DWARF/eh_frame then it is probably the most complicated as well. I'd like to avoid this option unless you have other implementation ideas to cut down on complexity here.</p>
<p>So ultimately, I'm personally leaning towards (1) but could be convinced of (2) and I'd prefer not to do (3) unless I'm missing something.</p>
</blockquote>



<a name="289528370"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289528370" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289528370">(Jul 13 2022 at 22:17)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[ ] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[ ] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[ ] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[ ] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[x] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="289577899"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289577899" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289577899">(Jul 14 2022 at 11:13)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184317864">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>Hm, I didn't realize this, since our other backends preserve frame pointers (other than leaf functions on aarch64).</p>
</blockquote>
<p>To be honest, I never understood that either.  In my mind, a _frame pointer_, i.e. a reserved register separate from the stack pointer, which is being using by generated code to access local variables, spill slots, and other objects in a function's stack frame, is only ever necessary if those objects cannot be accessed relative to the stack pointer instead.  This is normally only the case if the function performs dynamic stack space allocation (the C <code>alloca</code> or some equivalent), because then you no longer know at compile time what the offset of your stack frame objects relative to the stack pointer is. </p>
<p>Given that there is no dynamic stack allocation in Cranelift, I do not think maintaining an actual frame pointer register is <em>ever</em> needed for <em>any</em> architecture, so I do not understand why the Intel and Arm back-ends are currently doing so.  I would expect that as optimization of Cranelift proceeds, we would want to re-examine that choice - I believe unnecessarily maintaining a frame pointer does cost a noticable performance overhead.  Note that this overhead is not (or not <em>only</em>) due to the extra saves and restores in prolog and epilog, but primarily due to the fact that we've blocked one whole register that we could have used freely for register allocation otherwise.</p>
<p>I do understand that, once we <em>do</em> maintain a frame pointer register, there are ancillary benefits for stack walking, since the frame pointer must be callee-saved, and the saved copies of that register on the stack happen to form a nice chain that can be easily walked to perform a simple backtrace.  However, as soon as we enforce maintaining a frame pointer <em>just</em> for that purpose, this is not actually "free", but does incur the runtime overhead described above, which would otherwise be unnecessary.  I think there may be alternative solutions for the debugging problem without that overhead ...</p>
<blockquote>
<p>So I guess our options are to</p>
<div class="codehilite"><pre><span></span><code>1. preserve frame pointers in s390x (or equivalent; unsure what you meant by &quot;or equivalent of&quot; since I&#39;m not very familiar with s390x nor its calling conventions),

2. continue to depend on the `backtrace` crate and the system unwinder on s390x, or

3. write a custom stack walker for s390x that is not based on frame pointers (and is instead based on... DWARF/eh_frame? something else?)
</code></pre></div>

<p>I think (1) would be simplest, although it will incur some slight overhead to Wasm execution, but we pay this overhead on other architectures and it is generally considered acceptable. We could definitely make (2) work, but it wouldn't be as tidy as I'd like, since we would need to add more <code>cfg</code>s in more places than just choosing which bits of global assembly or frame pointer recovery code we'd like to compile with. Option (3) is the most nebulous to me, and if we are talking about DWARF/eh_frame then it is probably the most complicated as well. I'd like to avoid this option unless you have other implementation ideas to cut down on complexity here.</p>
<p>So ultimately, I'm personally leaning towards (1) but could be convinced of (2) and I'd prefer not to do (3) unless I'm missing something.</p>
</blockquote>
<p>As to the "equivalent" I mention under (1), sorry for being vague :-)   What I meant is in the s390x ABI we actually have an optional feature to maintain an explicit _stack backchain_, which forms a linked list of frames on the stack, just like the saved copies of a frame pointer register would, except we're not _actually_ maintaining a frame pointer register.  Basically, the backchain link is formed by prolog code storing a pointer to the caller's stack frame into the lowest word of the callee's stack frame - and that's it, there is no frame pointer register reserved throughout the function.</p>
<p>Now, we decided more than 20 years ago to even switch <em>this</em> feature off by default in the Linux toolchains, because with DWARF CFI it is no longer needed for debugging, and even that simple store has measurable overhead.  (It is still used in special circumstances, e.g. in Linux kernel code.)   But I could certainly enable that feature for Cranelift in the s390x back end.</p>
<p>That said, this would still leave us with the problem of frameless leaf functions, just like in the Arm case.  I could also force any function that contains a trap to always allocate a frame anyway, just so we can store the backchain and the return address.   But that would be even further run-time overhead ...</p>
<p>There may be a more elegant solution to the frameless leaf function problem, also for Arm.   Once we know we are currently in a frameless leaf function, this is actually simple to handle: to unwind from a leaf function, you only need to notice that the caller's SP equals the current SP, and the caller's PC equals the value currently in the link register.  (Assuming you have one; on Intel you'd get the return address from the lowest word of the stack instead.)</p>
<p>The only difficulty is to know whether we <em>are</em> in a frameless leaf function or not.  But we should (be able to) know that - after all, we did compile that function ourselves earlier on :-)   So, assuming we can associate the current PC with a data structure identifying the function (which I believe we must do anyway to get at the function <em>name</em> - which is the whole point of generating stack backtraces in the first place), the only thing we'd need to do is to have the compiler set a flag in that structure that this function is frameless.</p>
<p>In fact, spinning that thought experiment a bit further: if we'd store not just a "frameless" flag, but the actual _size_ of the stack frame, we should be able to use that information to unwind from non-leaf functions as well without requiring any explicit backchain or frame pointer: just compute the caller's SP as the callee's SP plus the callee's (known) stack frame size.   Note that this makes explicit use of the fact that frame sizes in Cranelift are constants known at compile time, because there is no dynamic stack allocation.   (Glossing over some details here; this assumes that the stack pointer doesn't change at all during function execution, at least not at the "relevant" places - traps and function call sites.  This is true on s390x and -as far as I know- on Arm, but not on Intel.  There'd be extra information required to handle Intel correctly.)<br>
</p>
</blockquote>



<a name="289584629"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289584629" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289584629">(Jul 14 2022 at 12:21)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184381542">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>... I do not think maintaining an actual frame pointer register is _ever_ needed for _any_ architecture, so I do not understand why the Intel and Arm back-ends are currently doing so.</p>
</blockquote>
<p>This is easy to answer in the AArch64 case - because the ABI (and its implementation on Linux in particular) pretty much <a href="https://github.com/ARM-software/abi-aa/blob/2022Q1/aapcs64/aapcs64.rst#the-frame-pointer">requires</a> it.</p>
</blockquote>



<a name="289586825"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289586825" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289586825">(Jul 14 2022 at 12:43)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184403178">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>... I do not think maintaining an actual frame pointer register is _ever_ needed for _any_ architecture, so I do not understand why the Intel and Arm back-ends are currently doing so.</p>
</blockquote>
<p>This is easy to answer in the AArch64 case - because the ABI (and its implementation on Linux in particular) pretty much <a href="https://github.com/ARM-software/abi-aa/blob/2022Q1/aapcs64/aapcs64.rst#the-frame-pointer">requires</a> it.</p>
</blockquote>
<p>Huh, interesting.   The ABI text still seems to leave it open to the "platform", up to and including the choice:</p>
<blockquote>
<p>It may elect not to maintain a frame chain and to use the frame pointer register as a general-purpose callee-saved register.</p>
</blockquote>
<p>Do you know why Linux specifically requires the frame pointer?</p>
<p>Anyway, I agree if that's the platform ABI standard, then we need to follow it in Cranelift.<br>
</p>
</blockquote>



<a name="289613824"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289613824" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289613824">(Jul 14 2022 at 16:17)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184636532">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Personally I see two routes for s390x w.r.t. this PR:</p>
<ul>
<li>Match what x86_64 and aarch64 are doing</li>
<li>Temporarily drop s390x from CI until @uweigand you've got time to implement an alternative stack-walking scheme</li>
</ul>
<p>I don't think we can keep around the <code>backtrace</code>-based traces for maintenance reasons. I feel that the code necessary to keep that working is so different than the code for the frame-pointer-based approach that it's too much to take on for something that most of us aren't running locally to test.</p>
<p>Otherwise this PR will require some more work regardless to handle things like leaf frames on AArch64. I think it would be worth evaluating at that point whether the frame pointer approach makes sense. If some metadata is plumbed through for leaf frames it might be "easy enough" to simply plumb through stack frame sizes as well making frame pointers unnecessary. If it's not as easy as originally thought though the frame pointers may still be needed. </p>
</blockquote>



<a name="289615081"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289615081" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289615081">(Jul 14 2022 at 16:27)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184647028">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>To be clear, I certainly agree it wouldn't make sense to keep the DWARF backtrace in place just for s390x.  As I said, I'd be happy to implement the backchain based mechanism on s390x described above, that's easy enough.  That would still leave the leaf function problem to be solved, just like on aarch64.   Just wondering whether this is best approach overall ...</p>
</blockquote>



<a name="289617815"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289617815" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289617815">(Jul 14 2022 at 16:49)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184668257">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>In fact, spinning that thought experiment a bit further: if we'd store not just a "frameless" flag, but the actual _size_ of the stack frame, we should be able to use that information to unwind from non-leaf functions as well without requiring any explicit backchain or frame pointer: just compute the caller's SP as the callee's SP plus the callee's (known) stack frame size. Note that this makes explicit use of the fact that frame sizes in Cranelift are constants known at compile time, because there is no dynamic stack allocation. (Glossing over some details here; this assumes that the stack pointer doesn't change at all during function execution, at least not at the "relevant" places - traps and function call sites. This is true on s390x and -as far as I know- on Arm, but not on Intel. There'd be extra information required to handle Intel correctly.)</p>
</blockquote>
<p>When discussing how to speed up stack walking with Chris, I originally proposed a side table approach, and he pushed back on that (and I ultimately agreed with him) because frame pointers are so much simpler and easier to implement correctly. This is an important property for anything that is critical for safety[^0].</p>
<p>[^0]: We walk the stack to identify on-stack GC roots, for example, and failing to find a stack frame can lead to the collector reclaiming something it shouldn't, resulting in use-after-free bugs. In fact, we've had problems with system unwinders before where they fail to fully walk the stack and if we fully trusted the system unwinder we would have exactly these use-after-free bugs! This was the motivation for the "stack canary" infrastructure that Wasmtime has in <code>main</code> now (and is obsoleted in this PR).</p>
<p>Frame pointers are a local property of compiling a single function that Cranelift can make sure are preserved and it is hard to get wrong.</p>
<p>Side tables on the other hand are more of a global property of all of the module's compilation and we also have to make sure that the runtime is interpreting and doing lookup in the table correctly. It isn't hard to have bugs with this kind of global integration between two far away components, as we've seen with multiple stack map-related CVEs.</p>
<p>This is why I've been pursuing frame pointers rather than side table metadata, even though I am aware that frame pointers are not strictly necessary (outside of ABI constraints) and impose some overhead (which we already happen to be paying on our most-used backends).</p>
</blockquote>



<a name="289618658"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289618658" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289618658">(Jul 14 2022 at 16:55)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184673374">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>My current hope for leaf functions is that we won't need a side table for identifying whether we are in a leaf function at the start of the backtrace, and instead there is an easy way to identify whether a leaf function has trapping instructions and maintain frame pointers in that case (as discussed at the last Cranelift meeting).</p>
<p>If that doesn't work out tho, I may need to maintain an "is this PC in a leaf function?" side table, and at that point it may be worth re-evaluating whether frame poiinters are the right approach, or if we can use a side table of static frame sizes, as you described @uweigand.</p>
</blockquote>



<a name="289627612"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289627612" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289627612">(Jul 14 2022 at 18:04)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184745861">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>If that doesn't work out tho, I may need to maintain an "is this PC in a leaf function?" side table</p>
</blockquote>
<p>As an alternate approach for this part, I think this question will only ever get asked for PCs that are trap locations, and we already <em>have</em> a side table for trap locations (holding the trap code), so this could just be an extra bit in there.<br>
</p>
</blockquote>



<a name="289629907"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289629907" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289629907">(Jul 14 2022 at 18:22)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[ ] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[ ] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[x] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[ ] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[x] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="289639287"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289639287" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289639287">(Jul 14 2022 at 19:39)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1184827287">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Hm, I didn't realize this, since our other backends preserve frame pointers (other than leaf functions on aarch64).</p>
</blockquote>
<p>To be honest, I never understood that either. In my mind, a _frame pointer_, i.e. a reserved register separate from the stack pointer, which is being using by generated code to access local variables, spill slots, and other objects in a function's stack frame, is only ever necessary if those objects cannot be accessed relative to the stack pointer instead. This is normally only the case if the function performs dynamic stack space allocation (the C <code>alloca</code> or some equivalent), because then you no longer know at compile time what the offset of your stack frame objects relative to the stack pointer is.</p>
</blockquote>
<p>Frame pointers are often used for sampling profilers to have lightning fast stack unwinding as necessary for accurate profiling. For example on macOS frame pointers are mandated to have Instruments work I believe. They don't even support DWARF unwinding AFAIK.</p>
</blockquote>



<a name="289764087"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289764087" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289764087">(Jul 15 2022 at 18:18)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1185788512">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>@uweigand </p>
<blockquote>
<p>Do you know why Linux specifically requires the frame pointer?</p>
</blockquote>
<p>No, I don't. TBH I think that all major AArch64 platforms have the same requirement, but I am most familiar with Linux.</p>
<p>My guess is that this choice makes it possible to have reliable backtraces in the absence of DWARF CFI, which is presumably worth having (e.g. consider the sampling profiler use case mentioned above) in light of the fact that the 64-bit Arm architecture is not as register-starved as others, e.g. even Cranelift, which imposes further limitations on the usable general-purpose registers on top of the base ABI, has access to 25 of them without restrictions (other than some of them being callee-saved).</p>
</blockquote>



<a name="289771094"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289771094" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289771094">(Jul 15 2022 at 19:17)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1185834915">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>@uweigand</p>
<blockquote>
<p>Do you know why Linux specifically requires the frame pointer?</p>
</blockquote>
<p>No, I don't. TBH I think that all major AArch64 platforms have the same requirement, but I am most familiar with Linux.</p>
<p>My guess is that this choice makes it possible to have reliable backtraces in the absence of DWARF CFI, which is presumably worth having (e.g. consider the sampling profiler use case mentioned above) in light of the fact that the 64-bit Arm architecture is not as register-starved as others, e.g. even Cranelift, which imposes further limitations on the usable general-purpose registers on top of the base ABI, has access to 25 of them without restrictions (other than some of them being callee-saved).</p>
</blockquote>
<p>Right, I guess that makes sense.  With 32 general-purpose registers, it's much less of a problem. Thanks!<br>
</p>
</blockquote>



<a name="289920792"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289920792" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289920792">(Jul 18 2022 at 04:16)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1186745844">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Regarding explicit stack pointers: @uweigand you're correct that one can gain additional performance by omitting them, at the cost of unwind performance and some additional complexity. And indeed, as @fitzgen noted above, I expressed a preference to keep explicit stack pointers previously (and I still feel that way). I want to elaborate a bit more on the benefits I see to this:</p>
<ul>
<li>
<p>It makes stack walking relatively bulletproof, both to security issues and to other correctness bugs (though arguably any correctness bug in stack walking is a security issue). Otherwise we need to rely on side-tables, which add additional attack surface. Unwinders are actually kind of a scary gadget: they follow pointers at specified offsets, through a chain of arbitrary depth. When the chain is a simple FP-points-to-previous-FP, by construction, then this is fairly hard to screw up with a compiler bug; emitting code that writes to FP should only happen in prologues/epilogues and would be noticed elsewhere, and FP is not in the list of allocatable registers to the regalloc so it won't even know to mention it. A bad stack write could trample the chain, but this is true in either approach. In contrast we've had a few fairly worrying issues with stackmap correctness in the past, and that's my closest proxy at the moment for "stack-related metadata that has to be correct".</p>
</li>
<li>
<p>We don't have <code>alloca</code> now, but we may in the future. If we make do without frame pointers <em>sometimes</em>, but not when an <code>alloca</code> is present, then we bifurcate the ABI code into two cases, and have to handle both correctly, and have to handle this with a special representation in the side-tables as well. My experience with special cases in the past is that they are not as well-tested. I don't want, for example, a CVE where doing something that requires <code>alloca</code> trips on a subtle flaw in the unwinder's rare actually-uses-FP path.</p>
</li>
<li>
<p>Stack-walking performance may be seen as relatively less important than a marginal gain in hot loops, etc., now; but there may exist workloads in the future that exercise stack-walking frequently, in particular once GC becomes more commonplace. The sampling profiler example given above is another use-case that will heavily stress this infrastructure.</p>
</li>
<li>
<p>At least the SpiderMonkey JIT uses the frame pointer register to build a chain of frames; see <a href="https://searchfox.org/mozilla-central/rev/3cb31675aeffd10f1f6ae7c40e24b254da7798e5/js/src/wasm/WasmFrame.h#102-103">here</a> for its stackframe layout for Wasm functions. If otherwise unsure, "what would SpiderMonkey do" seems like a good heuristic to me: we are generally targeting the same performance-tradeoff-space that it does.</p>
</li>
</ul>
<p>So, given all that, I'd <em>prefer</em> to converge to "always use FP" on all platforms. Thoughts?</p>
</blockquote>



<a name="289920840"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289920840" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289920840">(Jul 18 2022 at 04:16)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1186745844">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Regarding explicit frame pointers: @uweigand you're correct that one can gain additional performance by omitting them, at the cost of unwind performance and some additional complexity. And indeed, as @fitzgen noted above, I expressed a preference to keep explicit frame pointers previously (and I still feel that way). I want to elaborate a bit more on the benefits I see to this:</p>
<ul>
<li>
<p>It makes stack walking relatively bulletproof, both to security issues and to other correctness bugs (though arguably any correctness bug in stack walking is a security issue). Otherwise we need to rely on side-tables, which add additional attack surface. Unwinders are actually kind of a scary gadget: they follow pointers at specified offsets, through a chain of arbitrary depth. When the chain is a simple FP-points-to-previous-FP, by construction, then this is fairly hard to screw up with a compiler bug; emitting code that writes to FP should only happen in prologues/epilogues and would be noticed elsewhere, and FP is not in the list of allocatable registers to the regalloc so it won't even know to mention it. A bad stack write could trample the chain, but this is true in either approach. In contrast we've had a few fairly worrying issues with stackmap correctness in the past, and that's my closest proxy at the moment for "stack-related metadata that has to be correct".</p>
</li>
<li>
<p>We don't have <code>alloca</code> now, but we may in the future. If we make do without frame pointers <em>sometimes</em>, but not when an <code>alloca</code> is present, then we bifurcate the ABI code into two cases, and have to handle both correctly, and have to handle this with a special representation in the side-tables as well. My experience with special cases in the past is that they are not as well-tested. I don't want, for example, a CVE where doing something that requires <code>alloca</code> trips on a subtle flaw in the unwinder's rare actually-uses-FP path.</p>
</li>
<li>
<p>Stack-walking performance may be seen as relatively less important than a marginal gain in hot loops, etc., now; but there may exist workloads in the future that exercise stack-walking frequently, in particular once GC becomes more commonplace. The sampling profiler example given above is another use-case that will heavily stress this infrastructure.</p>
</li>
<li>
<p>At least the SpiderMonkey JIT uses the frame pointer register to build a chain of frames; see <a href="https://searchfox.org/mozilla-central/rev/3cb31675aeffd10f1f6ae7c40e24b254da7798e5/js/src/wasm/WasmFrame.h#102-103">here</a> for its stackframe layout for Wasm functions. If otherwise unsure, "what would SpiderMonkey do" seems like a good heuristic to me: we are generally targeting the same performance-tradeoff-space that it does.</p>
</li>
</ul>
<p>So, given all that, I'd <em>prefer</em> to converge to "always use FP" on all platforms. Thoughts?</p>
</blockquote>



<a name="289962036"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/289962036" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#289962036">(Jul 18 2022 at 13:02)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1187363173">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Fair enough.   I agree stack walking must be correct - that's the same in the DWARF CFI case, which is used e.g. for C++ exception handling, which also must always be correct.  If we cannot or do not want to use CFI for performance reasons, then an explicit linked chain of stack frames is an alternative that is easy to be shown correct.</p>
<p>As I said, I'd be happy to implement the s390x "-mbackchain" feature, which is equivalent to what you get with -fno-omit-frame-pointer on Intel w.r.t. your considerations above.  I can do that as part of this PR (once it's progressed enough), or as a stand-alone change (but I'd prefer to wait until the SIMD patch is merged to avoid merge conflicts in the ABI code).</p>
<p>However, there still remains the frameless leaf function problem to be solved - this is equivalent to the problem on AArch64, and can be solved using the same method we use there (either reliably detecting such functions, or else never generating them in the first place).<br>
</p>
</blockquote>



<a name="290167456"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290167456" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290167456">(Jul 19 2022 at 22:06)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1189597570">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>As I said, I'd be happy to implement the s390x "-mbackchain" feature, which is equivalent to what you get with -fno-omit-frame-pointer on Intel w.r.t. your considerations above. I can do that as part of this PR (once it's progressed enough), or as a stand-alone change (but I'd prefer to wait until the SIMD patch is merged to avoid merge conflicts in the ABI code).</p>
</blockquote>
<p>Thanks, very appreciated. I think there are two <code>s390x</code> TODO items here:</p>
<ul>
<li>
<p>[ ] Implement frame pointers preservation. I've split out <a href="https://github.com/bytecodealliance/wasmtime/pull/4469">https://github.com/bytecodealliance/wasmtime/pull/4469</a> to add a new flag for Cranelift that controls whether a backend should preserve frame pointers (or equivalent). I think that PR can land without <code>s390x</code> support, since all tests will all still pass, and then we can add <code>s390x</code> support in a follow up PR and add the equivalent filetests for <code>s390x</code> that I added for <code>aarch64</code> in that PR.</p>
</li>
<li>
<p>[ ] Create <code>s390x</code> implementations of the host-to-Wasm and Wasm-to-host trampolines in <code>crates/runtime/src/trampolines/s390x.rs</code>. I don't think I have enough <code>s390x</code> expertise to implement this myself, but I can definitely help clear up any questons around <em>what</em> the trampolines should do, and why they have the constraints that they do.</p>
</li>
</ul>
<p>More than happy to wait until your SIMD patch is merged.</p>
<p>As already mentioned, I think we can merge the new preserve-frame-pointers flag PR as soon as it gets review approval and CI is green, since it doesn't break anything by itself yet.</p>
<p>But I'd really prefer to not land this PR -- since doing so would break <code>s390x</code> support in Wasmtime -- until we've resolved both the frame pointers item and the trampolines item. Do you think this is something you can help out with within the next couple weeks? I'd prefer not to keep this PR open indefinitely, so if you are swamped and don't have the time, then we could consider the temporarily disabling <code>s390x</code> in CI until we can get it working again, but I would personally consider this an unfortunate outcome.</p>
<p>But yeah, I consider this PR to be pretty stable and generally ready for review now, so I don't think it makes sense to wait on it to be more fleshed out anymore.</p>
</blockquote>



<a name="290169004"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290169004" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290169004">(Jul 19 2022 at 22:23)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1189610123">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h4>Label Messager: wasmtime:config</h4>
<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>
complete this check list:</p>
<ul>
<li>
<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>
      it.</p>
<p>&lt;details&gt;</p>
<p>Our documentation should be of the following form:</p>
<p>```text<br>
Short, simple summary sentence.</p>
<p>More details. These details can be multiple paragraphs. There should be<br>
information about not just the method, but its parameters and results as<br>
well.</p>
<p>Is this method fallible? If so, when can it return an error?</p>
<p>Can this method panic? If so, when does it panic?</p>
<h1>Example</h1>
<p>Optional example here.<br>
```</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>
  ensured that this configuration is exercised by the fuzz targets.</p>
<p>&lt;details&gt;</p>
<p>For example, if you expose a new strategy for allocating the next instance<br>
slot inside the pooling allocator, you should ensure that at least one of our<br>
fuzz targets exercises that new strategy.</p>
<p>Often, all that is required of you is to ensure that there is a knob for this<br>
configuration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>
of its nested <code>struct</code>s).</p>
<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>
configuration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you are enabling a configuration option by default, make sure that it<br>
  has been fuzzed for at least two weeks before turning it on by default.</p>
</li>
</ul>
<p>[fuzzing-config]: <a href="https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>
[fuzzing-docs]: <a href="https://docs.wasmtime.dev/contributing-fuzzing.html">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>
<hr>
<p>&lt;details&gt;</p>
<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>
<p>To add new label messages or remove existing label messages, edit the<br>
&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/label-messager-action">Learn more.</a></p>
<p>&lt;/details&gt;</p>
</blockquote>



<a name="290169325"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290169325" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290169325">(Jul 19 2022 at 22:27)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1189610123">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h4>Label Messager: wasmtime:config</h4>
<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>
complete this check list:</p>
<ul>
<li>
<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>
      it.</p>
<p>&lt;details&gt;</p>
<p>Our documentation should be of the following form:</p>
<p>```text<br>
Short, simple summary sentence.</p>
<p>More details. These details can be multiple paragraphs. There should be<br>
information about not just the method, but its parameters and results as<br>
well.</p>
<p>Is this method fallible? If so, when can it return an error?</p>
<p>Can this method panic? If so, when does it panic?</p>
<h1>Example</h1>
<p>Optional example here.<br>
```</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>
  ensured that this configuration is exercised by the fuzz targets.</p>
<p>&lt;details&gt;</p>
<p>For example, if you expose a new strategy for allocating the next instance<br>
slot inside the pooling allocator, you should ensure that at least one of our<br>
fuzz targets exercises that new strategy.</p>
<p>Often, all that is required of you is to ensure that there is a knob for this<br>
configuration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>
of its nested <code>struct</code>s).</p>
<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>
configuration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] If you are enabling a configuration option by default, make sure that it<br>
  has been fuzzed for at least two weeks before turning it on by default.</p>
</li>
</ul>
<p>[fuzzing-config]: <a href="https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>
[fuzzing-docs]: <a href="https://docs.wasmtime.dev/contributing-fuzzing.html">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>
<hr>
<p>&lt;details&gt;</p>
<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>
<p>To add new label messages or remove existing label messages, edit the<br>
&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/label-messager-action">Learn more.</a></p>
<p>&lt;/details&gt;</p>
</blockquote>



<a name="290227545"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290227545" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290227545">(Jul 20 2022 at 12:23)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190220690">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>Implement frame pointers preservation. I've split out <a href="https://github.com/bytecodealliance/wasmtime/pull/4469">https://github.com/bytecodealliance/wasmtime/pull/4469</a> to add a new flag for Cranelift that controls whether a backend should preserve frame pointers (or equivalent). I think that PR can land without s390x support, since all tests will all still pass, and then we can add s390x support in a follow up PR and add the equivalent filetests for s390x that I added for aarch64 in that PR.</p>
</blockquote>
<p>I've already replied on that PR.</p>
<blockquote>
<p>Create s390x implementations of the host-to-Wasm and Wasm-to-host trampolines in crates/runtime/src/trampolines/s390x.rs. I don't think I have enough s390x expertise to implement this myself, but I can definitely help clear up any questons around what the trampolines should do, and why they have the constraints that they do.</p>
</blockquote>
<p>Sure, I can implement the trampolines.   The one concern I have is that the implementation seems to require <code>global_asm!</code>, and this is not yet supported in Rust for <code>s390x</code> - at least not yet stable.</p>
<blockquote>
<p>More than happy to wait until your SIMD patch is merged.</p>
</blockquote>
<p>That's already happened now.</p>
<blockquote>
<p>But yeah, I consider this PR to be pretty stable and generally ready for review now, so I don't think it makes sense to wait on it to be more fleshed out anymore.</p>
</blockquote>
<p>I still see this PR failing the CI tests (not just on s390x, but also elsewhere).   Does it still make sense for me to try to use the current patch as basis for working on s390x support?<br>
</p>
</blockquote>



<a name="290245711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290245711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290245711">(Jul 20 2022 at 14:51)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190386941">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>Sure, I can implement the trampolines. The one concern I have is that the implementation seems to require global_asm!, and this is not yet supported in Rust for s390x - at least not yet stable.</p>
</blockquote>
<p>I think this can use the same trick as the <code>wasmtime-fiber</code> crate where x86_64/aarch64 use <code>global_asm!</code> and s390x uses an external assembly file built with the <code>cc</code> crate.</p>
</blockquote>



<a name="290246624"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290246624" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290246624">(Jul 20 2022 at 14:58)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190394269">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Sure, I can implement the trampolines. The one concern I have is that the implementation seems to require global_asm!, and this is not yet supported in Rust for s390x - at least not yet stable.</p>
</blockquote>
<p>I think this can use the same trick as the <code>wasmtime-fiber</code> crate where x86_64/aarch64 use <code>global_asm!</code> and s390x uses an external assembly file built with the <code>cc</code> crate.</p>
</blockquote>
<p>How would this work with the <code>wasm_to_libcall_trampoline</code> macro, which has the function name as parameter?  <br>
</p>
</blockquote>



<a name="290248017"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290248017" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290248017">(Jul 20 2022 at 15:07)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190405429">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>I still see this PR failing the CI tests (not just on s390x, but also elsewhere). Does it still make sense for me to try to use the current patch as basis for working on s390x support?</p>
</blockquote>
<p>I think so. There are some little macos and windows specific bits that I need to add, but I don't expect the overall architecture of the patch to change from here on out.</p>
</blockquote>



<a name="290251418"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290251418" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290251418">(Jul 20 2022 at 15:30)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190433300">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>For s390x libcalls I think everything would need to be manually listed in the inline assembly file. I presume though that a preprocessor macro could be used to have something like <code>LIBCALL_TRAMPOLINE(memory32_grow)</code> which expands to everything necessary. It ideally would be pretty simple to maintain the list for others too</p>
</blockquote>



<a name="290280639"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290280639" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290280639">(Jul 20 2022 at 18:49)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190634272">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>@fitzgen I've had to disable these asserts:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">last_wasm_exit_fp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">last_wasm_exit_pc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">last_wasm_exit_fp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">last_wasm_exit_pc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">old_last_wasm_exit_fp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">old_last_wasm_exit_pc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">old_last_wasm_exit_fp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">old_last_wasm_exit_pc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>These can falsely trigger in the case where a host-to-wasm transition is immediately followed by a wasm-to-host transition.  In this case, <code>last_wasm_exit_pc</code> will point to the host code that started the first of these transitions (so it is not 0), and <code>last_wasm_exit_fp</code> will contain the FP value of that host code.  Since host code does not maintain FP, the contents are random, and may be 0.  This may happen only rarely on Intel, but with the backchain implementation on s390x, this seems to happen frequently.</p>
<p>With this change, I've got an initial implementation that passes all CI test on s390x.   I'll attach a patch here, feel free to include it <br>
into this PR to make it pass CI.</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/files/9153690/diff-pr4431-s390x.txt">diff-pr4431-s390x.txt</a></p>
</blockquote>



<a name="290286982"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290286982" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290286982">(Jul 20 2022 at 19:32)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1190673311">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>With this change, I've got an initial implementation that passes all CI test on s390x.</p>
</blockquote>
<p>Just to be clear, passing CI also requires <a href="https://github.com/bytecodealliance/wasmtime/pull/4477">https://github.com/bytecodealliance/wasmtime/pull/4477</a> to be merged.</p>
</blockquote>



<a name="290413547"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290413547" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290413547">(Jul 21 2022 at 18:17)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1191794966">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>@fitzgen, I see this error:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">warning</span>: <span class="nc">src</span><span class="o">/</span><span class="n">trampolines</span><span class="o">/</span><span class="n">s390x</span><span class="p">.</span><span class="n">S</span>: <span class="nc">Assembler</span><span class="w"> </span><span class="n">messages</span>:
<span class="nc">warning</span>: <span class="nc">src</span><span class="o">/</span><span class="n">trampolines</span><span class="o">/</span><span class="n">s390x</span><span class="p">.</span><span class="n">S</span>:<span class="mi">5</span>: <span class="nc">Error</span>: <span class="nc">invalid</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="err">`</span><span class="n">z14</span><span class="o">'</span><span class="w"></span>
</code></pre></div>
<p>Looks like the assembler on the build machine is a bit old.  You can try replacing <code>.machine z14</code>  with <code>.machine z13</code> in the <code>s390x.S</code> file, that should still be sufficient.   (z13 is supported in gas since 2015, so that should be good enough ...)<br>
</p>
</blockquote>



<a name="290830467"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290830467" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290830467">(Jul 25 2022 at 23:06)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[ ] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[x] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[x] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[ ] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[x] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="290830470"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290830470" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290830470">(Jul 25 2022 at 23:06)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[x] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[x] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[x] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[ ] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[x] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="290830473"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290830473" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290830473">(Jul 25 2022 at 23:06)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1180803916">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<h1>TODO</h1>
<ul>
<li>[x] aarch64 support (I think I can implement this myself, but cc @akirilov-arm anyways)</li>
<li>[x] s390x support (I think I will need some help with this, cc @uweigand)</li>
<li>[x] leaf functions that can trap need to preserve frame pointers to avoid missing frames in stack traces</li>
<li>[x] use the macros from <code>wasmtime-fiber</code> for defining the asm trampolines</li>
<li>[x] write a fuzz target that makes sure we are visiting all stack Wasm frames and aren't getting any host frames in our traces</li>
</ul>
</blockquote>



<a name="290932030"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290932030" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290932030">(Jul 26 2022 at 17:56)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1189597570">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>As I said, I'd be happy to implement the s390x "-mbackchain" feature, which is equivalent to what you get with -fno-omit-frame-pointer on Intel w.r.t. your considerations above. I can do that as part of this PR (once it's progressed enough), or as a stand-alone change (but I'd prefer to wait until the SIMD patch is merged to avoid merge conflicts in the ABI code).</p>
</blockquote>
<p>Thanks, very appreciated. I think there are two <code>s390x</code> TODO items here:</p>
<ul>
<li>
<p>[x] Implement frame pointers preservation. I've split out <a href="https://github.com/bytecodealliance/wasmtime/pull/4469">https://github.com/bytecodealliance/wasmtime/pull/4469</a> to add a new flag for Cranelift that controls whether a backend should preserve frame pointers (or equivalent). I think that PR can land without <code>s390x</code> support, since all tests will all still pass, and then we can add <code>s390x</code> support in a follow up PR and add the equivalent filetests for <code>s390x</code> that I added for <code>aarch64</code> in that PR.</p>
</li>
<li>
<p>[ ] Create <code>s390x</code> implementations of the host-to-Wasm and Wasm-to-host trampolines in <code>crates/runtime/src/trampolines/s390x.rs</code>. I don't think I have enough <code>s390x</code> expertise to implement this myself, but I can definitely help clear up any questons around <em>what</em> the trampolines should do, and why they have the constraints that they do.</p>
</li>
</ul>
<p>More than happy to wait until your SIMD patch is merged.</p>
<p>As already mentioned, I think we can merge the new preserve-frame-pointers flag PR as soon as it gets review approval and CI is green, since it doesn't break anything by itself yet.</p>
<p>But I'd really prefer to not land this PR -- since doing so would break <code>s390x</code> support in Wasmtime -- until we've resolved both the frame pointers item and the trampolines item. Do you think this is something you can help out with within the next couple weeks? I'd prefer not to keep this PR open indefinitely, so if you are swamped and don't have the time, then we could consider the temporarily disabling <code>s390x</code> in CI until we can get it working again, but I would personally consider this an unfortunate outcome.</p>
<p>But yeah, I consider this PR to be pretty stable and generally ready for review now, so I don't think it makes sense to wait on it to be more fleshed out anymore.</p>
</blockquote>



<a name="290932038"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290932038" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290932038">(Jul 26 2022 at 17:56)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1189597570">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>As I said, I'd be happy to implement the s390x "-mbackchain" feature, which is equivalent to what you get with -fno-omit-frame-pointer on Intel w.r.t. your considerations above. I can do that as part of this PR (once it's progressed enough), or as a stand-alone change (but I'd prefer to wait until the SIMD patch is merged to avoid merge conflicts in the ABI code).</p>
</blockquote>
<p>Thanks, very appreciated. I think there are two <code>s390x</code> TODO items here:</p>
<ul>
<li>
<p>[x] Implement frame pointers preservation. I've split out <a href="https://github.com/bytecodealliance/wasmtime/pull/4469">https://github.com/bytecodealliance/wasmtime/pull/4469</a> to add a new flag for Cranelift that controls whether a backend should preserve frame pointers (or equivalent). I think that PR can land without <code>s390x</code> support, since all tests will all still pass, and then we can add <code>s390x</code> support in a follow up PR and add the equivalent filetests for <code>s390x</code> that I added for <code>aarch64</code> in that PR.</p>
</li>
<li>
<p>[x] Create <code>s390x</code> implementations of the host-to-Wasm and Wasm-to-host trampolines in <code>crates/runtime/src/trampolines/s390x.rs</code>. I don't think I have enough <code>s390x</code> expertise to implement this myself, but I can definitely help clear up any questons around <em>what</em> the trampolines should do, and why they have the constraints that they do.</p>
</li>
</ul>
<p>More than happy to wait until your SIMD patch is merged.</p>
<p>As already mentioned, I think we can merge the new preserve-frame-pointers flag PR as soon as it gets review approval and CI is green, since it doesn't break anything by itself yet.</p>
<p>But I'd really prefer to not land this PR -- since doing so would break <code>s390x</code> support in Wasmtime -- until we've resolved both the frame pointers item and the trampolines item. Do you think this is something you can help out with within the next couple weeks? I'd prefer not to keep this PR open indefinitely, so if you are swamped and don't have the time, then we could consider the temporarily disabling <code>s390x</code> in CI until we can get it working again, but I would personally consider this an unfortunate outcome.</p>
<p>But yeah, I consider this PR to be pretty stable and generally ready for review now, so I don't think it makes sense to wait on it to be more fleshed out anymore.</p>
</blockquote>



<a name="290953990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/290953990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#290953990">(Jul 26 2022 at 20:47)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1195965249">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Okay! I've got CI green! I think this is ready for another round of review!</p>
</blockquote>



<a name="291004600"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291004600" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291004600">(Jul 27 2022 at 08:39)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1196430691">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Are native frames still listed in backtraces, are they shown with a marker like <code>&lt;native frames&gt;</code>, or will something like wasm a -&gt; native b -&gt; wasm c look like a -&gt; c in the backtrace?</p>
</blockquote>



<a name="291057997"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291057997" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291057997">(Jul 27 2022 at 15:41)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1196926706">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>Are native frames still listed in backtraces, are they shown with a marker like <code>&lt;native frames&gt;</code>, or will something like wasm a -&gt; native b -&gt; wasm c look like a -&gt; c in the backtrace?</p>
</blockquote>
<p>We don't list native frames in backtraces right now, we filter to only the Wasm frames, so this doesn't change that behavior. If, in the future, we wanted to insert <code>&lt;host frames&gt;</code> in between sequences of contiguous Wasm frames in the backtrace's display, we could do that in a follow up.</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/285bc5ce24109e41650594c2746087ae89f0953a/crates/wasmtime/src/trap.rs#L355">https://github.com/bytecodealliance/wasmtime/blob/285bc5ce24109e41650594c2746087ae89f0953a/crates/wasmtime/src/trap.rs#L355</a></p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/285bc5ce24109e41650594c2746087ae89f0953a/crates/wasmtime/src/trap.rs#L315">https://github.com/bytecodealliance/wasmtime/blob/285bc5ce24109e41650594c2746087ae89f0953a/crates/wasmtime/src/trap.rs#L315</a></p>
</blockquote>



<a name="291089358"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291089358" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291089358">(Jul 27 2022 at 18:24)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197185626">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>I've double-checked locally again and at least on an arm64 machine this is a significant regression in the overheads of calling in/out of wasm:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">sync</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="n">hook</span><span class="o">/</span><span class="n">host</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">typed</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nop</span><span class="w"></span>
<span class="w">                        </span><span class="n">time</span>:   <span class="p">[</span><span class="mf">39.549</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">39.608</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">39.660</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">change</span>: <span class="p">[</span><span class="o">+</span><span class="mf">51.084</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">51.260</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">51.444</span><span class="o">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.00</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">Performance</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">regressed</span><span class="p">.</span><span class="w"></span>
<span class="n">sync</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="n">hook</span><span class="o">/</span><span class="n">host</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">typed</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nop</span><span class="o">-</span><span class="n">params</span><span class="o">-</span><span class="n">and</span><span class="o">-</span><span class="n">results</span><span class="w"></span>
<span class="w">                        </span><span class="n">time</span>:   <span class="p">[</span><span class="mf">42.601</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">42.680</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">42.765</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">change</span>: <span class="p">[</span><span class="o">+</span><span class="mf">39.134</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">39.382</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">39.673</span><span class="o">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.00</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">Performance</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">regressed</span><span class="p">.</span><span class="w"></span>
<span class="n">sync</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="n">hook</span><span class="o">/</span><span class="n">wasm</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">host</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nop</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">typed</span><span class="w"></span>
<span class="w">                        </span><span class="n">time</span>:   <span class="p">[</span><span class="mf">9.0086</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">9.0131</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">9.0181</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">change</span>: <span class="p">[</span><span class="o">+</span><span class="mf">50.049</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">50.098</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">50.154</span><span class="o">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.00</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">Performance</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">regressed</span><span class="p">.</span><span class="w"></span>
<span class="n">sync</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="n">hook</span><span class="o">/</span><span class="n">wasm</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">host</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nop</span><span class="o">-</span><span class="n">params</span><span class="o">-</span><span class="n">and</span><span class="o">-</span><span class="n">results</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">typed</span><span class="w"></span>
<span class="w">                        </span><span class="n">time</span>:   <span class="p">[</span><span class="mf">12.741</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">12.771</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">12.805</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">change</span>: <span class="p">[</span><span class="o">+</span><span class="mf">41.357</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">41.672</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">42.013</span><span class="o">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.00</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="n">Performance</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">regressed</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>I'm not going to say this is a showstopper but at the same time I don't think we've worked to quantify where all this extra time is going.</p>
</blockquote>



<a name="291090061"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291090061" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291090061">(Jul 27 2022 at 18:30)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197199914">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>I just checked out this branch on my <code>aarch64-apple-darwin</code> system and confirmed that <code>./ci/run-tests.sh</code> passes all tests, as of commit <code>10b1f2e8a36ab544c7431d9dbd9d66d0120b87a8</code>.</p>
</blockquote>



<a name="291097573"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291097573" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291097573">(Jul 27 2022 at 19:18)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197263658">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<blockquote>
<p>I've double-checked locally again and at least on an arm64 machine this is a significant regression in the overheads of calling in/out of wasm:</p>
</blockquote>
<p>This seems significant in terms of % but in terms of actual time it seems pretty plausible/okay?</p>
<p>For example</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">sync</span><span class="o">/</span><span class="n">no</span><span class="o">-</span><span class="n">hook</span><span class="o">/</span><span class="n">wasm</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">host</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nop</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">typed</span><span class="w"></span>
<span class="w">                        </span><span class="n">time</span>:   <span class="p">[</span><span class="mf">9.0086</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">9.0131</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="mf">9.0181</span><span class="w"> </span><span class="n">ns</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">change</span>: <span class="p">[</span><span class="o">+</span><span class="mf">50.049</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">50.098</span><span class="o">%</span><span class="w"> </span><span class="o">+</span><span class="mf">50.154</span><span class="o">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.00</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>This is 50% overhead, but thats like an extra ~3 nanoseconds compared to <code>main</code>, which makes sense since we are doing a couple memory stores that we didn't used to.</p>
<p>The others are similar, although the host-to-wasm variants might have a little more room for improvement since it seems like they got ~10 nanoseconds slower, but I guess they are also doing a <code>cmp</code> and a <code>cmov</code> rather than just an unconditional store?</p>
<p>But ultimately, I think this just "looks" worse than it really is do to the combination of micro micro micro benchmarks and percentage display. Like, I think we can eat a performance regression on the order of ten nanoseconds for calls, since actual calls will not be nops and doing just about literally anything will make that new overhead disappear in the noise.</p>
<p>But let me know if you disagree, or if I am misreading these benchmark numbers.</p>
</blockquote>



<a name="291102167"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291102167" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291102167">(Jul 27 2022 at 19:57)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197302424">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>I don't disagree that a handful of ns here and there is unlikely to make or break the bank, but at the same time I do think it's still worth putting some time in to quantify what the runtime impact of this change is. Some quick benchmarking locally shows that <code>Instance::runtime_limits</code> is not inlined across crates, for example, but provides a small perf boost if it is (and it wasn't necessary before this commit).</p>
<p>Additionally logic added <a href="https://github.com/bytecodealliance/wasmtime/pull/4431/commits/4d8486dec7da8c1c7751f6f5d5801fbf9896563c">in the latest commit</a> greatly inflates the size of the return value which may not be easily optimizable (moving large-ish types around in Rust) and might be better modeled with a <code>Drop for SomeCustomStruct</code> to handle the unwind cleanup rather than deferring the <code>resume_unwind</code>.</p>
<p>I mostly just want to make sure that the slowdowns all come from expected sources. The extra indirect calls are expected to be slower along with the extra memory traffic of maintaining  pc/fp along with all the old pc/fp/etc. Additionally the stack frame for <code>catch_trap</code> is bigger with a bigger <code>CallThreadState</code> so the extra memory traffic in that function is also expected.</p>
</blockquote>



<a name="291103691"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291103691" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291103691">(Jul 27 2022 at 20:09)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197314114">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>@alexcrichton @fitzgen This is about the trampoline code, right? If yes, there are a couple of micro-optimizations that could be applied to it, i.e. loading and storing pairs of registers instead of individual ones (which is also going to reduce the instruction count) and some scheduling, but I didn't bother commenting because it seemed insignificant.</p>
</blockquote>



<a name="291103958"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291103958" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291103958">(Jul 27 2022 at 20:12)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197316302">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>Indeed yeah, the benchmarks I listed above are measuring the overhead it takes getting from Rust into wasm and the other way around as well. Those are affected by trampolines and additionally all the other infrastructure that we have for catching traps/etc. They're definitely micro-benchmarks but it's the bound of speed in how fast any embedder can call into wasm.</p>
</blockquote>



<a name="291105139"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291105139" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291105139">(Jul 27 2022 at 20:23)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197327508">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>@akirilov-arm would love to have your suggested micro optimizations in a follow up PR!</p>
</blockquote>



<a name="291113480"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291113480" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291113480">(Jul 27 2022 at 21:34)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1197392694">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p>I've tried tweaking a number of little bits to help improve the call benchmarks, but most changes are within the noise and changes that individually seem like a win for one benchmark are becoming losses across the board when put together.</p>
<p>Thing's I've tried:</p>
<ul>
<li>Mark <code>StoreInner::call_hook</code> as inline</li>
<li>Reset entry/exit registers via a custom <code>Drop</code> rather than delaying resuming panics</li>
<li>Mark <code>VMHostFuncContext::host_state</code> for inlining</li>
<li>Mark <code>wasmtime_runtime::Instance::runtime_limits</code> for inlining</li>
</ul>
<p>At this point I don't think there are any easy wins due to accidental lack of inlining or growing the sizes of function returns. For posterity, a branch with these changes is over here: <a href="https://github.com/fitzgen/wasmtime/tree/fast-stack-walking-with-attempts-to-improve-call-perf">https://github.com/fitzgen/wasmtime/tree/fast-stack-walking-with-attempts-to-improve-call-perf</a></p>
<p>In the meantime, I'm going to go ahead and merge this PR, and then we can work on making sure that the regressions to the call benchmarks are exactly the overhead of the new trampolines, and not anything extra/accidental included as well in follow up investigations.<br>
</p>
</blockquote>



<a name="291332103"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234431%20%60wasmtime%60%3A%20Implement%20fast%20Wasm%20st.../near/291332103" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234431.20.60wasmtime.60.3A.20Implement.20fast.20Wasm.20st.2E.2E.2E.html#291332103">(Jul 29 2022 at 14:16)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/4431#issuecomment-1199363171">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/4431">issue #4431</a>:</p>
<blockquote>
<p><span aria-label="confetti" class="emoji emoji-1f38a" role="img" title="confetti">:confetti:</span> </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>