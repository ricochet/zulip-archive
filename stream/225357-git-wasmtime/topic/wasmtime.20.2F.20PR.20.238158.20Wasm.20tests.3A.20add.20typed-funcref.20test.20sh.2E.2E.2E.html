<html>
<head><meta charset="utf-8"><title>wasmtime / PR #8158 Wasm tests: add typed-funcref test sh... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html">wasmtime / PR #8158 Wasm tests: add typed-funcref test sh...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="426988848"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/426988848" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#426988848">(Mar 17 2024 at 03:29)</a>:</h4>
<p><strong>cfallin</strong> requested <a href="https://github.com/jameysharp">jameysharp</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>.</p>



<a name="426988850"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/426988850" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#426988850">(Mar 17 2024 at 03:29)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a> from <code>cfallin:typed-funcref-ics-test</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>In order to have fast IC (inline cache) chains in AOT-compiled dynamic language Wasms, it would be great if we could make the "call to a typed funcref at a constant table index" pattern fast.</p>
<p>This use-case was discussed at the most recent Wasmtime biweekly and @jameysharp is working on some optimizations; the intent of this PR is to provide a concrete test-case whose blessed output we can see improve over time.</p>
<p>In particular, the following opts are still desirable:</p>
<ul>
<li>With the use of non-nullable typed funcrefs, there shouldn't be a null check (there currently is, as noted by a comment in the code due to lack of type information at the right spot).</li>
<li>With the use of a constant table size and a constant index to the <code>table.get</code>, we should be able to load from the table without a bounds-check or any Spectre masking.</li>
</ul>
<p>Other further optimizations for this pattern might be possible if we rearrange the table and function-reference data structures, and the lazy-initialization scheme thereof, but the above should be agnostic to that.</p>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
</blockquote>



<a name="426988852"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/426988852" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#426988852">(Mar 17 2024 at 03:29)</a>:</h4>
<p><strong>cfallin</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>.</p>



<a name="427010431"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427010431" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427010431">(Mar 17 2024 at 05:08)</a>:</h4>
<p>jameysharp submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#pullrequestreview-1941375209">PR review</a>:</p>
<blockquote>
<p>"Chris," I whine to myself, "stop working on a Saturday evening," as I approve your PR at 10pm</p>
<p>Thanks for this! It's definitely the kind of thing I was hoping for.</p>
<p>This example module initializes element zero of the table to point to a function, then calls through elements one and two. What is that supposed to do? Or am I misreading it?</p>
</blockquote>



<a name="427156972"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427156972" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427156972">(Mar 17 2024 at 16:14)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002526786">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p><code>(table $ic-sites 100 100 (ref $ic-stub) (ref.func $ic1))</code></p>
</blockquote>
<p>This example module initializes element zero of the table to point to a function</p>
</blockquote>
<p>Oh this syntax is actually initializing the entire table with <code>(ref.func $ic1)</code>, it's new syntax/binary stuff introduced as part of the function-references proposal (basically folded into the gc proposal)</p>
<hr>
<p>Somewhat orthogonal question as well: I forget if I asked this in the past, but is the reason to use a typed table instead of typed globals to get the lazy initialization? If I change the above test to use two typed function globals it ends up codegenning (today)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">u0</span>:<span class="mi">1</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">vmctx</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="nc">fast</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">gv0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmctx</span>
<span class="w">    </span><span class="n">gv1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">gv0</span><span class="o">+</span><span class="mi">8</span>
<span class="w">    </span><span class="n">gv2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">gv1</span>
<span class="w">    </span><span class="n">gv3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmctx</span>
<span class="w">    </span><span class="n">sig0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">vmctx</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="nc">fast</span>
<span class="w">    </span><span class="n">sig1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">vmctx</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">uext</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">uext</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="nc">uext</span><span class="w"> </span><span class="n">system_v</span>
<span class="w">    </span><span class="n">sig2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">vmctx</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">uext</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="nc">uext</span><span class="w"> </span><span class="n">system_v</span>
<span class="w">    </span><span class="n">stack_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gv2</span>

<span class="w">                                </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span>: <span class="kt">i32</span><span class="p">)</span>:
                                    <span class="nc">v8</span><span class="w"> </span>-&gt; <span class="nc">v0</span>
<span class="w">                                    </span><span class="n">v14</span><span class="w"> </span>-&gt; <span class="nc">v0</span>
<span class="o">@</span><span class="mi">003</span><span class="n">b</span><span class="w">                               </span><span class="n">v9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">v0</span><span class="o">+</span><span class="mi">80</span>
<span class="o">@</span><span class="mi">003</span><span class="n">d</span><span class="w">                               </span><span class="n">brif</span><span class="w"> </span><span class="n">v9</span><span class="p">,</span><span class="w"> </span><span class="n">block3</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span>

<span class="w">                                </span><span class="n">block2</span><span class="w"> </span><span class="n">cold</span>:
<span class="o">@</span><span class="mi">003</span><span class="n">d</span><span class="w">                               </span><span class="n">trap</span><span class="w"> </span><span class="n">null_reference</span>

<span class="w">                                </span><span class="n">block3</span>:
<span class="o">@</span><span class="mi">003</span><span class="n">d</span><span class="w">                               </span><span class="n">v10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">v9</span><span class="o">+</span><span class="mi">16</span>
<span class="o">@</span><span class="mi">003</span><span class="n">d</span><span class="w">                               </span><span class="n">v11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">v9</span><span class="o">+</span><span class="mi">32</span>
<span class="o">@</span><span class="mi">003</span><span class="n">d</span><span class="w">                               </span><span class="n">v12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_indirect</span><span class="w"> </span><span class="n">sig0</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span><span class="p">(</span><span class="n">v11</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span><span class="p">)</span>
<span class="o">@</span><span class="mi">004</span><span class="n">c</span><span class="w">                               </span><span class="n">v15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">v0</span><span class="o">+</span><span class="mi">96</span>
<span class="o">@</span><span class="mi">004</span><span class="n">e</span><span class="w">                               </span><span class="n">brif</span><span class="w"> </span><span class="n">v15</span><span class="p">,</span><span class="w"> </span><span class="n">block5</span><span class="p">,</span><span class="w"> </span><span class="n">block4</span>

<span class="w">                                </span><span class="n">block4</span><span class="w"> </span><span class="n">cold</span>:
<span class="o">@</span><span class="mi">004</span><span class="n">e</span><span class="w">                               </span><span class="n">trap</span><span class="w"> </span><span class="n">null_reference</span>

<span class="w">                                </span><span class="n">block5</span>:
<span class="o">@</span><span class="mi">004</span><span class="n">e</span><span class="w">                               </span><span class="n">v16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">v15</span><span class="o">+</span><span class="mi">16</span>
<span class="o">@</span><span class="mi">004</span><span class="n">e</span><span class="w">                               </span><span class="n">v17</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">v15</span><span class="o">+</span><span class="mi">32</span>
<span class="o">@</span><span class="mi">004</span><span class="n">e</span><span class="w">                               </span><span class="n">v18</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">call_indirect</span><span class="w"> </span><span class="n">sig0</span><span class="p">,</span><span class="w"> </span><span class="n">v16</span><span class="p">(</span><span class="n">v17</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span><span class="p">)</span>
<span class="o">@</span><span class="mi">0057</span><span class="w">                               </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span>

<span class="w">                                </span><span class="n">block1</span>:
<span class="o">@</span><span class="mi">0052</span><span class="w">                               </span><span class="n">v19</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">v18</span><span class="p">,</span><span class="w"> </span><span class="n">v12</span>
<span class="w">                                    </span><span class="n">v6</span><span class="w"> </span>-&gt; <span class="nc">v19</span>
<span class="o">@</span><span class="mi">0057</span><span class="w">                               </span><span class="k">return</span><span class="w"> </span><span class="n">v19</span>
<span class="p">}</span>
</code></pre></div>
<p>which is pretty good given that we've got <a href="https://github.com/bytecodealliance/wasmtime/issues/5291">https://github.com/bytecodealliance/wasmtime/issues/5291</a> in our pocket</p>
</blockquote>



<a name="427163970"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427163970" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427163970">(Mar 17 2024 at 16:45)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002535045">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<p>Thanks Alex, now I understand!</p>
<p>I'd forgotten about #5291; we just added a different use of memflags to indicate trap code so we have precedent now. But besides that, if I understood Chris correctly, this example is supposed to be typed as a non-nullable function reference. So if we thread that type information through correctly then we should be able to elide the null-check even without #5291, right?</p>
</blockquote>



<a name="427169432"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427169432" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427169432">(Mar 17 2024 at 17:09)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002542113">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<p>Indeed, this initializes everything then calls ICs 1 and 2, which were meant to be arbitrary -- I'll add some comments to make it clearer!</p>
<blockquote>
<p>is the reason to use a typed table instead of typed globals to get the lazy initialization?</p>
</blockquote>
<p>not quite; I realized once I progressed past "IC caller" logic to "IC update" logic that while AOT-compiling can produce bodies that have statically different code locations per IC head, the update logic is shared (polymorphic over IC index) and there's no "set global N to V" instruction. I could potentially finagle the IC-stub ABI to return a new funcref and always update in the statically-unique callsite sequence or something, but that's a lot of overhead if these are frequent; IMHO this is what tables are made for :-)</p>
</blockquote>



<a name="427170408"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427170408" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427170408">(Mar 17 2024 at 17:13)</a>:</h4>
<p>cfallin updated <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>.</p>



<a name="427171091"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427171091" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427171091">(Mar 17 2024 at 17:16)</a>:</h4>
<p>cfallin has enabled auto merge for <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>.</p>



<a name="427179843"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427179843" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427179843">(Mar 17 2024 at 17:56)</a>:</h4>
<p>cfallin merged <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>.</p>



<a name="427181342"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427181342" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427181342">(Mar 17 2024 at 18:03)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002558118">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<p>Ah so the <code>call_ref</code> instructions are always done with a constant index, but the <code>table.set</code> instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all <code>call_ref</code> is done with a constant index or otherwise this codegen wouldn't be representative.</p>
<blockquote>
<p>So if we thread that type information through correctly then we should be able to elide the null-check even without <a href="https://github.com/bytecodealliance/wasmtime/issues/5291">https://github.com/bytecodealliance/wasmtime/issues/5291</a>, right?</p>
</blockquote>
<p>True!</p>
<p>Thinking a bit more on this, if the <code>table.get</code> plus <code>call_ref</code> pair were replaced with <code>call_indirect</code> we wouldn't have to solve the problem of propagating validator type information into lowering. In such a situation we could inspect the table's type and notice that it's non-nullable and skip the null check. I think it should be the case that <code>table.get</code> plus <code>call_ref</code> should be the same codegen as <code>call_indirect</code> at least ...</p>
</blockquote>



<a name="427187558"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427187558" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427187558">(Mar 17 2024 at 18:31)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002567541">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<p>This has inspired me to go off and do <a href="https://github.com/bytecodealliance/wasmtime/pull/8159">https://github.com/bytecodealliance/wasmtime/pull/8159</a> to handle the null check </p>
</blockquote>



<a name="427208914"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427208914" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427208914">(Mar 17 2024 at 20:09)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<blockquote>
<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>
</blockquote>
<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>
<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>
<blockquote>
<p><code>call_indirect</code> instead</p>
</blockquote>
<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the "typed funcref" proposal; for some reason I had it pegged as "old dynamic sig check" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>
<hr>
<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>
<p>IC sites always start as linked to the "fallback IC"; my planned use for this "fast IC head" mechanism was to have a conditional at very IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>
<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc.</p>
</blockquote>



<a name="427209188"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427209188" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427209188">(Mar 17 2024 at 20:10)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<blockquote>
<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>
</blockquote>
<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>
<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>
<blockquote>
<p><code>call_indirect</code> instead</p>
</blockquote>
<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the "typed funcref" proposal; for some reason I had it pegged as "old dynamic sig check" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>
<hr>
<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>
<p>IC sites always start as linked to the "fallback IC"; my planned use for this "fast IC head" mechanism was to have a conditional at every IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>
<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc.</p>
</blockquote>



<a name="427209598"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427209598" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427209598">(Mar 17 2024 at 20:12)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<blockquote>
<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>
</blockquote>
<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>
<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>
<blockquote>
<p><code>call_indirect</code> instead</p>
</blockquote>
<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the "typed funcref" proposal; for some reason I had it pegged as "old dynamic sig check" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>
<hr>
<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>
<p>IC sites always start as linked to the "fallback IC"; my planned use for this "fast IC head" mechanism was to have a conditional at every IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>
<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc. (EDIT: and this combines with #8159 to eliminate the null-check branch, to be clear.)</p>
</blockquote>



<a name="427502719"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%238158%20Wasm%20tests%3A%20add%20typed-funcref%20test%20sh.../near/427502719" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.238158.20Wasm.20tests.3A.20add.20typed-funcref.20test.20sh.2E.2E.2E.html#427502719">(Mar 18 2024 at 14:49)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2004124070">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/8158">PR #8158</a>:</p>
<blockquote>
<p>Makes sense! It's always possible we can use the same optimization techniques on globals as well as tables, nothing saying we have to keep everything as-is for example. If tables work then there's no need to change though.</p>
<blockquote>
<p>could we avoid the lazy-init checks if we had a nullable typed funcref table, with null as the default value</p>
</blockquote>
<p>I like this idea! </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>