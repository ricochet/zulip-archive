<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4308 Support records, variants, enums, ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html">wasmtime / issue #4308 Support records, variants, enums, ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="287261656"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287261656" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287261656">(Jun 23 2022 at 21:36)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I'm splitting this issue out of <a href="https://github.com/bytecodealliance/wasmtime/issues/4185">https://github.com/bytecodealliance/wasmtime/issues/4185</a> to write up some thoughts on how this can be done. Specifically today the current Wasmtime support for the component model has mappings for many component model types to Rust native types but not all of them. For example integers, strings, lists, tuples, etc, are all mapped directly to Rust types. Basically if the component model types equivalent in Rust is in the Rust standard library that's already implemented. What that leaves to implement, however, is Rust-defined mappings for component model types that are "structural" like records.</p>
<p>This issue is intended to document the current thinking of how we're going to expose this. The general idea is that we'll create a <code>proc-macro</code> crate, probably named something like <code>wasmtime-component-macro</code>, which is an internal dependency of the <code>wasmtime</code> crate. The various macros would then get reexported at the <code>wasmtime::component::*</code> namespace.</p>
<p>Currently the bindings for host types are navigated through three traits: <code>ComponentValue</code>, <code>Lift</code>, and <code>Lower</code>. We'll want a custom derive for all three of these traits. Deriving <code>Lift</code> and <code>Lower</code> require a <code>ComponentValue</code> derive as well, but users should be able to pick one of <code>Lift</code> and <code>Lower</code> without the other one.</p>
<h2><code>record</code></h2>
<p>Records in the component model correspond to <code>struct</code>s in Rust. The rough shape of this will be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(record)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>To typecheck correctly the <code>record</code> type must list fields in the same order as the fields listed in the Rust code for now. Field reordering may be implemented at a later date but for now we'll do strict matching. Fields must have both matching names and matching types.</p>
<p>The <code>#[component(record)]</code> here may seem redundant but it's somewhat required below for variants/enums.</p>
<p>The <code>#[component(name = "...")]</code> is intended to rename the field from the component model's perspective. The type-checking will test against the <code>name</code> specified.</p>
<p>Using this derive on a tuple or empty struct will result in a compile-time error.</p>
<h2><code>variant</code></h2>
<p>Variants roughly correspond to Rust <code>enum</code>s:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(variant)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking, like records, will check cases in-order and all cases must match in both name and payload. A missing payload in Rust is automatically interpreted as the <code>unit</code> payload in the component model.</p>
<p>Variants with named fields (<code>B { bar: u32 }</code>) will be disallowed. Variants with multiple payloads (<code>B(u32, u32)</code>) will also be disallowed.</p>
<p>Note that <code>#[component(variant)]</code> here distinguishes it from...</p>
<h2><code>enum</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(enum)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking is similar to variants where the number/names of cases must all match. </p>
<p>Variants with any payload are disallowed in this derive mode.</p>
<h2><code>union</code></h2>
<p>This will, perhaps surprisingly, still map to an <code>enum</code> in Rust since this is still a tagged union, not a literal C <code>union</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The number of cases and the types of each case must match a union definition to correctly typecheck. Union cases don't have names so renaming here isn't needed.</p>
<p>A payload on each enum case in Rust is required, and like with <code>variant</code> it's required to be a tuple-variant with only one element. All other forms of payloads are disallowed. Note that the names in Rust are just informative in Rust, it doesn't affect the ABI or type-checking</p>
<h2><code>flags</code></h2>
<p>These will be a bit "funkier" than the above since there's not something obvious to attach a <code>#[derive]</code> to:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">flags</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[derive(Lift, Lower)]</span><span class="w"></span>
<span class="w">    </span><span class="n">flags</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[component(name = </span><span class="s">"..."</span><span class="cp">)]</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">B</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The general idea here is to roughly take inspiration from the <a href="https://crates.io/crates/bitflags"><code>bitflags</code> crate</a> in terms of what the generated code does. Ideally this should have a convenient <code>Debug</code> implementation along with various constants to OR-together and such in Rust. The exact syntax here is up for debate, this is just a strawman.</p>
<h2>Implementation Details</h2>
<p>One caveat is that the <code>ComponentValue</code>/<code>Lift</code>/<code>Lower</code> traits mention internal types in the <code>wasmtime</code> crate which aren't intended to be part of the public API. To solve this the macro will reference items in a path such as:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">__internal</span>::<span class="n">the_name</span><span class="w"></span>
</code></pre></div>
<p>The <code>__internal</code> module will be <code>#[doc(hidden)]</code> and will only exist to reexport dependencies needed by the proc-macro. This crate may end up having a bland <code>pub use wasmtime_environ</code> or individual items, whatever works best.</p>
<p>The actual generated trait impls will probably look very similar to the implementations that exist for <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1729-L1826">tuples</a>, and <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1582-L1727"><code>Result&lt;T, E&gt;</code></a> already present in <code>typed.rs</code></p>
<h2>Alternatives</h2>
<p>One alternative to the above is to have <code>#[derive(ComponentRecord)]</code> instead of <code>#[derive(ComponentValue)] #[component(record)]</code> or something like that. While historically some discussions have leaned in this direction with the introduction of <code>Lift</code> and <code>Lower</code> traits I personally feel that the balance is now slightly in the other direction where it would be nice if we can keep <code>derive</code> targeted at the specific traits and then configuration for the derive happens afterwards.</p>
</blockquote>



<a name="287261661"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287261661" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287261661">(Jun 23 2022 at 21:36)</a>:</h4>
<p>alexcrichton labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I'm splitting this issue out of <a href="https://github.com/bytecodealliance/wasmtime/issues/4185">https://github.com/bytecodealliance/wasmtime/issues/4185</a> to write up some thoughts on how this can be done. Specifically today the current Wasmtime support for the component model has mappings for many component model types to Rust native types but not all of them. For example integers, strings, lists, tuples, etc, are all mapped directly to Rust types. Basically if the component model types equivalent in Rust is in the Rust standard library that's already implemented. What that leaves to implement, however, is Rust-defined mappings for component model types that are "structural" like records.</p>
<p>This issue is intended to document the current thinking of how we're going to expose this. The general idea is that we'll create a <code>proc-macro</code> crate, probably named something like <code>wasmtime-component-macro</code>, which is an internal dependency of the <code>wasmtime</code> crate. The various macros would then get reexported at the <code>wasmtime::component::*</code> namespace.</p>
<p>Currently the bindings for host types are navigated through three traits: <code>ComponentValue</code>, <code>Lift</code>, and <code>Lower</code>. We'll want a custom derive for all three of these traits. Deriving <code>Lift</code> and <code>Lower</code> require a <code>ComponentValue</code> derive as well, but users should be able to pick one of <code>Lift</code> and <code>Lower</code> without the other one.</p>
<h2><code>record</code></h2>
<p>Records in the component model correspond to <code>struct</code>s in Rust. The rough shape of this will be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(record)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>To typecheck correctly the <code>record</code> type must list fields in the same order as the fields listed in the Rust code for now. Field reordering may be implemented at a later date but for now we'll do strict matching. Fields must have both matching names and matching types.</p>
<p>The <code>#[component(record)]</code> here may seem redundant but it's somewhat required below for variants/enums.</p>
<p>The <code>#[component(name = "...")]</code> is intended to rename the field from the component model's perspective. The type-checking will test against the <code>name</code> specified.</p>
<p>Using this derive on a tuple or empty struct will result in a compile-time error.</p>
<h2><code>variant</code></h2>
<p>Variants roughly correspond to Rust <code>enum</code>s:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(variant)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking, like records, will check cases in-order and all cases must match in both name and payload. A missing payload in Rust is automatically interpreted as the <code>unit</code> payload in the component model.</p>
<p>Variants with named fields (<code>B { bar: u32 }</code>) will be disallowed. Variants with multiple payloads (<code>B(u32, u32)</code>) will also be disallowed.</p>
<p>Note that <code>#[component(variant)]</code> here distinguishes it from...</p>
<h2><code>enum</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(enum)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking is similar to variants where the number/names of cases must all match. </p>
<p>Variants with any payload are disallowed in this derive mode.</p>
<h2><code>union</code></h2>
<p>This will, perhaps surprisingly, still map to an <code>enum</code> in Rust since this is still a tagged union, not a literal C <code>union</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The number of cases and the types of each case must match a union definition to correctly typecheck. Union cases don't have names so renaming here isn't needed.</p>
<p>A payload on each enum case in Rust is required, and like with <code>variant</code> it's required to be a tuple-variant with only one element. All other forms of payloads are disallowed. Note that the names in Rust are just informative in Rust, it doesn't affect the ABI or type-checking</p>
<h2><code>flags</code></h2>
<p>These will be a bit "funkier" than the above since there's not something obvious to attach a <code>#[derive]</code> to:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">flags</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[derive(Lift, Lower)]</span><span class="w"></span>
<span class="w">    </span><span class="n">flags</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[component(name = </span><span class="s">"..."</span><span class="cp">)]</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">B</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The general idea here is to roughly take inspiration from the <a href="https://crates.io/crates/bitflags"><code>bitflags</code> crate</a> in terms of what the generated code does. Ideally this should have a convenient <code>Debug</code> implementation along with various constants to OR-together and such in Rust. The exact syntax here is up for debate, this is just a strawman.</p>
<h2>Implementation Details</h2>
<p>One caveat is that the <code>ComponentValue</code>/<code>Lift</code>/<code>Lower</code> traits mention internal types in the <code>wasmtime</code> crate which aren't intended to be part of the public API. To solve this the macro will reference items in a path such as:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">__internal</span>::<span class="n">the_name</span><span class="w"></span>
</code></pre></div>
<p>The <code>__internal</code> module will be <code>#[doc(hidden)]</code> and will only exist to reexport dependencies needed by the proc-macro. This crate may end up having a bland <code>pub use wasmtime_environ</code> or individual items, whatever works best.</p>
<p>The actual generated trait impls will probably look very similar to the implementations that exist for <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1729-L1826">tuples</a>, and <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1582-L1727"><code>Result&lt;T, E&gt;</code></a> already present in <code>typed.rs</code></p>
<h2>Alternatives</h2>
<p>One alternative to the above is to have <code>#[derive(ComponentRecord)]</code> instead of <code>#[derive(ComponentValue)] #[component(record)]</code> or something like that. While historically some discussions have leaned in this direction with the introduction of <code>Lift</code> and <code>Lower</code> traits I personally feel that the balance is now slightly in the other direction where it would be nice if we can keep <code>derive</code> targeted at the specific traits and then configuration for the derive happens afterwards.</p>
</blockquote>



<a name="287261697"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287261697" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287261697">(Jun 23 2022 at 21:37)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1164903700">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>cc @dicej as I believe you were possibly interested in taking a stab at this</p>
</blockquote>



<a name="287264287"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287264287" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287264287">(Jun 23 2022 at 22:01)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1164923396">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Thanks, @alexcrichton -- this is extremely helpful.</p>
<p>BTW, you refer to <code>ComponentValue</code> here and in some of the comments in <a href="http://typed.rs">typed.rs</a>, but the trait is actually named <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L577"><code>ComponentType</code></a>, correct?</p>
<p>Anyway, yes, I'll take a stab at this and post questions here as they arise.</p>
</blockquote>



<a name="287264394"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287264394" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287264394">(Jun 23 2022 at 22:02)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1164923928">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Whoops sorry yes it's <code>ComponentType</code> (can't keep track of my own historical list of changes)</p>
</blockquote>



<a name="287266956"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287266956" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287266956">(Jun 23 2022 at 22:29)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1164975597">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I had started work on this, but I fully support somebody else taking this on as I've had to switch gears to something else.</p>
<p>My first contribution here was in PR #4217; there's a little rationale discussion there. And my very work-in-progress branch might help in getting started: <a href="https://github.com/jameysharp/wasmtime/tree/component-derive">https://github.com/jameysharp/wasmtime/tree/component-derive</a></p>
<p>I'm happy to do code review or answer questions regarding this feature. I'm going to defer to Alex in case of any disagreements but I think I have a pretty good sense of where he wants this to go.</p>
</blockquote>



<a name="287864382"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/287864382" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#287864382">(Jun 29 2022 at 14:42)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1170072029">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Support for record types has been merged.  I'm working on variants now and will move on to the others after that.</p>
</blockquote>



<a name="288043631"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288043631" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288043631">(Jun 30 2022 at 15:15)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171347987">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>@alexcrichton How would you suggest I handle cases like these?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">type</span> <span class="nc">Baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<p>Should we throw an error in the first case or silently de-duplicate the types?  And should we simply disallow <code>#[component(union)]</code> on generic <code>enum</code>s?</p>
</blockquote>



<a name="288043722"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288043722" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288043722">(Jun 30 2022 at 15:16)</a>:</h4>
<p>dicej edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171347987">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>@alexcrichton How would you suggest I handle cases like these?</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">type</span> <span class="nc">Baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>Should we throw an error in the first case or silently de-duplicate the types?  And should we simply disallow <code>#[component(union)]</code> on generic <code>enum</code>s?</p>
</blockquote>



<a name="288043954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288043954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288043954">(Jun 30 2022 at 15:18)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171350413">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Hm I'm not sure I understand, those both look pretty reasonable to me and like they should work. Could you clarify which part you're thinking probably needs an error?</p>
</blockquote>



<a name="288045278"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288045278" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288045278">(Jun 30 2022 at 15:27)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171360741">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I guess I assumed duplicate types (e.g. two <code>f32</code>s) in a union type with no way to distinguish between them would be a problem.  If not, then I guess <code>(union float32 float32)</code> is equivalent to <code>(union float32)</code> and both are equally valid?</p>
</blockquote>



<a name="288045642"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288045642" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288045642">(Jun 30 2022 at 15:29)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171363755">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Ah ok, my impression is that <code>(union float32 float32)</code> is valid in the component model and because it's a tagged discriminant you can distinguish between the two cases, albeit it does seem a bit silly.</p>
</blockquote>



<a name="288046066"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288046066" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288046066">(Jun 30 2022 at 15:32)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171366585">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Okay -- I guess I got thrown off by the fact that the cases aren't named.  Good point about them having separate discriminants, i.e. you can distinguish them based on the order in which they appear.</p>
</blockquote>



<a name="288046899"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288046899" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288046899">(Jun 30 2022 at 15:38)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171373228">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Would it make sense to have a custom syntax for unions, like you suggested for flags?  With flags, only the names need to be specified.  With unions, only the types need to be specified.  Seems kind of awkward to make the programmer choose names that will be ignored anyway.</p>
</blockquote>



<a name="288047597"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288047597" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288047597">(Jun 30 2022 at 15:43)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171378792">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>In general I'm happy to leave it to your discretion. My assumption was that a <code>union</code> in the component model is represented in Rust with an <code>enum</code> one way or another so I figured "may as well let the input have the names" but I don't really mind one way or another.</p>
</blockquote>



<a name="288047599"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288047599" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288047599">(Jun 30 2022 at 15:43)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171378766">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Arguing with myself: the programmer will still use those names in Rust code, so they're not useless.  Nevermind my suggestion above.</p>
</blockquote>



<a name="288047751"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288047751" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288047751">(Jun 30 2022 at 15:44)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171379890">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I found it helpful to think of union cases as still being "named". There's a bit of text in the <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#type-definitions">Type Definitions section of the component model explainer</a> that describes union and enum as syntactic sugar for variants:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">                </span><span class="p">(</span><span class="k">enum</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;+</span><span class="p">)</span><span class="w"> </span><span class="err">↦</span><span class="w"> </span><span class="p">(</span><span class="n">variant</span><span class="w"> </span><span class="p">(</span><span class="n">case</span><span class="w"> </span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unit</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">union</span> <span class="o">&lt;</span><span class="n">valtype</span><span class="o">&gt;+</span><span class="p">)</span><span class="w"> </span><span class="err">↦</span><span class="w"> </span><span class="p">(</span><span class="n">variant</span><span class="w"> </span><span class="p">(</span><span class="n">case</span><span class="w"> </span><span class="s">"𝒊"</span><span class="w"> </span><span class="o">&lt;</span><span class="n">valtype</span><span class="o">&gt;</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">𝒊</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>
<p>So the case names for unions are "0", "1", ...</p>
<p>I've been tempted to suggest that we should expect a union type for any Rust enum where the cases are named <code>_0</code>, <code>_1</code>, ... But that might be too much magic.</p>
</blockquote>



<a name="288048649"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288048649" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288048649">(Jun 30 2022 at 15:50)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171386731">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Thanks for the feedback, @alexcrichton and @jameysharp .  Let's stick with the original plan; being able to specify meaningful names can be nice for use in Rust code, even if they don't get carried over into the component interface.</p>
</blockquote>



<a name="288078994"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288078994" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288078994">(Jun 30 2022 at 19:53)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171616633">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p><a href="https://github.com/bytecodealliance/wasmtime/pull/4359">https://github.com/bytecodealliance/wasmtime/pull/4359</a> adds support for variant, enum, and union types.  I'll follow up with a separate PR for flags, since that will be a different kind of macro.</p>
</blockquote>



<a name="288097685"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288097685" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288097685">(Jun 30 2022 at 22:43)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1171745125">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>This is excellent work, @dicej! <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>
</blockquote>



<a name="288295068"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288295068" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288295068">(Jul 02 2022 at 23:21)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1172977346">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>How should we handle <code>enum</code>s with explicit discriminants?  For example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(enum)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Should we ignore them?  Throw an error?</p>
<p>Similarly, should we pay any attention to e.g. <code>#[repr(u16)]</code> annotations on the target <code>enum</code>?</p>
</blockquote>



<a name="288330866"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288330866" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288330866">(Jul 03 2022 at 14:43)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1173104118">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I think <code>#[repr(u16)]</code> can be ignored. As for discriminants I think those can be ignored as well as only the name matters for the wasm component model. They might be used for interacting with native code through a C abi for example.</p>
</blockquote>



<a name="288331182"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288331182" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288331182">(Jul 03 2022 at 14:50)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1173105310">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<blockquote>
<p>I think <code>#[repr(u16)]</code> can be ignored. As for discriminants I think those can be ignored as well as only the name matters for the wasm component model. They might be used for interacting with native code through a C abi for example.</p>
</blockquote>
<p>Agreed.  I think the guiding principle here is: just because a type is annotated with <code>#[derive(ComponentValue)]</code> doesn't mean that the _only_ purpose of the type is for interop with Wasm components.  It could be used for C interop, among other things.</p>
</blockquote>



<a name="288479901"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288479901" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288479901">(Jul 05 2022 at 05:22)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1174625477">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>My assumption had been that setting an explicit discriminant would be an error. But, I guess we already keep the Canonical ABI used on the wasm side entirely independent of whatever ABI happens to be used on the Rust side. So yes, you've convinced me that neither explicit discriminants nor <code>#[repr]</code> matter for this purpose.</p>
</blockquote>



<a name="288785619"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288785619" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288785619">(Jul 07 2022 at 09:58)</a>:</h4>
<p>tsoutsman <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1177340968">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>How does <code>wit-bindgen</code> fit into this? I'm currently trying to create a <code>wasmtime::component::Component</code> from a wasm component with the following export interface file:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>record pci-device {
    vendor-id: u16,
    device-id: u16,
}

init: func(dev: pci-device)
</code></pre></div>
<p>but have ran into <a href="https://github.com/bytecodealliance/wasmtime/blob/7000b0a4cff1798b8e2fc5316b1be29b9fee2415/crates/environ/src/component/translate.rs#L737">this <code>unimplemented!()</code> statement</a>.</p>
<p>Is the idea that I would have a corresponding struct definition in my Rust i.e.:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(record)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">PciDevice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"vendor-id"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">vendor_id</span>: <span class="kt">u16</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"device-id"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">device_id</span>: <span class="kt">u16</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>That I would use when interacting with the module (e.g. <code>TypedFunc</code> type parameters)?</p>
<p>Also, as a side note, if someone could give me some pointers on implementing "component type export" to remove the <code>unimplemented!()</code> statement, I'd be happy to give it a shot.</p>
</blockquote>



<a name="288785829"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288785829" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288785829">(Jul 07 2022 at 10:00)</a>:</h4>
<p>tsoutsman edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1177340968">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>How does <code>wit-bindgen</code> fit into this? I'm currently trying to create a <code>wasmtime::component::Component</code> from a wasm component with the following export interface file:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>record pci-device {
    vendor-id: u16,
    device-id: u16,
}

init: func(dev: pci-device)
</code></pre></div>
<p>but have ran into <a href="https://github.com/bytecodealliance/wasmtime/blob/7000b0a4cff1798b8e2fc5316b1be29b9fee2415/crates/environ/src/component/translate.rs#L737">this <code>unimplemented!()</code> statement</a>.</p>
<p>The wasm component is a separate Rust crate that uses <code>wit-bindgen</code> and <code>wit-component</code> to implement the <code>init</code> function.</p>
<p>Is the idea that I would have a corresponding struct definition in my Rust i.e.:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(record)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">PciDevice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"vendor-id"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">vendor_id</span>: <span class="kt">u16</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"device-id"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">device_id</span>: <span class="kt">u16</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>That I would use when interacting with the component (e.g. in <code>TypedFunc</code> type parameters)?</p>
<p>Also, as a side note, if someone could give me some pointers on implementing "component type export" to remove the <code>unimplemented!()</code> statement, I'd be happy to give it a shot.</p>
</blockquote>



<a name="288877306"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/288877306" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#288877306">(Jul 07 2022 at 23:04)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1178349357">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>#4414 should be the last PR for this issue :crossed_fingers: </p>
</blockquote>



<a name="289483704"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/289483704" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#289483704">(Jul 13 2022 at 16:18)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1183422726">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I believe this can be closed now that #4414 has been merged.</p>
</blockquote>



<a name="289484953"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/289484953" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#289484953">(Jul 13 2022 at 16:27)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4308#issuecomment-1183431694">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>Indeed, thanks so much @dicej!</p>
</blockquote>



<a name="289484954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234308%20Support%20records%2C%20variants%2C%20enums%2C%20.../near/289484954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234308.20Support.20records.2C.20variants.2C.20enums.2C.20.2E.2E.2E.html#289484954">(Jul 13 2022 at 16:27)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/4308">issue #4308</a>:</p>
<blockquote>
<p>I'm splitting this issue out of <a href="https://github.com/bytecodealliance/wasmtime/issues/4185">https://github.com/bytecodealliance/wasmtime/issues/4185</a> to write up some thoughts on how this can be done. Specifically today the current Wasmtime support for the component model has mappings for many component model types to Rust native types but not all of them. For example integers, strings, lists, tuples, etc, are all mapped directly to Rust types. Basically if the component model types equivalent in Rust is in the Rust standard library that's already implemented. What that leaves to implement, however, is Rust-defined mappings for component model types that are "structural" like records.</p>
<p>This issue is intended to document the current thinking of how we're going to expose this. The general idea is that we'll create a <code>proc-macro</code> crate, probably named something like <code>wasmtime-component-macro</code>, which is an internal dependency of the <code>wasmtime</code> crate. The various macros would then get reexported at the <code>wasmtime::component::*</code> namespace.</p>
<p>Currently the bindings for host types are navigated through three traits: <code>ComponentValue</code>, <code>Lift</code>, and <code>Lower</code>. We'll want a custom derive for all three of these traits. Deriving <code>Lift</code> and <code>Lower</code> require a <code>ComponentValue</code> derive as well, but users should be able to pick one of <code>Lift</code> and <code>Lower</code> without the other one.</p>
<h2><code>record</code></h2>
<p>Records in the component model correspond to <code>struct</code>s in Rust. The rough shape of this will be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(record)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>To typecheck correctly the <code>record</code> type must list fields in the same order as the fields listed in the Rust code for now. Field reordering may be implemented at a later date but for now we'll do strict matching. Fields must have both matching names and matching types.</p>
<p>The <code>#[component(record)]</code> here may seem redundant but it's somewhat required below for variants/enums.</p>
<p>The <code>#[component(name = "...")]</code> is intended to rename the field from the component model's perspective. The type-checking will test against the <code>name</code> specified.</p>
<p>Using this derive on a tuple or empty struct will result in a compile-time error.</p>
<h2><code>variant</code></h2>
<p>Variants roughly correspond to Rust <code>enum</code>s:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(variant)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking, like records, will check cases in-order and all cases must match in both name and payload. A missing payload in Rust is automatically interpreted as the <code>unit</code> payload in the component model.</p>
<p>Variants with named fields (<code>B { bar: u32 }</code>) will be disallowed. Variants with multiple payloads (<code>B(u32, u32)</code>) will also be disallowed.</p>
<p>Note that <code>#[component(variant)]</code> here distinguishes it from...</p>
<h2><code>enum</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(enum)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[component(name = </span><span class="s">"foo-bar-baz"</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Typechecking is similar to variants where the number/names of cases must all match. </p>
<p>Variants with any payload are disallowed in this derive mode.</p>
<h2><code>union</code></h2>
<p>This will, perhaps surprisingly, still map to an <code>enum</code> in Rust since this is still a tagged union, not a literal C <code>union</code>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="p">{</span><span class="n">ComponentValue</span><span class="p">,</span><span class="w"> </span><span class="n">Lift</span><span class="p">,</span><span class="w"> </span><span class="n">Lower</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[derive(ComponentValue, Lift, Lower)]</span><span class="w"></span>
<span class="cp">#[component(union)]</span><span class="w"></span>
<span class="k">enum</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">u32</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">f32</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The number of cases and the types of each case must match a union definition to correctly typecheck. Union cases don't have names so renaming here isn't needed.</p>
<p>A payload on each enum case in Rust is required, and like with <code>variant</code> it's required to be a tuple-variant with only one element. All other forms of payloads are disallowed. Note that the names in Rust are just informative in Rust, it doesn't affect the ABI or type-checking</p>
<h2><code>flags</code></h2>
<p>These will be a bit "funkier" than the above since there's not something obvious to attach a <code>#[derive]</code> to:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">flags</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[derive(Lift, Lower)]</span><span class="w"></span>
<span class="w">    </span><span class="n">flags</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[component(name = </span><span class="s">"..."</span><span class="cp">)]</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">B</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The general idea here is to roughly take inspiration from the <a href="https://crates.io/crates/bitflags"><code>bitflags</code> crate</a> in terms of what the generated code does. Ideally this should have a convenient <code>Debug</code> implementation along with various constants to OR-together and such in Rust. The exact syntax here is up for debate, this is just a strawman.</p>
<h2>Implementation Details</h2>
<p>One caveat is that the <code>ComponentValue</code>/<code>Lift</code>/<code>Lower</code> traits mention internal types in the <code>wasmtime</code> crate which aren't intended to be part of the public API. To solve this the macro will reference items in a path such as:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span>::<span class="n">component</span>::<span class="n">__internal</span>::<span class="n">the_name</span><span class="w"></span>
</code></pre></div>
<p>The <code>__internal</code> module will be <code>#[doc(hidden)]</code> and will only exist to reexport dependencies needed by the proc-macro. This crate may end up having a bland <code>pub use wasmtime_environ</code> or individual items, whatever works best.</p>
<p>The actual generated trait impls will probably look very similar to the implementations that exist for <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1729-L1826">tuples</a>, and <a href="https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1582-L1727"><code>Result&lt;T, E&gt;</code></a> already present in <code>typed.rs</code></p>
<h2>Alternatives</h2>
<p>One alternative to the above is to have <code>#[derive(ComponentRecord)]</code> instead of <code>#[derive(ComponentValue)] #[component(record)]</code> or something like that. While historically some discussions have leaned in this direction with the introduction of <code>Lift</code> and <code>Lower</code> traits I personally feel that the balance is now slightly in the other direction where it would be nice if we can keep <code>derive</code> targeted at the specific traits and then configuration for the derive happens afterwards.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>