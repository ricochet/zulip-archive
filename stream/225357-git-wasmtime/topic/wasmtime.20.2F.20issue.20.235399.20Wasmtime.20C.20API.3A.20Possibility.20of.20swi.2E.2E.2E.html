<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5399 Wasmtime C API: Possibility of swi... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html">wasmtime / issue #5399 Wasmtime C API: Possibility of swi...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="314724235"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314724235" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314724235">(Dec 08 2022 at 17:16)</a>:</h4>
<p>kpreisser opened <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <code>Environment.FailFast()</code>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/187">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>
</blockquote>



<a name="314724705"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314724705" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314724705">(Dec 08 2022 at 17:19)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/187">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>
</blockquote>



<a name="314724788"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314724788" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314724788">(Dec 08 2022 at 17:19)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/187">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>
</blockquote>



<a name="314724864"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314724864" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314724864">(Dec 08 2022 at 17:19)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/187">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>
</blockquote>



<a name="314725058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314725058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314725058">(Dec 08 2022 at 17:20)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/187">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>
</blockquote>



<a name="314725191"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314725191" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314725191">(Dec 08 2022 at 17:21)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343050650">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Using <code>panic=abort</code> for the C api is not enough. You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern "C"</code> is UB. In the future unwinding out from an <code>extern "C"</code> rust function will abort independent of the panic mode, but unwinding into rust from a function declared as <code>extern "C"</code> is still UB.</p>
</blockquote>



<a name="314726795"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314726795" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314726795">(Dec 08 2022 at 17:28)</a>:</h4>
<p>kpreisser <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343059110">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi  @bjorn3, thanks for your reply!</p>
<blockquote>
<p>You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern "C"</code> is UB.</p>
</blockquote>
<p>If I understand you correctly, that should already be the case in <code>wasmtime-dotnet</code>, as it uses a <code>catch (Exception ex)</code> clause at wasmtime callbacks (e.g. defined with <code>wasmtime_func_new</code> or <code>wasmtime_func_new_unchecked</code>), to ensure no unwinding can happen beyond the native-to-managed transition (see the referenced issue in the footnote for an example where this still happend previously but was fixed).</p>
<p>Thanks!</p>
</blockquote>



<a name="314728595"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314728595" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314728595">(Dec 08 2022 at 17:37)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>
<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/187">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>
</blockquote>



<a name="314739687"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314739687" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314739687">(Dec 08 2022 at 18:15)</a>:</h4>
<p>kpreisser edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343059110">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi  @bjorn3, thanks for your reply!</p>
<blockquote>
<p>You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern "C"</code> is UB.</p>
</blockquote>
<p>If I understand you correctly, that should already be the case in <code>wasmtime-dotnet</code>, as it uses a <code>catch (Exception ex)</code> clause at wasmtime callbacks (e.g. defined with <code>wasmtime_func_new</code> or <code>wasmtime_func_new_unchecked</code>), to ensure no unwinding can happen beyond the native-to-managed transition (see the referenced issue in the footnote for an example where this still happend previously but has been fixed).</p>
<p>Thanks!</p>
</blockquote>



<a name="314751447"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314751447" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314751447">(Dec 08 2022 at 19:14)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343220252">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>I agree that changing to <code>panic=abort</code> is the best solution here. This will get a bit tricky with CI since it will require a lot of new artifacts to be built (can't share <code>panic=abort</code> and <code>panic=unwind</code>), but otherwise should be easy enough to configure at least.</p>
</blockquote>



<a name="314755055"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314755055" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314755055">(Dec 08 2022 at 19:32)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> if user code actually doesn't intend to catch <code>SEHException</code>: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]<br>
Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/187">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>
</blockquote>



<a name="314755098"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/314755098" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#314755098">(Dec 08 2022 at 19:32)</a>:</h4>
<p>kpreisser edited <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Hi!</p>
<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
<p>In <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/192">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception"><code>RaiseException</code></a> or <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>
<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>
<p>This can even happen in <code>wasmtime-dotnet</code> if user code actually doesn't intend to catch <code>SEHException</code>:<br>
When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]<br>
Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href="https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>
So even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>
<p>On Windows there is an alternative function <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)"><code>Environment.FailFast()</code></a>).<br>
From Rust PR <a href="https://github.com/rust-lang/rust/issues/32900">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>
<p>Quoting @peterhuene from <a href="https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>
<blockquote>
<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>
</blockquote>
<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>
(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>
<p>Thank you!</p>
<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/187">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>
</blockquote>



<a name="318031284"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/318031284" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#318031284">(Dec 27 2022 at 03:46)</a>:</h4>
<p>Muon <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1365587677">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<blockquote>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
</blockquote>
<p>To my understanding, this is not the case. A panic is a sign that whatever you tried to do was incorrect, and that logical invariants may not be upheld any more. However, <code>catch_unwind()</code> is not <code>unsafe</code>. Therefore, if you panic, it's your responsibility to ensure that UB cannot happen if the panic is caught and execution continues.</p>
</blockquote>



<a name="318031297"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/318031297" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#318031297">(Dec 27 2022 at 03:46)</a>:</h4>
<p>Muon edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1365587677">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<blockquote>
<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>
</blockquote>
<p>To my understanding, this is not the case. A panic is a sign that whatever you tried to do was incorrect, and that logical invariants may not be upheld any more. However, <code>catch_unwind()</code> is not <code>unsafe</code>. Therefore, if you panic in a safe function, it's your responsibility to ensure that UB cannot happen if the panic is caught and execution continues.</p>
</blockquote>



<a name="390973140"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/390973140" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#390973140">(Sep 14 2023 at 15:59)</a>:</h4>
<p>rockwotj <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">thread</span><span class="w"> </span><span class="o">'&lt;</span><span class="n">unnamed</span><span class="o">&gt;'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>: <span class="nc">failed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Caused</span><span class="w"> </span><span class="n">by</span>:
<span class="nc">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>:     <span class="nc">Cannot</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">(</span><span class="n">os</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">crates</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">code_memory</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">254</span>:<span class="mi">18</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">note</span>: <span class="nc">run</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">backtrace</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">fatal</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="n">error</span>: <span class="nc">Rust</span><span class="w"> </span><span class="n">panics</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">rethrown</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Aborting</span><span class="p">.</span>
</code></pre></div>
<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? <a href="https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41</a></p>
</blockquote>



<a name="390973223"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/390973223" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#390973223">(Sep 14 2023 at 15:59)</a>:</h4>
<p>rockwotj edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">thread</span><span class="w"> </span><span class="o">'&lt;</span><span class="n">unnamed</span><span class="o">&gt;'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>: <span class="nc">failed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Caused</span><span class="w"> </span><span class="n">by</span>:
<span class="nc">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>:     <span class="nc">Cannot</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">(</span><span class="n">os</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">crates</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">code_memory</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">254</span>:<span class="mi">18</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">note</span>: <span class="nc">run</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">backtrace</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">fatal</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="n">error</span>: <span class="nc">Rust</span><span class="w"> </span><span class="n">panics</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">rethrown</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Aborting</span><span class="p">.</span>
</code></pre></div>
<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? </p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41</a></p>
</blockquote>



<a name="390973296"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/390973296" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#390973296">(Sep 14 2023 at 16:00)</a>:</h4>
<p>rockwotj edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">thread</span><span class="w"> </span><span class="o">'&lt;</span><span class="n">unnamed</span><span class="o">&gt;'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>: <span class="nc">failed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">executable</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Caused</span><span class="w"> </span><span class="n">by</span>:
<span class="nc">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>:     <span class="nc">Cannot</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">(</span><span class="n">os</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">crates</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">code_memory</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">254</span>:<span class="mi">18</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">note</span>: <span class="nc">run</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">backtrace</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">fatal</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="n">error</span>: <span class="nc">Rust</span><span class="w"> </span><span class="n">panics</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">rethrown</span>
<span class="n">Sep</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">14</span>:<span class="mi">49</span>:<span class="mi">23</span><span class="w"> </span><span class="n">rp</span><span class="o">-</span><span class="n">node</span><span class="o">-</span><span class="mi">0</span><span class="o">-</span><span class="n">overly</span><span class="o">-</span><span class="n">top</span><span class="o">-</span><span class="n">warthog</span><span class="w"> </span><span class="n">rpk</span><span class="p">[</span><span class="mi">21379</span><span class="p">]</span>: <span class="nc">Aborting</span><span class="p">.</span>
</code></pre></div>
<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? </p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32-L40">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32-L40</a></p>
</blockquote>



<a name="390978550"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235399%20Wasmtime%20C%20API%3A%20Possibility%20of%20swi.../near/390978550" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235399.20Wasmtime.20C.20API.3A.20Possibility.20of.20swi.2E.2E.2E.html#390978550">(Sep 14 2023 at 16:28)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719774028">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5399">issue #5399</a>:</p>
<blockquote>
<p>Ah for that case specifically the panic is <a href="https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/jit/src/code_memory.rs#L254">this call to <code>.expect</code></a> and that's not something you should be catching in the C API but is instead an error which should be bubbled up. If you'd like sending a PR there to use <code>?</code> to bubble up the error I believe would fix that issue (as it'd be returned through the error returned by <code>wasm_module_new</code>)</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>