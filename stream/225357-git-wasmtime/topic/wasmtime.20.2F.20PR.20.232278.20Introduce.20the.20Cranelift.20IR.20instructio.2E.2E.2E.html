<html>
<head><meta charset="utf-8"><title>wasmtime / PR #2278 Introduce the Cranelift IR instructio... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html">wasmtime / PR #2278 Introduce the Cranelift IR instructio...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="212607449"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/212607449" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#212607449">(Oct 07 2020 at 19:26)</a>:</h4>
<p>akirilov-arm opened <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="212608755"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/212608755" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#212608755">(Oct 07 2020 at 19:36)</a>:</h4>
<p>abrown submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2278#pullrequestreview-504205742">PR Review</a>.</p>



<a name="212610168"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/212610168" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#212610168">(Oct 07 2020 at 19:48)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2278#pullrequestreview-504213758">PR Review</a>.</p>



<a name="212820654"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/212820654" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#212820654">(Oct 09 2020 at 12:50)</a>:</h4>
<p>akirilov-arm updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="213187239"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/213187239" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#213187239">(Oct 13 2020 at 17:10)</a>:</h4>
<p>abrown updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="213193274"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/213193274" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#213193274">(Oct 13 2020 at 17:58)</a>:</h4>
<p>akirilov-arm updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="213278590"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/213278590" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#213278590">(Oct 14 2020 at 12:09)</a>:</h4>
<p>akirilov-arm updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="213318368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/213318368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#213318368">(Oct 14 2020 at 16:43)</a>:</h4>
<p>abrown updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a> from <code>load_splat</code> to <code>main</code>:</p>
<blockquote>
<p>It corresponds to WebAssembly's <code>load*_splat</code> operations, which were previously represented as a combination of <code>Load</code> and <code>Splat</code> instructions. However, there are architectures such as Armv8-A that have a single machine instruction equivalent to the Wasm operations. In order to generate it, it is necessary to merge the <code>Load</code> and the <code>Splat</code> in the backend, which is not possible because the load may have side effects. The new IR instruction works around this limitation.</p>
<p>The AArch64 backend leverages the new instruction to improve code generation. I am not really qualified to implement the optimization for x86, so I have added a temporary work-around to avoid any test breakage. It's a bit of a hack, but it should be incorrect only when cross-compiling to x86 on an Arm platform.</p>
<p>Fixes #1175 (but other backends need work too).</p>
<p>cc @abrown @cfallin</p>
</blockquote>



<a name="214888810"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/214888810" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#214888810">(Oct 28 2020 at 19:52)</a>:</h4>
<p>cfallin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2278#pullrequestreview-519030474">PR Review</a>.</p>



<a name="214889059"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232278%20Introduce%20the%20Cranelift%20IR%20instructio.../near/214889059" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232278.20Introduce.20the.20Cranelift.20IR.20instructio.2E.2E.2E.html#214889059">(Oct 28 2020 at 19:54)</a>:</h4>
<p>cfallin merged <a href="https://github.com/bytecodealliance/wasmtime/pull/2278">PR #2278</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>