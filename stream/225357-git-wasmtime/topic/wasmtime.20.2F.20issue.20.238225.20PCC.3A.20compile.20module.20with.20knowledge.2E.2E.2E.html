<html>
<head><meta charset="utf-8"><title>wasmtime / issue #8225 PCC: compile module with knowledge... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html">wasmtime / issue #8225 PCC: compile module with knowledge...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="428413852"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/428413852" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#428413852">(Mar 22 2024 at 21:45)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>A fuzzbug recently came in (<a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=67568">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=67568</a>) that has a load with a very large (~3GiB) offset. With our bounds-checking code and default setting of a 2GiB guard region, we handle this today with a dynamic bounds-check. PCC currently cannot handle dynamic bounds-checks. So if we want to (i) deploy PCC in our default configuration, and (ii) correctly handle all legal Wasm inputs, we need to find a way to check such instructions.</p>
<p>It occurs to me that if our guard region is large enough, any load/store with an offset larger than the guard region will also have a minimum address that is larger than the biggest possible memory in most "reasonable" production configurations. If we can guarantee that, and compile with that assumption, we can statically compile a <code>i32.load offset=9bazillion</code> instruction into a trap (with a <code>HeapOutOfBounds</code> trap code so it is semantically unchanged to observers). This would allow PCC to check the result as well.</p>
<p>I'd like to file the issue first to get opinions: would it be reasonable to have a <code>maximum_memory_size</code> configuration option that bounds <em>all</em> memories, such that it is an error to grow larger than that, and then use this during compilation to handle the above case? And then set it so that it is at (or ever so slightly smaller than, by the maximum load/store width) the default guard-region size, so we get the nice property that our default configuration never generates dynamic bounds checks?</p>
</blockquote>



<a name="428414375"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/428414375" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#428414375">(Mar 22 2024 at 21:50)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2015985501">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>Here's a minimal <code>tests/disas/</code> testcase for reference:</p>
<p>&lt;details&gt;<br>
&lt;summary&gt;compile test&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Common Lisp"><pre><span></span><code><span class="c1">;;! target = "x86_64"</span>
<span class="c1">;;! test = "compile"</span>
<span class="c1">;;! flags = [ "-Cpcc=y" ]</span>

<span class="p">(</span><span class="nv">module</span>
<span class="w">  </span><span class="p">(</span><span class="nv">func</span><span class="w"> </span><span class="p">(</span><span class="nv">result</span><span class="w"> </span><span class="nv">i32</span><span class="p">)</span>
<span class="w">    </span><span class="nv">i32.const</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nv">i32.load</span><span class="w"> </span><span class="nv">offset=3876003872</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">memory</span><span class="w"> </span><span class="p">(</span><span class="c1">;0;) 8164 8167))</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
</blockquote>



<a name="429228886"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429228886" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429228886">(Mar 24 2024 at 17:19)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2016877027">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<blockquote>
<p>It occurs to me that if our guard region is large enough, any load/store with an offset larger than the guard region will also have a minimum address that is larger than the biggest possible memory in most "reasonable" production configurations</p>
</blockquote>
<p>This isn't quite true in that wasm memory loads create an effective 33-bit address meaning that with a 4G guard region we statically know everything will hit a guard page and no dynamic bounds checks regardless of the offset are needed. </p>
<p>Notably you can't use an offset larger than the memory size, that's a validation error (IIRC). </p>
<blockquote>
<p>we can statically compile a i32.load offset=9bazillion instruction into a trap (with a HeapOutOfBounds trap code so it is semantically unchanged to observers). This would allow PCC to check the result as well.</p>
</blockquote>
<p>I'll note that I believe this already happens.</p>
<blockquote>
<p>so we get the nice property that our default configuration never generates dynamic bounds checks?</p>
</blockquote>
<p>I think that makes sense yeah. The pooling allocator actually already has this configuration but that's purely runtime configuration, it's not compile-time configuration, and this would be a compile-time-config option (that then must be matched at runtime as well)</p>
</blockquote>



<a name="429243828"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429243828" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429243828">(Mar 24 2024 at 20:23)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2016932776">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<blockquote>
<p>4G guard region</p>
</blockquote>
<p>Ah, the default is a 2GiB guard region (post, and separately 2GiB pre); that's what I'm assuming we need to find a workable PCC configuration for, in order not to impact virtual memory overhead.</p>
<blockquote>
<p>I'll note that I believe this already happens.</p>
</blockquote>
<p>@alexcrichton please see the test case above, where it doesn't, for a default wasmtime config (2GiB guard region) -- is there some other setting we need to enforce to get this property? In particular I note <a href="https://github.com/bytecodealliance/wasmtime/blob/8052bb9e3b792503b225f2a5b2ba3bc023bff462/cranelift/wasm/src/code_translator/bounds_checks.rs#L377-L387">this case</a> in the seven bounds-check cases, which triggers for static memories where the guard is otherwise not large enough. There is the <a href="https://github.com/bytecodealliance/wasmtime/blob/8052bb9e3b792503b225f2a5b2ba3bc023bff462/cranelift/wasm/src/code_translator/bounds_checks.rs#L308-L319">case here</a> that statically becomes a trap, but that's only if the offset and size exceed the <em>memory size</em> bound, and that bound needs to be 4GiB to elide bounds checks otherwise; so a 3GiB offset doesn't fit. That's precisely the gap I want to reify here: a separate "actual maximum size" configuration that is distinct from "virtual memory size".</p>
</blockquote>



<a name="429244742"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429244742" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429244742">(Mar 24 2024 at 20:34)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2016935113">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<blockquote>
<p>Notably you can't use an offset larger than the memory size, that's a validation error (IIRC).</p>
</blockquote>
<p>This also seems not to be true, per the test case above: its max memory size is 8167 pages (a little under 512MiB) yet it has an offset of ~3GiB. Regardless, we aren't rejecting modules at compile time that have a max memory size somehow incompatible with our memory config, so we can't rely on that here.</p>
</blockquote>



<a name="429427957"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429427957" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429427957">(Mar 25 2024 at 14:54)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2018191351">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>Ah yes sorry forgot to mention Wasmtime's default is 2G. I can confirm that with <code>-O static-memory-guard-size=$((1&lt;&lt;32))</code> the above test case works as-is today. I can also confirm that if the above offset is changed to <code>$((1&lt;&lt;32)) - 4</code> then it still works, but offsets larger than that actually work with the default 2G region. </p>
<p>I think I was confusing a different optimization we have where when access size + offset is &gt;4G we compile a static trap, but you're right that the maximum size of memory isn't taken into account. That's something we should add! Not that it would "truly" fix this test case though since most memories don't have an upper bound in the real world.</p>
<p>Also sorry for "larger than memory size" I should have clarified I meant the indexing type. The index type here is a 32-bit integer so the offset <code>1&lt;&lt;32</code> is rejected by wasm validation. My point being that for 32-bit linear memories we statically know all linear memory offsets are less than <code>1&lt;&lt;32</code>, so we are guaranteed that everything is a 33-bit address and no more.</p>
<p>Thinking a bit more on this, I think we could perhaps do two different things:</p>
<ul>
<li>With PCC recommend a 4G guard region. Whether or not that's suitable for virtual memory overheads I think will be situation-specific. For example with mpk there's no issue as you could probably still get more instances today than already. Additionally the 2G guard region today is somewhat arbitrarily the maximum signed distance to go, but there's no reason (pending bugs) that we couldn't switch the default to a 1G or 512M guard region which would already be a significant improvement over today. Mostly I don't think 4G guards should be immediately discarded, but instead weigh the cost with other factors.</li>
<li>I don't really know PCC at all, but is it possible to codegen a different pattern for bounds-checked offsets? For example with a 2G guard region the risk is that the access lies outside the guard region, but we could perform manual arithmetic with a manual trap if the access is &gt;=6G and then perform a normal trapping load if it's &lt;= 6G. I'd hope that in this situation it'd look to PCC like the address was a normal load, but I don't know enough about PCC to know if this is possible.</li>
</ul>
</blockquote>



<a name="429702131"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429702131" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429702131">(Mar 26 2024 at 17:10)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021013021">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>I'm trying to follow along and I have a lot of questions.</p>
<p>First off, how do I tell which heap settings Wasmtime actually picked?</p>
<p>With default flags, it's producing this CLIF for your test case:</p>
<p>&lt;details&gt;&lt;summary&gt;Unoptimized CLIF for the above disas test case&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">u0</span>:<span class="mi">0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="n">vmctx</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="nc">fast</span><span class="w"> </span><span class="p">{</span>
<span class="p">;;</span><span class="w">     </span><span class="n">gv0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmctx</span>
<span class="p">;;</span><span class="w">     </span><span class="n">gv1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">gv0</span><span class="o">+</span><span class="mi">8</span>
<span class="p">;;</span><span class="w">     </span><span class="n">gv2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">gv1</span>
<span class="p">;;</span><span class="w">     </span><span class="n">gv3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vmctx</span>
<span class="p">;;</span><span class="w">     </span><span class="n">gv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">checked</span><span class="w"> </span><span class="n">gv3</span><span class="o">+</span><span class="mi">80</span>
<span class="p">;;</span><span class="w">     </span><span class="n">stack_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gv2</span>
<span class="p">;;</span>
<span class="p">;;</span><span class="w">                                 </span><span class="n">block0</span><span class="p">(</span><span class="n">v0</span>: <span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span>: <span class="kt">i64</span><span class="p">)</span>:
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0020</span><span class="w">                               </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">0</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uextend</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">v3</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mh">0x18f8_dfdc</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="n">ugt</span><span class="w"> </span><span class="n">v4</span><span class="p">,</span><span class="w"> </span><span class="n">v5</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x18f8_dfdc</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_value</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">gv4</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v7</span><span class="p">,</span><span class="w"> </span><span class="n">v4</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mh">0xe707_2020</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v8</span><span class="p">,</span><span class="w"> </span><span class="n">v9</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xe707_2020</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mi">0</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">select_spectre_guard</span><span class="w"> </span><span class="n">v6</span><span class="p">,</span><span class="w"> </span><span class="n">v11</span><span class="p">,</span><span class="w"> </span><span class="n">v10</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">v12</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0029</span><span class="w">                               </span><span class="n">jump</span><span class="w"> </span><span class="n">block1</span><span class="p">(</span><span class="n">v13</span><span class="p">)</span>
<span class="p">;;</span>
<span class="p">;;</span><span class="w">                                 </span><span class="n">block1</span><span class="p">(</span><span class="n">v2</span>: <span class="kt">i32</span><span class="p">)</span>:
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0029</span><span class="w">                               </span><span class="k">return</span><span class="w"> </span><span class="n">v2</span>
<span class="p">;;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>It's checking the index (a constant 0) against 4GB minus the offset and access width. So is this case "3. General case for static memories" with bound=4GB? And this means we're allocating 4GB of virtual memory and leaving the out-of-bounds parts unmapped?</p>
<p>Wasmtime won't generate even unoptimized CLIF for this with <code>-Cpcc=y</code> so I guess the problem is there was some instruction in the unoptimized version that we can't generate a fact for; what was it?</p>
<p>After optimization, the bounds-check constant-folds away:</p>
<p>&lt;details&gt;&lt;summary&gt;Optimized CLIF&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="n">notrap</span><span class="w"> </span><span class="n">aligned</span><span class="w"> </span><span class="n">readonly</span><span class="w"> </span><span class="n">checked</span><span class="w"> </span><span class="n">v0</span><span class="o">+</span><span class="mi">80</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i64</span><span class="w"> </span><span class="mh">0xe707_2020</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iadd</span><span class="w"> </span><span class="n">v7</span><span class="p">,</span><span class="w"> </span><span class="n">v9</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">v9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xe707_2020</span>
<span class="p">;;</span><span class="w"> </span><span class="o">@</span><span class="mi">0022</span><span class="w">                               </span><span class="n">v13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="n">little</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">v10</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>This seems like it should be easy to verify: it's an add of a constant &lt;4GB to a pointer which I gather should be valid up to 4GB. Perhaps it would be a better test case if the index were an i32 parameter, since I assume your concern is for PCC's ability to verify the general case.</p>
<p>If I add the <code>-Ostatic-memory-maximum-size=535232512</code> flag, then the same example compiles to an unconditional trap. (That number is 8167 pages, the maximum bound of the memory's limits.) So is that the flag that you wanted, Chris?</p>
</blockquote>



<a name="429709789"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429709789" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429709789">(Mar 26 2024 at 17:53)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021118045">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>Ah I think now that heap settings moved out of CLIF you'd need to consult <a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/environ/src/tunables.rs">tunables</a> and cross-reference that with flags passed to Wasmtime. (where tunables mostly match <code>Config</code> names but not always)</p>
<p>By default static memories have a max size of 4G (exactly 1&lt;&lt;32) and a 2G guard region (1&lt;&lt;31).</p>
<blockquote>
<p>And this means we're allocating 4GB of virtual memory and leaving the out-of-bounds parts unmapped?</p>
</blockquote>
<p>Mostly correct yeah. The code generator assumes that 4G (the static memory bound) + 2G (guard region) is allocated and the only mapped pages are those actually in. use by the heap. </p>
<p>I also sort of forget exactly what the static_memory_bound variable is. It selects dynamic/static but I think you're also seeing an interaction that I forgot about (and I suspect at this point you could probably explain it to me as well!)</p>
</blockquote>



<a name="429710934"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429710934" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429710934">(Mar 26 2024 at 17:59)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021133878">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>@jameysharp ah, sure, it was a trivial testcase that was not optimization-proof, but replace the <code>i32.const 0</code> with a <code>local.get</code> if you like -- the interesting bit is that with a large-enough load offset, we still get a dynamic bounds check, even with a nominally static memory. (Sorry for the confusion!) The bit that is not PCC-able is exactly the dynamic bounds check -- the symbolic reasoning to match up the compare to the select breaks when opts merge more than one access together. The point of the testcase is not exactly literally to trigger a PCC failure but to show that we can still get dynamic bounds checks here.</p>
</blockquote>



<a name="429727324"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429727324" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429727324">(Mar 26 2024 at 19:44)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021327729">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<blockquote>
<p>I also sort of forget exactly what the static_memory_bound variable is. It selects dynamic/static but I think you're also seeing an interaction that I forgot about (and I suspect at this point you could probably explain it to me as well!)</p>
</blockquote>
<p>Reading enough of the implementation to explain this may help me understand what Chris is asking for, so here goes.</p>
<p><code>Tunables::static_memory_bound</code> is both:</p>
<ul>
<li>the maximum number of 64kB pages that a memory can use while still using the static memory heap style,</li>
<li>and the amount of virtual address space that the runtime will reserve (before guard pages) for static memories.</li>
</ul>
<p>If at compile time we know that a static memory style was selected, and the constant offset plus access width given in the memory access is greater than the static memory bound in bytes, then it doesn't matter what index we add to that offset: The result will always be greater than the current size of the memory—which must be no bigger than the static memory bound—and so the access should always trap.</p>
<p>Chris, what you want is 4GB of guard pages and a static memory bound of reasonable size. For example if an embedder doesn't allow more than 128MB of linear memory, the static memory bound should be set to 128MB, or 2048 pages. The static memory bound will turn overly-large offsets into traps, and for smaller offsets, the 4GB of guard pages will ensure that any <code>i32</code> index doesn't need a bounds-check.</p>
<p>We could also just trap when the offset is too large for any memory which is declared with a maximum limit, whether it's static or dynamic. If the static memory bound is used as an implied maximum limit when the module doesn't declare one, then that would remove the need for the current "case 1" for static memories. However that doesn't change that we need 4GB of guard pages to avoid bounds-checks when the offset is smaller.</p>
<blockquote>
<p>The bit that is not PCC-able is exactly the dynamic bounds check -- the symbolic reasoning to match up the compare to the select breaks when opts merge more than one access together.</p>
</blockquote>
<p>I'd still like to understand this better. This error is being reported before any optimization pass runs, so optimizations merging accesses isn't the direct cause, right? Is it that you need a new kind of fact which you then can't define a merge operation for? Which specific instruction do you need this fact for? Is it the <code>select_spectre_guard</code> which could produce either a known-valid pointer or a known-inaccessible one?</p>
</blockquote>



<a name="429729925"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429729925" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429729925">(Mar 26 2024 at 20:00)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021355805">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<blockquote>
<p>I'd still like to understand this better. This error is being reported before any optimization pass runs, so optimizations merging accesses isn't the direct cause, right? Is it that you need a new kind of fact which you then can't define a merge operation for? Which specific instruction do you need this fact for? Is it the select_spectre_guard which could produce either a known-valid pointer or a known-inaccessible one?</p>
</blockquote>
<p>Yes, but again, we're a few steps removed from the actual issue in this test case. The point of the test case is to show that dynamic bounds checks still occur; it says nothing about PCC, is not designed to be tested with PCC, has never even heard of PCC, etc etc.</p>
<p>The underlying cause for all of this is that, yes, when optimizations run, multiple dynamic checks get merged together (the same base address is used for multiple accesses because of GVN, and the facts merge), and when symbolic facts merge, we either need to merge symbolic worlds (unscalable) or a consistent merging strategy; and separately, sometimes optimizations around constant addresses are smart and there's no stable <em>thing</em> with an identity to hang the comparison reasoning off if, because constants get absorbed directly into instructions or folded away.</p>
<p>I haven't shown any test case that demonstrates <em>that</em>, because it's deep in fuzzbugs and I really don't have the bandwidth to write it up properly (sorry). You're of course welcome to dig into it; the <code>pcc_memory</code> integration test will trigger the issue if you enable bounds-checking configurations. But it's a deep research question and IMHO the right course is to save it for later (and I will not be able to help further right now).</p>
<p>The point of all this is that we think we can do PCC if we only have implicit (virtual memory)-based bounds checking. So I pushed a recursion level and instantiated a subproblem: let's create a mode where codegen <em>never</em> does explicit bounds checks. Then we don't have to worry about the above. That's this specific issue, and the test case above demonstrates <em>that</em>: we still get dynamic bounds checks even in the default configuration (and even under opts if you replace my silly const-0 with an arg input). Does that make sense?</p>
</blockquote>



<a name="429731571"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429731571" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429731571">(Mar 26 2024 at 20:11)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021376201">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>Okay, that makes sense.</p>
<p>Does my suggested configuration sound reasonable to you? I don't think we need any new configuration options to do what you want. Just set <code>-Ostatic-memory-maximum-size</code> to e.g. 128MB and <code>-Ostatic-memory-guard-size</code> to 4GB. Then I believe you'll never get bounds checks.</p>
</blockquote>



<a name="429732454"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429732454" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429732454">(Mar 26 2024 at 20:17)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/8225#issuecomment-2021385443">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>I think so actually -- thanks for digging into this! If I understand right, one way to see it is that we've been "holding it wrong" wrt the two knobs and how they divide the total space: if the embedder has a reasonable per-instance limit significantly below 4GiB then most of the address space should be within the guard, not the possibly-available static memory region.</p>
<p>I think that's sufficient to close the issue actually; when I pick PCC back up I'll plan to fuzz under such a configuration.</p>
</blockquote>



<a name="429732459"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%238225%20PCC%3A%20compile%20module%20with%20knowledge.../near/429732459" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.238225.20PCC.3A.20compile.20module.20with.20knowledge.2E.2E.2E.html#429732459">(Mar 26 2024 at 20:17)</a>:</h4>
<p>cfallin closed <a href="https://github.com/bytecodealliance/wasmtime/issues/8225">issue #8225</a>:</p>
<blockquote>
<p>A fuzzbug recently came in (<a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=67568">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=67568</a>) that has a load with a very large (~3GiB) offset. With our bounds-checking code and default setting of a 2GiB guard region, we handle this today with a dynamic bounds-check. PCC currently cannot handle dynamic bounds-checks. So if we want to (i) deploy PCC in our default configuration, and (ii) correctly handle all legal Wasm inputs, we need to find a way to check such instructions.</p>
<p>It occurs to me that if our guard region is large enough, any load/store with an offset larger than the guard region will also have a minimum address that is larger than the biggest possible memory in most "reasonable" production configurations. If we can guarantee that, and compile with that assumption, we can statically compile a <code>i32.load offset=9bazillion</code> instruction into a trap (with a <code>HeapOutOfBounds</code> trap code so it is semantically unchanged to observers). This would allow PCC to check the result as well.</p>
<p>I'd like to file the issue first to get opinions: would it be reasonable to have a <code>maximum_memory_size</code> configuration option that bounds <em>all</em> memories, such that it is an error to grow larger than that, and then use this during compilation to handle the above case? And then set it so that it is at (or ever so slightly smaller than, by the maximum load/store width) the default guard-region size, so we get the nice property that our default configuration never generates dynamic bounds checks?</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>