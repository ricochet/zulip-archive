<html>
<head><meta charset="utf-8"><title>wasmtime / issue #3205 Cranelift: formalize, document, an... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html">wasmtime / issue #3205 Cranelift: formalize, document, an...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="249880144"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249880144" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249880144">(Aug 18 2021 at 17:03)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>In #3202 and a number of past issues as well, we've repeatedly encountered some uncertainty as to (i) how boolean values of varying widths are stored in registers, (ii) whether they can be loaded/stored or not and what representation they take in memory (see e.g. #3102 where we addressed this for trampoline args), and (iii) how this interacts with boolean&lt;-&gt;integer conversion ops like <code>bint</code> and <code>bmask</code>.</p>
<p>The understanding we seem to generally agree on is that booleans of width &gt; 1 bit have all bits set (true) or all bits cleared (false). And a <code>b1</code> is stored in a register with the same invariant as other integer values: the upper bits (in this case everything above the LSB) are undefined.</p>
<p>However, this is far from being confusion-free and unambiguous; thus, it seems reasonable to (i) agree definitively on how bools are represented in registers and memory, and (ii) audit our compliance to whatever invariants we decide on.</p>
</blockquote>



<a name="249880209"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249880209" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249880209">(Aug 18 2021 at 17:03)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>In #3202 and a number of past issues as well, we've repeatedly encountered some uncertainty as to (i) how boolean values of varying widths are stored in registers, (ii) whether they can be loaded/stored or not and what representation they take in memory (see e.g. #3102 where we addressed this for trampoline args), and (iii) how this interacts with boolean&lt;-&gt;integer conversion ops like <code>bint</code> and <code>bmask</code>.</p>
<p>The understanding we seem to generally agree on is that booleans of width &gt; 1 bit have all bits set (true) or all bits cleared (false). And a <code>b1</code> is stored in a register with the same invariant as other integer values: the upper bits (in this case everything above the LSB) are undefined.</p>
<p>However, this is far from being confusion-free and unambiguous; thus, it seems reasonable to (i) agree definitively on how bools are represented in registers and memory, and (ii) audit our compliance to whatever invariants we decide on.</p>
</blockquote>



<a name="249880345"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249880345" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249880345">(Aug 18 2021 at 17:04)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901279568">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>cc @abrown @afonso360 @bjorn3 @alexcrichton @akirilov-arm for recent folks who've discussed this topic.</p>
</blockquote>



<a name="249882982"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249882982" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249882982">(Aug 18 2021 at 17:22)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901292428">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I'd like to propose the following for loads and stores:</p>
<ul>
<li>Define loads and stores of boolean values. We haven't done this in the past, but it is a somewhat incongruous hole in our semantics, IMHO, and we <em>do</em> load and store booleans sometimes behind the scenes (see: trampoline args). I think it would be better if we formally say what it means to do so.</li>
<li>Let's define the size of a <code>b1</code> to be one byte, and others (<code>b8</code> and up) as the size of the equivalent integer type.</li>
<li>A store of a <code>b1</code> stores 0 or 1 (i.e., it is zero-extended to 8 bits); a store of a <code>b8</code>..<code>b128</code> stores all zeroes or all ones.</li>
<li>A load of a boolean type has undefined behavior if the value loaded from memory is not canonical as per the above bullet point.</li>
</ul>
<p>The last is probably the most controversial; disallowing loads and stores of bools avoids the semantic question, which may have been why this was done (@sunfishcode comments?). But we already allow bitcasts, so we already have some notion of the bits underlying a bool, so IMHO it's better to allow loading/storing those bits.</p>
<p>An alternative is to canonicalize a boolean when loading. For a <code>b1</code> this is a mask (<code>and</code> op); for a <code>b8</code> and up we could just compare to zero and if the loaded value is nonzero (any bit is set), canonicalize to <code>true</code> (all bits set). I actually prefer this option, after a bit of thought: it gives well-defined semantics and avoids illegal bool values (e.g. <code>b128</code> with half the bits set) that might cause other undefined behavior.</p>
<p>Then for bitcasts:</p>
<ul>
<li>A raw_bitcast or bitcast from a bool to an int produces the same value that a store would produce.</li>
<li>A raw_bitcast or bitcast from an int to a bool canonicalizes just as a load does.</li>
</ul>
<p>All of the above should fully pin down how we store the values in registers as well: we (i) have a well-defined integer interpretation of the bool, (ii) always store it in canonicalized form (all zeroes or all ones in defined bits), and (iii) keep to the same "upper bits undefined" invariant as for integers. With one exception: for a <code>b1</code> type I think that we should maintain the lowest <em>8</em> bits defined, i.e. lowest byte of <code>0x00</code> or <code>0x01</code> only, so that a store can be done without a mask.</p>
<p>Thoughts?</p>
</blockquote>



<a name="249883186"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249883186" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249883186">(Aug 18 2021 at 17:24)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901292428">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I'd like to propose the following for loads and stores:</p>
<ul>
<li>Define loads and stores of boolean values. We haven't done this in the past, but it is a somewhat incongruous hole in our semantics, IMHO, and we <em>do</em> load and store booleans sometimes behind the scenes (see: trampoline args). I think it would be better if we formally say what it means to do so.</li>
<li>Let's define the size of a <code>b1</code> to be one byte, and others (<code>b8</code> and up) as the size of the equivalent integer type.</li>
<li>A store of a <code>b1</code> stores 0 or 1 (i.e., it is zero-extended to 8 bits); a store of a <code>b8</code>..<code>b128</code> stores all zeroes or all ones.</li>
<li>&lt;strike&gt;A load of a boolean type has undefined behavior if the value loaded from memory is not canonical as per the above bullet point.&lt;/strike&gt; <em>better option, see below</em></li>
</ul>
<p>The last is probably the most controversial; disallowing loads and stores of bools avoids the semantic question, which may have been why this was done (@sunfishcode comments?). But we already allow bitcasts, so we already have some notion of the bits underlying a bool, so IMHO it's better to allow loading/storing those bits.</p>
<p>An alternative is to canonicalize a boolean when loading. For a <code>b1</code> this is a mask (<code>and</code> op); for a <code>b8</code> and up we could just compare to zero and if the loaded value is nonzero (any bit is set), canonicalize to <code>true</code> (all bits set). I actually prefer this option, after a bit of thought: it gives well-defined semantics and avoids illegal bool values (e.g. <code>b128</code> with half the bits set) that might cause other undefined behavior.</p>
<p>Then for bitcasts:</p>
<ul>
<li>A raw_bitcast or bitcast from a bool to an int produces the same value that a store would produce.</li>
<li>A raw_bitcast or bitcast from an int to a bool canonicalizes just as a load does.</li>
</ul>
<p>All of the above should fully pin down how we store the values in registers as well: we (i) have a well-defined integer interpretation of the bool, (ii) always store it in canonicalized form (all zeroes or all ones in defined bits), and (iii) keep to the same "upper bits undefined" invariant as for integers. With one exception: for a <code>b1</code> type I think that we should maintain the lowest <em>8</em> bits defined, i.e. lowest byte of <code>0x00</code> or <code>0x01</code> only, so that a store can be done without a mask.</p>
<p>Thoughts?</p>
</blockquote>



<a name="249906423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249906423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249906423">(Aug 18 2021 at 20:20)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901404151">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I've just added this to the agenda for Monday's public Cranelift biweekly meeting as well.</p>
</blockquote>



<a name="249908424"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249908424" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249908424">(Aug 18 2021 at 20:38)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901414872">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I think a side effect of going doing the path above would be that <code>raw_bitcast</code> is no longer necessary. <code>bitcast</code> says: "A bitcast is equivalent to storing one type and loading the other type from the same address." If we can load and store booleans I think that eliminates the reason for <code>raw_bitcast</code>'s existence (?).</p>
</blockquote>



<a name="249908975"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249908975" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249908975">(Aug 18 2021 at 20:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901417670">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>That's a good point; the distinction between the two is pretty confusing, so if we could remove <code>raw_bitcast</code> as well and have only one kind of bitcast, all the better.</p>
</blockquote>



<a name="249918789"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249918789" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249918789">(Aug 18 2021 at 22:17)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901465989">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<blockquote>
<p>A store of a <code>b1</code> stores 0 or 1 (i.e., it is zero-extended to 8 bits); a store of a <code>b8</code>..<code>b128</code> stores all zeroes or all ones.</p>
</blockquote>
<p>Why not have <code>b1</code> store all ones? The inconsistency between <code>b1</code> and <code>b8..b128</code> is a bit of a surprise.</p>
</blockquote>



<a name="249919230"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249919230" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249919230">(Aug 18 2021 at 22:23)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901468488">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<blockquote>
<p>Why not have <code>b1</code> store all ones?</p>
</blockquote>
<p>So my thought process is: <code>b1</code> is, semantically, one bit wide; so "all ones" is just <code>0x01</code>. But because memory is byte-oriented, we have to store a whole byte, so we zero-extend. I definitely recognize this is kind of subjective and "all ones in all bits that are written" is just as much a valid perspective though.</p>
<p>Pragmatic reasons: <code>b1</code> will be most common, and generating a zero or one is slightly easier than zero or <code>-1</code> (all ones), e.g. the one instruction <code>cset</code> on aarch64; and <code>bint</code> (bool to int) from a <code>b1</code> with a zero-or-one value is a no-op (just a copy) while it's a masking operation with zero or <code>-1</code>.</p>
</blockquote>



<a name="249920266"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249920266" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249920266">(Aug 18 2021 at 22:35)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901473558">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I should probably add another possibility too: we could define all of <code>b1</code>..<code>b128</code> to use <code>0</code> for false and <code>1</code> for true.</p>
<p>The main reason for the all-ones representation, to my understanding, was to be able to use e.g. a <code>b128</code> as a SIMD mask after a <code>raw_bitcast</code> (or at least, that's the way it has been explained to me -- many issues back I think someone linked some code that had assumed this). But this is sort of getting a desired higher-level semantic behavior implicitly by setting up the low-level definitions in a certain way; it would be better to require the "turn this bool into an all-ones mask" use-case to use <code>bmask</code>, which already exists for this purpose. Then we get to use the (IMHO) slightly more intuitive <code>0</code>/<code>1</code> values which work well for most cases, and we have a fully consistent behavior. We would just need to look for use-cases that assume all-ones currently and ensure they use <code>bmask</code> instead.</p>
<p>This probably needs a sanity check from a SIMD perspective though -- @abrown / @jlb6740 / @akirilov-arm, thoughts?</p>
</blockquote>



<a name="249920823"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249920823" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249920823">(Aug 18 2021 at 22:42)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901476385">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>Ah, here is one example of a dependence on all-ones in cg_clif: <a href="https://github.com/bjorn3/rustc_codegen_cranelift/blob/75eff64977ff149ead73bc0077bac5872d599aa2/src/intrinsics/mod.rs#L293">link</a> (linked by @afonso360 in #3003)</p>
</blockquote>



<a name="249921222"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249921222" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249921222">(Aug 18 2021 at 22:48)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901478585">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I would mention that the all-ones/all-zeroes representation for SIMD is not just because using the output of a comparison as a mask is convenient, it's also that the Wasm SIMD spec <a href="https://github.com/WebAssembly/simd/blob/main/proposals/simd/SIMD.md#comparisons">specifies that representation</a> (but obviously without the boolean type) and that machines (x64, aarch64) represent things this way as well.</p>
</blockquote>



<a name="249924620"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249924620" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249924620">(Aug 18 2021 at 23:35)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901498010">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>@abrown this has me thinking further: the existing Wasm-SIMD implementation (lowering in <code>cranelift-wasm</code> specifically) does not use <code>b128</code> (or any other boolean type), right?</p>
<p>So one fundamental question I have is: what is the use-case for boolean types wider than 1 bit? If for an actual SIMD use-case we represent the mask as an <code>I8X16</code> (that's what I gather from <a href="https://github.com/bytecodealliance/wasmtime/blob/ddfadaeb384c11d2928fcf89dd1bd4e40692367b/cranelift/wasm/src/code_translator.rs#L2612-L2615">here</a> and the implementation of <code>optionally_bitcast_vector</code>), then it seems that the question of what Wasm-SIMD masks require is separate from the question of what <code>b128</code> means.</p>
<p>In other words, what we decide here doesn't impact Wasm-SIMD, because Wasm-SIMD doesn't depend on CLIF-level bool types; so it's better to base on decision on whatever makes the most semantic sense and leads to the least confusion, IMHO.</p>
<p>If <code>b128</code> is just "a 1-bit-narrow value stored in a much wider space", then IMHO it makes as much sense to zero-extend it (as one would zero-extend an <code>i8</code> stored in an <code>i128</code> worth of space) as sign-extend it.</p>
<p>Argued from another perspective: If we say that booleans (abstractly) have two possible values, then storing such a value in anything wider than 1 bit grants us the freedom to choose the bit representation for each of those two possible values. In other words, <code>b128</code> is still just semantically <code>true</code> or <code>false</code>; the bit-patterns that represent those are invisible at the CLIF-semantics level.</p>
<p>So I'm starting to convince myself a bit more than the <code>0</code>/<code>1</code> approach is cleanest, and then we need to look for uses of <code>raw_bitcast</code> (as in cg_clif) to peek under the hood and see the actual bits, and convert those uses into <code>bmask</code> or <code>bint</code> as appropriate. But I'm (still) very curious how that sits with others...</p>
</blockquote>



<a name="249946098"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/249946098" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#249946098">(Aug 19 2021 at 06:21)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-901643025">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<blockquote>
<p>Why not have b1 store all ones? The inconsistency between b1 and b8..b128 is a bit of a surprise.</p>
</blockquote>
<p>Rust stores bools as 0 or 1. Storing b1 as all zeros or all ones would require an extra instruction in the common case to convert it to 0 or 1 when storing it. The larger boolean types are pretty much only useful for vector types where it is common for masks to have all zeros or all ones as value.</p>
</blockquote>



<a name="250342948"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/250342948" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#250342948">(Aug 23 2021 at 12:18)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-903713032">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>@cfallin I am a bit confused about your comments on <code>B128</code> and its relation to SIMD - isn't that a scalar type? I.e. in the SIMD case wouldn't one use something like <code>B16X8</code>?</p>
<blockquote>
<p>Pragmatic reasons: <code>b1</code> will be most common, and generating a zero or one is slightly easier than zero or <code>-1</code> (all ones), e.g. the one instruction <code>cset</code> on aarch64...</p>
</blockquote>
<p>The all ones case is actually a single AArch64 instruction as well, <code>CSETM</code> (assuming that the upper bits for types like <code>B16</code> are undefined, so that we can set them to all ones).</p>
</blockquote>



<a name="250367518"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/250367518" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#250367518">(Aug 23 2021 at 15:25)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-903873941">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>@akirilov-arm indeed, that was more or less my point as well -- in the past it has been described as all-ones "because SIMD" and e.g. see the <code>raw_bitcast</code> linked above that uses it as a mask, but really it's a <code>true</code>/<code>false</code> value still, and so the fundamental question is "what does a multi-bit scalar boolean mean".</p>
</blockquote>



<a name="281231889"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/281231889" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#281231889">(May 04 2022 at 22:58)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>In #3202 and a number of past issues as well, we've repeatedly encountered some uncertainty as to (i) how boolean values of varying widths are stored in registers, (ii) whether they can be loaded/stored or not and what representation they take in memory (see e.g. #3102 where we addressed this for trampoline args), and (iii) how this interacts with boolean&lt;-&gt;integer conversion ops like <code>bint</code> and <code>bmask</code>.</p>
<p>The understanding we seem to generally agree on is that booleans of width &gt; 1 bit have all bits set (true) or all bits cleared (false). And a <code>b1</code> is stored in a register with the same invariant as other integer values: the upper bits (in this case everything above the LSB) are undefined.</p>
<p>However, this is far from being confusion-free and unambiguous; thus, it seems reasonable to (i) agree definitively on how bools are represented in registers and memory, and (ii) audit our compliance to whatever invariants we decide on.</p>
</blockquote>



<a name="281231891"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/281231891" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#281231891">(May 04 2022 at 22:58)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>In #3202 and a number of past issues as well, we've repeatedly encountered some uncertainty as to (i) how boolean values of varying widths are stored in registers, (ii) whether they can be loaded/stored or not and what representation they take in memory (see e.g. #3102 where we addressed this for trampoline args), and (iii) how this interacts with boolean&lt;-&gt;integer conversion ops like <code>bint</code> and <code>bmask</code>.</p>
<p>The understanding we seem to generally agree on is that booleans of width &gt; 1 bit have all bits set (true) or all bits cleared (false). And a <code>b1</code> is stored in a register with the same invariant as other integer values: the upper bits (in this case everything above the LSB) are undefined.</p>
<p>However, this is far from being confusion-free and unambiguous; thus, it seems reasonable to (i) agree definitively on how bools are represented in registers and memory, and (ii) audit our compliance to whatever invariants we decide on.</p>
</blockquote>



<a name="302349031"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/302349031" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#302349031">(Oct 04 2022 at 21:20)</a>:</h4>
<p>elliottt <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-1267590607">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>Here's a link to the <a href="https://github.com/bytecodealliance/meetings/blob/main/cranelift/2021/cranelift-08-23.md#notes-1">2021-08-23</a> meeting notes where this was discussed originally.</p>
</blockquote>



<a name="302363058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/302363058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#302363058">(Oct 04 2022 at 23:25)</a>:</h4>
<p>elliottt <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-1267713534">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>There has been discussion recently about whether or not we need the boolean types at all, and we seem to be converging on the opinion that we should remove them rather than handle the issues surrounding load/store with <code>b1</code> values. Effectively, this would mean that we will remove all boolean types, scalar and vector, replacing them with their bit-width integer equivalent (except for <code>b1</code> that would be replaced with <code>i8</code>).</p>
<p>I'd like to propose the following semantics for instructions that return boolean values now:</p>
<ul>
<li>Instructions that currently return <code>b1</code> values will switch to returning <code>i8</code> values in the range [0,1]. This doesn't immediately address the current issues surrounding load/store with <code>b1</code> values, and I'm interested to hear how we should address cases that look like <code>x = load.i8 ...; brz x ...</code>.</li>
<li>All other boolean types would return integer values of the same bit-width, where true would be represented as all <code>1</code>s and false would be represented as all <code>0</code>s. I believe this would be effectively no value-level change from the current behavior.</li>
</ul>
</blockquote>



<a name="302365615"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/302365615" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#302365615">(Oct 04 2022 at 23:48)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-1267732416">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>Thanks @elliottt -- I think the above is largely a good plan and will result in nice simplifications and removal of awkward special cases!</p>
<blockquote>
<p><code>x = load.i8 ...; brz x ...</code></p>
</blockquote>
<p>For this case specifically I think the semantics would be for <code>brz</code> to branch if <code>x != 0</code>; in fact I think it already works this way (accepted types defined <a href="https://github.com/bytecodealliance/wasmtime/blob/e63771f2d921cdce440620dbf38bd3e186747b1e/cranelift/codegen/meta/src/shared/instructions.rs#L40-L47">here</a> and the mnemonics are "branch if zero" and "branch if not zero"). So the 0/1 encodings of a bool work as always, and other nonzero values are also truthy.</p>
</blockquote>



<a name="302493306"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/302493306" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#302493306">(Oct 05 2022 at 16:15)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/3205#issuecomment-1268642200">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>I agree. IIRC, there may be an optimization or two that rely on the boolean type but given the move towards e-graphs those optimizations will need to be re-worked anyway.</p>
</blockquote>



<a name="304575992"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233205%20Cranelift%3A%20formalize%2C%20document%2C%20an.../near/304575992" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233205.20Cranelift.3A.20formalize.2C.20document.2C.20an.2E.2E.2E.html#304575992">(Oct 17 2022 at 23:00)</a>:</h4>
<p>elliottt closed <a href="https://github.com/bytecodealliance/wasmtime/issues/3205">issue #3205</a>:</p>
<blockquote>
<p>In #3202 and a number of past issues as well, we've repeatedly encountered some uncertainty as to (i) how boolean values of varying widths are stored in registers, (ii) whether they can be loaded/stored or not and what representation they take in memory (see e.g. #3102 where we addressed this for trampoline args), and (iii) how this interacts with boolean&lt;-&gt;integer conversion ops like <code>bint</code> and <code>bmask</code>.</p>
<p>The understanding we seem to generally agree on is that booleans of width &gt; 1 bit have all bits set (true) or all bits cleared (false). And a <code>b1</code> is stored in a register with the same invariant as other integer values: the upper bits (in this case everything above the LSB) are undefined.</p>
<p>However, this is far from being confusion-free and unambiguous; thus, it seems reasonable to (i) agree definitively on how bools are represented in registers and memory, and (ii) audit our compliance to whatever invariants we decide on.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>