<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6530 Cranelift: get tail calls working ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html">wasmtime / issue #6530 Cranelift: get tail calls working ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="376747812"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/376747812" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#376747812">(Jul 19 2023 at 17:53)</a>:</h4>
<p>fitzgen edited <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<blockquote>
<p>I'm having a hard time figuring out the details of s390x here, so I am going to disable support for the <code>tail</code> calling convention on s390x (with a loud assertion) to land this PR. We can get s390x working in follow ups.</p>
</blockquote>
<p>_Originally posted by @fitzgen in <a href="https://github.com/bytecodealliance/wasmtime/issues/6500#issuecomment-1579427510_">https://github.com/bytecodealliance/wasmtime/issues/6500#issuecomment-1579427510_</a></p>
</blockquote>



<a name="376747822"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/376747822" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#376747822">(Jul 19 2023 at 17:53)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-1642510442">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Hey @uweigand, would really appreciate your help here. There are two things that need to be done (or at least, I have done it with these two different steps for the other backends):</p>
<ol>
<li>
<p><strong>Get regular, non-tail calls working with the <code>tail</code> calling convention.</strong></p>
<p>This has involved modifying the calling convention such that callees (rather than callers) pop stack arguments as part of their function epilogue and before/at the same time as returning to their caller.</p>
<p>There is <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/filetests/filetests/runtests/tail-call-conv.clif">a runtest that use the <code>tail</code> calling convention without actually doing tail calls</a>, it is currently disabled on s390x but would presumably be enabled during this step. I also recommend copying that test to <code>filetests/isa/x390x</code> and turning it into a <code>compile precise-output</code> test as well, which the other backends have done too.</p>
</li>
<li>
<p><strong>Implement tail calls.</strong></p>
<p>These are only valid CLIF when both the caller and callee use the <code>tail</code> calling convention, so that is something we can rely upon.</p>
<p>None of the other backends have been doing parallel move solving during tail calls to make sure new arguments end up in the correct locations without overwriting old arguments that are on the stack but become new arguments elsewhere on the stack in the tail call. Instead, they bump SP and construct a temporary frame and then move the frame down on top of the current frame and then initialize SP for the callee. I recommend starting with this simple approach, and we can later do parallel move solving as an optimization, but whatever works for you.</p>
<p>There are a few runtests for exercising tail calls: <code>filetests/runtests/return-call{.clif,-indirect.clif,-loop.clif}</code>. Each backend also has a copy of <code>return-call.clif</code> (which actually covers both colocated and not calls) to their ISA-specific tests as <code>compile precise-output</code> tests, and I recommend that s390x has a copy as well.</p>
<p>I've been adding <code>emit_return_call</code> methods to each backend's <code>abi::CallSite&lt;M&gt;</code> instantiation, so that the top-level entry is arch-specific rather than going through a common generic helper. The ISLE lowering calls the external <code>gen_return_call[_indirect]</code> constructor, which each backend implements. This external constructor creates an <code>abi::CallSite&lt;MyBackend&gt;</code> and then calls its <code>emit_return_call</code> method. There is a generic helper to create the temporary tail call frame that you can use if you want, but in general you have direct control of everything we do here, you don't have to fit into the shape of generic hooks and callbacks. I think it is easier to read and write the code this way, hopefully you find the same.</p>
<p>For reference, the last commit in <a href="https://github.com/bytecodealliance/wasmtime/pull/6749">https://github.com/bytecodealliance/wasmtime/pull/6749</a> shows what implementing tail calls for riscv64 entailed. It was pretty straightforward, and hopefully can serve as a template to reference and crib from for s390x.</p>
</li>
</ol>
<p>Don't hesitate to reach out with any questions or clarifications or anything like that! Thanks very much!</p>
</blockquote>



<a name="376748107"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/376748107" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#376748107">(Jul 19 2023 at 17:54)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-1642511982">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Oh also, since Wasmtime will use the <code>tail</code> calling convention for all Wasm functions, I think we need to mark the <code>tail</code> calling convention as having little endian lane ordering on s390x. I am not sure where that change needs to be made.</p>
</blockquote>



<a name="377022787"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/377022787" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#377022787">(Jul 20 2023 at 15:25)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-1644131763">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<blockquote>
<p>This has involved modifying the calling convention such that callees (rather than callers) pop stack arguments as part of their function epilogue and before/at the same time as returning to their caller.</p>
</blockquote>
<p>This is probably the core of the problem - in the current s390x ABI, <em>neither</em> callers nor callees pop stack arguments as part of the calling sequence.  Instead, the stack pointer stays constant around calls, and the space for all arguments for all calls the current function may ever make is statically allocated in its prologue.   Therefore the tail calling convention will have to be implemented differently, either by switching over to a completely different convention that actually pushes/pops argument space around calls, or by some other means like allowing calls to not preserve the stack pointer (which in turn would enforce use of a frame pointer, which we also currently do not have on s390x ...).</p>
<p>I'll need to look into those options a bit more, but I won't get to this before I'm back from vacation in early August.<br>
</p>
</blockquote>



<a name="438828607"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/438828607" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#438828607">(May 15 2024 at 15:18)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2112837917">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Here's finally my current design of a tail-call ABI for s390x.</p>
<p>The SystemV ABI has the following stack layout:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//! CFA                  -----&gt;  | stack args                |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | 160 bytes reg save area   |</span>
<span class="sd">//!                              | (used to save GPRs)       |</span>
<span class="sd">//! SP at function entry -----&gt;  | (incl. caller's backchain)|</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | clobbered callee-saves    |</span>
<span class="sd">//!                              | (used to save FPRs)       |</span>
<span class="sd">//! unwind-frame base     ----&gt;  | (alloc'd by prologue)     |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | spill slots               |</span>
<span class="sd">//!                              | (accessed via nominal SP) |</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | stack slots               |</span>
<span class="sd">//!                              | (accessed via nominal SP) |</span>
<span class="sd">//! nominal SP ---------------&gt;  | (alloc'd by prologue)     |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | outgoing calls return buf |</span>
<span class="sd">//!                              | outgoing calls args       |</span>
<span class="sd">//!                              | outgoing reg save area    |</span>
<span class="sd">//!                              | (alloc'd by prologue)     |</span>
<span class="sd">//! SP during function  ------&gt;  | (incl. callee's backchain)|</span>
<span class="sd">//!                              +---------------------------+</span>
</code></pre></div>
<p>The new tail-call ABI would instead use this layout:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//! CFA                  -----&gt;  | (caller's frame)          |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | 160 bytes reg save area   |</span>
<span class="sd">//!                              | (used to save GPRs)       |</span>
<span class="sd">//! SP at function return-----&gt;  | (incl. caller's backchain)|</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | incoming stack args       |</span>
<span class="sd">//! SP at function entry -----&gt;  | (incl. backchain copy)    |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | outgoing tail call args   |</span>
<span class="sd">//!                              | (overlaps incoming args)  |</span>
<span class="sd">//!                              | (incl. backchain copy)    |</span>
<span class="sd">//! SP at tail cail       ----&gt;  | (alloc'd by prologue)     |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | clobbered callee-saves    |</span>
<span class="sd">//!                              | (used to save FPRs)       |</span>
<span class="sd">//! unwind-frame base     ----&gt;  | (alloc'd by prologue)     |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | spill slots               |</span>
<span class="sd">//!                              | (accessed via nominal SP) |</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | stack slots               |</span>
<span class="sd">//!                              | (accessed via nominal SP) |</span>
<span class="sd">//! nominal SP ---------------&gt;  | (alloc'd by prologue)     |</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | outgoing calls return buf |</span>
<span class="sd">//!                              | outgoing reg save area    |</span>
<span class="sd">//!                              | (alloc'd by prologue)     |</span>
<span class="sd">//! SP during function  ------&gt;  | (incl. callee's backchain)|</span>
<span class="sd">//!                              +---------------------------+</span>
<span class="sd">//!                              |          ...              |</span>
<span class="sd">//!                              | outgoing stack args       |</span>
<span class="sd">//!                              | (alloc'd by call sequence)|</span>
<span class="sd">//! SP at non-tail call  -----&gt;  | (incl. backchain copy)    |</span>
<span class="sd">//!                              +---------------------------+</span>
</code></pre></div>
<p>Notably, the handling of the stack backchain with this tail-call ABI remains fully compatible with the SystemV ABI.  Existing unwinder routines should be able to correctly unwind through any combination of SystemV and tail-call ABI frames.  To enable asynchronous unwinding during the call sequence, we store copies of the innermost backchain value at the bottom of the outgoing (or tail-call) argument area.  These only remain live during the call sequence, they are no longer accessed after the call sequence is completed by the callee setting up it's own stack frame.  Note that if unwinding during that period is not required, it would be possible to omit storing those copies to avoid some overhead.</p>
<p>In addition, the tail-call ABI would use both <code>r6</code> and <code>r7</code> as argument registers, and make them both non-callee-saved.  (<code>r6</code> is a callee-saved argument register in the SystemV ABI, which is incompatible with tail calls.  As we're making changes anway, it makes sense to also change <code>r7</code> so we have 6 argument registers instead of 5.)</p>
<p>To implement the new ABI, the following changes would need to be made:</p>
<ol>
<li>Tail-call ABI prologue:</li>
</ol>
<ul>
<li>Save callee-saved GPRs into incoming reg save area</li>
<li>Compute size of tail-call argument area (extending incoming argument area)</li>
<li>Allocate local stack frame, including<ul>
<li>tail-call argument area</li>
<li>clobbered callee-saves area</li>
<li>spill slots</li>
<li>stack slots</li>
<li>outgoing calls return buffer</li>
<li>outgoing reg save area</li>
</ul>
</li>
<li>Store backchain, pointing to caller's backchain (not the copy!)</li>
<li>Save callee-saved FPRs into callee-saves area</li>
</ul>
<p>(Overhead compared to SystemV ABI: compute backchain value; none if no incoming stack args)</p>
<ol start="2">
<li>Tail-call ABI epilogue:</li>
</ol>
<ul>
<li>Restore callee-saved FPRs from callee-saves area</li>
<li>Restore callee-saved GPRs (except SP, including %r14) from incoming reg save area</li>
<li>Restore SP to value at function return (popping incoming args area)</li>
<li>Return by branching to (restored) %r14</li>
</ul>
<p>(Overhead compared to SystemV ABI: compute restored SP; none if no incoming stack args)</p>
<ol start="3">
<li>Tail-call sequence:</li>
</ol>
<ul>
<li>(If present) Construct outgoing args into (possibly extended) incoming args area<ul>
<li>Includes storing copy of caller's backchain to the bottom of the outgoing args</li>
</ul>
</li>
<li>Load up arguments into registers</li>
<li>(If present) restore return buffer address register to incoming value</li>
<li>Restore callee-saved FPRs from callee-saves area</li>
<li>Restore callee-saved GPRs (except SP, including %r14) from incoming reg save area</li>
<li>Set SP to bottom of outgoing args area for this call</li>
<li>Jump to target address</li>
</ul>
<p>(Overhead compared to SystemV ABI: n/a, doesn't have tail calls)</p>
<ol start="4">
<li>Non-tail calls:</li>
</ol>
<ul>
<li>(If present) Set up outgoing args area<ul>
<li>Allocate area by decrementing stack pointer</li>
<li>Store copy of callee's backchain to the bottom of the outgoing args</li>
<li>Construct outgoing args into outgoing args area</li>
</ul>
</li>
<li>Load up arguments into register</li>
<li>(If present) set up return buffer address register to return buffer</li>
<li>Perform function call (storing return address into %r14)</li>
<li>Retrieve return values from registers and/or return buffer</li>
</ul>
<p>(Overhead compared to SystemV ABI: allocating outgoing args area &amp; storing backchain copy; none if no outgoing stack args)</p>
<p>Cross-calling-convention calls would also be possible:</p>
<ol>
<li>SystemV ABI to tail-call ABI</li>
</ol>
<ul>
<li>mostly the same as tail-call to tail-call calls</li>
<li>GPRs 6 and 7 must be considered clobbered by callee</li>
</ul>
<ol start="2">
<li>tail-call ABI to SystemV ABI</li>
</ol>
<ul>
<li>allocate outgoing args in caller's frame as for SystemV ABI</li>
</ul>
<p>CC @elliottt @jameysharp @cfallin </p>
</blockquote>



<a name="438843988"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/438843988" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#438843988">(May 15 2024 at 16:34)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2112994803">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Noting my comment from today's Cranelift meeting for posterity: the async stack walking doesn't seem too important (can be relegated to a default off setting, imo) if we preserve the invariant on s390x that other backends have that we don't interleave argument evaluation with calling convention code. This would be easy to do, and wouldn't require moving s390x to the shared ABI framework code, by having s390x's calling convention code in ISLE take <code>Reg</code>s rather than <code>Value</code>s, forcing the evaluation to happen at the boundary before we begin calling convention stuff.</p>
<p>Ulrich, you mentioned that this would prevent us from performing an existing sign-/zero-extend optimization. I guess my question then is which has more overhead: missing that optimization or storing a copy of the backchain?</p>
</blockquote>



<a name="438844095"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/438844095" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#438844095">(May 15 2024 at 16:35)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2112994803">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Noting my comment from today's Cranelift meeting for posterity: the async stack walking doesn't seem too important (can be relegated to a default off setting, imo) if we preserve the invariant on s390x that other backends have that we don't interleave argument evaluation with calling convention code (since argument evaluation can trap, and we <em>must</em> be able to walk the stack at trap sites. This would be easy to do, and wouldn't require moving s390x to the shared ABI framework code, by having s390x's calling convention code in ISLE take <code>Reg</code>s rather than <code>Value</code>s, forcing the evaluation to happen at the boundary before we begin calling convention stuff.</p>
<p>Ulrich, you mentioned that this would prevent us from performing an existing sign-/zero-extend optimization. I guess my question then is which has more overhead: missing that optimization or storing a copy of the backchain?</p>
</blockquote>



<a name="438844211"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/438844211" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#438844211">(May 15 2024 at 16:36)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2112994803">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>Noting my comment from today's Cranelift meeting for posterity: the async stack walking doesn't seem too important (can be relegated to a default off setting, imo) if we preserve the invariant on s390x that other backends have that we don't interleave argument evaluation with calling convention code (since argument evaluation can trap, and we <em>must</em> be able to walk the stack at trap sites). This would be easy to do, and wouldn't require moving s390x to the shared ABI framework code, by having s390x's calling convention code in ISLE take <code>Reg</code>s rather than <code>Value</code>s, forcing the evaluation to happen at the boundary before we begin calling convention stuff.</p>
<p>Ulrich, you mentioned that this would prevent us from performing an existing sign-/zero-extend optimization. I guess my question then is which has more overhead: missing that optimization or storing a copy of the backchain?</p>
</blockquote>



<a name="454301712"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/454301712" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#454301712">(Jul 26 2024 at 13:43)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2252796096">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>I've now completed a prototype implementation of the above design.  This sucessfully passes all tests (including the wasm tail-call tests), with one execption: <code>gc_and_tail_calls_and_stack_arguments</code>.</p>
<p>Unfortunately, this indicates a fundamental problem: the above design requires dynamic stack adjustments around calls.  However, common code support for that was removed recently.  I thought I could work around this in the back-end, and that does indeed work fine for code generation - but then common code gets the stack maps at call sites wrong, as it no longer takes this dynamic adjustment into account.</p>
<p>So at this point we can either add that common code support back, or else re-design the ABI to avoid dynamic stack adjustments.  The latter is a bit tricky if we want to avoid frequent copying of the back chain value.  I'll need to think about that more.<br>
</p>
</blockquote>



<a name="454361677"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/454361677" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#454361677">(Jul 26 2024 at 19:59)</a>:</h4>
<p>jameysharp <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2253399909">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>I haven't been able to focus on this enough to understand what problem you're solving with dynamic stack adjustments, but I think we wanted to do something similar enough someday in other backends that it may be worth talking through how to get this right in common code.</p>
<p>In particular, to keep things simple, @elliottt and I placed outgoing arguments at the bottom of the outgoing argument area, so the stack pointer is always in the same place on entry to a call. But we planned eventually to place those arguments at the top of the outgoing argument area instead and move the stack pointer before and after the call, to reduce stack usage in deeply nested call stacks. I'm not sure but perhaps that would mean we would run into the same issue you're seeing with stack maps.</p>
<p>Of course, @fitzgen is currently working on significant changes to the stack map infrastructure, which might also change this situation, I'm not sure.</p>
</blockquote>



<a name="454401137"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/454401137" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#454401137">(Jul 27 2024 at 01:16)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2253691233">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<p>While walking the stack to identify on-stack GC roots, the runtime is given a series of frame pointers (backchains on s390x) and PCs for each frame. It looks up the appropriate stack map metadata based on the PC. The stack map provides the offset-from-SP of every GC root in the stack frame and the size of the stack frame that it is mapping. The runtime takes the frame's FP, subtracts the stack map's frame size from FP, which yields the SP. It then uses the stack map and the SP to note all of the live, on-stack GC roots.</p>
<p>(I have a branch that is <em>just</em> not quite ready yet to move Wasmtime over from the "old" stack maps (current situation) to the new "user" stack maps (stuff myself and Trevor have been poking at the last couple weeks). But it shouldn't actually change anything with regards to the above; all that should be just as true for the new system as it is for the old system.)</p>
<p>All this to say: If you are adjusting the SP at call sites, then it is possible (likely?) that the frame size noted in the stack maps have gotten out of sync with the frame's actual size, which could explain why that test is failing.</p>
<p>Some relevant bits of code:</p>
<ul>
<li>The method that the new "user" stack maps use to get the frame size: <a href="https://github.com/bytecodealliance/wasmtime/blob/3767f76b487959194b10ec9e17ddb8d1c3a37116/cranelift/codegen/src/machinst/abi.rs#L986">https://github.com/bytecodealliance/wasmtime/blob/3767f76b487959194b10ec9e17ddb8d1c3a37116/cranelift/codegen/src/machinst/abi.rs#L986</a></li>
<li>The open-coded version of getting the frame size for the "old" stack maps: <a href="https://github.com/bytecodealliance/wasmtime/blob/3767f76b487959194b10ec9e17ddb8d1c3a37116/cranelift/codegen/src/machinst/abi.rs#L1661">https://github.com/bytecodealliance/wasmtime/blob/3767f76b487959194b10ec9e17ddb8d1c3a37116/cranelift/codegen/src/machinst/abi.rs#L1661</a></li>
</ul>
<p>The stack maps are then passed to the <code>EmitState</code> via the <code>pre_safepoint</code> method. Then they are taken out of the <code>EmitState</code> during via <code>take_stack_map</code> calls when emitting a call/call-indirect instruction in the backends. It seems like maybe updating the frame size of the stack map in this call-emit code, if you adjust the SP for the call, might be the easiest solution here.</p>
</blockquote>



<a name="454844500"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/454844500" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#454844500">(Jul 29 2024 at 14:04)</a>:</h4>
<p>uweigand <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2256037782">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<blockquote>
<p>While walking the stack to identify on-stack GC roots, the runtime is given a series of frame pointers (backchains on s390x) and PCs for each frame. It looks up the appropriate stack map metadata based on the PC. The stack map provides the offset-from-SP of every GC root in the stack frame and the size of the stack frame that it is mapping. The runtime takes the frame's FP, subtracts the stack map's frame size from FP, which yields the SP. It then uses the stack map and the SP to note all of the live, on-stack GC roots.</p>
</blockquote>
<p>Thanks for the explanation!  With this approach, "local" SP manipulations around call sites should actually not affect use of the stack map at all, as long as runtime unwinding provides correct frame pointer values and the stack map provides the correct size of the "nominal" stack.</p>
<blockquote>
<p>All this to say: If you are adjusting the SP at call sites, then it is possible (likely?) that the frame size noted in the stack maps have gotten out of sync with the frame's actual size, which could explain why that test is failing.</p>
</blockquote>
<p>And this was indeed the case, but not because of SP adjusting, but because the frame size of tail call frames was just generally wrong.  In my approach, incoming tail call arguments are part of the <em>callee</em>'s frame (as opposed to the caller's), and therefore must be accounted as part of the callee's frame size.</p>
<p>With this fixed, I now see the GC test (and all other tests) pass.</p>
<p>I'll have to do a bit more cleanup, and then I should be ready to post a PR.</p>
<blockquote>
<p>I haven't been able to focus on this enough to understand what problem you're solving with dynamic stack adjustments, but I think we wanted to do something similar enough someday in other backends that it may be worth talking through how to get this right in common code.</p>
</blockquote>
<p>To elaborate on that: in the s390x ABI we do not have a frame pointer, but instead stack backtracing works by having a stack "backchain" that is always present directly at the location the stack pointer points to.   This is usually quite efficient, but has the drawback that any adjustment of the stack pointer requires also updating the back chain field - unless you can prove it must have already been set in the past.  In particular, for function return in the current ABI, we know that we'll restore SP back to where the caller already placed the correct backchain value, so we do not have to re-write the backchain on every return.</p>
<p>With the approach you're currently taking for tail calls on Intel and ARM, however, incoming tail call arguments are part of the caller's frame, and so are outgoing arguments.  This may require growing the <em>caller</em>'s frame.  If we were to do that on s390x, that growing stack frame would overwrite the caller's backchain value, and would require us to re-write a backchain on every return (actually only on every return from a tail-call chain that somewhere grew the frame, but as we don't know whether this is the case, we'd in fact have to re-write on every return).  This would be quite some overhead, which I'm avoiding by making tail call arguments always part of the <em>callee</em>'s frame.  But that means the caller has to start allocated that bit of the callee's frame and therefore temporarily adjust SP around the call site.<br>
</p>
</blockquote>



<a name="454845117"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/454845117" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#454845117">(Jul 29 2024 at 14:06)</a>:</h4>
<p>uweigand edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/6530#issuecomment-2256037782">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<blockquote>
<p>While walking the stack to identify on-stack GC roots, the runtime is given a series of frame pointers (backchains on s390x) and PCs for each frame. It looks up the appropriate stack map metadata based on the PC. The stack map provides the offset-from-SP of every GC root in the stack frame and the size of the stack frame that it is mapping. The runtime takes the frame's FP, subtracts the stack map's frame size from FP, which yields the SP. It then uses the stack map and the SP to note all of the live, on-stack GC roots.</p>
</blockquote>
<p>Thanks for the explanation!  With this approach, "local" SP manipulations around call sites should actually not affect use of the stack map at all, as long as runtime unwinding provides correct frame pointer values and the stack map provides the correct size of the "nominal" stack.</p>
<blockquote>
<p>All this to say: If you are adjusting the SP at call sites, then it is possible (likely?) that the frame size noted in the stack maps have gotten out of sync with the frame's actual size, which could explain why that test is failing.</p>
</blockquote>
<p>And this was indeed the case, but not because of SP adjusting, but because the frame size of tail call frames was just generally wrong.  In my approach, incoming tail call arguments are part of the <em>callee</em>'s frame (as opposed to the caller's), and therefore must be accounted as part of the callee's frame size.</p>
<p>With this fixed, I now see the GC test (and all other tests) pass.</p>
<p>I'll have to do a bit more cleanup, and then I should be ready to post a PR.</p>
<blockquote>
<p>I haven't been able to focus on this enough to understand what problem you're solving with dynamic stack adjustments, but I think we wanted to do something similar enough someday in other backends that it may be worth talking through how to get this right in common code.</p>
</blockquote>
<p>To elaborate on that: in the s390x ABI we do not have a frame pointer, but instead stack backtracing works by having a stack "backchain" that is always present directly at the location the stack pointer points to.   This is usually quite efficient, but has the drawback that any adjustment of the stack pointer requires also updating the back chain field - unless you can prove it must have already been set in the past.  In particular, for function return in the current ABI, we know that we'll restore SP back to where the caller already placed the correct backchain value, so we do not have to re-write the backchain on every return.</p>
<p>With the approach you're currently taking for tail calls on Intel and ARM, however, incoming tail call arguments are part of the caller's frame, and so are outgoing arguments.  This may require growing the <em>caller</em>'s frame.  If we were to do that on s390x, that growing stack frame would overwrite the caller's backchain value, and would require us to re-write a backchain on every return (actually only on every return from a tail-call chain that somewhere grew the frame, but as we don't know whether this is the case, we'd in fact have to re-write on every return).  This would be quite some overhead, which I'm avoiding by making tail call arguments always part of the <em>callee</em>'s frame.  But that means the caller has to start allocating that bit of the callee's frame and therefore temporarily adjust SP around the call site.<br>
</p>
</blockquote>



<a name="455750136"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236530%20Cranelift%3A%20get%20tail%20calls%20working%20.../near/455750136" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236530.20Cranelift.3A.20get.20tail.20calls.20working.20.2E.2E.2E.html#455750136">(Aug 01 2024 at 20:22)</a>:</h4>
<p>fitzgen closed <a href="https://github.com/bytecodealliance/wasmtime/issues/6530">issue #6530</a>:</p>
<blockquote>
<blockquote>
<p>I'm having a hard time figuring out the details of s390x here, so I am going to disable support for the <code>tail</code> calling convention on s390x (with a loud assertion) to land this PR. We can get s390x working in follow ups.</p>
</blockquote>
<p>_Originally posted by @fitzgen in <a href="https://github.com/bytecodealliance/wasmtime/issues/6500#issuecomment-1579427510_">https://github.com/bytecodealliance/wasmtime/issues/6500#issuecomment-1579427510_</a></p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>