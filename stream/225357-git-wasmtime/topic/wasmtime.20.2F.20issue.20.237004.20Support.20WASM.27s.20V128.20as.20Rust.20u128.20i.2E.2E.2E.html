<html>
<head><meta charset="utf-8"><title>wasmtime / issue #7004 Support WASM&#x27;s V128 as Rust u128 i... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html">wasmtime / issue #7004 Support WASM&#x27;s V128 as Rust u128 i...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="390533175"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/390533175" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#390533175">(Sep 12 2023 at 14:34)</a>:</h4>
<p>cylewitruk opened <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>Wondering why V128 isn't supported in Func::wrap()? Both Walrus and Wasmer seem to allow V128's to be used in host functions mapped as u128's. I know this wasn't the "intended" use for V128's, but it would sure be nice for host functions :)</p>
<h4>Benefit</h4>
<p>Would allow passing of 128-bit numbers to/from host-functions without the need to split them into two parameters including lower and upper bits.</p>
<h4>Implementation</h4>
<p>Haven't looked into the Wasmtime internals, so no comment.</p>
<h4>Alternatives</h4>
<ul>
<li>Passing two i64's low+high bits and bitwising them apart/together (fast, but boilerplate needed).</li>
<li>Using ExternRef's to pass u/i128's (slow)</li>
<li>Open to other suggestions...?<br>
</li>
</ul>
</blockquote>



<a name="390534352"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/390534352" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#390534352">(Sep 12 2023 at 14:40)</a>:</h4>
<p>cylewitruk edited <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>Wondering why V128 isn't supported in Func::wrap()? Both Walrus and Wasmer seem to allow V128's to be used in host functions mapped as u128's. I know this wasn't the "intended" use for V128's, but it would sure be nice for host functions, at least in Rust :)</p>
<h4>Benefit</h4>
<p>Would allow passing of 128-bit numbers to/from host-functions without the need to split them into two parameters including lower and upper bits.</p>
<h4>Implementation</h4>
<p>Haven't looked into the Wasmtime internals, so no comment.</p>
<h4>Alternatives</h4>
<ul>
<li>Passing two i64's low+high bits and bitwising them apart/together (fast, but boilerplate needed).</li>
<li>Using ExternRef's to pass u/i128's (slow)</li>
<li>Open to other suggestions...?<br>
</li>
</ul>
</blockquote>



<a name="390596620"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/390596620" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#390596620">(Sep 12 2023 at 21:05)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1716437250">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>I've been meaning to dust off <a href="https://github.com/bytecodealliance/wasmtime/pull/7010">this branch</a> for some time now!</p>
</blockquote>



<a name="390691907"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/390691907" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#390691907">(Sep 13 2023 at 10:25)</a>:</h4>
<p>cylewitruk <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1717362427">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Well look at that! I searched issues and PR's before opening this and didn't find anything, but looks like it was hiding in a branch :) That would be really awesome, actually.  We're currently evaluating Wasmtime as the runtime for <a href="http://stacks.co">stacks.co</a> VM runtime for its Clarity language. As all numbers are currently treated as 128-bits, this would definitely save us some headaches! :D </p>
</blockquote>



<a name="390745157"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/390745157" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#390745157">(Sep 13 2023 at 15:09)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1717827631">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>One thing to keep in mind perhaps is that <code>v128</code> is generally intended for vector/simd operations right now so it may not be totally suitable for 128-bit numbers since there's nothing like <code>v128.add</code> which performs a 128-bit addition. You may get more mileage out of pairs of <code>u64</code> depending on your use case. </p>
<p>Additionally most engines may not be that optimal at this time passing around <code>v128</code> as parameters and results. The <code>v128</code> type is generally thought of "you use this in your hot inner loop and that's it". One example is that Cranelift/Wasmtime follow System-V which means that on RISC-V for example all arguments/results are passed through memory rather than in registers. </p>
<p>Not to say that this isn't a good use case, just figured it might be worth giving a heads up! I personally think it'd be reasonable to improve these sorts of issues if they arise. If you're interested in running on other engines though it might be worth testing there too</p>
</blockquote>



<a name="391271112"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/391271112" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#391271112">(Sep 15 2023 at 22:06)</a>:</h4>
<p>cylewitruk <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1721917437">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Very informed input, and good information for anyone else who might be wondering the same thing!</p>
<p>In our case we're aware of the limitations and that v128 was meant primarily for simd operations - we're currently passing low/high u64 pairs back-and-forth, but this does incur a slight overhead in host functions instead of simply being able to, for example, <code>u128:.from_le_bytes(...)</code>.</p>
</blockquote>



<a name="391271144"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/391271144" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#391271144">(Sep 15 2023 at 22:07)</a>:</h4>
<p>cylewitruk edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1721917437">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Very informed input, and good information for anyone else who might be wondering the same thing!</p>
<p>In our case we're aware of the limitations and that v128 was meant primarily for simd operations - we're currently passing low/high u64 pairs back-and-forth, but this does incur a slight overhead in host functions instead of simply being able to, for example, <code>u128::from_le_bytes(...)</code>.</p>
</blockquote>



<a name="391275874"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/391275874" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#391275874">(Sep 15 2023 at 22:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/7004#issuecomment-1721969301">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Ok sounds good! I forgot to close this earlier but this was solved by <a href="https://github.com/bytecodealliance/wasmtime/pull/7010">https://github.com/bytecodealliance/wasmtime/pull/7010</a>.</p>
<p>If you notice any performance issues though in this area (or others) please let us know!</p>
</blockquote>



<a name="391275876"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237004%20Support%20WASM%27s%20V128%20as%20Rust%20u128%20i.../near/391275876" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237004.20Support.20WASM.27s.20V128.20as.20Rust.20u128.20i.2E.2E.2E.html#391275876">(Sep 15 2023 at 22:42)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/7004">issue #7004</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>Wondering why V128 isn't supported in Func::wrap()? Both Walrus and Wasmer seem to allow V128's to be used in host functions mapped as u128's. I know this wasn't the "intended" use for V128's, but it would sure be nice for host functions, at least in Rust :)</p>
<h4>Benefit</h4>
<p>Would allow passing of 128-bit numbers to/from host-functions without the need to split them into two parameters including lower and upper bits.</p>
<h4>Implementation</h4>
<p>Haven't looked into the Wasmtime internals, so no comment.</p>
<h4>Alternatives</h4>
<ul>
<li>Passing two i64's low+high bits and bitwising them apart/together (fast, but boilerplate needed).</li>
<li>Using ExternRef's to pass u/i128's (slow)</li>
<li>Open to other suggestions...?<br>
</li>
</ul>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>