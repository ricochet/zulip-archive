<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4127 Cranelift: develop an inlining pass · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html">wasmtime / issue #4127 Cranelift: develop an inlining pass</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="281895723"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/281895723" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#281895723">(May 10 2022 at 22:40)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<p>In the <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2022.md">2022 roadmap</a>, we described the need to add <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlining</a> to Cranelift. This need comes mainly from anticipated future workloads in some Cranelift applications. For example, when used as a Wasm backend, multi-module use-cases will become more common as the <a href="https://github.com/WebAssembly/component-model">component model</a> becomes a reality. In such use-cases, no inlining would have been done by the Wasm toolchain; execution in Wasmtime/Cranelift is the first time that modules "meet" and can cross-inline calls, or at least interface-type adapter shim functions.</p>
<p>We will likely want to be a little careful about the inlining heuristic and associated costs, in order to preserve our general "fast compilation" focus. Perhaps we want to only inline explicitly-marked-as-inlinable functions. Or perhaps a bottom-up-over-callgraph-SCCs approach (like LLVM) is still the right one, but with a low cutoff threshold for function size to inline.</p>
</blockquote>



<a name="281895724"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/281895724" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#281895724">(May 10 2022 at 22:40)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<p>In the <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2022.md">2022 roadmap</a>, we described the need to add <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlining</a> to Cranelift. This need comes mainly from anticipated future workloads in some Cranelift applications. For example, when used as a Wasm backend, multi-module use-cases will become more common as the <a href="https://github.com/WebAssembly/component-model">component model</a> becomes a reality. In such use-cases, no inlining would have been done by the Wasm toolchain; execution in Wasmtime/Cranelift is the first time that modules "meet" and can cross-inline calls, or at least interface-type adapter shim functions.</p>
<p>We will likely want to be a little careful about the inlining heuristic and associated costs, in order to preserve our general "fast compilation" focus. Perhaps we want to only inline explicitly-marked-as-inlinable functions. Or perhaps a bottom-up-over-callgraph-SCCs approach (like LLVM) is still the right one, but with a low cutoff threshold for function size to inline.</p>
</blockquote>



<a name="281895725"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/281895725" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#281895725">(May 10 2022 at 22:40)</a>:</h4>
<p>cfallin labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<p>In the <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2022.md">2022 roadmap</a>, we described the need to add <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlining</a> to Cranelift. This need comes mainly from anticipated future workloads in some Cranelift applications. For example, when used as a Wasm backend, multi-module use-cases will become more common as the <a href="https://github.com/WebAssembly/component-model">component model</a> becomes a reality. In such use-cases, no inlining would have been done by the Wasm toolchain; execution in Wasmtime/Cranelift is the first time that modules "meet" and can cross-inline calls, or at least interface-type adapter shim functions.</p>
<p>We will likely want to be a little careful about the inlining heuristic and associated costs, in order to preserve our general "fast compilation" focus. Perhaps we want to only inline explicitly-marked-as-inlinable functions. Or perhaps a bottom-up-over-callgraph-SCCs approach (like LLVM) is still the right one, but with a low cutoff threshold for function size to inline.</p>
</blockquote>



<a name="282000455"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/282000455" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#282000455">(May 11 2022 at 17:30)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/4127#issuecomment-1124052557">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<blockquote>
<p>We will likely want to be a little careful about the inlining heuristic and associated costs, in order to preserve our general "fast compilation" focus.</p>
</blockquote>
<p>I think we will want to use information about the modules that functions come from when deciding whether to inline.</p>
<p>For example, inlining a tiny function from module A into a function in module B makes a lot of sense.</p>
<p>However inlining a tiny function from module A into another function in module A doesn't make sense. If that was profitable, the Wasm-producing toolchain (LLVM 99.99% of the time) would have presumably already done it, and because the toolchain didn't the function was most likely marked the equivalent of <code>#[inline(never)]</code>; we just don't have that attribute/metadata anymore by the time we are compiling the Wasm and therefore don't know why the decision not to inline was made.</p>
<p>Note that this means that the <em>same</em> function could be considered a good candidate for inlining at one call site and a bad candidate for inlining at another call site.</p>
<blockquote>
<p>Perhaps we want to only inline explicitly-marked-as-inlinable functions.</p>
</blockquote>
<p>Who would do mark functions as inlinable? The Wasm won't have any such annotations and it isn't really something that the Wasm frontend can determine on its own in general (mayyyyyyyyybe by looking at Wasm branch hinting annotation and only inlining for hot call sites in hot blocks? Seems easy to get poor heuristics this way and I'd rather intoduce an inlining hint annotation Wasm proposal than seriously pursue this).</p>
</blockquote>



<a name="282002310"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/282002310" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#282002310">(May 11 2022 at 17:45)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4127#issuecomment-1124078388">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<blockquote>
<p>Who would do mark functions as inlinable? The Wasm won't have any such annotations and it isn't really something that the Wasm frontend can determine on its own in general (mayyyyyyyyybe by looking at Wasm branch hinting annotation and only inlining for hot call sites in hot blocks? Seems easy to get poor heuristics this way and I'd rather intoduce an inlining hint annotation Wasm proposal than seriously pursue this).</p>
</blockquote>
<p>For this use-case I'm mostly anticipating Interface Types-like applications: generated adapter functions/thunks/stubs can be explicitly marked as "please inline". This seems like some nice low-hanging fruit in that (i) the Cranelift user (here Wasmtime) might know that some functions are small, by construction, and (ii) there are relatively few of them and they are only one level deep, so this is not blowing up compile-time by inlining everywhere.</p>
</blockquote>



<a name="282008766"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234127%20Cranelift%3A%20develop%20an%20inlining%20pass/near/282008766" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234127.20Cranelift.3A.20develop.20an.20inlining.20pass.html#282008766">(May 11 2022 at 18:30)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4127#issuecomment-1124158041">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4127">issue #4127</a>:</p>
<blockquote>
<blockquote>
<p>However inlining a tiny function from module A into another function in module A doesn't make sense.</p>
</blockquote>
<p>For wasm you are mostly right, although someone may have used <code>#[inline(never)]</code> for debuginfo reasons or to hide UB from the compiler, in which case inlining at clif ir level should be fine I think. For cg_clif inlining within the same module is absolutely necessary.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>