<html>
<head><meta charset="utf-8"><title>wasmtime / issue #7321 Move CLIF legalization into ISLE · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html">wasmtime / issue #7321 Move CLIF legalization into ISLE</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="397884204"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/397884204" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#397884204">(Oct 21 2023 at 23:26)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1773944731">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Adding myself as a reviewer in addition to Trevor as I definitely want to look this over... this is really exciting!</p>
</blockquote>



<a name="397884725"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/397884725" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#397884725">(Oct 21 2023 at 23:38)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1773946212">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>One of the more recent test failures highlights a weakness of this strategy. One of the concerns brought up was that if legalization removes a construct there's nothing preventing optimizations from recreating the construct. That in fact just happened. For example a <code>fcvt_from_uint (splat x)</code> was converted into <code>splat (fcvt_from_uint x)</code> which then failed to codegen on the x64 backend because it no longer implements a lowering for 64-bit <code>fcvt_from_uint</code>. I "fixed" the issue since it only showed up in a pattern where a <code>uextend</code> could be removed which downgraded it to a conversion-from-32-bit integer which works, but that's not a complete fix. The alternative would be to add support to optimizes to understand the current ISA and when appropriate a question could be asked "can I create this node?" and it might return <code>false</code> on some ISAs if it produces something that can't be lowered. Alternatively legalization could run both before and after egraphs, too.</p>
<p>This also reminds me that I have not done requisite performance work for this. I don't think it will have much of an impact on compile time since it's not much different than the previous legalization pass. That being said I should still confirm before landing of course.</p>
</blockquote>



<a name="397886397"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/397886397" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#397886397">(Oct 22 2023 at 00:10)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1773951306">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>One high-level thought: if legalization rewrites were egraph rules, that would allow us to use the cost mechanism to push away from "illegal" outputs for a given ISA: the op we want to legalize away has infinite cost. That would also address one concern I had skimming this just now, namely the <code>ins_...</code> vs. <code>replace_...</code> ctors, which I suppose is an efficiency vs. orthogonality question (egraph rewrites necessarily create new nodes rather than replacing inst-data in place). The other downside is that it would require us to run the egraphs infra even with opts disabled, since legalizations are necessary for compilation to succeed. However we could either exclude the usual body of opt rules and alias-based optimizations, or write a faster toplevel loop that avoids the egraph / elab roundtrip altogether, if that were a concern. The major upside of course is that it puts these rewrites into the one mechanism we have for CLIF-to-CLIF rewrites already (hence simplicity).</p>
</blockquote>



<a name="397886791"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/397886791" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#397886791">(Oct 22 2023 at 00:17)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1773952874">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Ah, and I guess using the egraph pass in this way would also force the question of side-effecting ops -- we need to be able to create new ones, and replace/delete existing ones.</p>
<p>If we keep this as a separate pass for that reason then one possible tweak I'd suggest to the API is to have ctors the same as in the egraph ISLE environment (so <code>(iadd ty x y)</code> rather than <code>ins_iadd</code> / <code>replace_iadd</code>), make them insert before source inst, and have a separate <code>delete</code>; that would make a merging of the layers later a bit easier.</p>
</blockquote>



<a name="397898617"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/397898617" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#397898617">(Oct 22 2023 at 02:45)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1773976722">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @cfallin, @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift", "cranelift:area:aarch64", "cranelift:area:x64", "cranelift:meta", "isle"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>cfallin: isle</li>
<li>fitzgen: isle</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="398110562"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398110562" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398110562">(Oct 23 2023 at 15:28)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1775462145">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Yeah the <code>ins_*</code> and <code>replace_*</code> I wasn't super happy about, and it represents my best attempt to match what the existing legalizations do only in ISLE instead. I do agree it'd be best to have all this in one place rather than two, but one other thing we'd have to figure out for egraphs would be CFG modification which I don't think currently has infrastructure, but probably would be possible? Or I suppose I should clarify that I would not personally feel confident modifying egraphs for this purpose for either handling side-effecting-ops or updating control flow, although I suspect it's still possible.</p>
<p>I originally wanted to reuse the <code>(iadd ...)</code> extract as a constructor as well, similar to how egraphs does it. One problem with this though was that during if the ctor/etor have the same name then they also have to have the same arguments, and I think this only works when the instruction produces a single result (e.g. somewhere to get the type-to-match from). That didn't work for legalizing <code>trapz</code> for example which didn't produce any results.</p>
<p>I do wish there was something better than <code>ins_*</code> and <code>replace_*</code> though because it does feel error-prone. I had a tough time figuring something else out though so I ended up giving up and settling on translating what was preexisting faithfully. Mostly saying this to express my desire to find a better system as well.</p>
</blockquote>



<a name="398330857"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398330857" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398330857">(Oct 24 2023 at 17:16)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777681031">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>CFG modification would be difficult at best in the egraph rewrite infra, because that's not really the paradigm the thing is built around -- the skeleton remains fixed and we deal in value representations. I think I'm settling on "edits to the skeleton are a fundamentally different pass"; that's a much clearer factoring, and points toward this basic design of three passes total -- legalize, opt, lower -- each with different possibilities, namely:</p>
<ul>
<li>
<p>Legalize: 1-to-many expansion; can edit the CFG, can replace side-effecting and multivalue ops. Not meant to be the place for optimizations (identities, etc.); purely meant to be a lowering into a "core CLIF" subset that the selected backend can process. Rewrites are in-place mutations and rules are "directed" -- no multiple-representation possibility.</p>
</li>
<li>
<p>Optimize: many-to-many replacement, on pure ops only. Multiple representations supported, cost function drives the final choice. Meant to get the fixpoint goodness from combination of many identities. Should not re-introduce ops that legalize rewrites out; we may need some mild backend awareness for this to disable some rules (?). Cannot edit the "skeleton" of the CFG of side-effecting ops.</p>
</li>
<li>
<p>Lower: many-to-many expansion into instructions. Should encode whatever priorities and shortcuts are appropriate for the ISA, but should not embody general optimizations (e.g. algebraic rewrites). Cannot edit the CFG.</p>
</li>
</ul>
<p>which is basically what you have in this PR (I just wanted to write it out explicitly here). So the main question IMHO, if this is OK with everyone, is the design around <code>ins_</code> vs. <code>replace_</code>. I do feel that that's too big a footgun to take at the moment. Maybe one alternative could be: all ctors are <code>ins_</code> variants (without the prefix), and we track whether any insts were inserted and delete the original if so? The return type of the <code>legalize</code> entry point could be the values that replace the original inst's values. I think the types of the terms would then be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">bxor</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="n">Inst</span><span class="p">)</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">two_result_inst</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="n">Inst</span><span class="p">)</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">side_effect_no_result_inst</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="n">Inst</span><span class="p">)</span>
</code></pre></div>
<p>then to sketch some more</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">inst_result</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span>
<span class="p">(</span><span class="k">extern</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">inst_result</span><span class="w"> </span><span class="n">inst_result</span><span class="p">)</span>

<span class="p">(</span><span class="k">type</span> <span class="nc">Values</span><span class="w"> </span><span class="p">(</span><span class="k">enum</span>
  <span class="p">(</span><span class="n">Zero</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">One</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="n">Value</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="n">Two</span><span class="w"> </span><span class="p">(</span><span class="n">val1</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">val2</span><span class="w"> </span><span class="n">Value</span><span class="p">))))</span>

<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">legalize</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>

<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_zero</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">return_zero</span><span class="w"> </span><span class="n">inst</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Zero</span><span class="p">))</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">return_one</span><span class="w"> </span><span class="n">inst</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="p">((</span><span class="n">value</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">inst_result</span><span class="w"> </span><span class="n">inst</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">One</span><span class="w"> </span><span class="n">value</span><span class="p">)))</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">;;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span>

<span class="p">;;</span><span class="w"> </span><span class="n">convenience</span><span class="w"> </span><span class="n">converter</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">get_only_result</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span>
<span class="p">(</span><span class="k">extern</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">get_only_result</span><span class="w"> </span><span class="n">get_only_result</span><span class="p">)</span>
<span class="p">(</span><span class="n">convert</span><span class="w"> </span><span class="n">Inst</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">get_only_result</span><span class="p">)</span>

<span class="p">;;</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="kr">do</span>:

<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">legalize</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I128</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">a_lo</span><span class="w"> </span><span class="n">a_hi</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">isplit</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">b_lo</span><span class="w"> </span><span class="n">b_hi</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">isplit</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="p">((</span><span class="n">lo</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">a_lo</span><span class="w"> </span><span class="n">a_hi</span><span class="p">))</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="n">converter</span>
<span class="w">          </span><span class="p">(</span><span class="n">hi</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">b_lo</span><span class="w"> </span><span class="n">b_hi</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">)))</span>
</code></pre></div>
<p>and given the rule that emitting any inst deletes the original, and its results are aliased to the return values, this should work. Thoughts?</p>
</blockquote>



<a name="398330958"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398330958" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398330958">(Oct 24 2023 at 17:17)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777681031">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>CFG modification would be difficult at best in the egraph rewrite infra, because that's not really the paradigm the thing is built around -- the skeleton remains fixed and we deal in value representations. I think I'm settling on "edits to the skeleton are a fundamentally different pass"; that's a much clearer factoring, and points toward this basic design of three passes total -- legalize, opt, lower -- each with different possibilities, namely:</p>
<ul>
<li>
<p>Legalize: 1-to-many expansion; can edit the CFG, can replace side-effecting and multivalue ops. Not meant to be the place for optimizations (identities, etc.); purely meant to be a lowering into a "core CLIF" subset that the selected backend can process. Rewrites are in-place mutations and rules are "directed" -- no multiple-representation possibility.</p>
</li>
<li>
<p>Optimize: many-to-many replacement, on pure ops only. Multiple representations supported, cost function drives the final choice. Meant to get the fixpoint goodness from combination of many identities. Should not re-introduce ops that legalize rewrites out; we may need some mild backend awareness for this to disable some rules (?). Cannot edit the "skeleton" of the CFG of side-effecting ops.</p>
</li>
<li>
<p>Lower: many-to-many expansion into instructions. Should encode whatever priorities and shortcuts are appropriate for the ISA, but should not embody general optimizations (e.g. algebraic rewrites). Cannot edit the CFG.</p>
</li>
</ul>
<p>which is basically what you have in this PR (I just wanted to write it out explicitly here). So the main question IMHO, if this is OK with everyone, is the design around <code>ins_</code> vs. <code>replace_</code>. I do feel that that's too big a footgun to take at the moment. Maybe one alternative could be: all ctors are <code>ins_</code> variants (without the prefix), and we track whether any insts were inserted and delete the original if so? The return type of the <code>legalize</code> entry point could be the values that replace the original inst's values. I think the types of the terms would then be:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">bxor</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="n">Inst</span><span class="p">)</span>
</code></pre></div>
<p>then to sketch some more</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">inst_result</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span>
<span class="p">(</span><span class="k">extern</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">inst_result</span><span class="w"> </span><span class="n">inst_result</span><span class="p">)</span>

<span class="p">(</span><span class="k">type</span> <span class="nc">Values</span><span class="w"> </span><span class="p">(</span><span class="k">enum</span>
  <span class="p">(</span><span class="n">Zero</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">One</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="n">Value</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="n">Two</span><span class="w"> </span><span class="p">(</span><span class="n">val1</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">val2</span><span class="w"> </span><span class="n">Value</span><span class="p">))))</span>

<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">legalize</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>

<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_zero</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">return_zero</span><span class="w"> </span><span class="n">inst</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Zero</span><span class="p">))</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">return_one</span><span class="w"> </span><span class="n">inst</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="p">((</span><span class="n">value</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">inst_result</span><span class="w"> </span><span class="n">inst</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">One</span><span class="w"> </span><span class="n">value</span><span class="p">)))</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Values</span><span class="p">)</span>
<span class="p">;;</span><span class="w"> </span><span class="o">..</span><span class="p">.</span>

<span class="p">;;</span><span class="w"> </span><span class="n">convenience</span><span class="w"> </span><span class="n">converter</span>
<span class="p">(</span><span class="n">decl</span><span class="w"> </span><span class="n">get_only_result</span><span class="w"> </span><span class="p">(</span><span class="n">Inst</span><span class="p">)</span><span class="w"> </span><span class="n">Value</span><span class="p">)</span>
<span class="p">(</span><span class="k">extern</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">get_only_result</span><span class="w"> </span><span class="n">get_only_result</span><span class="p">)</span>
<span class="p">(</span><span class="n">convert</span><span class="w"> </span><span class="n">Inst</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">get_only_result</span><span class="p">)</span>

<span class="p">;;</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="kr">do</span>:

<span class="p">(</span><span class="n">rule</span><span class="w"> </span><span class="p">(</span><span class="n">legalize</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I128</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">a_lo</span><span class="w"> </span><span class="n">a_hi</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">isplit</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">b_lo</span><span class="w"> </span><span class="n">b_hi</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">return_two</span><span class="w"> </span><span class="p">(</span><span class="n">isplit</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">b</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="p">((</span><span class="n">lo</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">a_lo</span><span class="w"> </span><span class="n">a_hi</span><span class="p">))</span><span class="w"> </span><span class="p">;;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="n">converter</span>
<span class="w">          </span><span class="p">(</span><span class="n">hi</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">(</span><span class="n">bxor</span><span class="w"> </span><span class="cp">$I64</span><span class="w"> </span><span class="n">b_lo</span><span class="w"> </span><span class="n">b_hi</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="n">Values</span><span class="p">.</span><span class="n">Two</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">)))</span>
</code></pre></div>
<p>and given the rule that emitting any inst deletes the original, and its results are aliased to the return values, this should work. Thoughts?</p>
</blockquote>



<a name="398333246"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398333246" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398333246">(Oct 24 2023 at 17:35)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777711385">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>(And on a little further thought, with some more autoconversions, the <code>return_two</code> bit could go away too)</p>
</blockquote>



<a name="398333423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398333423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398333423">(Oct 24 2023 at 17:36)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777713606">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<blockquote>
<p>Optimize: Should not re-introduce ops that legalize rewrites out; we may need some mild backend awareness for this to disable some rules (?).</p>
</blockquote>
<p>I'm slightly concerned about this, I think we are going to run into a lot of these situations. Not for i128, those are fairly hard operations to recognize.</p>
<p>But here's an example: (or (ishl x) (ushr x)) -&gt; (rotl x) is a transformation that I think would be worth having at the midend, however that is exactly something that we also need to legalize away in RISC-V (if we don't have a certain extension).</p>
<p>So in this case we would also have to disable that rule for the RISC-V backend, if the <code>x</code> flag was not present.<br>
We have a <strong>lot</strong> of these situation in the RISC-V backend, and my concern is that all of them are also good candidates to invert and say, hey this is also a good midend rule! (It's how I found most of the rule's I've added!)</p>
<p>Which worries me because, we now either have to have a lot of checks in the midend for X arch with Y extension. Or avoid adding rules. RISC-V is particularly bad here since we don't support a lot without extensions, so it might be that we end up adding a lot of legalization rules.</p>
</blockquote>



<a name="398333502"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398333502" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398333502">(Oct 24 2023 at 17:37)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777713606">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<blockquote>
<p>Optimize: Should not re-introduce ops that legalize rewrites out; we may need some mild backend awareness for this to disable some rules (?).</p>
</blockquote>
<p>I'm slightly concerned about this, I think we are going to run into a lot of these situations. Not for i128, those are fairly hard operations to recognize.</p>
<p>But here's an example: <code>(or (ishl x) (ushr x)) -&gt; (rotl x)</code> is a transformation that I think would be worth having at the midend, however that is exactly something that we also need to legalize away in RISC-V (if we don't have a certain extension).</p>
<p>So in this case we would also have to disable that rule for the RISC-V backend, if the <code>x</code> flag was not present.<br>
We have a <strong>lot</strong> of these situation in the RISC-V backend, and my concern is that all of them are also good candidates to invert and say, hey this is also a good midend rule! (It's how I found most of the rule's I've added!)</p>
<p>Which worries me because, we now either have to have a lot of checks in the midend for X arch with Y extension. Or avoid adding rules. RISC-V is particularly bad here since we don't support a lot without extensions, so it might be that we end up adding a lot of legalization rules.</p>
</blockquote>



<a name="398335253"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398335253" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398335253">(Oct 24 2023 at 17:50)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777734270">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>@afonso360 I agree, but I think that's pretty fundamental here: if we start making backends require a specific subset of total CLIF after opts, then we'll have to be aware of that when rewriting CLIF; the alternative I guess is doing legalization <em>after</em> optimization, which is effectively what we do today (in the sense that the legalization -- expansion of i128 ops etc -- is folded into the lowering) but loses optimization opportunities.</p>
<p>Said another way I think there are two separate choices here: what we legalize, and when we legalize. This discussion is about when we legalize (and carries the observation that if we legalize before rewrites, those rewrites need to preserve the legalized subset); but we haven't expanded <em>what</em> we legalize yet, and that's what causes the real issue. If we were to legalize rotates into something else in today's (pre-optimization) legalization phase we'd hit the same issues that you're describing, I think -- we're OK mainly because we legalize away fairly little (the <code>_imm</code> ops, table ops, global values) at the moment.</p>
</blockquote>



<a name="398336505"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398336505" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398336505">(Oct 24 2023 at 17:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777749683">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>One option would perhaps be to start running legalization twice? Once before egraphs and once after. Legalization might not expand <code>rotr</code> in the pre-egraph-pass but only in the post-egraph pass. In the theory that legalization isn't too expensive (mostly just an iteration of the IR) it in theory shouldn't add too much cost.</p>
</blockquote>



<a name="398552510"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/398552510" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#398552510">(Oct 25 2023 at 19:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1779963799">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Conclusions from <a href="https://github.com/bytecodealliance/meetings/blob/main/cranelift/2023/cranelift-10-25.md">today's meeting</a> (please correct me if I'm wrong):</p>
<ul>
<li>Replace <code>ins_*</code> and <code>replace_*</code> with a single constructor as (<a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1777681031">described above</a>).</li>
<li>Add per-backend cost functions to assign a high cost to any instruction which can't be natively lowered to prevent egraphs from generating it.</li>
<li>Only run lowering once before egraphs.<br>
</li>
</ul>
</blockquote>



<a name="401860824"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/401860824" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#401860824">(Nov 13 2023 at 23:11)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1809281134">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Ok I've come back to this and I've implemented the first piece which is to unify the ctors/etors into one. The downside of that commit, however, is that there's quite a few changes in the test suite, not all of which are positive I think. For example I saw a number of x64 <code>add</code> instructions turn into <code>lea</code>.</p>
<p>Additionally as I've dug in more, I'm not actually sure how to implement the cost function. The nuances of what can and cannot be codegen'd cannot be represented currently in the cost model and what the inputs are. For example given the legalization implemented in this PR the x64 backend cannot codegen <code>fcvt_from_uint</code> but only when the input is a 64-bit type. This means that neither the opcode nor the result type of the instruction is sufficient to determine whether something has a high cost or not, only in combination in this opcode does it become high cost. I couldn't at least initially myself see how to slot that in.</p>
<p>Now one answer could perhaps be "well we just can't legalize that and the backend must support it". I'm not sure how to best handle that.</p>
</blockquote>



<a name="402036456"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/402036456" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#402036456">(Nov 14 2023 at 17:43)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1810794112">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<blockquote>
<p>This means that neither the opcode nor the result type of the instruction is sufficient to determine whether something has a high cost or not, only in combination in this opcode does it become high cost. I couldn't at least initially myself see how to slot that in.</p>
</blockquote>
<p>We can't pass both of those to the cost function?</p>
</blockquote>



<a name="402038790"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%237321%20Move%20CLIF%20legalization%20into%20ISLE/near/402038790" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.237321.20Move.20CLIF.20legalization.20into.20ISLE.html#402038790">(Nov 14 2023 at 17:57)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7321#issuecomment-1810832293">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7321">issue #7321</a>:</p>
<blockquote>
<p>Ah sorry I should speak a bit more precisely. Yes both types can be passed in by I gave the wrong impression that this would be sufficient. Instead what actually needs to happen is that a <code>fcvt_from_uint</code> instruction can only fail to be generated on x64 if the input type is i64. The opcode plus the control type (either f32 or f64 in this case) doesn't contain the information about the operand.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>