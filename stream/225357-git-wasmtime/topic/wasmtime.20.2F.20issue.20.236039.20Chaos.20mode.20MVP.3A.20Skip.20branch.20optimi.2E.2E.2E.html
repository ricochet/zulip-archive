<html>
<head><meta charset="utf-8"><title>wasmtime / issue #6039 Chaos mode MVP: Skip branch optimi... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html">wasmtime / issue #6039 Chaos mode MVP: Skip branch optimi...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="342522177"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342522177" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342522177">(Mar 17 2023 at 10:36)</a>:</h4>
<p>afonso360 <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1473632443">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<p>Maybe someone has an intuition along the lines of: "Oh yes, of course that will fail when branch optimization is randomly skipped", or similar? </p>
</blockquote>
<p>I suspect that might be the case. The <code>icache</code> fuzzer tests that our function cache is working properly. It does this by generating a random function, applying a random mutation and the recompiling and checking if the cache key matches or not.</p>
<p>In this case what I suspect might be happening is that It selected that no mutation should be applied and the cache key should be valid. But if we skip branch opts in the recompile and not in the original compilation or vice-versa, then it should panic! (This is a guess, I'm not too familiar with how our caching mechanism works)</p>
<p>For icache it would be nice to reset the bytes on the second recompile so that we make the same decisions along the way.</p>
</blockquote>



<a name="342522374"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342522374" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342522374">(Mar 17 2023 at 10:37)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1473632443">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<p>Maybe someone has an intuition along the lines of: "Oh yes, of course that will fail when branch optimization is randomly skipped", or similar? </p>
</blockquote>
<p>I suspect that might be the case. The <code>icache</code> fuzzer tests that our function cache is working properly. It does this by generating a random function, applying a random mutation and the recompiling and checking if the cache key matches or not.</p>
<p>In this case what I suspect might be happening is that It selected that no mutation should be applied and the cache key should be valid. But if we skip branch opts in the recompile and not in the original compilation or vice-versa, then it should panic! (This is a guess, I'm not too familiar with how our caching mechanism works)</p>
<p>For icache it would be nice to reset the chaos engine bytes on the second recompile so that we make the same decisions along the way.</p>
</blockquote>



<a name="342522583"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342522583" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342522583">(Mar 17 2023 at 10:38)</a>:</h4>
<p>afonso360 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1473632443">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<p>Maybe someone has an intuition along the lines of: "Oh yes, of course that will fail when branch optimization is randomly skipped", or similar? </p>
</blockquote>
<p>I suspect that might be the case. The <code>icache</code> fuzzer tests that our function cache is working properly. It does this by generating a random function, applying a random mutation and then recompiling and checking if the cache key matches or not.</p>
<p>In this case what I suspect might be happening is that It selected that no mutation should be applied and the cache key should be valid. But if we skip branch opts in the recompile and not in the original compilation or vice-versa, then it should panic! (This is a guess, I'm not too familiar with how our caching mechanism works)</p>
<p>For icache it would be nice to reset the chaos engine bytes on the second recompile so that we make the same decisions along the way.</p>
</blockquote>



<a name="342637651"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342637651" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342637651">(Mar 17 2023 at 18:20)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474232845">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>Thanks so much for making a start on this problem -- the infrastructure will surely pay off in a bunch of ways!</p>
<p>I've read over most of this prototype; but before a detailed line-by-line review, I wanted to offer some high-level design feedback. I think it might be related to (or rather, might address) the issue with the <code>icache</code> fuzzer above too.</p>
<ul>
<li>I'd prefer if we actually generalize just a <em>little</em> bit more and call the struct that is threaded through the compilation pipeline the <code>ControlPlane</code>; this abstracts over randomized decisions (chaos mode) but also optimization fuel and maybe user-directed optimization instructions and the like later. So, would you mind renaming both the types and the crate itself (maybe <code>cranelift-control</code>, though bikeshed comments welcome here)?</li>
<li>In general, we want to avoid unsafe code as much as possible. The "self-referential struct trick" wherein there's a <code>Vec</code> and then there's an <code>Unstructured</code> that holds a borrow to that <code>Vec</code>'s contents, transmuted to erase the lifetime and get a <code>&amp;'static</code>, is simply too unsafe for us to include in Cranelift code...</li>
<li>... fortunately, though, I suspect it's not really necessary. I suspect that much of the trouble comes from trying to hold ownership of the <code>ChaosEngine</code> in various places, rather than threading it through the stack as needed. I suspect it should be possible, in principle to have a <code>ControlPlane</code> such that:<ul>
<li>We have <code>&amp;mut self</code> methods that ask it for decisions;</li>
<li>We pass a <code>&amp;mut ControlPlane</code> into toplevel compilation entry points, and down the stack as necessary;</li>
<li>If we need to (e.g. when building the <code>Lower</code> context), we can store a <code>&amp;'a mut ControlPlane</code>, but that <code>'a</code> is internal to the compiler, and not exposed to the top-level entry point.</li>
<li>This <code>ControlPlane</code> should itself not have any lifetime parameters, ideally. I suspect that means we don't actually hold an <code>Unstructured</code>, since it expects to borrow data owned elsewhere; rather for now we can implement our own sort of equivalent, where we keep e.g. a <code>Vec&lt;bool&gt;</code> and take decisions off the back of it. (e.g., <code>self.chaos_decisions.pop().unwrap_or(false)</code> or something similar.)</li>
<li>We can then impl <code>Arbitrary</code> for <code>ControlPlane</code>, perhaps just the automatic derivation, and use this when fuzzing: take an arbitrary <code>Function</code> and compile it with an arbitrary <code>ControlPlane</code>.</li>
</ul>
</li>
<li>The sharing of the <code>ChaosEngine</code> via an <code>Arc</code>, and the <code>Mutex</code> and such, are another red flag and warning that we're going down a nondeterministic path. I suspect this is a contributing factor to the <code>icache</code> fuzzer issues above. The issue is that it allows different parts of the compiler to pull random choices in some potentially unordered way, potentially across threads, and that gives up reproducibility. Instead, we should have one <code>ControlPlane</code> per function, because that is the unit of compilation in Cranelift. At the fuzzer level, we can easily ask for a <code>Vec&lt;ControlPlane&gt;</code>; that automatically impls <code>Arbitrary</code> if <code>ControlPlane</code> does.</li>
</ul>
<p>Does that make some sense at least? Basically, I want to push this all toward a more idiomatic Rust ownership model, which I think will have the side-effect of removing nondeterminism and making compilation a true pure function of a "control" input for one function body.</p>
</blockquote>



<a name="342673035"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342673035" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342673035">(Mar 17 2023 at 22:11)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474453678">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>Thank you both for the great feedback!</p>
<p>I totally agree that a more idiomatic Rust ownership model would be much better. I remember starting out with mutable references and running into compiler errors about mutable aliasing. I was concerned there could be way too many of these issues while threading the control plane through every code path, and I didn't know how difficult it would be. I probably was scared away too easily. I'll have another go at implementing it that way.</p>
<p>I understand that the use of <code>unsafe</code> for storing an <code>Unstructured</code> is a non-starter. The nice thing about it would've been that we get all the functionality of <code>arbitrary</code> for free and the API of the control plane would be very flexible with little effort. I'm still feeling a bit unsure about taking the manual approach. Not primarily because it would be more work, but because I expect the work would in many cases just be reimplementing <code>Unstructured</code>. And probably even in a worse way: Casually reading the source code of <code>arbitrary</code>, I'm seeing comments like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// Take lengths from the end of the data, since the `libFuzzer` folks</span>
<span class="c1">// found that this lets fuzzers more efficiently explore the input</span>
<span class="c1">// space.</span>
</code></pre></div>
<p>I'm sure we would miss such fuzzing specific optimizations if we reimplemented it ourselves, degrading the efficiency of our fuzz testing. On the other hand, we could just liberally copy-paste from the source code of <code>arbitrary</code> whatever we need, only adapting it so it works on an owned vector of bytes instead of a slice with some lifetime?</p>
<p>I'm just thinking it's a little sad that a small thing like a lifetime would stand in the way of such a good opportunity of code reuse <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
</blockquote>



<a name="342680745"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342680745" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342680745">(Mar 17 2023 at 23:08)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474498031">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>Yeah, that's fair -- I suppose it's not the worst thing in the world to take a <code>ctrl_plane: &amp;mut ControlPlane&lt;'_&gt;</code> everywhere and then keep an <code>Unstructured</code> inside. Ideally then the way we cut off lifetime proliferation is to be strict about passing this down the stack only, and not storing it in structs (requiring an extra lifetime to that struct). A prototype of this option would probably tell us pretty quickly how tenable that is!</p>
</blockquote>



<a name="342752870"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342752870" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342752870">(Mar 18 2023 at 10:42)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474809018">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<p>We have <code>&amp;mut self</code> methods that ask it for decisions</p>
</blockquote>
<p>Another question that came up while we tried that at the beginning was about the size of this. A simple test indicates that references to zero-sized types are <em>not</em> optimized away:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 8...</span>
</code></pre></div>
<p>Am I missing something with that? How can we be certain that the performance of release builds is not affected?</p>
</blockquote>



<a name="342779681"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342779681" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342779681">(Mar 18 2023 at 13:10)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474848094">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>Instead of passing <code>&amp;mut ControlPlane&lt;'_&gt;</code> you could pass <code>ControlPlane&lt;'_&gt;</code> and add a <code>as_mut()</code> method which takes <code>&amp;mut self</code> and returns another <code>ControlPlane&lt;'_&gt;</code> which can be used to pass <code>ControlPlane&lt;'_&gt;</code> to multiple functions. Then <code>ControlPlane&lt;'_&gt;</code> could be a mutable reference during fuzzing and a ZST when not fuzzing.</p>
</blockquote>



<a name="342806865"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342806865" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342806865">(Mar 18 2023 at 16:01)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474887198">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>I think I'm misunderstanding something, the function signature you're describing looks like this, right? (ignoring the lifetimes)</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">ControlPlane</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ?</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>I don't know how this function can be written without reference counting?</p>
</blockquote>



<a name="342821761"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342821761" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342821761">(Mar 18 2023 at 17:59)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474932898">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>You did do something like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ControlPlaneInner</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ControlPlane</span><span class="p">(</span><span class="cm">/*this does an implicit reborrow*/</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>And then use it like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">control_plane</span>: <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">baz</span><span class="p">(</span><span class="n">control_plane</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Playground link: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5</a></p>
</blockquote>



<a name="342821923"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342821923" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342821923">(Mar 18 2023 at 18:00)</a>:</h4>
<p>bjorn3 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474932898">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>You did do something like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ControlPlaneInner</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Reborrow `ControlPlane`.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ControlPlane</span><span class="p">(</span><span class="cm">/*this does an implicit reborrow*/</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>And then use it like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">control_plane</span>: <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">baz</span><span class="p">(</span><span class="n">control_plane</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Playground link: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5</a></p>
</blockquote>



<a name="342822063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342822063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342822063">(Mar 18 2023 at 18:01)</a>:</h4>
<p>bjorn3 edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474932898">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>You did do something like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span> <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;'</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ControlPlaneInner</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Reborrow `ControlPlane`.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ControlPlane</span><span class="p">(</span><span class="cm">/*this does an implicit reborrow*/</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// Equivalent to:</span>
<span class="w">        </span><span class="c1">// ControlPlane(&amp;mut *self.0)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>And then use it like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">control_plane</span>: <span class="nc">ControlPlane</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="n">control_plane</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span>
<span class="w">    </span><span class="n">baz</span><span class="p">(</span><span class="n">control_plane</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Playground link: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5cde2151f4f2b1c6a9ad5ea959b2f5f5</a></p>
</blockquote>



<a name="342827993"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342827993" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342827993">(Mar 18 2023 at 18:53)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474954679">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>I'm sure we would miss such fuzzing specific optimizations if we reimplemented it ourselves, degrading the efficiency of our fuzz testing. On the other hand, we could just liberally copy-paste from the source code of arbitrary whatever we need, only adapting it so it works on an owned vector of bytes instead of a slice with some lifetime?</p>
<p>I'm just thinking it's a little sad that a small thing like a lifetime would stand in the way of such a good opportunity of code reuse <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
</blockquote>
<p>Yeah, that's fair -- I suppose it's not the worst thing in the world to take a <code>ctrl_plane: &amp;mut ControlPlane&lt;'_&gt;</code> everywhere and then keep an <code>Unstructured</code> inside. Ideally then the way we cut off lifetime proliferation is to be strict about passing this down the stack only, and not storing it in structs (requiring an extra lifetime to that struct). A prototype of this option would probably tell us pretty quickly how tenable that is!</p>
</blockquote>
<p>I let this bounce around in my head a bit more and I think I'm coming back to my original position: it's probably better not to carry the fuzzing-specific <code>Unstructured</code> everywhere, and instead build an abstraction around it. I got to this position by starting with a separation-of-concerns mindset but I think it has other nice properties.</p>
<p>I think I want the design to follow these principles:</p>
<ul>
<li>Compilation output of some CLIF is a function of that CLIF, compiler settings, and a <code>ControlPlane</code> composed of Rust primitives (<code>bool</code>s, later a fuel counter, etc);</li>
<li>The fuzzing infrastructure can create these <code>ControlPlane</code>s with an <code>Arbitrary</code> impl.</li>
</ul>
<p>This has a few nice properties:</p>
<ul>
<li>It avoids lifetime proliferation.</li>
<li>It allows us to more naturally handle the multiple-function case: it's much easier to ask a top-level <code>Unstructured</code> for a <code>Vec&lt;bool&gt;</code> per function than it is to somehow try to split the random input into chunks.</li>
<li>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</li>
<li>It means that we don't have to propagate "not enough data" errors upward from <code>Unstructured</code>.</li>
<li>It means that we could later drive the mechanism with some other source of decisions; we're not tied to <code>arbitrary</code>.</li>
</ul>
<p>Basically, the compiler's core is too late for construction of structured data from random bytes; we should build an input for the compiler that is just plain data. That leads to less friction with Rust's ownership model as well as more determinism and control.</p>
<p>IMHO the "reimplement <code>Arbitrary</code>" concern is somewhat smaller in comparison: we shouldn't have to implement any of the detailed logic but rather the "pop a <code>bool</code> off a <code>Vec</code>" approach, and likewise for other data types we need. It's true that the fuzzer may give us only <code>N</code> bools in our <code>Vec&lt;bool&gt;</code>, and a particular compilation path asks for <code>M &gt; N</code> bools (the last <code>M - N</code> of which are just defaulted to <code>false</code>); but libFuzzer is generally good about learning the structure of data that leads to better coverage.</p>
<p>Finally, a thought on zero-sized types: I think it will be fine to take the cost of an extra parameter <code>&amp;mut ControlPlane</code>; as long as its methods in a chaos-disabled build return constants, and the <code>ControlPlane</code> itself is zero-sized, my intuition is that this will be minimal. (Basically, we're not injecting new paths into any hot loops, we're just adding one live <code>usize</code>-sized value passed into a few functions per compilation.) If it turns out to be measurable then we can definitely revisit but let's not worry much until we see that impact, IMHO.</p>
</blockquote>



<a name="342829350"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342829350" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342829350">(Mar 18 2023 at 19:06)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1474954679">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>I'm sure we would miss such fuzzing specific optimizations if we reimplemented it ourselves, degrading the efficiency of our fuzz testing. On the other hand, we could just liberally copy-paste from the source code of arbitrary whatever we need, only adapting it so it works on an owned vector of bytes instead of a slice with some lifetime?</p>
<p>I'm just thinking it's a little sad that a small thing like a lifetime would stand in the way of such a good opportunity of code reuse <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>
</blockquote>
<p>Yeah, that's fair -- I suppose it's not the worst thing in the world to take a <code>ctrl_plane: &amp;mut ControlPlane&lt;'_&gt;</code> everywhere and then keep an <code>Unstructured</code> inside. Ideally then the way we cut off lifetime proliferation is to be strict about passing this down the stack only, and not storing it in structs (requiring an extra lifetime to that struct). A prototype of this option would probably tell us pretty quickly how tenable that is!</p>
</blockquote>
<p>I let this bounce around in my head a bit more and I think I'm coming back to my original position: it's probably better not to carry the fuzzing-specific <code>Unstructured</code> everywhere, and instead build an abstraction around it. I got to this position by starting with a separation-of-concerns mindset but I think it has other nice properties.</p>
<p>I think I want the design to follow these principles:</p>
<ul>
<li>Compilation output of some CLIF is a function of that CLIF, compiler settings, and a <code>ControlPlane</code> composed of Rust primitives (<code>bool</code>s, later a fuel counter, etc);</li>
<li>The fuzzing infrastructure can create these <code>ControlPlane</code>s with an <code>Arbitrary</code> impl.</li>
</ul>
<p>This has a few nice properties:</p>
<ul>
<li>It avoids lifetime proliferation.</li>
<li>It allows us to more naturally handle the multiple-function case: it's much easier to ask a top-level <code>Unstructured</code> for a <code>Vec&lt;bool&gt;</code> per function than it is to somehow try to split the random input into chunks.</li>
<li>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</li>
<li>It means that we don't have to propagate "not enough data" errors upward from <code>Unstructured</code>.</li>
<li>It means that we could later drive the mechanism with some other source of decisions; we're not tied to <code>arbitrary</code>.</li>
</ul>
<p>Basically, the compiler's core is too late for construction of structured data from random bytes; we should build an input for the compiler that is just plain (structured) data. That leads to less friction with Rust's ownership model as well as more determinism and control.</p>
<p>IMHO the "reimplement <code>Arbitrary</code>" concern is somewhat smaller in comparison: we shouldn't have to implement any of the detailed logic but rather the "pop a <code>bool</code> off a <code>Vec</code>" approach, and likewise for other data types we need. It's true that the fuzzer may give us only <code>N</code> bools in our <code>Vec&lt;bool&gt;</code>, and a particular compilation path asks for <code>M &gt; N</code> bools (the last <code>M - N</code> of which are just defaulted to <code>false</code>); but libFuzzer is generally good about learning the structure of data that leads to better coverage.</p>
<p>Finally, a thought on zero-sized types: I think it will be fine to take the cost of an extra parameter <code>&amp;mut ControlPlane</code>; as long as its methods in a chaos-disabled build return constants, and the <code>ControlPlane</code> itself is zero-sized, my intuition is that this will be minimal. (Basically, we're not injecting new paths into any hot loops, we're just adding one live <code>usize</code>-sized value passed into a few functions per compilation.) If it turns out to be measurable then we can definitely revisit but let's not worry much until we see that impact, IMHO.</p>
</blockquote>



<a name="342932879"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342932879" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342932879">(Mar 19 2023 at 13:08)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[ ] Don't make use of unsafe and implement our own, similar functionality according to our needs.</li>
</ul>
<hr>
<h2>non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>:</h2>
<p>approaches:</p>
<ul>
<li>[ ] Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</li>
<li>[ ] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="342932998"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342932998" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342932998">(Mar 19 2023 at 13:09)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[ ] Don't make use of unsafe and implement our own, similar functionality according to our needs.</li>
</ul>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>:</h2>
<p>approaches:</p>
<ul>
<li>[ ] Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</li>
<li>[ ] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="342947094"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342947094" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342947094">(Mar 19 2023 at 14:49)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[ ] Don't make use of unsafe and implement our own, similar functionality according to our needs.</li>
</ul>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code></h2>
<p>approaches:</p>
<ul>
<li>[ ] Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</li>
<li>[ ] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="342947186"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342947186" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342947186">(Mar 19 2023 at 14:50)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also a bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[ ] Don't make use of unsafe and implement our own, similar functionality according to our needs.</li>
</ul>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code></h2>
<p>approaches:</p>
<ul>
<li>[ ] Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</li>
<li>[ ] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="342954060"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342954060" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342954060">(Mar 19 2023 at 15:29)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also a bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/3">https://github.com/remlse/wasmtime/pull/3</a></li>
</ul>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code></h2>
<p>approaches:</p>
<ul>
<li>[ ] Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</li>
<li>[ ] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="342977305"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342977305" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342977305">(Mar 19 2023 at 18:50)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475359467">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>I would prefer if we went with a <code>&amp;mut ControlPlane</code> as well, rather than subverting the ownership system with a <code>Rc&lt;RefCell&lt;ControlPlane&gt;&gt;</code>. Given the uncertainty here, I want to understand a bit more: are you proposing the alternative because you'd rather not have to pass an extra function parameter? Or for some other reason?</p>
<p>In addition to the disadvantages you named, using a <code>RefCell</code> <em>will</em> actually have a measurable impact on compile time, I suspect: every query of the control plane in an inner loop will require a dynamically-checked borrow. This alone is reason not to do it IMHO. There's also the fact that if stored anywhere, it would make data structures <code>!Send</code> which is problematic for our internal compilation parallelism.</p>
<p>But the other argument I would  make is that subverting the Rust ownership model should not be a "why not" sort of design choice, but should be a "why is this the only possibility" sort of discussion. The alternative proposed here is "just pass a <code>&amp;mut</code> around" and I don't really see the downsides. In particular, this statement</p>
<blockquote>
<p>If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
</blockquote>
<p>is somewhat perplexing and is exactly the opposite of my experience with building large systems with Rust. Internal mutability is a "cheat code" that arises because of unavoidable pressure from the outside. The <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> pattern is a bit of a crutch, in that it emulates how one can write code in other languages with less restrictive sharing of aliases; as a result, it is sort of a way to give up on thinking through the ownership model, and can result in unexpected logic bugs, as we've seen here already with nondetermism. I would expect that, contrary to such a context parameter "getting in the way", this internal-mutability trick would get in the way by violating expectations and leading to all sorts of issues.</p>
<p>The "better developer experience" bit I would question specifically: what downsides are we avoiding by not passing a <code>&amp;mut</code> context parameter around? Just that (the need for the parameter)? Or a perceived difficulty with <code>&amp;mut</code> references in general? Or something else?</p>
<p>Anyway, given all that, I would really strongly prefer the suggestions I gave above: a <code>&amp;mut ControlPlane</code>, passed as a normal function parameter; no internal mutability or other trickery, only idiomatic Rust; and for now let's not try to make the borrow itself zero-sized, because that adds complexity and I suspect won't matter much.</p>
</blockquote>



<a name="342977659"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342977659" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342977659">(Mar 19 2023 at 18:54)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475359467">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>I would prefer if we went with a <code>&amp;mut ControlPlane</code> as well, rather than subverting the ownership system with a <code>Rc&lt;RefCell&lt;ControlPlane&gt;&gt;</code>. Given the uncertainty here, I want to understand a bit more: are you proposing the alternative because you'd rather not have to pass an extra function parameter? Or for some other reason?</p>
<p>In addition to the disadvantages you named, using a <code>RefCell</code> <em>will</em> actually have a measurable impact on compile time, I suspect: every query of the control plane in an inner loop will require a dynamically-checked borrow. This alone is reason not to do it IMHO. There's also the fact that if stored anywhere, it would make data structures <code>!Send</code> which is problematic for our internal compilation parallelism.</p>
<p>But the other argument I would  make is that subverting the Rust ownership model should not be a "why not" sort of discussion, but should be a "why is this the only possibility" sort of discussion. The alternative proposed here is "just pass a <code>&amp;mut</code> around" and I don't really see the downsides. In particular, this statement</p>
<blockquote>
<p>If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
</blockquote>
<p>is somewhat perplexing and is exactly the opposite of my experience with building large systems with Rust. Internal mutability is a "cheat code" that arises because of unavoidable pressure from the outside. The <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> pattern is a bit of a crutch, in that it emulates how one can write code in other languages with less restrictive sharing of aliases; as a result, it is sort of a way to give up on thinking through the ownership model, and can result in unexpected logic bugs, as we've seen here already with nondetermism. I would expect that, contrary to such a context parameter "getting in the way", this internal-mutability trick would get in the way by violating expectations and leading to all sorts of issues.</p>
<p>The "better developer experience" bit I would question specifically: what downsides are we avoiding by not passing a <code>&amp;mut</code> context parameter around? Just that (the need for the parameter)? Or a perceived difficulty with <code>&amp;mut</code> references in general? Or something else?</p>
<p>Anyway, given all that, I would really strongly prefer the suggestions I gave above: a <code>&amp;mut ControlPlane</code>, passed as a normal function parameter; no internal mutability or other trickery, only idiomatic Rust; and for now let's not try to make the borrow itself zero-sized, because that adds complexity and I suspect won't matter much.</p>
</blockquote>



<a name="342980986"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342980986" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342980986">(Mar 19 2023 at 19:30)</a>:</h4>
<p>iximeow <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475374504">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>just in the interest of being explicit: i think part of the feedback here is, _if there is an overhead for passing <code>&amp;mut ControlPlane</code> around, it is overhead Cranelift would need to deal with at some point in the future anyway, for other reasons [like user-directed opt hints or optimization fuel], so that definitely won't be held against your MVP here_. doing the simple thing with <code>&amp;mut ControlPlane</code> is Probably Fine, and the relative benefit of having <code>Chaos mode</code> in the compiler almost certainly outweighs a small compile time regression if one is measurable.</p>
<p>(also, i think the trick about holding a <code>&amp;'a mut ControlPlaneInner</code> actually ensures that <code>ControlPlane</code> is _always_ a <code>usize</code> - a ref of a zero-size type is still a reference and still a <code>usize</code> wide. <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0e7e2e2223b4c2e09179ec813e424595">this example</a> might help show which changes are actually resulting in optimizations: rustc deletes the <code>ControlPlane</code> argument when it's not needed, even if it is non-zero-size, but it turns out that if <code>foo</code>/<code>bar</code>/<code>baz</code> are left non-side-effectful they aren't useful to demonstrate the calling convention changes anyway!</p>
<p>this happens to make me think that passing around a <code>&amp;mut ControlPlane</code> promises to have no cost - rather than "not enough to care" cost - in the <code>chaos mode is disabled</code> case after all :D)</p>
</blockquote>



<a name="342982497"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/342982497" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#342982497">(Mar 19 2023 at 19:46)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475359467">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>I would prefer if we went with a <code>&amp;mut ControlPlane</code> as well, rather than subverting the ownership system with a <code>Rc&lt;RefCell&lt;ControlPlane&gt;&gt;</code>. Given the uncertainty here, I want to understand a bit more: are you proposing the alternative because you'd rather not have to pass an extra function parameter? Or for some other reason?</p>
<p>In addition to the disadvantages you named, using a <code>RefCell</code> <em>will</em> actually have a measurable impact on compile time, I suspect: every query of the control plane in an inner loop will require a dynamically-checked borrow. This alone is reason not to do it IMHO. There's also the fact that if stored anywhere, it would make data structures <code>!Send</code> which is problematic for our internal compilation parallelism.</p>
<p>But the other argument I would  make is that subverting the Rust ownership model should not be a "why not" sort of discussion, but should be a "why is this the only possibility" sort of discussion. The alternative proposed here is "just pass a <code>&amp;mut</code> around" and I don't really see the downsides. In particular, this statement</p>
<blockquote>
<p>If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
</blockquote>
<p>is somewhat perplexing and is exactly the opposite of my experience with building large systems with Rust. Internal mutability is a "cheat code" that arises because of unavoidable pressure from the outside. The <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> pattern is a bit of a crutch, in that it emulates how one can write code in other languages with less restrictive sharing of aliases; as a result, it is sort of a way to give up on thinking through the ownership model, and can result in unexpected logic bugs, as we've seen here already with nondeterminism. I would expect that, contrary to such a context parameter "getting in the way", this internal-mutability trick would get in the way by violating expectations and leading to all sorts of issues.</p>
<p>The "better developer experience" bit I would question specifically: what downsides are we avoiding by not passing a <code>&amp;mut</code> context parameter around? Just that (the need for the parameter)? Or a perceived difficulty with <code>&amp;mut</code> references in general? Or something else?</p>
<p>Anyway, given all that, I would really strongly prefer the suggestions I gave above: a <code>&amp;mut ControlPlane</code>, passed as a normal function parameter; no internal mutability or other trickery, only idiomatic Rust; and for now let's not try to make the borrow itself zero-sized, because that adds complexity and I suspect won't matter much.</p>
</blockquote>



<a name="344047809"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/344047809" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#344047809">(Mar 23 2023 at 17:18)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also a bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/3">https://github.com/remlse/wasmtime/pull/3</a></li>
</ul>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code></h2>
<p>approaches:</p>
<ul>
<li><del>Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</del></li>
<li>[x] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="344078355"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/344078355" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#344078355">(Mar 23 2023 at 19:10)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1481752954">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The approach with the mutable references is now working, thanks mostly to @MzrW. For now we made sure the fuzz target <code>cranelift-fuzzgen</code> compiles and works to validate the architecture.</p>
</blockquote>



<a name="344082299"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/344082299" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#344082299">(Mar 23 2023 at 19:27)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1481752954">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The approach with the mutable references is now working, thanks mostly to @MzrW. For now we made sure the fuzz target <code>cranelift-fuzzgen</code> compiles (with feature chaos) and works to validate the architecture.</p>
</blockquote>



<a name="346632910"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/346632910" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#346632910">(Apr 03 2023 at 17:15)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1494693522">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>(Sorry about the rebase, habits are stubborn. I'll solve the conflicts with a merge commit next time.)</p>
</blockquote>



<a name="346646864"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/346646864" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#346646864">(Apr 03 2023 at 18:17)</a>:</h4>
<p>remlse edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1475249958">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>The rename seems uncontroversial, so I did that right on this branch.</p>
<ul>
<li>crate <code>cranelift-chaos</code> renamed -&gt; <code>cranelift-control</code></li>
<li><code>ChaosEngine</code> renamed -&gt; <code>ControlPlane</code></li>
<li>[ ] should the <em>feature</em> also be renamed from <code>chaos</code> to <code>control</code>? I left it as is, assuming that future potential features of the control plane outside the scope of chaos mode might be implemented as different compilation features.</li>
</ul>
<p>From my understanding, there are two major, orthogonal problems with the architecture. I think it's best to branch off from here so we can evaluate the possible approaches separately. I will create a draft PR for each approach so we have a basis for comparison.</p>
<hr>
<h2>Usage of <code>unsafe</code> vs. lifetime proliferation to make use of <code>Unstructured</code></h2>
<p>I agree with the feedback that <code>unsafe</code> must be avoided and that spreading <code>&amp;'a mut ControlPlane</code> everywhere is also a bad idea.</p>
<p>approaches:</p>
<ul>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/2">https://github.com/remlse/wasmtime/pull/2</a></li>
<li>[x] <a href="https://github.com/remlse/wasmtime/pull/3">https://github.com/remlse/wasmtime/pull/3</a></li>
</ul>
<p>Edit: Currently, the internal representation is a <code>Vec&lt;bool&gt;</code> without using <code>Unstructured</code>. When it is useful to do so, we can use it in the future, internally, and without leaking any lifetimes. As an implementation detail, it's easy to change.</p>
<hr>
<h2>Non-deterministic order of perturbations because of multi-threading combined with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code></h2>
<p>approaches:</p>
<ul>
<li><del>Replace with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>, the compiler will then prevent control planes from being shared across threads.</del></li>
<li>[x] Propagate <code>&amp;mut ControlPlane</code> through the call stack instead of owned <code>ControlPlane</code>s. (use bjorn3's pattern to make the reference zero-sized)</li>
</ul>
<p>Maybe this question can be discussed already, before I'm done with the POCs: Is there a downside to using internal mutability when multi-threading is prevented with <code>Rc&lt;RefCell&lt;_&gt;&gt;</code>? What is the benefit of regular mutable references? Off the top of my head, the downsides of internal mutability are in general:</p>
<ul>
<li>It is error prone because users of <code>&amp;Foo</code> may erroneously assume the state of <code>Foo</code> not to change.</li>
<li>It is less performant, because ownership rules are checked at runtime.</li>
</ul>
<p>In our case, I would say these two do not apply: users of <code>ControlPlane</code> shouldn't be concerned with its internal state anyway and the small performance hit during fuzz testing shouldn't matter IMO. If single-threaded internal mutability works just as well for our purposes, I would prefer it over mutable references because of the better developer experience. It would be regrettable if issues with mutable references ever get in the way of regular Cranelift development.</p>
<blockquote>
<p>It allows us to more naturally integrate into the cache infrastructure: compilation is a property of this <code>ControlPlane</code>, which is a piece of data that can impl <code>Hash</code> and <code>Eq</code> like anything else.</p>
</blockquote>
<p>This may be an issue though, as <code>Hash</code> and <code>Eq</code> cannot be derived on <code>Rc</code> and <code>RefCell</code>. I am somewhat confident that we can write a straight forward manual implementation for those without much trouble, but I'll have to show that in the POC.</p>
</blockquote>



<a name="346972980"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/346972980" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#346972980">(Apr 04 2023 at 21:29)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1496629204">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>As a timing note, I'm going to wait to merge this until tomorrow, after our next release's beta branch is cut; I want it to bake on <code>main</code> a little more than the two-week minimum with the beta-to-release delay.</p>
</blockquote>



<a name="346973127"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/346973127" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#346973127">(Apr 04 2023 at 21:30)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1496629204">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>As a timing note, I'm going to wait to merge this until tomorrow, after our next release's beta branch is cut; I want it to bake on <code>main</code> a little more than the two-week minimum with the beta-to-release delay (and want to give a chance to notice if we have any unexpected regressions,e tc).</p>
</blockquote>



<a name="346973157"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/346973157" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#346973157">(Apr 04 2023 at 21:30)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1496629204">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>As a timing note, I'm going to wait to merge this until tomorrow, after our next release's beta branch is cut; I want it to bake on <code>main</code> a little more than the two-week minimum with the beta-to-release delay (and want to give a chance to notice if we have any unexpected regressions, etc).</p>
</blockquote>



<a name="347195987"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/347195987" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#347195987">(Apr 05 2023 at 16:13)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1497765844">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>@remlse it looks like we'll need to add the new crate to a list in <code>scripts/publish.rs</code>; this was only caught in the full CI run in the merge queue. (If you want to test in your commit to fix this, you can add <code>prtest:full</code> to the commit message.)</p>
</blockquote>



<a name="347235148"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%236039%20Chaos%20mode%20MVP%3A%20Skip%20branch%20optimi.../near/347235148" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.236039.20Chaos.20mode.20MVP.3A.20Skip.20branch.20optimi.2E.2E.2E.html#347235148">(Apr 05 2023 at 19:11)</a>:</h4>
<p>remlse <a href="https://github.com/bytecodealliance/wasmtime/pull/6039#issuecomment-1497989168">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/6039">issue #6039</a>:</p>
<blockquote>
<p>@cfallin the full tests are passing now, maybe we can try to merge again?</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>