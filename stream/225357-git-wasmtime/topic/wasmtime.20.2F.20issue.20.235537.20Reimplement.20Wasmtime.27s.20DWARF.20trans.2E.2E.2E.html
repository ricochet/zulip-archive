<html>
<head><meta charset="utf-8"><title>wasmtime / issue #5537 Reimplement Wasmtime&#x27;s DWARF trans... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html">wasmtime / issue #5537 Reimplement Wasmtime&#x27;s DWARF trans...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="319692358"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/319692358" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#319692358">(Jan 05 2023 at 23:29)</a>:</h4>
<p>fitzgen labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>We should reimplement the DWARF&lt;sub&gt;wasm&lt;/sub&gt; to DWARF&lt;sub&gt;native&lt;/sub&gt;<br>
transformation pass that implements the GDB/LLDB debugging support in Wasmtime<br>
by separating DWARF translation from DWARF traversal. We could do this by<br>
defining a generic DWARF transformation pass that takes a generic visitor<br>
implementation, walks the read-only input DWARF, calls the corresponding visitor<br>
method for each DIE/attribute/value/line-table entry/etc... in the DWARF to<br>
produce a new DWARF entity, and writes that new DWARF entity into the output<br>
DWARF that is being built up. We would then implement a DWARF&lt;sub&gt;wasm&lt;/sub&gt; to<br>
DWARF&lt;sub&gt;native&lt;/sub&gt; visitor.</p>
<p>I think this approach would be much easier to implement, maintain, and ensure<br>
correctness of than our current open-coded transformation.</p>
<p>Assuming this interface works out well and we prove it out, it could be worth<br>
upstreaming the generic transformation pass and visitor trait into <code>gimli</code><br>
itself (cc @philipc).</p>
<p>Potential hiccups could be that, for our purposes here, the visitor might not be<br>
exactly a simple map over the input DWARF (or "functor-ish") in that one<br>
DWARF&lt;sub&gt;wasm&lt;/sub&gt; entity might become multiple DWARF&lt;sub&gt;native&lt;/sub&gt;<br>
entities (making it more "monad-ish", apologies if I'm just muddying the waters<br>
with this nomenclature). One example is that what might be a location list entry<br>
in Wasm could become multiple location list entries in native code due to<br>
register allocation, live range splitting, and spilling.</p>
<h3>Testing</h3>
<p>Our testing story for debugging support is very poor at the moment and the<br>
debugging support is correspondingly buggy. As part of this reimplementation, we<br>
should take the opportunity to improve our approach to testing.</p>
<p>I think we can do something like this, in a loop:</p>
<ul>
<li>generate a random C program with <a href="https://embed.cs.utah.edu/csmith/">C-Smith</a></li>
<li>
<p>compile the program twice:</p>
<ol>
<li>to wasm32-wasi</li>
<li>to the host target</li>
</ol>
</li>
<li>
<p>attach <code>gdb</code> and/or <code>lldb</code> to</p>
<ol>
<li>wasmtime running the wasm version</li>
<li>the native binary</li>
</ol>
</li>
<li>
<p>single step N times (or until <code>main</code> exits) and at each point assert that:</p>
<ul>
<li>the native and wasm programs are paused at the same location</li>
<li>the same variables are in scope</li>
<li>the variables in scope have the same values (at least for non-pointer<br>
  scalars, we can tune the C-Smith flags we use to generate test programs as<br>
  necessary)</li>
</ul>
</li>
</ul>
<p>I think this should give us fairly high confidence in the correctness of the new<br>
DWARF transform.</p>
<p>Unfortunately, this won't fit into OSS-Fuzz's paradigm super well. It involves a<br>
lot of wrangling external processes. I think we can do N iterations under normal<br>
<code>cargo test</code> with a fixed corpus of seeds, so that running <code>cargo test</code> twice<br>
runs the same set of test programs each time. And then in CI perhaps we can have<br>
a job that runs more iterations, or a nightly CI job that does a bunch of<br>
iterations, or something like that. To some degree, we can kick this can down<br>
the road and figure things out once we have the test infrastructure set up (even<br>
just running it manually whenever we touch this code would be a huge improvement<br>
over our current debugging testing strategy).</p>
<p>cc @cfallin as this is something we have talked about together in the past.<br>
</p>
</blockquote>



<a name="319692359"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/319692359" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#319692359">(Jan 05 2023 at 23:29)</a>:</h4>
<p>fitzgen opened <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>We should reimplement the DWARF&lt;sub&gt;wasm&lt;/sub&gt; to DWARF&lt;sub&gt;native&lt;/sub&gt;<br>
transformation pass that implements the GDB/LLDB debugging support in Wasmtime<br>
by separating DWARF translation from DWARF traversal. We could do this by<br>
defining a generic DWARF transformation pass that takes a generic visitor<br>
implementation, walks the read-only input DWARF, calls the corresponding visitor<br>
method for each DIE/attribute/value/line-table entry/etc... in the DWARF to<br>
produce a new DWARF entity, and writes that new DWARF entity into the output<br>
DWARF that is being built up. We would then implement a DWARF&lt;sub&gt;wasm&lt;/sub&gt; to<br>
DWARF&lt;sub&gt;native&lt;/sub&gt; visitor.</p>
<p>I think this approach would be much easier to implement, maintain, and ensure<br>
correctness of than our current open-coded transformation.</p>
<p>Assuming this interface works out well and we prove it out, it could be worth<br>
upstreaming the generic transformation pass and visitor trait into <code>gimli</code><br>
itself (cc @philipc).</p>
<p>Potential hiccups could be that, for our purposes here, the visitor might not be<br>
exactly a simple map over the input DWARF (or "functor-ish") in that one<br>
DWARF&lt;sub&gt;wasm&lt;/sub&gt; entity might become multiple DWARF&lt;sub&gt;native&lt;/sub&gt;<br>
entities (making it more "monad-ish", apologies if I'm just muddying the waters<br>
with this nomenclature). One example is that what might be a location list entry<br>
in Wasm could become multiple location list entries in native code due to<br>
register allocation, live range splitting, and spilling.</p>
<h3>Testing</h3>
<p>Our testing story for debugging support is very poor at the moment and the<br>
debugging support is correspondingly buggy. As part of this reimplementation, we<br>
should take the opportunity to improve our approach to testing.</p>
<p>I think we can do something like this, in a loop:</p>
<ul>
<li>generate a random C program with <a href="https://embed.cs.utah.edu/csmith/">C-Smith</a></li>
<li>
<p>compile the program twice:</p>
<ol>
<li>to wasm32-wasi</li>
<li>to the host target</li>
</ol>
</li>
<li>
<p>attach <code>gdb</code> and/or <code>lldb</code> to</p>
<ol>
<li>wasmtime running the wasm version</li>
<li>the native binary</li>
</ol>
</li>
<li>
<p>single step N times (or until <code>main</code> exits) and at each point assert that:</p>
<ul>
<li>the native and wasm programs are paused at the same location</li>
<li>the same variables are in scope</li>
<li>the variables in scope have the same values (at least for non-pointer<br>
  scalars, we can tune the C-Smith flags we use to generate test programs as<br>
  necessary)</li>
</ul>
</li>
</ul>
<p>I think this should give us fairly high confidence in the correctness of the new<br>
DWARF transform.</p>
<p>Unfortunately, this won't fit into OSS-Fuzz's paradigm super well. It involves a<br>
lot of wrangling external processes. I think we can do N iterations under normal<br>
<code>cargo test</code> with a fixed corpus of seeds, so that running <code>cargo test</code> twice<br>
runs the same set of test programs each time. And then in CI perhaps we can have<br>
a job that runs more iterations, or a nightly CI job that does a bunch of<br>
iterations, or something like that. To some degree, we can kick this can down<br>
the road and figure things out once we have the test infrastructure set up (even<br>
just running it manually whenever we touch this code would be a huge improvement<br>
over our current debugging testing strategy).</p>
<p>cc @cfallin as this is something we have talked about together in the past.<br>
</p>
</blockquote>



<a name="321911705"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/321911705" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#321911705">(Jan 17 2023 at 19:39)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-1385952340">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>Admittedly a slightly wild idea, if we wanted to try to fuzz: if the Wasmtime function-call API had a mode in which we could "single-step call" (maybe an async fn that yields at each new srcloc), and a way to introspect via DWARF the Wasm-level state at each step (so, a built-in programmatic <code>gdb</code>), <em>and</em> if we similarly instrumented an interpreter (<code>wasmi</code>?) to let us single-step and introspect state, then we could fuzz in-process as rapidly as we do differential execution tests today.</p>
<p>I wonder how we might be able to leverage existing Rust debugger libraries; I see <a href="https://headcrab.rs/">Headcrab</a>, and e.g. its DWARF support may be usable for this on the native-code side.</p>
<p>This is probably at least three months of developer time but we'd have best-in-class assurances of debuggability and the correctness of the provided program state if we had something like this, and a "debugger API" on Wasmtime could be the basis for a lot of other useful tooling too.</p>
</blockquote>



<a name="452946556"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/452946556" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#452946556">(Jul 21 2024 at 05:50)</a>:</h4>
<p>philipc <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2241487222">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<blockquote>
<p>We could do this by defining a generic DWARF transformation pass that takes a generic visitor implementation, walks the read-only input DWARF, calls the corresponding visitor method for each DIE/attribute/value/line-table entry/etc... in the DWARF to produce a new DWARF entity, and writes that new DWARF entity into the output DWARF that is being built up. We would then implement a DWARFwasm to DWARFnative visitor.</p>
</blockquote>
<p>I may not be understanding exactly what you mean here, but I think that a simple visitor is not enough. If code instructions can be reordered, then the line table instructions must also be reordered. Without knowing much about wasmtime and without any prior knowledge of your proposal here, this is how I would have expected this work:</p>
<ul>
<li>read the WASM</li>
<li>read the DWARF line table, and convert it into a parsed form (e.g. at a similar level to what LLVM IR uses)</li>
<li>create links between the WASM and the parsed line table</li>
<li>compile the WASM to native while preserving these links</li>
<li>generate a completely new line table using the native code and its links (no need to use the original line table here)</li>
</ul>
<p>How would your proposal handle this?</p>
<p>I think .debug_info is a lot simpler to handle, and visitor could work for it. One concern would be about location lists for variables. These may need to be handled in a similar way to the line table.</p>
<p>I'm interested in doing gimli work to support whatever is needed here.</p>
</blockquote>



<a name="453205696"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453205696" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453205696">(Jul 22 2024 at 15:21)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2243224264">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>You're right that instructions can be reordered, and currently the way things work is that Cranelift instructions are tagged with where they came from in wasm and then the original DWARF is used to determine where that wasm offset corresponds to. How exactly this all gets transformed in DWARF I'm not 100% sure as I'm not that familiar with the code.</p>
<p>One thing I can possibly add though is that for variable locations we do have to translate custom DWARF things like global-relative or local-relative operands into native DWARF instead. That means that for various expressions they're rewritten and/or appended to or things like that. I think there's also some bits and bobs here and there about translating DWARF for the 32-bit wasm architecture to the host 64-bit architecture, but I think those are more minor.</p>
</blockquote>



<a name="453263748"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453263748" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453263748">(Jul 22 2024 at 19:43)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2243688713">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>@philipc regarding line tables, I still think that, from a user perspective, the desired interface is handing an <code>impl Fn(Pc) -&gt; Pc</code> function (or visitor or whatever) to a generic line-tables rewriting function. Perhaps, as you point out, that cannot be implemented in a single pass, and might require materializing some intermediate representation that then needs to be re-sorted or whatever before emitting the actual encoded tables. I think that is fine.</p>
<p>Below is a sketch of what this might look like, but I'm sure I'm overlooking or missing something -- it's been a while since I was deep in DWARF stuff!</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">LineProgramRewriter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Error</span><span class="p">:</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">gimli</span><span class="p">::</span><span class="n">read</span><span class="p">::</span><span class="nb">Result</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="sd">/// Rewrite a PC address in the line program.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// By default, it is unmodified.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">address</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// Rewrite a directory in the line program.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// By default, it is unmodified.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">directory</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">dir</span><span class="p">:</span><span class="w"> </span><span class="nc">gimli</span><span class="p">::</span><span class="n">read</span><span class="p">::</span><span class="n">LineString</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">gimli</span><span class="p">::</span><span class="n">read</span><span class="p">::</span><span class="n">LineString</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// Rewrite a source line number in the line program.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// By default, it is unmodified.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Etc...</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rewrite_line_program</span><span class="o">&lt;</span><span class="n">Reader</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="p">,</span><span class="w"> </span><span class="n">Rewriter</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="n">input</span><span class="p">:</span><span class="w"> </span><span class="nc">gimli</span><span class="p">::</span><span class="n">read</span><span class="p">::</span><span class="n">IncompleteLineProgram</span><span class="o">&lt;</span><span class="n">Reader</span><span class="p">,</span><span class="w"> </span><span class="n">Offset</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">rewriter</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Rewriter</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">gimli</span><span class="p">::</span><span class="n">write</span><span class="p">::</span><span class="n">LineProgram</span><span class="p">,</span><span class="w"> </span><span class="n">Rewriter</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">Rewriter</span><span class="p">:</span><span class="w"> </span><span class="nc">LineProgramRewriter</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rewritten_rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">sequences</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">sequences</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">sequences</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">program</span><span class="p">.</span><span class="n">resume_from</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rows</span><span class="p">.</span><span class="n">next_row</span><span class="p">()</span><span class="o">?</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Apply each method of the `rewriter` to each part of the row.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">new_row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rewrite_one_row</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">rewriter</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">            </span><span class="n">rewritten_rows</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_row</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Sort the rows such that they are in an order that we can correctly</span>
<span class="w">    </span><span class="c1">// encode.</span>
<span class="w">    </span><span class="n">rewritten_rows</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Encode the rewritten rows into a new line program.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gimli</span><span class="p">::</span><span class="n">write</span><span class="p">::</span><span class="n">LineProgram</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rewritten_rows</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Encode each row, decide whether to start a new sequence or continue</span>
<span class="w">        </span><span class="c1">// the existing sequence, etc...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>I think the biggest difference from what you laid out in "this is how I would have expected this work" is that I want to factor out the wasmtime-specific bits around the DWARF&lt;sub&gt;Wasm&lt;/sub&gt;-to-DWARF&lt;sub&gt;native&lt;/sub&gt; mapping from the generic, possibly-generally-useful bits of "I have <em>some</em> kind of new mapping, and I want to apply it to this input DWARF to get a new rewritten DWARF".</p>
<p>The other thing is that, again as you mentioned, line tables are only one piece, and we would want to do this for every single section.</p>
<p>Is that all making sense? Does it seem reasonable?</p>
</blockquote>



<a name="453297904"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453297904" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453297904">(Jul 23 2024 at 00:31)</a>:</h4>
<p>philipc <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2244038036">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>I can understand your motivation, and it makes sense to me at a high level. The rest of this reply is just getting into the details of how it would work for line programs.</p>
<p>I don't think that applying a transformation to each row in the original line program is the right way to do it in general. In addition to the reordering, it would easily be possible that you need less rows, or maybe more rows (I'm not as sure about that one). So I still think that we should be generating a new line program roughly how I outlined.</p>
<p>In order to make the rewriting generic, we can still factor out parts of that into a trait. So the wasmtime-specific inputs that it would need at a minimum are the native address range for each sequence (one per function), and a mapping from native address to Wasm address (the reverse of what is in your <code>LineProgramRewriter::address</code>). The tags on the Cranelift instructions can trivially provide that.</p>
<p>This should probably be rewriting the range lists for inlined functions at the same time, but I haven't thought much about that.</p>
</blockquote>



<a name="453466910"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453466910" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453466910">(Jul 23 2024 at 16:55)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2245759033">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<blockquote>
<p>In addition to the reordering, it would easily be possible that you need less rows, or maybe more rows (I'm not as sure about that one).</p>
</blockquote>
<p>Yeah it actually isn't clear to me whether, in the general case, we would want to</p>
<ol>
<li>start with the old rows and translate them into new rows using the user's mapping,</li>
<li>iterate over the user's mapping and reconstruct the new rows from scratch, or</li>
<li>some combination of the two.</li>
</ol>
<p>I suspect there are subtleties that will impact the final debug info's fidelity involving whether the user's mapping is surjective or injective, but it isn't totally clear in my mind at this point. I guess I'm just thinking about how lossy the user's mapping is and how the direction of translation interacts with that.</p>
<p>I suspect that each direction is probably lossy in some way, which makes me think that we probably want to do some variant of (3) because debuggers query the DWARF in both directions: when setting breakpoints, they go from source location to set of PCs, and when intercepting an exception/fault/etc they go from PC to source location.</p>
</blockquote>



<a name="453467285"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453467285" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453467285">(Jul 23 2024 at 16:57)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2245762374">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>Oh also: I am more concerned about losing information that inserting duplicate rows, because I think it should be pretty easy to clean up duplicate rows during the phase where we take the IR and actually encode it as DWARF, sort of like a peephole pass.</p>
</blockquote>



<a name="453467314"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/453467314" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#453467314">(Jul 23 2024 at 16:57)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2245762374">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>Oh also: I am more concerned about losing information than inserting duplicate rows, because I think it should be pretty easy to clean up duplicate rows during the phase where we take the IR and actually encode it as DWARF, sort of like a peephole pass.</p>
</blockquote>



<a name="454424770"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/454424770" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#454424770">(Jul 27 2024 at 04:53)</a>:</h4>
<p>philipc <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2253764854">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>I had a look at what LLVM BOLT does (which is a similar use case that should be supported by any generic transformation support), and it works by writing new line sequences for each function (using information from the new instructions and the original line program), rather than rewriting the original line program.</p>
<p>When disassembling functions, it <a href="https://github.com/llvm/llvm-project/blob/9a3e66e314e698ffb08dba151bc098b6b8867c61/bolt/lib/Core/BinaryFunction.cpp#L1468-L1471">attaches the original line row to each instruction</a>, and then when emitting the function, it potentially <a href="https://github.com/llvm/llvm-project/blob/9a3e66e314e698ffb08dba151bc098b6b8867c61/bolt/lib/Core/BinaryEmitter.cpp#L460-L464">emits a new line row for each instruction</a>, which is generated using the information from the original row that is attached to that instruction.</p>
<p>BOLT also has the ability to copy an original line sequence for functions that it did not modify.</p>
<p>I had a quick look at BOLT's DIE handling, and that process is a rewrite of the original DIEs. It works by building a representation of the DIEs in memory, and mutates that.</p>
</blockquote>



<a name="454492397"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/454492397" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#454492397">(Jul 27 2024 at 16:22)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2254192007">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>That’s really informative to know, thanks for investigating that! Sounds like we should probably follow their lead.</p>
</blockquote>



<a name="462512790"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/462512790" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#462512790">(Aug 15 2024 at 09:42)</a>:</h4>
<p>philipc <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2290980994">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>I've been looking at the DWARF transform in Wasmtime some more. It appears that while there are some problems with the implementation details, there's nothing fundamentally wrong with the approach it is taking. In particular, at a high level the line program transformation is the same as BOLT. So I don't see the need for a complete rewrite. I think it would be better to evolve what's there already. The end result of that should still be a generic transformation pass in gimli.</p>
<p>As a background, my interest in this to improve the write API in gimli. Also, I have a gimli PR (<a href="https://github.com/gimli-rs/gimli/pull/735">https://github.com/gimli-rs/gimli/pull/735</a>) to add a <code>ReaderAddress</code> trait. One of the goals for that is to remove the <code>convert_address</code> callback in the write API. However, <code>walrus</code> is using that callback for its DWARF transformation, so I don't want to remove it without a solution.</p>
<p>Hence I'm interested in making a start on Wasmtime's <code>.debug_line</code> transformation. I think gimli can add transformation support for it without needing to support all of <code>.debug_info</code> as well. The goal of that transformation would be to support exactly what Wasmtime is doing today in a way that can be used for both Wasmtime and walrus.</p>
<p>Your testing ideas are interesting, but I'm not sure how much I will be able to do on that.</p>
</blockquote>



<a name="481227300"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%235537%20Reimplement%20Wasmtime%27s%20DWARF%20trans.../near/481227300" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.235537.20Reimplement.20Wasmtime.27s.20DWARF.20trans.2E.2E.2E.html#481227300">(Nov 08 2024 at 01:37)</a>:</h4>
<p>philipc <a href="https://github.com/bytecodealliance/wasmtime/issues/5537#issuecomment-2463580360">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/5537">issue #5537</a>:</p>
<blockquote>
<p>The current status on this is that there is a gimli PR (<a href="https://github.com/gimli-rs/gimli/pull/745">https://github.com/gimli-rs/gimli/pull/745</a>) for .debug_line transformations that I'm happy with.</p>
<p>I still need to come up with a design for the .debug_info transformation. The main sticking point is dealing with attributes that reference other entries.</p>
<p>The conversion code in gimli currently handles this by doing two passes: one for entries and one for attributes. The downside of this approach is it's hard to handle transformations that change the shape of the tree (e.g. by inserting wrapper entries).</p>
<p>The transform code in wasmtime does both entries and attributes in one pass, but stores a list of attributes with references and <a href="https://github.com/bytecodealliance/wasmtime/blob/c8b13696549982190a031a05aa978402d8dc81d4/crates/cranelift/src/debug/transform/mod.rs#L228">patches them later</a>. The problem with this approach is it doesn't currently handle all possible references (e.g. expressions can contain references). This is probably still the best approach if I can cleanly extend it to handle these other references too.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>