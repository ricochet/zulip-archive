<html>
<head><meta charset="utf-8"><title>wasmtime / issue #3254 Use relative `call` instructions b... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html">wasmtime / issue #3254 Use relative `call` instructions b...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="250848739"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250848739" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250848739">(Aug 26 2021 at 22:13)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906778987">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>I'm not overly happy with the number of tests I have for this, but I don't know how to otherwise exercise it more. One test I'd like to add is a sort of binary search that tries to stress the logic around precise sizes and when veneers are inserted, but I couldn't figure out a good way to test the binary search, e.g. somehow read out whether a veneer was inserted or not. @cfallin if you've got ideas of how to more thoroughly test this I'd love to implement them.</p>
</blockquote>



<a name="250850129"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250850129" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250850129">(Aug 26 2021 at 22:24)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906783785">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>@alexcrichton Thanks -- this looks like a bit of a monster and I will dive in a bit later, but on reading the PR description only, one thing strikes me: it should be possible to test the veneer insertion without generating tons of padding by forcing a "always use veneers" mode, no? I'm not sure if the plumbing is there to take Cranelift options in <code>wasmtime-cranelift::obj</code> but if not, perhaps this would be an appropriate reason to carry some options into that code (I can imagine other linker options might appear in the future).</p>
</blockquote>



<a name="250850268"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250850268" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250850268">(Aug 26 2021 at 22:26)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906783785">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>@alexcrichton Thanks -- this looks like a bit of a monster and I will dive in a bit later, but on reading the PR description only, one thing strikes me: it should be possible to test the veneer insertion without generating tons of padding by forcing an "always use veneers" mode, no? I'm not sure if the plumbing is there to take Cranelift options in <code>wasmtime_cranelift::obj</code> but if not, perhaps this would be an appropriate reason to carry some options into that code (I can imagine other linker options might appear in the future).</p>
</blockquote>



<a name="250855798"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250855798" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250855798">(Aug 26 2021 at 23:17)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906806036">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen, @kubkon, @peterhuene</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift", "cranelift:area:aarch64", "cranelift:area:machinst", "cranelift:area:x64", "fuzzing", "wasi", "wasmtime:api"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: fuzzing</li>
<li>kubkon: wasi</li>
<li>peterhuene: wasmtime:api</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="250859377"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250859377" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250859377">(Aug 27 2021 at 00:03)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906822064">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<blockquote>
<p>we could extend the calls to an 8 GB range</p>
</blockquote>
<p>Do you know if this is common in normal AArch64 compilers? (e.g. gcc or llvm). Do you know if this is better than our current strategy of load-a-literal-and-call-it? (which we could presumably change to being a relative literal if we wanted)</p>
<blockquote>
<p>have we ever thought about using code memory pages that are executable, but not readable, as additional security hardening?</p>
</blockquote>
<p>ooh interesting! I always thought the execute permission implied the read permission, but if we could prevent reading that'd be pretty nifty! I'm not sure how feasible it would be at the Cranelift-level but we could try to shove information like that into the VMContext, but that's pretty Wasmtime-specific.</p>
<p>(I don't know if others have pondered this myself)</p>
</blockquote>



<a name="250861180"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250861180" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250861180">(Aug 27 2021 at 00:29)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906832916">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>have we ever thought about using code memory pages that are executable, but not readable, as additional security hardening?</p>
</blockquote>
<p>ooh interesting! I always thought the execute permission implied the read permission, but if we could prevent reading that'd be pretty nifty! I'm not sure how feasible it would be at the Cranelift-level but we could try to shove information like that into the VMContext, but that's pretty Wasmtime-specific.</p>
</blockquote>
<p>It's definitely possible, but it would take some additional work with regard to linking: specifically we would need relocations that refer to <code>.rodata</code> and would need to fix those up to point to all constants in a pool at the end of the object.</p>
<p>There's the additional complication that on RISC-ish architectures like aarch64 there are limits on distance to literal-constant loads (<code>LDR</code> supports +/- 1MiB if I'm not mistaken?) which would mean we'd need constant islands between functions, and to switch between execute-only and read-only pages.</p>
<p>That said other platforms do W^X pretty successfully (OpenBSD by default at least) and it'd be a cool mitigation to say that we can do  too :-)</p>
</blockquote>



<a name="250864090"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250864090" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250864090">(Aug 27 2021 at 01:10)</a>:</h4>
<p>akirilov-arm <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-906846765">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<blockquote>
<p>Do you know if this is common in normal AArch64 compilers? (e.g. gcc or llvm).</p>
</blockquote>
<p>I honestly don't know - I just wanted to mention the possibility.</p>
<blockquote>
<p>Do you know if this is better than our current strategy of load-a-literal-and-call-it?</p>
</blockquote>
<p>I believe so - while the veneers avoid the worst aspect of that approach (the need to have a short jump over the literal, as we do for SIMD &amp; FP literals right now), <code>ADRP</code> and <code>ADD</code> are very fast arithmetic instructions, while a literal load is still a load. Also, unless several call sites manage to share the literal, the code size is worse - 12 bytes (literal load, i.e. 4 bytes + 8-byte literal) vs. 2 instructions, i.e. 8 bytes.</p>
<blockquote>
<p>I always thought the execute permission implied the read permission...</p>
</blockquote>
<p>If I am not mistaken, not in the 64-bit Arm architecture.</p>
<blockquote>
<p>There's the additional complication that on RISC-ish architectures like aarch64 there are limits on distance to literal-constant loads (<code>LDR</code> supports +/- 1MiB if I'm not mistaken?)...</p>
</blockquote>
<p>Yes, but in the AArch64 case we could apply a similar trick to get some extra breathing room, i.e. an <code>ADRP</code> + plain <code>LDR</code> combination - it is not an accident that <code>ADRP</code> forms 12-bit-aligned addresses, while <code>LDR</code> supports unsigned 12-bit offsets <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>. In fact, that combination is treated in a special way by Cortex-A55, for example, effectively fusing it.</p>
</blockquote>



<a name="250964904"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250964904" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250964904">(Aug 27 2021 at 17:24)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-907357136">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>Today the <code>X86PCRelRodata4</code> relocation type coming out of cranelift is <a href="https://github.com/bytecodealliance/wasmtime/blob/7b98be1beee19cb886cdd69d616fe0bd5548b2a5/crates/cranelift/src/obj.rs#L336-L338">simply ignored</a>, but I don't know why it is ignored. I just added a commit to ignore it which fixes tests on the old backend, but if someone else knows of a better comment to add as to why it's ignored I'd be happy to write it in.</p>
</blockquote>



<a name="250966568"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250966568" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250966568">(Aug 27 2021 at 17:36)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-907363415">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p><code>X86PCRelRodata4</code> is a relocation pointing to read-only data directly after a function. It only exists so that it is possible to move this read-only data away from the function. If you don't do this, the emitted code is pre-relocated for the expected location of the trailing read-only data.</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/e6f399419c60c0306d13e39c2f955090f7da943f/cranelift/jit/src/backend.rs#L916-L919">https://github.com/bytecodealliance/wasmtime/blob/e6f399419c60c0306d13e39c2f955090f7da943f/cranelift/jit/src/backend.rs#L916-L919</a></p>
<p>It by the way isn't emitted by any new style backends.</p>
</blockquote>



<a name="250971932"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/250971932" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#250971932">(Aug 27 2021 at 18:14)</a>:</h4>
<p>sunfishcode <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-907385083">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>I don't know the current status of this, but at one point, the way Cranelift was embedded in SpiderMonkey, SpiderMonkey would prepend and append instructions to Cranelift's output, and we needed the ability to move the constant pool rodata around to make room.</p>
</blockquote>



<a name="251458223"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%233254%20Use%20relative%20%60call%60%20instructions%20b.../near/251458223" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.233254.20Use.20relative.20.60call.60.20instructions.20b.2E.2E.2E.html#251458223">(Aug 31 2021 at 20:56)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/3254#issuecomment-909630357">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/3254">issue #3254</a>:</p>
<blockquote>
<p>Ok talked with @cfallin offline about merging all this into <code>MachBuffer</code> and after some fiddling I think it's going to work (got the test suite passing locally on arm64 at least). I'm gonna close this and I'll reopen with a cleaned up history, a rebase, and a new commit message.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>