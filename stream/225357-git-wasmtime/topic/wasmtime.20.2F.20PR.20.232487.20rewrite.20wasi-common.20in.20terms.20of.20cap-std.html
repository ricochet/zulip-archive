<html>
<head><meta charset="utf-8"><title>wasmtime / PR #2487 rewrite wasi-common in terms of cap-std · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html">wasmtime / PR #2487 rewrite wasi-common in terms of cap-std</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="219160429"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219160429" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219160429">(Dec 08 2020 at 01:12)</a>:</h4>
<p>pchickey opened <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219164258"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219164258" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219164258">(Dec 08 2020 at 02:21)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219173527"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173527" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173527">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-546747601">PR Review</a>.</p>



<a name="219173528"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173528" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173528">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-546747601">PR Review</a>.</p>



<a name="219173529"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173529" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173529">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r538040138">PR Review Comment</a>:</p>
<blockquote>
<p>system-interface 0.1.0 now has <a href="https://docs.rs/system-interface/0.1.0/system_interface/fs/trait.FileIoExt.html#tymethod.allocate"><code>FileIoExt::allocate</code></a> which does this.</p>
</blockquote>



<a name="219173530"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173530" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173530">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r538037609">PR Review Comment</a>:</p>
<blockquote>
<p>Ah, sorry I neglected to mention it, that's in a separate crate -- <a href="https://crates.io/crates/fs-set-times">fs-set-times</a>. If you use that crate's <a href="https://docs.rs/fs-set-times/0.2.1/fs_set_times/enum.SystemTimeSpec.html">SystemTimeSpec</a> in place the <code>FilestatSetTime</code> definition above, then usage is basically</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">fs_set_times</span>::<span class="n">SetTimes</span><span class="p">;</span><span class="w"></span>
<span class="n">file</span><span class="p">.</span><span class="n">set_times</span><span class="p">(</span><span class="n">atime</span><span class="p">,</span><span class="w"> </span><span class="n">mtime</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p>Or something like <code>pub trait WasiFile: FileIoExt + SetTimes</code> might work too.</p>
</blockquote>



<a name="219173531"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173531" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173531">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r538047620">PR Review Comment</a>:</p>
<blockquote>
<p><code>cap_std::fs::Metadata</code> implements Unix's <a href="https://doc.rust-lang.org/nightly/std/os/unix/fs/trait.MetadataExt.html"><code>MetadataExt</code></a> on Unix, and Windows' <a href="https://doc.rust-lang.org/nightly/std/os/windows/fs/trait.MetadataExt.html"><code>MetadataExt</code></a> on Windows, with functions that provide all the info here, though I can look into something more portable too.<br>
</p>
</blockquote>



<a name="219173532"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219173532" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219173532">(Dec 08 2020 at 05:43)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r538048872">PR Review Comment</a>:</p>
<blockquote>
<p>Yeah, cap-std is following std in this respect. On Unix, <code>PermissionsExt</code> does have a <code>from_mode</code>, but I'll think about adding something portable too.</p>
</blockquote>



<a name="219526791"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219526791" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219526791">(Dec 10 2020 at 20:06)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219539458"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219539458" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219539458">(Dec 10 2020 at 21:57)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-549636364">PR Review</a>.</p>



<a name="219539459"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219539459" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219539459">(Dec 10 2020 at 21:57)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r540526535">PR Review Comment</a>:</p>
<blockquote>
<p>I'll prototype something portable that lets us implement this in the wasi-c2 crate, and we can figure out where to upstream it after.</p>
</blockquote>



<a name="219539754"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219539754" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219539754">(Dec 10 2020 at 22:00)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219545239"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219545239" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219545239">(Dec 10 2020 at 22:51)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219546742"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219546742" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219546742">(Dec 10 2020 at 23:07)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219549123"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219549123" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219549123">(Dec 10 2020 at 23:37)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219549501"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219549501" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219549501">(Dec 10 2020 at 23:42)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-549699514">PR Review</a>.</p>



<a name="219549502"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219549502" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219549502">(Dec 10 2020 at 23:42)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r540582788">PR Review Comment</a>:</p>
<blockquote>
<p>I came up with something janky here which depends on nightly to work on windows...</p>
</blockquote>



<a name="219549544"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219549544" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219549544">(Dec 10 2020 at 23:43)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-549699864">PR Review</a>.</p>



<a name="219549545"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219549545" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219549545">(Dec 10 2020 at 23:43)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r540583136">PR Review Comment</a>:</p>
<blockquote>
<p>Implemented this except for making the flags canonical, which is the sort of thing we can sort out later.</p>
<p>On windows, should we reject this with an error or should we silently do nothing?</p>
</blockquote>



<a name="219556638"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219556638" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219556638">(Dec 11 2020 at 01:31)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219656288"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219656288" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219656288">(Dec 11 2020 at 20:14)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219672861"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219672861" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219672861">(Dec 11 2020 at 23:01)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219674989"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219674989" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219674989">(Dec 11 2020 at 23:34)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219679488"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219679488" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219679488">(Dec 12 2020 at 00:43)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219682854"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219682854" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219682854">(Dec 12 2020 at 01:54)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219683888"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219683888" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219683888">(Dec 12 2020 at 02:22)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="219934971"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/219934971" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#219934971">(Dec 15 2020 at 03:48)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220069761"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220069761" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220069761">(Dec 16 2020 at 02:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220187376"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220187376" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220187376">(Dec 16 2020 at 23:17)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220191451"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220191451" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220191451">(Dec 17 2020 at 00:07)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220196613"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220196613" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220196613">(Dec 17 2020 at 01:19)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220198806"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220198806" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220198806">(Dec 17 2020 at 01:54)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220327164"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220327164" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220327164">(Dec 18 2020 at 01:30)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220328331"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220328331" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220328331">(Dec 18 2020 at 01:48)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220329709"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220329709" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220329709">(Dec 18 2020 at 02:12)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220424686"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220424686" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220424686">(Dec 18 2020 at 20:31)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220442785"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220442785" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220442785">(Dec 19 2020 at 00:13)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="220445295"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/220445295" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#220445295">(Dec 19 2020 at 01:04)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221575531"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221575531" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221575531">(Jan 04 2021 at 20:21)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221576930"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221576930" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221576930">(Jan 04 2021 at 20:33)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221577345"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221577345" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221577345">(Jan 04 2021 at 20:37)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221597931"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221597931" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221597931">(Jan 05 2021 at 00:04)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221599374"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221599374" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221599374">(Jan 05 2021 at 00:22)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221599840"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221599840" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221599840">(Jan 05 2021 at 00:28)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221600813"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221600813" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221600813">(Jan 05 2021 at 00:42)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221603463"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221603463" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221603463">(Jan 05 2021 at 01:23)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221603825"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221603825" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221603825">(Jan 05 2021 at 01:28)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221696418"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221696418" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221696418">(Jan 05 2021 at 20:20)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221707292"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221707292" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221707292">(Jan 05 2021 at 21:57)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221710412"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221710412" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221710412">(Jan 05 2021 at 22:28)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="221711164"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/221711164" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#221711164">(Jan 05 2021 at 22:36)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222012521"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222012521" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222012521">(Jan 07 2021 at 22:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222013738"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222013738" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222013738">(Jan 07 2021 at 22:56)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222021849"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222021849" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222021849">(Jan 08 2021 at 00:39)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222022370"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222022370" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222022370">(Jan 08 2021 at 00:47)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222078946"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222078946" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222078946">(Jan 08 2021 at 14:36)</a>:</h4>
<p>ueno submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-564305563">PR Review</a>.</p>



<a name="222078947"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222078947" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222078947">(Jan 08 2021 at 14:36)</a>:</h4>
<p>ueno created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r553978772">PR Review Comment</a>:</p>
<blockquote>
<p>Probably a dumb question, but I wonder if there is a reason to have separate structs for read and write (<code>ReadPipe</code> and <code>WritePipe</code>) rather than a single bi-directional pipe, something like below?<br>
<a href="https://github.com/ueno/wasmtime/blob/wip/dueno/wasi-c2-virt/crates/wasi-c2/src/virt/pipe.rs#L375">https://github.com/ueno/wasmtime/blob/wip/dueno/wasi-c2-virt/crates/wasi-c2/src/virt/pipe.rs#L375</a></p>
</blockquote>



<a name="222095741"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222095741" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222095741">(Jan 08 2021 at 16:52)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-564421673">PR Review</a>.</p>



<a name="222095742"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222095742" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222095742">(Jan 08 2021 at 16:52)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r554065823">PR Review Comment</a>:</p>
<blockquote>
<p>From my perspective, the granularity of various traits in this area is something we're still figuring out. Could you say more about why <code>Pipe</code> in your link here uses <code>Seek</code>? Elsewhere you mentioned using TCP, QUIC, etc. sockets, however they don't support <code>Seek</code>. Things that do implement <code>Seek</code> such as files and memory buffers aren't interactive and don't make sense for interactive protocols, which is what one typically does on top of TCP, QUIC, etc. sockets.<br>
</p>
</blockquote>



<a name="222108205"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222108205" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222108205">(Jan 08 2021 at 18:30)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-564487966">PR Review</a>.</p>



<a name="222108207"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222108207" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222108207">(Jan 08 2021 at 18:30)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r554118872">PR Review Comment</a>:</p>
<blockquote>
<p>The use case we wrote ReadPipe and WritePipe for is just to buffering stdin and stdout/err for an instance, rather than communicate between instances. Bi-directional communication is more complex and something I wasn't ready to bite off yet.</p>
</blockquote>



<a name="222305665"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222305665" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222305665">(Jan 11 2021 at 14:47)</a>:</h4>
<p>ueno submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-565421780">PR Review</a>.</p>



<a name="222305666"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222305666" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222305666">(Jan 11 2021 at 14:47)</a>:</h4>
<p>ueno created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r555097799">PR Review Comment</a>:</p>
<blockquote>
<blockquote>
<p>Could you say more about why Pipe in your link here uses Seek? Elsewhere you mentioned using TCP, QUIC, etc. sockets, however they don't support Seek.</p>
</blockquote>
<p>Yes, that's true; I added it just for my <a href="https://github.com/ueno/wasi-shared-handles/tree/wip/dueno/wasi-c2">demo</a> of the other branch. On the other hand, I suspect Seek will be desirable in the case with running Wasm programs in TEE, to support transparent encryption of files.</p>
</blockquote>



<a name="222374458"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222374458" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222374458">(Jan 11 2021 at 23:48)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222375059"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222375059" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222375059">(Jan 11 2021 at 23:57)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222380852"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222380852" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222380852">(Jan 12 2021 at 01:12)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222383074"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222383074" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222383074">(Jan 12 2021 at 01:48)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222383617"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222383617" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222383617">(Jan 12 2021 at 01:59)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222385366"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222385366" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222385366">(Jan 12 2021 at 02:34)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222487180"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222487180" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222487180">(Jan 12 2021 at 20:07)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222521624"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222521624" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222521624">(Jan 13 2021 at 01:43)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222629268"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222629268" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222629268">(Jan 13 2021 at 19:03)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222629847"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222629847" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222629847">(Jan 13 2021 at 19:07)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222660506"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222660506" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222660506">(Jan 13 2021 at 23:11)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="222809734"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/222809734" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#222809734">(Jan 15 2021 at 01:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223265736"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223265736" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223265736">(Jan 19 2021 at 17:57)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-571506142">PR Review</a>.</p>



<a name="223265737"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223265737" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223265737">(Jan 19 2021 at 17:57)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r560374273">PR Review Comment</a>:</p>
<blockquote>
<p>system-interface has this in <a href="https://docs.rs/system-interface/0.4.0/system_interface/io/trait.ReadReady.html#tymethod.num_ready_bytes"><code>num_ready_bytes</code></a>. One difference from how wasi-common does it is that system-interface will sometimes return 0 if the underlying device can't report how many bytes it can read. Here, since we just called <code>poll</code> and it told us that <em>something</em> was ready, we should do <code>let n = sub.num_ready_bytes()</code> and then <code>max(n, 1)</code>.</p>
</blockquote>



<a name="223307060"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223307060" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223307060">(Jan 19 2021 at 22:39)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223307333"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223307333" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223307333">(Jan 19 2021 at 22:43)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-571727213">PR Review</a>.</p>



<a name="223307334"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223307334" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223307334">(Jan 19 2021 at 22:43)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r560549061">PR Review Comment</a>:</p>
<blockquote>
<p>Fixed now- thanks!</p>
</blockquote>



<a name="223310272"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223310272" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223310272">(Jan 19 2021 at 23:14)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223465106"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223465106" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223465106">(Jan 21 2021 at 03:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223470107"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223470107" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223470107">(Jan 21 2021 at 04:54)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223470490"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223470490" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223470490">(Jan 21 2021 at 05:03)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223575710"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223575710" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223575710">(Jan 21 2021 at 21:51)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223578474"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223578474" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223578474">(Jan 21 2021 at 22:14)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223591646"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223591646" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223591646">(Jan 22 2021 at 00:55)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223595390"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223595390" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223595390">(Jan 22 2021 at 01:57)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223596028"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223596028" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223596028">(Jan 22 2021 at 02:08)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223596513"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223596513" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223596513">(Jan 22 2021 at 02:18)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223704916"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223704916" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223704916">(Jan 22 2021 at 21:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223715982"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223715982" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223715982">(Jan 22 2021 at 23:33)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223716812"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223716812" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223716812">(Jan 22 2021 at 23:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223726606"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223726606" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223726606">(Jan 23 2021 at 02:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223954372"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223954372" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223954372">(Jan 25 2021 at 20:20)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223958420"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223958420" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223958420">(Jan 25 2021 at 20:54)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223977044"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223977044" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223977044">(Jan 25 2021 at 23:20)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223977693"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223977693" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223977693">(Jan 25 2021 at 23:28)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223985023"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223985023" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223985023">(Jan 26 2021 at 00:59)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223985296"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223985296" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223985296">(Jan 26 2021 at 01:02)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223985715"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223985715" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223985715">(Jan 26 2021 at 01:08)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="223986126"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/223986126" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#223986126">(Jan 26 2021 at 01:15)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224097692"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224097692" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224097692">(Jan 26 2021 at 20:25)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224097919"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224097919" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224097919">(Jan 26 2021 at 20:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224241478"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224241478" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224241478">(Jan 27 2021 at 20:18)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224242446"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224242446" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224242446">(Jan 27 2021 at 20:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224244465"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224244465" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224244465">(Jan 27 2021 at 20:43)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224268331"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224268331" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224268331">(Jan 28 2021 at 00:16)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224276564"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224276564" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224276564">(Jan 28 2021 at 02:10)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224277109"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224277109" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224277109">(Jan 28 2021 at 02:18)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224279457"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224279457" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224279457">(Jan 28 2021 at 03:06)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224364696"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224364696" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224364696">(Jan 28 2021 at 17:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224382149"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224382149" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224382149">(Jan 28 2021 at 19:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224387511"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224387511" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224387511">(Jan 28 2021 at 20:24)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224392290"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224392290" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224392290">(Jan 28 2021 at 21:03)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224394557"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224394557" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224394557">(Jan 28 2021 at 21:23)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224408389"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224408389" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224408389">(Jan 28 2021 at 23:17)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224418395"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224418395" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224418395">(Jan 29 2021 at 01:00)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224526297"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224526297" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224526297">(Jan 29 2021 at 20:07)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224528661"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224528661" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224528661">(Jan 29 2021 at 20:29)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224529703"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224529703" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224529703">(Jan 29 2021 at 20:38)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224535843"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224535843" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224535843">(Jan 29 2021 at 21:25)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224541834"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224541834" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224541834">(Jan 29 2021 at 22:10)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224544340"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224544340" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224544340">(Jan 29 2021 at 22:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224551118"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224551118" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224551118">(Jan 29 2021 at 23:40)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224551309"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224551309" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224551309">(Jan 29 2021 at 23:43)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224551678"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224551678" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224551678">(Jan 29 2021 at 23:49)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224557798"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224557798" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224557798">(Jan 30 2021 at 01:24)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224557940"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224557940" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224557940">(Jan 30 2021 at 01:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224559429"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224559429" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224559429">(Jan 30 2021 at 02:02)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224563634"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224563634" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224563634">(Jan 30 2021 at 03:52)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224563648"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224563648" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224563648">(Jan 30 2021 at 03:53)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224563702"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224563702" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224563702">(Jan 30 2021 at 03:54)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224566034"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224566034" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224566034">(Jan 30 2021 at 04:58)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224566476"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224566476" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224566476">(Jan 30 2021 at 05:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224567025"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224567025" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224567025">(Jan 30 2021 at 05:25)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224607404"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224607404" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224607404">(Jan 30 2021 at 21:58)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224774552"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224774552" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224774552">(Feb 01 2021 at 19:01)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224775784"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224775784" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224775784">(Feb 01 2021 at 19:10)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224787953"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224787953" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224787953">(Feb 01 2021 at 20:43)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224792251"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224792251" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224792251">(Feb 01 2021 at 21:16)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224792871"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224792871" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224792871">(Feb 01 2021 at 21:21)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224792877"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224792877" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224792877">(Feb 01 2021 at 21:21)</a>:</h4>
<p><strong>pchickey</strong> has marked <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> as ready for review.</p>



<a name="224800869"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224800869" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224800869">(Feb 01 2021 at 22:14)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224802333"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224802333" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224802333">(Feb 01 2021 at 22:26)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224803234"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224803234" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224803234">(Feb 01 2021 at 22:33)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224804469"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224804469" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224804469">(Feb 01 2021 at 22:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224808401"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224808401" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224808401">(Feb 01 2021 at 23:26)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>WIP</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224810639"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224810639" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224810639">(Feb 01 2021 at 23:47)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<h2>Traits for the rest of WASI's features</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224810957"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224810957" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224810957">(Feb 01 2021 at 23:50)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<h2>Traits for the rest of WASI's features</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224812176"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224812176" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224812176">(Feb 02 2021 at 00:03)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types.</p>
<h2>Traits for the rest of WASI's features</h2>
<h2>Snapshot architecture</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224812853"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224812853" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224812853">(Feb 02 2021 at 00:11)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR)</p>
<h2>Traits for the rest of WASI's features</h2>
<h2>Snapshot architecture</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224814089"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224814089" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224814089">(Feb 02 2021 at 00:25)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR)</p>
<h2>Traits for the rest of WASI's features</h2>
<h2>Snapshot architecture</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224815498"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224815498" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224815498">(Feb 02 2021 at 00:45)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR)</p>
<h2>Traits for the rest of WASI's features</h2>
<h2>Snapshot architecture</h2>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224816325"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224816325" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224816325">(Feb 02 2021 at 00:57)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224816931"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224816931" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224816931">(Feb 02 2021 at 01:06)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224816985"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224816985" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224816985">(Feb 02 2021 at 01:07)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon!</p>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224817060"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224817060" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224817060">(Feb 02 2021 at 01:08)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>cap-std-sync</code> implementation of the WASI traits</h2>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224817669"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224817669" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224817669">(Feb 02 2021 at 01:18)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>Wasi-common's test suite lives at <code>crates/test-programs</code>. </p>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs out to a separate PR</li>
</ul>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;<br>
</p>
</blockquote>



<a name="224818280"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224818280" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224818280">(Feb 02 2021 at 01:29)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
</ul>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<h1>Regressions</h1>
<p>Some behavior around trailing slashes in paths has changed from the test suite. We expect there are some improvements we'll make to these corner cases after this PR lands.</p>
<p>For now, the <code>path_rename_file_trailing_slashes</code> and <code>remove_directory_trailing_slashes</code> tests are <code>#[ignore]</code>'d on all platforms, and additionally the <code>interesting_paths</code> test is ignored on Windows.</p>
<p>Additionally, some behavior around the <code>FdFlags::{SYNC, DSYNC, RSYNC}</code> flags have changed. For now, cap-std does not support opening a file with these flags. Using these flags will result in an <code>Errno::NOTSUP</code> (Not supported).</p>
<h1>Outstanding issues required to merge this PR:</h1>
<ul>
<li>[ ] Metadata not associated with open file panics on windows: <a href="https://github.com/bytecodealliance/cap-std/issues/142">https://github.com/bytecodealliance/cap-std/issues/142</a></li>
<li>[ ] <code>DirExt::delete_file_or_symlink</code> for <code>symlink_create</code> test to pass on Windows</li>
<li>[ ] Yeet the virtfs into a separate PR<br>
</li>
</ul>
</blockquote>



<a name="224818895"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224818895" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224818895">(Feb 02 2021 at 01:39)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. This PR will only land with support for testing <code>wasi-cap-std-sync</code>, but it will be easy to add more runtimes under <code>tests/wasm_tests/runtime/</code> as more impls are created, with a minimum of boilerplate in <code>build.rs</code>.</li>
</ul>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<p>You used to pass a <code>WasiCtx</code> (or whatever ctx type) directly to the <code>Wasi</code> struct generated by <code>wiggle-wasmtime</code>, and the generated code would wrap the ctx into a <code>Rc&lt;RefCell&lt;ctx&gt;&gt;</code>. This got in the way of supporting multiple snapshots simultaneously, so now callers of the generated code have to pass in an <code>Rc&lt;RefCell&lt;ctx&gt;&gt;</code>.</p>
<p>I made mechanical changes to <code>wasi-nn</code> (cc @abrown) and <code>wasi-crypto</code> (cc @jedisct1) to accommodate these changes. This was of particular help to the <code>wasi-crypto</code> code - I was able to erase an entire Rc&lt;&gt; indirection by getting wiggle out of our way. Sorry that I did not take the time to break this out into a standalone PR. </p>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<p><code>wasmtime-wasi</code> now supports using multiple snapshots to interface to the same <code>WasiCtx</code>!</p>
<ul>
<li>`wasmtime_wa<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224819185"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224819185" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224819185">(Feb 02 2021 at 01:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. This PR will only land with support for testing <code>wasi-cap-std-sync</code>, but it will be easy to add more runtimes under <code>tests/wasm_tests/runtime/</code> as more impls are created, with a minimum of boilerplate in <code>build.rs</code>.</li>
</ul>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<p>You used to pass a <code>WasiCtx</code> (or whatever ctx type) directly to the <code>Wasi</code> struct generated by <code>wiggle-wasmtime</code>, and the generated code would wrap the ctx into a <code>Rc&lt;RefCell&lt;ctx&gt;&gt;</code>. This got in the way of supporting multiple snapshots simultaneously, so now callers of the generated code have to pass in an <code>Rc&lt;RefCell&lt;ctx&gt;&gt;</code>.</p>
<p>I made mechanical changes to <code>wasi-nn</code> (cc @abrown) and <code>wasi-crypto</code> (cc @jedisct1) to accommodate these changes. This was of particular help to the <code>wasi-crypto</code> code - I was able to erase an entire Rc&lt;&gt; indirection by getting wiggle out of our way. Sorry that I did not take the time to break this out into a standalone PR. </p>
<h1>Changes to <code>wasmtime-wasi</code></h1>
<p><code>wasmtime-wasi</code> now supports using multiple snapshots to interface to the same <code>WasiCtx</code>!</p>
<ul>
<li>`wasmtime_w<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224819286"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224819286" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224819286">(Feb 02 2021 at 01:46)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code></li>
<li><code>wasi_common::ErrorKind</code></li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. This PR will only land with support for testing <code>wasi-cap-std-sync</code>, but it will be easy to add more runtimes under <code>tests/wasm_tests/runtime/</code> as more impls are created, with a minimum of boilerplate in <code>build.rs</code>.</li>
</ul>
<h1>Changes to <code>wiggle-wasmtime</code> and dependents</h1>
<p>You used to pass a <code>WasiCtx</code> (or whatever ctx type) directly to the <code>Wasi</code> struct generated by <code>wiggle-wasmtime</code>, and the generated code would wrap the ctx into a <code>Rc&lt;RefCell&lt;ctx&gt;&gt;</code>. This got in the way of supporting multiple snapshots simul<br>
[message truncated]</p>
</blockquote>



<a name="224819448"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224819448" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224819448">(Feb 02 2021 at 01:48)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants </p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. This PR will only land with support for testing <code>wasi-cap-std-sync</code>, but it will be easy to add more runtimes under `tests/wasm_<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224819488"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224819488" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224819488">(Feb 02 2021 at 01:49)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. T<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224821128"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224821128" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224821128">(Feb 02 2021 at 02:22)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224821559"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224821559" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224821559">(Feb 02 2021 at 02:31)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224821932"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224821932" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224821932">(Feb 02 2021 at 02:38)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224823552"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224823552" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224823552">(Feb 02 2021 at 03:12)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224824094"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224824094" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224824094">(Feb 02 2021 at 03:22)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224825217"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224825217" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224825217">(Feb 02 2021 at 03:40)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224916940"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224916940" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224916940">(Feb 02 2021 at 18:44)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224939569"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224939569" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224939569">(Feb 02 2021 at 21:30)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224940938"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224940938" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224940938">(Feb 02 2021 at 21:41)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224952481"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224952481" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224952481">(Feb 02 2021 at 23:30)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224956793"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224956793" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224956793">(Feb 03 2021 at 00:16)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224957500"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224957500" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224957500">(Feb 03 2021 at 00:24)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="224960987"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/224960987" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#224960987">(Feb 03 2021 at 01:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225035539"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225035539" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225035539">(Feb 03 2021 at 15:57)</a>:</h4>
<p>jedisct1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582521456">PR Review</a>.</p>



<a name="225035540"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225035540" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225035540">(Feb 03 2021 at 15:57)</a>:</h4>
<p>jedisct1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569532238">PR Review Comment</a>:</p>
<blockquote>
<p>Incrementing the key is a very good thing; it helps avoid reuse and catch bugs (and we don't have to deal with <code>select(2)</code>).</p>
<p>But why not wrap on overflow? If entries are properly closed after use, there wouldn't be anything wrong with that, especially since the map is checked right after (even though it is not necessary before a wrap).</p>
</blockquote>



<a name="225036136"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225036136" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225036136">(Feb 03 2021 at 16:00)</a>:</h4>
<p>jedisct1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582524658">PR Review</a>.</p>



<a name="225036138"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225036138" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225036138">(Feb 03 2021 at 16:00)</a>:</h4>
<p>jedisct1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569534754">PR Review Comment</a>:</p>
<blockquote>
<p>What are the thread-safety guaranty requirements?</p>
<p>Couldn't multiple threads access the same key concurrently?</p>
<p>Instead of <code>Any</code>, wouldn't it be safer to enforce <code>Any + Send + Sync</code>?</p>
</blockquote>



<a name="225064950"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225064950" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225064950">(Feb 03 2021 at 19:07)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582707612">PR Review</a>.</p>



<a name="225064952"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225064952" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225064952">(Feb 03 2021 at 19:07)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569673728">PR Review Comment</a>:</p>
<blockquote>
<p>A <code>Table</code> should only be associated with a single <code>wasmtime::Store</code>, which is not Send or Sync. So, I made no attempt to provide any thread-safety guarantees.</p>
</blockquote>



<a name="225065265"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225065265" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225065265">(Feb 03 2021 at 19:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225065331"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225065331" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225065331">(Feb 03 2021 at 19:09)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582709802">PR Review</a>.</p>



<a name="225065332"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225065332" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225065332">(Feb 03 2021 at 19:09)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569676920">PR Review Comment</a>:</p>
<blockquote>
<p>Thanks, I fixed this to wrap on overflow, and only trap when the table is full.</p>
</blockquote>



<a name="225068138"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225068138" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225068138">(Feb 03 2021 at 19:28)</a>:</h4>
<p>jedisct1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582724695">PR Review</a>.</p>



<a name="225068139"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225068139" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225068139">(Feb 03 2021 at 19:28)</a>:</h4>
<p>jedisct1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569688592">PR Review Comment</a>:</p>
<blockquote>
<p>Are descriptors 0/1/2 counted here?</p>
</blockquote>



<a name="225068989"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225068989" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225068989">(Feb 03 2021 at 19:33)</a>:</h4>
<p>jedisct1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582729096">PR Review</a>.</p>



<a name="225068990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225068990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225068990">(Feb 03 2021 at 19:33)</a>:</h4>
<p>jedisct1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569691987">PR Review Comment</a>:</p>
<blockquote>
<p>As a side note, it may be useful to:</p>
<ul>
<li>Have a way to set an upper limit to the number of entries</li>
<li>Have a way to get the current set of keys in the table, or at least the count. This is super useful in order to debug descriptor leaks (not just in hostcalls, also in applications).</li>
</ul>
</blockquote>



<a name="225069309"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225069309" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225069309">(Feb 03 2021 at 19:35)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582730537">PR Review</a>.</p>



<a name="225069310"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225069310" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225069310">(Feb 03 2021 at 19:35)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569693050">PR Review Comment</a>:</p>
<blockquote>
<p>The ctx constructor asserts that descriptors 0/1/2 are populated, so I believe they are counted, though in a different spot.</p>
<p>I agree those features sound useful, but I think they're out of scope for landing the initial version of this.</p>
</blockquote>



<a name="225069902"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225069902" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225069902">(Feb 03 2021 at 19:39)</a>:</h4>
<p>jedisct1 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582734021">PR Review</a>.</p>



<a name="225069904"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225069904" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225069904">(Feb 03 2021 at 19:39)</a>:</h4>
<p>jedisct1 created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569695795">PR Review Comment</a>:</p>
<blockquote>
<p>So a handle will never be shared by multiple threads?</p>
<p>Is this a requirement of the WebAssembly threading proposal, or a temporary limitation in Wasmtime?</p>
<p>More generally, should hostcalls assume that a resource will never be shared?</p>
</blockquote>



<a name="225072803"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225072803" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225072803">(Feb 03 2021 at 20:00)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-582750596">PR Review</a>.</p>



<a name="225072804"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225072804" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225072804">(Feb 03 2021 at 20:00)</a>:</h4>
<p>pchickey created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r569708851">PR Review Comment</a>:</p>
<blockquote>
<p>Right, a handle will never be shared between threads. It is a limitation of Wasmtime until we choose to implement a threading proposal.</p>
<p>If a hostcall needs to assume a resource is shared between multiple Stores running in separate threads, it can do its own internal arc/mutex wrapping inside the resource. </p>
</blockquote>



<a name="225092751"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225092751" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225092751">(Feb 03 2021 at 22:27)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225095576"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225095576" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225095576">(Feb 03 2021 at 22:55)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225097145"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225097145" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225097145">(Feb 03 2021 at 23:11)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225097246"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225097246" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225097246">(Feb 03 2021 at 23:12)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. T<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225100807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225100807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225100807">(Feb 03 2021 at 23:52)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225102974"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225102974" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225102974">(Feb 04 2021 at 00:17)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225109003"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225109003" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225109003">(Feb 04 2021 at 01:35)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225110104"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225110104" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225110104">(Feb 04 2021 at 01:53)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. T<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225110105"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225110105" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225110105">(Feb 04 2021 at 01:53)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. T<br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225110741"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225110741" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225110741">(Feb 04 2021 at 02:04)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225198098"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225198098" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225198098">(Feb 04 2021 at 18:03)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225203081"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225203081" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225203081">(Feb 04 2021 at 18:38)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225236923"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225236923" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225236923">(Feb 04 2021 at 22:59)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225240943"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225240943" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225240943">(Feb 04 2021 at 23:38)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225247968"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225247968" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225247968">(Feb 05 2021 at 01:01)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225247993"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225247993" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225247993">(Feb 05 2021 at 01:01)</a>:</h4>
<p><strong>pchickey</strong> requested <a href="https://github.com/sunfishcode">sunfishcode</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a>.</p>



<a name="225248561"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248561" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248561">(Feb 05 2021 at 01:09)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a> from <code>pch/wasi_common_cap_std</code> to <code>main</code>:</p>
<blockquote>
<p>This PR is a complete rewrite of the <code>wasi-common</code> crate. It uses @sunfishcode 's new <code>cap-std</code> family of crates to provide a sandboxed implementation of WASI on the local filesystem.</p>
<p>Note that this is a breaking change for all users of WASI with Wasmtime, except for the C API.</p>
<h1>Re-architecting <code>wasi-common</code></h1>
<p>Over the past year or so, we've run up against many design problems in <code>wasi-common</code>. Many of these problems ended up being so fundamental that a rewrite, as prolonged as it was, ended up being more tractable than incremental changes.</p>
<h2>The <code>Table</code></h2>
<p><code>wasi-common</code> now has a <code>Table</code> type that is designed to map u32 handles to resources. The table is now part of the public interface to a <code>WasiCtx</code> - it is reference counted so that it can be shared beyond a <code>WasiCtx</code> with other WASI proposals (e.g. <code>wasi-crypto</code> and <code>wasi-nn</code>) to manage their resources. Elements in the <code>Table</code> are <code>Any</code> typed.</p>
<p>The <code>Table</code> type is intended to model how the Interface Types concept of Resources is shaping up. Right now it is just an approximation.</p>
<h2>The <code>WasiFile</code> and <code>WasiDir</code> traits</h2>
<p>The WASI specification only defines one <code>handle</code> type, <code>fd</code>, on which all operations on both files and directories (aka dirfds) are defined. We believe this is a design mistake, and are architecting wasi-common to make this straightforward to correct in future snapshots of WASI. Wasi-common internally treats files and directories as two distinct resource types in the table - <code>Box&lt;dyn WasiFile&gt;</code> and <code>Box&lt;dyn WasiDir&gt;</code>. The snapshot 0 and 1 interfaces via <code>fd</code> will attempt to downcast a table element to one or both of these interfaces depending on what is appropriate - e.g. <code>fd_close</code> operates on both files and directories, <code>fd_read</code> only operates on files, and <code>fd_readdir</code> only operates on directories.</p>
<p>The <code>WasiFile</code> and <code>WasiDir</code> traits are defined by <code>wasi-common</code> in terms of types defined directly in the crate's source code (I decided it should NOT those generated by the <code>wiggle</code> proc macros, see snapshot architecture below), as well as the <code>cap_std::time</code> family of types. And, importantly, <code>wasi-common</code> itself provides no implementation of <code>WasiDir</code>, and only two trivial implementations of <code>WasiFile</code> on the <code>crate::pipe::{ReadPipe, WritePipe}</code> types, which in turn just delegate to <code>std::io::{Read, Write}</code>. In order for <code>wasi-common</code> to access the local filesystem at all, you need to provide <code>WasiFile</code> and <code>WasiDir</code> impls through either the new <code>wasi-cap-std-sync</code> crate found at <code>crates/wasi-common/cap-std-sync</code> - see the section on that crate below - or by providing your own implementation from elsewhere.</p>
<p>This design makes it possible for <code>wasi-common</code> embedders to statically reason about access to the local filesystem by examining what impls are linked into an application. We found that this separation of concerns also makes it pretty enjoyable to write alternative implementations, e.g. a virtual filesystem (which will land in a future PR).</p>
<h2>Traits for the rest of WASI's features</h2>
<p>Other aspects of a WASI implementation are not yet considered resources and accessed by <code>handle</code>. We plan to correct this design deficiency in WASI in the future, but for now we have designed the following traits to provide embedders with the same sort of implementation flexibility they get with WasiFile/WasiDir:</p>
<ul>
<li>Timekeeping: <code>clocks::WasiSystemClock</code> and <code>clock::WasiMonotonicClock</code> provide the two interfaces for a clock. <code>WasiSystemClock</code> represents time as a <code>cap_std::time::SystemTime</code>, and <code>WasiMonotonicClock</code> represents time as <code>cap_std::time::Instant</code>.</li>
<li>Randomness: we re-use the <code>cap_rand::RngCore</code> trait to represent a randomness source. A trivial <code>Deterministic</code> impl is provided.</li>
<li>Scheduling: The <code>WasiSched</code> trait abstracts over the <code>sched_yield</code> and <code>poll_oneoff</code> functions.</li>
</ul>
<p>Users can provide implementations of each of these interfaces to the <code>WasiCtx::builder(...)</code> function. The <code>wasi_cap_std_sync::WasiCtxBuilder::new()</code> function uses this public interface to plug in its own implementations of each of these resources.</p>
<h2>Snapshot architecture</h2>
<p>One goal we've had for a while, but not quite met, is for multiple WASI snapshots to provide an interface to the same underlying <code>WasiCtx</code>. This provides us a path to evolve WASI by allowing the same WASI Command to import functions from different snapshots - e.g. the user could use Rust's <code>std</code> which imports snapshot 1, but also depend directly on the <code>wasi</code> crate which imports some future snapshot 2. Right now, this amounts to supporting snapshot 1 and "snapshot 0" aka wasi_unstable at once.</p>
<p>The architectural rules for snapshots are:</p>
<ul>
<li>Snapshots are arranged into modules under <code>crate::snapshots::</code>.</li>
<li>Each snapshot should invoke <code>wiggle::from_witx!</code> with <code>ctx: crate::WasiCtx</code> in its module, and impl all of the required traits.</li>
<li>Snapshots can be implemented in terms of other snapshots. For example, snapshot 0 is mostly implemented by calling the snapshot 1 implementation, and converting its own types back and forth with the snapshot 1 types. In a few cases, that is not feasible, so snapshot 0 carries its own implementations in terms of the <code>WasiFile</code> and <code>WasiSched</code> traits.</li>
<li>Snapshots can be implemented in terms of the <code>Wasi*</code> traits given by <code>WasiCtx</code>. No further downcasting via the <code>as_any</code> escape hatch is permitted.</li>
</ul>
<h2>The <code>wasi_common::Error</code> type</h2>
<p><code>wasi_common::Error</code> is now <code>anyhow::Error</code>. <code>wasi_common::snapshots::preview_1</code> contains all of the logic for transforming an <code>Error</code> into an <code>Errno</code>, by downcasting the error into any of</p>
<ul>
<li><code>std::io::Error</code> - these are thrown by <code>std</code>, <code>cap_std</code>, etc for most of the operations WASI is concerned with.</li>
<li><code>wasi_common::ErrorKind</code> - these are a subset of the Errnos, and are constructed directly by wasi-common or an impl rather than coming from the OS or some library which doesn't know about WASI.</li>
<li><code>wiggle::GuestError</code></li>
<li><code>std::num::TryFromIntError</code></li>
<li><code>std::str::Utf8Error</code><br>
and then applying specialized logic to translate each of those into <code>Errno</code>s.</li>
</ul>
<p>The <code>wasi_common::ErrorExt</code> trait provides human-friendly constructors for the <code>wasi_common::ErrorKind</code> variants .</p>
<p>If you throw an error that does not downcast to one of those, it will turn into a <code>wiggle::Trap</code> and terminate execution.</p>
<p>The real value of using <code>anyhow::Error</code> here is being able to use <code>anyhow::Result::context</code> to aid in debugging of errors.</p>
<h2>The <code>wasi-cap-std-sync</code> implementation of the WASI traits</h2>
<p>The <code>wasi-cap-std-sync</code> crate provides impl of <code>WasiFile</code> and <code>WasiDir</code> in terms of <code>cap_std::fs::{File, Dir}</code>. These types provide sandboxed access to the local filesystem on both Unix and Windows.</p>
<p>The entire design story of <code>cap-std</code> is much bigger than we can address here, but in short, its functionality replaces all of the <code>wasi_common::sys</code> hierarchy, as well as the <code>yanix</code> / <code>winx</code> crates. All syscalls are hidden behind the <code>cap-std</code> hierarchy, with the lone exception of the <code>sched</code> implementation, which is provided for both unix and windows in separate modules. </p>
<p>Any <code>wasi_common::{WasiCtx, WasiCtxBuilder}</code> is interoperable with the <code>wasi-cap-std-sync</code> crate. However, for convenience, <code>wasi-cap-std-sync</code> provides its own <code>WasiCtxBuilder</code> that hooks up to all of the crate's components, i.e. it fills in all of the arguments to <code>WasiCtx::builder(...)</code>, presents <code>preopen_dir</code> in terms of <code>cap_std::fs::Dir</code>, and provides convenience methods for inheriting the parent process's stdio, args, and env.</p>
<p>The only place we expect to run into long-term compatibility issues between <code>wasi-cap-std-sync</code> and the other impl crates that will come later is in the <code>Sched</code> abstraction. Once we can build an async scheduler based on Rust <code>Future</code>s, async impls will be able to interoperate, but the synchronous scheduler depends on downcasting the <code>WasiFile</code> type down to concrete types it knows about (which in turn impl <code>AsRawFd</code> for passing to unix <code>poll</code>, or the analogous traits on windows).</p>
<p>Why is this impl suffixed with <code>-sync</code>? <a href="https://github.com/bytecodealliance/wasmtime/pull/2434">https://github.com/bytecodealliance/wasmtime/pull/2434</a> async is coming soon! The async impl may end up depending on tokio or other relatively heavy deps, so we will retain a sync implementation so that wasi-common users have an option of not pulling in an async runtime.</p>
<h1>Improving the WASI test suite</h1>
<p>The bulk of <code>wasi-common</code>'s test suite lives at <code>crates/test-programs</code>. This test suite was extremely useful for guiding this rewrite. We improved the test suite in numerous ways, including</p>
<ul>
<li>Breaking tests out into smaller units, so that failing behavior can be isolated more easily</li>
<li>Introducing a scheme which allows the test runner to describe to the wasm code what behaviors to expect of the embedding. Behaviors which vary between platforms (e.g. <code>fd_allcoate</code> is impossible to faithfully implement on Windows and is not provided by MacOS) are communicated to the guest by environment variables, which in turn is available in the guest behind the global <code>TESTCONFIG</code> struct.</li>
<li>Introducing the <code>assert_errno!</code> macro, which pretty-prints errnos by name rather than number in the error message. <code>assert_errno!</code> integrates with <code>TESTCONFIG</code> to specify which errno is expected on which platform. This allows the test source to describe the full set of acceptable errnos a call may return (all possible errnos will be acceptable if no <code>ERRNO_MODE_*</code> env var is set), and also detect regressions on any given platform.</li>
<li>We still use <code>crates/test-platforms/build.rs</code> to generate the test suite, and use functions directly in <code>build.rs</code> to describe the <code>TESTCONFIG</code> expectations, as well as which tests are to be ignored (expected to fail due to regressions) on what platforms.</li>
<li>The test suite has been generalized to support multiple backends to the <code>wasi-common</code> crate. <br>
[message truncated]</li>
</ul>
</blockquote>



<a name="225248888"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248888" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248888">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-583944078">PR Review</a>.</p>



<a name="225248889"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248889" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248889">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#pullrequestreview-583944078">PR Review</a>.</p>



<a name="225248890"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248890" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248890">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r570652081">PR Review Comment</a>:</p>
<blockquote>
<p>Is this line still needed?</p>
</blockquote>



<a name="225248892"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248892" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248892">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r570652250">PR Review Comment</a>:</p>
<blockquote>
<p>Are these <code>fail-fast: false</code> lines still needed?</p>
</blockquote>



<a name="225248915"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248915" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248915">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode deleted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r570652081">PR Review Comment</a>.</p>



<a name="225248920"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225248920" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225248920">(Feb 05 2021 at 01:15)</a>:</h4>
<p>sunfishcode deleted <a href="https://github.com/bytecodealliance/wasmtime/pull/2487#discussion_r570652250">PR Review Comment</a>.</p>



<a name="225252152"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%232487%20rewrite%20wasi-common%20in%20terms%20of%20cap-std/near/225252152" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.232487.20rewrite.20wasi-common.20in.20terms.20of.20cap-std.html#225252152">(Feb 05 2021 at 02:02)</a>:</h4>
<p>pchickey merged <a href="https://github.com/bytecodealliance/wasmtime/pull/2487">PR #2487</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>