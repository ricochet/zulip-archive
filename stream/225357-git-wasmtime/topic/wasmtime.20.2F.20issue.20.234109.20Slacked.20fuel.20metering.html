<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4109 Slacked fuel metering · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html">wasmtime / issue #4109 Slacked fuel metering</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="281540112"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281540112" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281540112">(May 07 2022 at 13:14)</a>:</h4>
<p>pepyakin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather significant performance hit.</p>
<p>I believe we can do better in case the user only wants to know <strong>if</strong>  the execution exceeded some fuel limit. The cost to pay is that condition is detected with a delay, hence slacked. Therefore, this works similarly to the fuel metering mechanism only if there are no side effects when the execution reaches its deadline. For instance, all changes performed are rolled back if a DB transaction exceeds its fuel allowance.</p>
<p>The idea is to take the existing fuel mechanism, remove the compare &amp; conditional jumps, and check the out-of-fuel condition asynchronously.</p>
<p>The tricky part is the asynchronous fuel variable checking and suspending the execution. </p>
<p>We could leverage HotSpot-style safepoints to implement this. Such a safepoint could be implemented just as access to a page. Suspending the execution could be triggered by <code>mprotect</code>-ing the page. Similarly to epoch interruption, we could place safepoints when entering a function and loop backedges. We would need to extract the fuel counter while handling the page fault signal. We assume that the codegen thoughtfully left us a mapping where the fuel counter is saved: either a register or an offset for a spilled variable. Having recovered the fuel counter, we'd check if it exceeded the limit and yield if so.</p>
<p>I've tried to benchmark this by avoiding <code>fuel_check</code>, and the results seemed promising. The benchmark shows a 5-20% impact on performance relative to non-metered execution, whereas the fuel metering overhead is 15-40%. Those, however, do not include safepoint access.</p>
<ul>
<li>Does this sound sensible? Am I missing something obvious?</li>
<li>Is this something that could be considered to be accepted upstream?<br>
</li>
</ul>
</blockquote>



<a name="281687378"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281687378" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281687378">(May 09 2022 at 13:53)</a>:</h4>
<p>pepyakin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather significant performance hit.</p>
<p>I believe we can do better in case the user only wants to know <strong>if</strong>  the execution exceeded some fuel limit. The cost to pay is that condition is detected with a delay, hence slacked. Therefore, this works similarly to the fuel metering mechanism only if there are no side effects when the execution reaches its deadline. For instance, all changes performed are rolled back if a DB transaction exceeds its fuel allowance.</p>
<p>The idea is to take the existing fuel mechanism, remove the compare &amp; conditional jumps, and check the out-of-fuel condition asynchronously.</p>
<p>The tricky part is the asynchronous fuel variable checking and suspending the execution. </p>
<p>We could leverage HotSpot-style safepoints to implement this. Such a safepoint could be implemented just as access to a page. Suspending the execution could be triggered by <code>mprotect</code>-ing the page. Similarly to epoch interruption, we could place safepoints when entering a function and loop backedges. We would need to extract the fuel counter while handling the page fault signal. We assume that the codegen thoughtfully left us a mapping where the fuel counter is saved: either a register or an offset for a spilled variable. Having recovered the fuel counter, we'd check if it exceeded the limit and yield if so.</p>
<ul>
<li>Does this sound sensible? Am I missing something obvious?</li>
<li>Is this something that could be considered to be accepted upstream?<br>
</li>
</ul>
</blockquote>



<a name="281687799"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281687799" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281687799">(May 09 2022 at 13:56)</a>:</h4>
<p>pepyakin edited <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather significant performance hit.</p>
<p>I believe we can do better in case the user only wants to know <strong>if</strong>  the execution exceeded some fuel limit. The cost to pay is that condition is detected with a delay, hence slacked. Therefore, this works similarly to the fuel metering mechanism only if there are no side effects when the execution reaches its deadline. For instance, all changes performed are rolled back if a DB transaction exceeds its fuel allowance.</p>
<p>The idea is to take the existing fuel mechanism, remove the compare &amp; conditional jumps, and check the out-of-fuel condition asynchronously.</p>
<p>The tricky part is the asynchronous fuel variable checking and suspending the execution. </p>
<p>We could leverage HotSpot-style safepoints to implement this. Such a safepoint could be implemented just as access to a page. Suspending the execution could be triggered by <code>mprotect</code>-ing the page. Similarly to epoch interruption, we could place safepoints when entering a function and loop backedges. We would need to extract the fuel counter while handling the page fault signal. We assume that the codegen thoughtfully left us a mapping where the fuel counter is saved: either a register or an offset for a spilled variable. Having recovered the fuel counter, we'd check if it exceeded the limit and yield if so.</p>
<p>I realized that this is not trivial to benchmark. I tried removing <code>fuel_check</code>, but that would lead to DCE of the now unused fuel value. I would appreciate suggestions on how to benchmark that properly.</p>
<ul>
<li>Does this sound sensible? Am I missing something obvious?</li>
<li>Is this something that could be considered to be accepted upstream?<br>
</li>
</ul>
</blockquote>



<a name="281692126"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281692126" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281692126">(May 09 2022 at 14:26)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1121175310">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>One of the primary reasons for fuel as oppose to epochs is due to the deterministic nature of fuel, which I think is why a scheme like you've proposed where with asynchronous checks wouldn't entirely supplant fuel but would perhaps be another method of limiting wasm execution in Wasmtime. In some sense though what it seems like you're looking for is a hybrid of epochs (asynchronous cancellation, low overhead) and fuel (the measure of cancellation being how much code has run). I wonder if that might make more sense? For example if you could read (but not write) fuel from another thread then you could increment the epoch when fuel runs out or something like that.</p>
<p>In terms of the cost of fuel, though, I believe the main cost associated with it is not the checks for out-of-fuel but rather the management of the fuel counter itself which has lots of loads and, critically, stores to memory. The repeated memory traffic ends up being quite costly as oppose to epochs which is simply always reading the same memory location which should be more efficient (and from our benchmarking the efficiency of epochs is much better).</p>
<p>I suppose that I can put this a little differently in that if the fuel check was moved asynchronously I'm not sure it would buy much. If the check itself is moved externally then that loses the determinism of fuel, and I also think that the main cost associated with fuel will still be present, namely the management of the fuel counter itself.</p>
</blockquote>



<a name="281710941"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281710941" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281710941">(May 09 2022 at 16:34)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1121325078">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>There does seem to be some utility to a "count the ops but don't interrupt" configuration for fuel, in that some users may be interested in basically a perf counter/stat but don't need to set limits. I agree that the removal of the control flow will only remove a part of the overhead for fuel; but it should significantly shrink code size, which is something.</p>
<p>I guess mostly I'd love to see measurements: @pepyakin have you experimented with this already? If not, would you be willing to hack something together? It shouldn't be <em>too</em> complex: basically we want to return from a codegen helper <a href="https://github.com/bytecodealliance/wasmtime/blob/4e6f3ea899efd6bbe8e77235fcba69b73257d23c/crates/cranelift/src/func_environ.rs#L539">here</a> (just after <code>fuel_increment_var</code>, before we create the blocks and add the compare/branch).</p>
</blockquote>



<a name="281712153"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281712153" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281712153">(May 09 2022 at 16:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1121333837">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>(For clarity, if this shows a sufficient benefit for your use-case, then I agree with Alex's suggested hybrid approach above: the way to go is to make it a config option to count fuel without interrupts, and then use epoch interruption to actually halt execution asynchronously.)</p>
</blockquote>



<a name="281807549"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281807549" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281807549">(May 10 2022 at 11:01)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1122240936">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>In some sense though what it seems like you're looking for is a hybrid of epochs (asynchronous cancellation, low overhead) and fuel (the measure of cancellation being how much code has run). I wonder if that might make more sense? For example if you could read (but not write) fuel from another thread then you could increment the epoch when fuel runs out or something like that.</p>
</blockquote>
<p>Yes, this is similar to what I was looking for. </p>
<p>Although I would still clarify,</p>
<ol>
<li>I am interested in if a given program finished executing within a given number of steps.</li>
<li>If it was not able to finish, I am not interested in the results.</li>
<li>I am also ok with allowing some time slack until the detection that the program exceeded the number of steps.</li>
</ol>
<p>Given point 2 this can be deterministic: ignoring timing, multiple executions of the same program with the same inputs will lead to the same outcome.</p>
<p>I was also wondering about the same construction that you propose. I assumed that that approach would require memory writes on each loop header &amp; function call and those have to be atomic, and I assumed that would be even more overhead.</p>
<blockquote>
<p>In terms of the cost of fuel, though, I believe the main cost associated with it is not the checks for out-of-fuel but rather the management of the fuel counter itself which has lots of loads and, critically, stores to memory. The repeated memory traffic ends up being quite costly as oppose to epochs which is simply always reading the same memory location which should be more efficient (and from our benchmarking the efficiency of epochs is much better).</p>
</blockquote>
<p>I might have explained myself poorly. </p>
<p>All this faffing around with safepoints I proposed was in the hope, that we can avoid not only compare&amp;branch but the memory writing as well. It is avoiding, not eliminating though since the fuel counter still can be spilled.</p>
<blockquote>
<p>I guess mostly I'd love to see measurements: @pepyakin have you experimented with this already? If not, would you be willing to hack something together? It shouldn't be _too_ complex: basically we want to return from a codegen helper <a href="https://github.com/bytecodealliance/wasmtime/blob/4e6f3ea899efd6bbe8e77235fcba69b73257d23c/crates/cranelift/src/func_environ.rs#L539">here</a> (just after <code>fuel_increment_var</code>, before we create the blocks and add the compare/branch).</p>
</blockquote>
<p>So all of the above are just uneducated guesses, turns out. I've tried to make a benchmark but then I realized that did a mickey mouse mistake, the one about DCE I mentioned in OP. </p>
<p>I'm too will love to see measurements and willing to hack. I am not sure what would be the best way to do that though.</p>
</blockquote>



<a name="281839872"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281839872" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281839872">(May 10 2022 at 15:22)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1122538404">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>So all of the above are just uneducated guesses, turns out. I've tried to make a benchmark but then I realized that did a mickey mouse mistake, the one about DCE I mentioned in OP.</p>
</blockquote>
<p>Ah, sorry, I had missed that  note; but it's a little surprising given that <a href="https://github.com/bytecodealliance/wasmtime/blob/4e6f3ea899efd6bbe8e77235fcba69b73257d23c/crates/cranelift/src/func_environ.rs#L377">here</a> we call <code>fuel_save_from_var</code> to store the value back to memory, and this is invoked at every function exit. Stores shouldn't be DCE'd (since they are side-effecting). Can you dump the CLIF (<code>RUST_LOG=trace</code> should show it buried among a bunch of other output) and see what it looks like just after wasm translation?</p>
</blockquote>



<a name="281844232"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/281844232" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#281844232">(May 10 2022 at 15:49)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1122571817">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>I assumed that that approach would require memory writes on each loop header &amp; function call and those have to be atomic, and I assumed that would be even more overhead.</p>
</blockquote>
<p>With epochs the increment of the epoch is an atomic write but all the reads are "just" atomic reads which in practice ends up being quite fast. The instrumented code itself doesn't do any atomic writes anywhere (same for fuel, not atomic writes anywhere)</p>
<p>Given your clarification (thanks!) it does sort of sound like you want fuel + epochs without the actual interruption of fuel though, just the accounting. This may also need to be specialized a bit in codegen to make things a bit more optimal but otherwise seems pretty close? </p>
</blockquote>



<a name="282281905"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282281905" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282281905">(May 13 2022 at 17:48)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1126296087">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>Ah, sorry, I had missed that note; but it's a little surprising given that <a href="https://github.com/bytecodealliance/wasmtime/blob/4e6f3ea899efd6bbe8e77235fcba69b73257d23c/crates/cranelift/src/func_environ.rs#L377">here</a> we call <code>fuel_save_from_var</code> to store the value back to memory, and this is invoked at every function exit. Stores shouldn't be DCE'd (since they are side-effecting). Can you dump the CLIF (<code>RUST_LOG=trace</code> should show it buried among a bunch of other output) and see what it looks like just after wasm translation?</p>
</blockquote>
<p>Was a mistake on my part, I was doing something else. Modifying <code>fuel_check</code> skipping everything after <code>fuel_increment_var</code> as you proposed works.</p>
<p>So the results with my microbenchmarks are:</p>
<p>fuel overhead with interrupts 24-34%, <br>
fuel overhead without interrupts 10-25%</p>
<p>which is something, but ideally we lower it even more.</p>
<blockquote>
<p>This may also need to be specialized a bit in codegen to make things a bit more optimal but otherwise seems pretty close?</p>
</blockquote>
<p>Could you elaborate on this bit?<br>
</p>
</blockquote>



<a name="282289462"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282289462" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282289462">(May 13 2022 at 18:48)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1126349551">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>FWIW, enabling epoch interrupts and consuming fuel (but without fuel interrupts) gives 28-40% overhead.</p>
</blockquote>



<a name="282289594"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282289594" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282289594">(May 13 2022 at 18:48)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1126350020">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>ideally we lower it even more.</p>
</blockquote>
<p>So, some fairly complex ideas incoming: there are at least research-level ideas floating around (I can't find any papers at the moment unfortunately but I know I've seen it before) on how to minimally/optimally record the trace (path taken through a program). Counting ops is equivalent to this problem so I think the same ideas apply. It goes something like: choose a set of "profiling points" (here, points at which you increment the counter), such that every branch outcome can be deduced from the points that are reached.</p>
<p>The simple/intuitive cases are loops (one profiling point in the header) and if/then diamonds (one profiling point in each branch) and in fact that's what we do today, rather than a profiling point in every block. But it actually starts to get interesting even with the if/else: we really only need a profiling point in <em>one</em> branch of the diamond. E.g., if the if-path takes 10 ops, and the else-path takes 15 ops, then we unconditionally add 10 (probably as part of the profiling point at the top of the function or enclosing loop), and add 5 more only on the else-path. Bonus points if we choose the rare path for the additional increment.</p>
<p>The general answer to this problem I think will have something to do with dom/postdom relations -- as a first pass, can we merge a block's profiling point (fuel increment amount) into the increment of any block it postdominates? And then there might be another transform where we draw a "postdom cut" across N blocks relative to some block, and hoist some common factor k out of all of those blocks (i.e., if anywhere we go will eventually increment by at least 10, let's hoist that). It has to be a little more subtle than that because loop bodies can postdom the post-loop tail, so we really need some sort of "1-to-1 execution count" relation. But I'd have to sit down and think more (or just find the papers on this!).</p>
</blockquote>



<a name="282292075"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282292075" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282292075">(May 13 2022 at 19:07)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1126362388">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Ah, one more idea that just came to mind: we could potentially remove a lot of the memory-traffic overhead of fuel counting by defining a new ABI with a "pinned fuel counter". Then it only needs from the vmctx in host-to-wasm trampolines, and we could "spill" to vmctx at callsites to non-pinned-fuel-counter ABIs (direct calls to imported host functions for example).</p>
</blockquote>



<a name="282292103"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282292103" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282292103">(May 13 2022 at 19:07)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1126362388">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Ah, one more idea that just came to mind: we could potentially remove a lot of the memory-traffic overhead of fuel counting by defining a new ABI with a "pinned fuel counter". Then it only needs to be loaded from the vmctx in host-to-wasm trampolines, and we could "spill" to vmctx at callsites to non-pinned-fuel-counter ABIs (direct calls to imported host functions for example).</p>
</blockquote>



<a name="282490938"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282490938" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282490938">(May 16 2022 at 12:59)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127641795">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>So, some fairly complex ideas incoming...</p>
</blockquote>
<p>Oh, right, something like this also crossed my mind. </p>
<p>It looks that the ABI idea is easier to hack though. You don't mean literal new ABI (as in a new variant in <code>CallConv</code>), since it seems to me that you can get away with changes only in <code>crates/cranelift</code> though, right?</p>
</blockquote>



<a name="282522088"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282522088" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282522088">(May 16 2022 at 16:37)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127892165">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<p>It looks that the ABI idea is easier to hack though. You don't mean literal new ABI (as in a new variant in CallConv), since it seems to me that you can get away with changes only in crates/cranelift though, right?</p>
</blockquote>
<p>We could do it that way; but passing the value then has to be explicit (argument into every function, and extra return value from every function). Also slightly less efficient since those would be different registers, so some extra moves.</p>
<p>I had been thinking a flag on the Cranelift options that means "reserve a register that is globally allocated for this purpose, and provide CLIF ops to get and set it", but actually we already have that: I realized that we aren't using the "pinned reg" for anything in Wasmtime's wasm-to-CLIF lowering right now, so we could set that option and then use <code>get_pinned_reg</code> / <code>set_pinned_reg</code> to "load" and "store" the fuel count.</p>
<p>We'd still need to transfer it to and from the vmctx when transitioning from host to Wasm code (in the trampoline) and from Wasm to host code (this one is a little trickier).</p>
</blockquote>



<a name="282524400"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282524400" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282524400">(May 16 2022 at 16:53)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127907309">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Well, I went ahead and implemented the explicit value passing. It's messy and now I stumbled upon some problem in the wasm translation code. I suspect there is some hidden dependency on the fact that there are only two hidden params. I am debugging it right now. The trampoline code is already in place though.</p>
<p>Regarding <code>get_pinned_reg</code>/<code>set_pinned_reg</code>, that's funny, I looked at it but thought it's not worth of exploration thinking that it's a remnant of the old style backend. If that works, that means cranelift always has a reserved register that is not used for anything then?</p>
</blockquote>



<a name="282524918"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282524918" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282524918">(May 16 2022 at 16:56)</a>:</h4>
<p>pepyakin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127907309">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Well, I went ahead and implemented the explicit value passing. It's messy and now I stumbled upon some problem in the wasm translation code. I suspect there is some hidden dependency on the fact that there are only two hidden params. I am debugging it right now. The trampoline code is already in place though.</p>
<p>Regarding <code>get_pinned_reg</code>/<code>set_pinned_reg</code>, that's funny, I looked at it but thought it's not worth of exploration thinking that it's a remnant of the old style backend. If that works, that means cranelift always has a reserved register that is not used for anything then?</p>
<p>UPD: Nvm, I see there is <code>enable_pinned_reg</code>.</p>
</blockquote>



<a name="282539206"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282539206" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282539206">(May 16 2022 at 18:19)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127988965">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>IIRC there's a fair bit of open-coding about our two implicit <code>VMContext</code> parameters. I think it would be great to reduce this open-coding if we can, though. But if you're hitting issues with our current two hidden parameters that's probably what's happening.</p>
<p>Otherwise though one important bit about ABI details and pinned registers is that right now Wasmtime's API relies on the fact that trampolines can be <a href="https://github.com/bytecodealliance/wasmtime/blob/edf07a8da64f9bbfecccca9faf1577735d2181c6/crates/wasmtime/src/func.rs#L1925-L1960">defined natively in Rust</a>. This is tested currently and will break if there's ABI details Rust can't uphold (like preserving the pinned register). Overall I personally feel this is a mis-feature of Wasmtime as the only thing it buys us is the ability to <code>Func::call</code> a native function wrapped up via a <code>Func</code>, which no one really wants to do. Instead I think we should use the trampoline registration system that is already in place for modules and just simply require that lookup succeeds (e.g. documenting that <code>Func::call</code> in a store with no modules will panic). That would mean that we no longer have to define trampolines in Rust (and that <code>host_trampoline</code> function could be deleted) and all trampolines would be assembled by Cranelift. We'd still have to define a host ABI for the trampolines to talk to Rust but having that transition point where Cranelift is always in control seems prudent.</p>
<p>This latter point though of refactoring how trampolines-to-imported-host-functions work would require some relatively deep refactorings. I think something about the <code>VMContext</code> would have to change to support host trampolines, but I'm not sure precisely what having not designed it yet.</p>
<p>Basically I just wanted to mention that dealing with a pinned register and/or non-System-V ABIs I think is a good idea and something we should enable, but I don't believe it can trivially be done so today without more significant refactorings of what a trampoline looks like when wasm enters the host. (and enabling this all would probably best be done as a separate PR)</p>
</blockquote>



<a name="282669984"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282669984" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282669984">(May 17 2022 at 16:42)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1129090463">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Hacking on the explicit passing of the fuel counter without storing it in the memory, I bumped on a bug. It manifests with fuel metering and the <code>unreachable</code> instruction. Basically, the transfer of control out of there means the fuel counter should be flushed just before the trap. That's easy enough.</p>
<p>However, other traps are tricky: memory accesses (at least with the eliminated bounds checked / mprotect) and stack overflows. If we were to flush the fuel counter, it would have to be done pretty much everywhere. I think it's not impossible that it would fare worse than vanilla fuel metering. Am I missing something?</p>
<p>The pinned fuel counter approach proposed by @cfallin might work in this case. I assume traps always transfer control through a signal handler. We could extract the contents of the pinned register from the last frame before the trap from within the signal handler and then flush it to <code>VMRuntimeLimits</code>.</p>
<p>I read from @alexcrichton's post that the codebase is not ready for this change yet. However, I am trying to get a sense of potential wins here, not a final solution. Do you folks see any roadblocks to hacking the solution here? If not, I might try to tackle that approach then.<br>
</p>
</blockquote>



<a name="282673854"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282673854" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282673854">(May 17 2022 at 17:07)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1129112482">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I think reading the fuel in the signal handler and writing it there instead of in the jit code would be a good approach. While getting this all 100% correct will be difficult I suspect you could "just implement it" today and get some good perf numbers for what the final solution would look like performance-wise.</p>
</blockquote>



<a name="282821167"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282821167" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282821167">(May 18 2022 at 17:26)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1130288350">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I've hacked a version that uses the pinned_reg approach. I did not bother implementing extracting fuel in the signal handler, though. I just checked that it is possible, and it seemed positive.</p>
<p>The results are mixed: one benchmark suffers from a slowdown. I haven't isolated the root cause.</p>
<p>However, I ran an extra experiment. Basically, I just omitted calls to <code>fuel_check</code>. </p>
<p>Similar to the one I described in OP, the idea is to periodically send a signal to interrupt the thread to check the counter value. Except, it is way simpler,</p>
<ul>
<li>No stack maps are needed since it's always the same pinned register.</li>
<li>No safepoints are needed. That was just dumb. If the counter is positive, I assume it would be possible to jump out from the signal handler back to the user code, reporting an OOG trap.</li>
</ul>
<p>According to my measurements, the overhead is around ≈5% relative to no fuel metering. This result is promising.</p>
<p>Do you think this approach is something that could be upstreamed?</p>
</blockquote>



<a name="282829041"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282829041" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282829041">(May 18 2022 at 18:29)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1130369399">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>That sounds pretty reasonable to me, although I think there's probably trickiness to work out along the lines of a signal being sent to a thread that isn't currently executing wasm, e.g. it's in the middle of an import or something like that. In that situation is it something that's ok to unconditionally ignore? Or should the signal get "deferred" to get handled once wasm is reentered?</p>
<p>Also to make sure I understand, the 5% overhead is basically incrementing a pinned register which is fuel consumed, right? And presumably one less register in register allocation as well, too.</p>
</blockquote>



<a name="282834926"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282834926" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282834926">(May 18 2022 at 19:15)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1130409692">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I assumed we could just check <code>IS_WASM_PC</code> for the IP while handling a signal. I thought that would be acceptable since I am spilling the fuel counter in trampolines in both directions. The OOG check can be performed in the trampoline or asynchronously as well. I thought that would be enough. Am I missing something?</p>
<blockquote>
<p>Also to make sure I understand, the 5% overhead is basically incrementing a pinned register which is fuel consumed, right? And presumably one less register in register allocation as well, too.</p>
</blockquote>
<p>Yes, that's my understanding.</p>
</blockquote>



<a name="282835077"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282835077" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282835077">(May 18 2022 at 19:16)</a>:</h4>
<p>pepyakin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1130409692">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I assumed we could just check <code>IS_WASM_PC</code> for the IP while handling a signal. If the control is not inside of the wasm then we ignore it. It should be enough at least for our use cases. I thought that would be acceptable since I am spilling the fuel counter in trampolines in both directions. The OOG check can be performed in the trampoline or asynchronously as well. I thought that would be enough. Am I missing something?</p>
<blockquote>
<p>Also to make sure I understand, the 5% overhead is basically incrementing a pinned register which is fuel consumed, right? And presumably one less register in register allocation as well, too.</p>
</blockquote>
<p>Yes, that's my understanding.</p>
</blockquote>



<a name="282847365"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/282847365" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#282847365">(May 18 2022 at 20:48)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1130527740">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Ok yeah that makes sense to me at a high level at least. That would make cross wasm/host calls a bit slower with all the trampolines but that seems reasonable and isn't the end of the world. (e.g. on-part with other slowdowns and seems like a good tradeoff of complexity)</p>
<p>So again though to make sure I understand everything, the changes would be:</p>
<ul>
<li>Fuel becomes a pinned register</li>
<li>Fuel can be configured rely on an asynchronous signal for detection of out-of-fuel rather than today's synchronous detection</li>
<li>Wasm-to-host trampolines need to be added to Wasmtime. These trampolines will perform a synchronous fuel check and flush the counter to the VMContext.</li>
<li>Host-to-wasm trampolines would be updated to check the fuel counter and then insert it into the pinned register.</li>
<li>Wasmtime would install a signal handler (for which signal?) for the asynchronous notification to check fuel. If the signal interrupted wasm code itself we check the pinned register against the limit (probably pre-configured in the TLS state we maintain or something like that?). On out-of-fuel this raises a trap (how does this happen? Is this an "async trap" or do we need a "landing pad" for each function of where to raise a fuel trap?)</li>
<li>We'd leave things up to the embedder to send the signal itself (how does this happen? Do we keep track of the current thread within some <code>Store&lt;T&gt;</code> state? Do we rely on the user to get the target thread right? Can we do this portably?)</li>
</ul>
<p>Hm so actually writing this out, there's actually a fair amount of design space here. I think it would be good to write up something describing the new fuel system first perhaps to review before writing all the code? I don't think this needs an RFC per-se but something at that level of technical detail would be useful to help judge how best to fit this within Wasmtime. For example we could leave the signal handling and signal sending entirely up to the embedder and simply document that a specific register has the fuel amount (plus maybe adding public signal-safe methods to test whether something is a known wasm program counter)</p>
</blockquote>



<a name="283338161"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/283338161" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#283338161">(May 23 2022 at 15:47)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134843857">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>To be fair, right now, I am only at the proof-of-concept stage. Probably it will take a couple of iterations to come up with the final design. That said, I was leaning towards something that you described in the end. In fact, I already have a prototype of that locally.</p>
<p>To kick off the discussion, here is my vision of the minimal slacked fuel metering:</p>
<ol>
<li>Add a new configuration option <code>slacked_fuel_metering(bool)</code>. That option can only be enabled together with <code>consume_fuel</code>. It is also saved in tunables so that it's accessible in func_environ.</li>
<li>If <code>consume_fuel</code> is enabled, we also set cranelift flag <code>enabled_pinned_reg</code> to <code>true</code></li>
<li>In func_environ, we would stop relying on cranelift_frontend SSA def-use var for <code>self.fuel_var</code>. Instead, <code>use_var</code> becomes <code>get_pinned_reg(I64)</code> and <code>def_var</code> becomes <code>set_pinned_reg</code>.</li>
<li>In func_environ, if <code>slacked_fuel_metering</code> enabled then we skip <code>fuel_load_into_var</code>, <code>fuel_save_from_var</code> and <code>fuel_check</code>.</li>
<li>In <a href="http://compiler.rs">compiler.rs</a>, we change the trampoline generation for host-to-wasm and wasm-to-host[^1]. In both cases, we surround the code that performs the call with code that flushes/reloads the fuel counter. This code is predicated on the <code>slacked_fuel_metering</code>[^2] option. The flush/reload code snippets are very similar to those found in func_environ[^3], with the addition that a fuel check is made before entering or after leaving the wasm code. </li>
<li>Note that the previous item promotes trampolines from just argument adapters to dealing with the fuel counter. We will have to use the trampolines in some places where they are not needed before. One of such places is calling the <code>start</code> function. It's easily solved, though: just <code>lookup_trampoline</code>, and that's it. As it was <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127988965">mentioned</a>, we will have to fix/remove the <code>host_trampoline</code>.</li>
<li>We introduce the <code>wasmtime_runtime::is_wasm_pc</code> function, which returns <code>true</code> if the given PC points to any wasm code we generated.[^4]</li>
</ol>
<p>That should give a minimal toolset to allow the embedder to implement slacked fuel metering. One possible instantiation for Linux x86_64:</p>
<ol>
<li>In the setup phase, the embedder installs a signal handler for SIGUSR1. The flags should include <code>SA_SIGINFO</code>.</li>
<li>The embedder saves the current TID before entering the wasm code and spawns a thread that periodically (say, 10-100 Hz) calls <code>kill</code> with the saved TID and the SIGUSR1 signal.</li>
<li>The embedder extracts RIP &amp; R15 (pinned fuel reg) in the signal handler and makes the <code>wasmtime_runtime::is_wasm_pc</code> query. If it returns false, the signal handler returns. Then, if r15 ≥ 0, the signal handler calls a trap raising routine (I used <code>raise_lib_trap</code> since it does not require allocation, which is not signal-safe).</li>
</ol>
<p>Here are some questions.</p>
<ol>
<li>The embedder example above does not account for the <code>fuel_adj</code> component. I am not sure how it gets accounted for in the compiled code. It just seems that the maximum fuel available is <code>i64::max_value()</code> rather than <code>u64::max_value</code>. Anyway, in case I just don't understand how it works and we want to fix that for that example, we should be able to reach out to the store from the signal handler to account for that properly. I am not sure how to do that cleanly.</li>
<li>There is a potential race between a trap and the detection of OOG. For example, there's a function with <code>unreachable</code> in it. The fuel counter is increased just before <code>ud2</code>. If the async signal is triggered with RIP pointing just after the <code>add</code> but <code>ud2</code>, that is reported as OOG. Otherwise, it's a trap. If we care to distinguish between those, then <code>traphandlers</code> should check the fuel pinned register first. If there's an overflow, it should be reported as OOG and not the original trap reason (in this case, explicit <code>unreachable</code>).</li>
<li>You mentioned the async trap and landing pads. I don't know what you mean by an async trap. I also don't understand what you meant by 'do we need a "landing pad" for each function of where to raise a fuel trap'. Potentially, the async fuel check signal can arrive anywhere in the wasm code.</li>
</ol>
<p>[^1]: You seem to assume in your previous message that wasm-to-host trampolines do not exist, but they do.<br>
[^2]: That would require us to pass tunables into the functions that generate trampolines.<br>
[^3]: The complication is we need to pass the <code>VMOffsets</code> there to know how to get to the <code>VMContext-&gt;VMRuntimeLimits→consumed_fuel</code>.<br>
[^4]: The existing private <code>IS_WASM_PC</code> returns true if the code points to an instruction that can produce a trap.</p>
</blockquote>



<a name="283345519"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/283345519" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#283345519">(May 23 2022 at 16:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134902184">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>One of my main worries is from an engine perspective I don't think we want to tie our hands too much with respect to whatever the initial implementation looks like. In what you're proposing there's a fair bit of open-coding around things like:</p>
<ul>
<li>Free-functions to test whether something is a wasm pc or not. In general embedders don't have access to crates like <code>wasmtime_runtime</code> and instead we want to expose everything from the <code>wasmtime</code> crate. Additionally where possible we ideally want to scope things at least on an <code>Engine</code> to have access to configuration settings and other necessary "global" state or such.</li>
<li>The pinned register is r15 and that's all you need for fuel. I think we want to get here from a technical implementation perspective but committing to this for a long time could be difficult. As you mentioned we may need to reach into the <code>VMContext</code> which we currently can't do from a signal handler. For now I think we should design fuel to not need to reach into the <code>VMContext</code> but leaving open the possibility of something like two pinned registers in the future I think would be good.</li>
<li>We can raise a trap without any extra context via the <code>raise_lib_trap</code>. IIRC on macOS and maybe other platforms from a signal handler to raise a trap we have to actually return from the signal handler to raise the trap (<a href="https://github.com/bytecodealliance/wasmtime/blob/6e828df63244e04657a0967ab51f2eabf1a7de67/crates/runtime/src/traphandlers/unix.rs#L103-L138">this bit of code</a>). I realize macOS primarily does mach port stuff but in unix signal mode we can't actually longjmp immediately to get out of the signal handler. Also as a small aside I don't think you need to worry about async-signal safety here. That's all handled in the "is this a wasm pc" test, where once that returns true we know it's safe to call malloc and things. (if "is this wasm" returns <code>false</code>, though, then everything up to and after must be async-signal-safe though)</li>
</ul>
<p>(etc)</p>
<p>I think ideally we want to design things to be as flexible for the engine as we can while still satisfying your use case. Along those lines I think something like this may help:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">Engine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">maybe_handle_out_of_gas</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">info</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">libc</span>::<span class="n">siginfo_t</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">OutOfGas</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span> <span class="nc">OutOfGas</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NotInWasm</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">SigInfoUpdated</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Unwound,</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The rough idea here being that we try to leave details like exact registers and exact "jump out of here to generate a trap" strategy to Wasmtime as much as possible. This function would return <code>SigInfoUpdated</code> on macOS for example and would directly longjmp out on Unix (or other applicable platforms). We could then also have a function that takes a <code>*mut CONTEXT</code> argument for Windows or something like that.</p>
<hr>
<p>To give thoughts on your questions:</p>
<blockquote>
<p>The embedder example above does not account for the fuel_adj component</p>
</blockquote>
<p>I forget what this is used for, but if we can I think we should ensure that the wasm code simply needs to look at the pinned register to determine if it's out of fuel (same for the signal handler). If that's not currently the case then I think we should refactor a bit to make this applicable (e.g. adjust the fuel handling in the trampolines or similar)</p>
<blockquote>
<p>There is a potential race between a trap and the detection of OOG</p>
</blockquote>
<p>I think you have a good idea here of checking for out-of-gas in the trap handler code. That seems reasonable to me to ignore the original trap and switch it to out-of-gas to try to make that deterministic (as fuel is supposed to be deterministic after all).</p>
<p>The caveat to this is that while host-level side effects are guaranteed to be deterministic (as we always check for fuel in trampolines when we come back to the host) the wasm-level side effects aren't guaranteed to be deterministic. For example memory modifications are going to be nondeterministic in the face of fuel since we can't precisely stop the wasm. This seems like a reasonable tradeoff to me, though, and just something to mention in the slacked fuel configuration documentation. Basically 100% determinism is fuel, and only host-side-effect determinism is guaranteed with slacked fuel. (or something like that)</p>
<blockquote>
<p>You mentioned the async trap and landing pads</p>
</blockquote>
<p>Ah sure, let me expand a bit. When I say "async trap" I mean the idea of an asynchronous signal coming into wasm and raising a trap at any time. Right now wasm can only raise traps at defined points but with slacked fuel any wasm pc could be the origin source of a trap. Raising a trap from any pc in a module from a signal handler isn't trivial to do and will be tricky to get right across platforms. (I think even just getting it right on only Linux is like 90% of the trickiness)</p>
<p>When I say "landing pad" one scheme for implementing this is that when out-of-gas is detected then the running context of the thread is updated in-place. For example if all wasm functions had a <code>ud2</code> instruction at the end that was registered as the "out of gas trap area" then we would update RIP to point to this <code>ud2</code> instruction and then resume the thread. The thread would then immediately fault and trigger the normal trap logic. Having a landing pad I think can be advantageous because it would support Windows (which doesn't have asynchronous signals but you can suspend/resume a thread) and possibly macOS better too (since no sort of fake stack frame needs to be created). Even on Linux it would help centralize all the unwinding logic into the existing trap handling function instead of adding a new entry point of this custom handler.</p>
<p>That being said I'm not sure that this is the best implementation strategy. Our DWARF-based backtracing right now probably won't work super well with this which can hurt debuggability relative to raising a trap in the SIGUSR1 handler, for example. In general I'm personally quite paranoid of signals and want to do as little as possible in signal handlers, centralizing all the complications in one place if possible instead of having multiple handlers do the same thing (especially if these handlers are managed by the embedder rather than Wasmtime). My hesitation is that this is implementation-wise complex relative to what you've probably already got working.</p>
</blockquote>



<a name="283347268"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/283347268" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#283347268">(May 23 2022 at 16:54)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134917766">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Also, to clarify, I don't think you need to implement support for anything other than your platform of interest. Despite this though I think it's still worthwhile to consider other platforms during the design process so that if and when someone comes a long and is interested in getting this feature working for a new platform we have a way for them to do it which doesn't involve rewriting too much. I don't want to get lost in the weeds of theoreticals of other platforms though.</p>
</blockquote>



<a name="284127982"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/284127982" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#284127982">(May 27 2022 at 12:51)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1139589938">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I agree with your points that we should try to hide the guts that are inconsequential and that we should try to have at least an idea of how it could work on other platforms. </p>
<p>I acknowledge that the wasm environment would be incoherent after an async OOG trap. That's fine. In fact, this idea came to me after focusing on the observation that we discard the wasm environment anyway. We only want to know if the code successfully returned before the deadline.</p>
<p>Also, thanks for all the help. It was incredibly helpful so far.</p>
<blockquote>
<p>I think even just getting it right on only Linux is like 90% of the trickiness</p>
</blockquote>
<p>Can you expand on this bit? I cannot see any trickiness (in the sense of ignorance). My thinking here is:</p>
<ol>
<li>We only really trap if the PC is within the wasm code. If the code is in host functions, libcalls, or trampolines we do not trap.</li>
<li>Trapping in prologues or epilogues is fine. We discard the stack anyway.</li>
<li>Some of the updates currently could be assumed to be atomic/uninterrupted, but that should be fine:<p>- I imagine a trap in the middle of a 64-bit store on a 32-bit machine can lead to tearing. Probably that can include the fuel counter itself. For our use case, we can assume 64-bit hardware though. I guess this might happen anyway with e.g. v128 but we already accept the inconsistency of the wasm environment in case of a trap.<br>
  - All non-atomic complicated stuff is done in libcalls anyway.</p>
</li>
</ol>
<p>Or do you mean something else?</p>
<blockquote>
<p>Having a landing pad I think can be advantageous because it would support Windows.</p>
</blockquote>
<p>Can't we simulate an async trap with a shim trick similar to what we do on macOS? Something along those lines: </p>
<ol>
<li>we suspend the thread of the interest,</li>
<li>check R15. If it's less than 0, we resume the thread and bail. Otherwise, go to the next item.</li>
<li>we modify the PC of the context to point on an <code>ud2</code>. The <code>ud2</code> can be anywhere.</li>
<li>we resume the thread. The thread executes <code>ud2</code>, traps, and the control gets transferred to the VEH, where it's handled as a standard trap.</li>
</ol>
<blockquote>
<p>I forget what this is used for, but if we can I think we should ensure that the wasm code simply needs to look at the pinned register to determine if it's out of fuel (same for the signal handler). If that's not currently the case then I think we should refactor a bit to make this applicable (e.g., adjust the fuel handling in the trampolines or similar)</p>
</blockquote>
<p>After looking at the code once more, I am confused about why we even have it in the first place. From what I can tell, the fuel counter is effectively a 32-bit number. Shouldn't we admit the counter is a 32-bit value from a user's perspective? </p>
<blockquote>
<p>Our DWARF-based backtracing right now probably won't work super well with this which can hurt debuggability relative to raising a trap in the SIGUSR1 handler</p>
</blockquote>
<p>What's the worry here? Is that we don't see the backtrace from the precise place/function where it was triggered?</p>
<p>I also share your concerns about smearing complications all over the place. However, I am concerned that it might be too much for me to deliver on this <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> I assume I will need to work on machinst for that, and I lack the required knowledge for it, and also DWARF makes me anxious.</p>
<p>I also assume that we can change the strategy later. </p>
</blockquote>



<a name="284140059"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/284140059" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#284140059">(May 27 2022 at 14:25)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1139670490">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>I think even just getting it right on only Linux is like 90% of the trickiness</p>
</blockquote>
<p>Can you expand on this bit? ...</p>
</blockquote>
<p>In some sense the setjmp/longjmp we do is the easiest way to handle this today where we can technically longjmp from any point. I think I may be getting ahead of myself by alluding to trickiness here. I'm a bit worried about future proposals of wasm and how we're going to handle them, such as:</p>
<ul>
<li>Stack unwinding to get a wasm backtrace, which technically isn't required for correctness but is useful for debugging, is not easy with asynchronous exceptions. Asynchronous dwarf unwind information is much larger than normal unwind information and otherwise custom schemes (e.g. JIT/cranelift-specific ones) would all have to be sure to handle asynchronous unwinding as well.</li>
<li>Related to stack unwinding implementing the exceptions proposal would probably be tricky in the face of asynchronous traps here. (again this is very forward-looking and not necessarily a concern today; additionally it may be the case that traps don't interact with the exceptions proposal at all). One of my worries here is that the implementation strategy for the exception-handling proposal is probably going to subsume longjmp/setjmp we have for traps today since we want to get rid of that anyway.</li>
<li>One theoretical use case of fuel is resumption of execution to use fuel to time-slice. This means that a possible application of this feature would be to use the signal to context switch out but a big thing here is we want to resume later on. I suspect resumption from an async signal is trickier than simply trapping (e.g. landing pads to "just" do a ud2 wouldn't be sufficie)t.</li>
<li>In the case of a single ud2-per-function which serves as the actual vector for the trap there's some work to be done to thread through that metadata all the way to the signal handler which isn't the end of the world but not necessarily trivial.</li>
<li>One concern which is actually more concrete is that writing async-signal-safe code is not easy. Currently our signal handler is not async-signal-safe because it attempts to acquire an rwlock in the handler to read the global module metadata to determine if something is a wasm module or not. This is sort of ok today since it only runs on segfaults and our current stance is "well things are already really wrong on a non-wasm segfault anyway", but with a timer signal this is something we'd have to worry about.</li>
</ul>
<p>To clarify again though I don't mean to try to dump everything on you at once though. I think it's fine to keep this focused on your use case at hand and if it doesn't expand then it doesn't expand. We'll need to take these things into account when reviewing, though. In general though my past experience with asynchronous exceptions/signals is "there be dragons" so I'm also trying to make sure we've got all our bases covered here as well.</p>
<blockquote>
<blockquote>
<p>Having a landing pad I think can be advantageous because it would support Windows.</p>
</blockquote>
<p>Can't we simulate an async trap with a shim trick similar to what we do on macOS? ...</p>
</blockquote>
<p>Indeed that was my thinking!</p>
<blockquote>
<p>Shouldn't we admit the counter is a 32-bit value from a user's perspective?</p>
</blockquote>
<p>That may be a bug... but yes if it's 32-bit we should probably update the 64-bit values in the <code>Store</code> to 32-bit!</p>
<blockquote>
<blockquote>
<p>Our DWARF-based backtracing right now probably won't work super well with this which can hurt debuggability relative to raising a trap in the SIGUSR1 handler</p>
</blockquote>
<p>What's the worry here? Is that we don't see the backtrace from the precise place/function where it was triggered?</p>
</blockquote>
<p>I alluded to this above, but concerns here are pretty forward-looking related to possibly different implementations of traps, unwinding, exceptions, etc. I think it's safe to ignore these for now and say "we wouldn't support capturing backtraces from the async handler" and leave it at that. </p>
</blockquote>



<a name="285303091"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/285303091" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#285303091">(Jun 07 2022 at 19:33)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1149082809">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>After working on the <code>maybe_handle_out_of_gas</code>-like approach realized that it may be worth exploring the high-level and user-friendly API. Initially, my main concern was that I did not want wasmtime to clash with the user code by reserving a signal. After you gave me the context about the future features, I realized that a high-level API would provide us with more leeway regarding implementation strategy and that reserving a hardcoded signal is not a big issue. Also all complications, like writing async-signal-safe code, are shifted to wasmtime which is a good thing.</p>
<p>The user-friendly API I have in mind now looks like the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// A handle bound to a thread. Allows for checking the fuel in the thread it is bound.</span>
<span class="sd">/// Send + Sync</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">AsyncFuelChecker</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">AsyncFuelChecker</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="sd">/// Schedules the fuel check to be performed on the thread this checker is bound to. Make sure to call it often enough</span>
<span class="w">  </span><span class="sd">/// to avoid the fuel counter wrapping around between the calls.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// The fuel check has effect only if the control is in wasm. It's your responsibility to make sure that host functions take</span>
<span class="w">  </span><span class="sd">/// into account the fuel consumption. Also, wasm may be stuck in libcall impls of instructions like `memory.copy` which</span>
<span class="w">  </span><span class="sd">/// cannot be effectively interrupted. It's your responsibility to mitigate that.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// No-op if is called on the thread its bound to.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// We may be courteous to provide feedback on whether the thread does not exist but probably nothing more than that.</span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="sd">/// Returns a async fuel checker for the current thread. Can return `Err` in case the platform unsupported or</span>
<span class="w">  </span><span class="sd">/// the engine is not configured for slacked fuel metering.</span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">current_thread_async_fuel_checker</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">AsyncFuelChecker</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>We could reserve the SIGUSR1 and use <code>pthread_sigqueue</code> with a magic cookie parameter to differentiate signals sent by wasmtime. If the signal handler receives SIGUSR1 without the cookie parameter, it will be passed to the <a href="https://github.com/bytecodealliance/wasmtime/blob/20f510671dbaa1c9c41b51f39f6c517461fc08d3/crates/runtime/src/traphandlers/unix.rs#L146-L164">previously</a> installed, presumably by the user, signal handler.</p>
<p>One caveat here is that macOS <a href="https://github.com/apple/darwin-libpthread/blob/2b46cbcc56ba33791296cd9714b2c90dae185ec7/src/pthread.c">does not</a> really provide anything more than basic <code>pthread_kill</code>. Obviously, one way to solve it is to get away without sending this magic cookie. However, there is another caveat with <code>pthread_kill</code>. Apparently, <code>pthread_kill</code> cannot be used for threads managed by GCD, which is not the end of the world but still annoying. </p>
<p>On Linux/FreeBSD checking and interrupting happens on the same thread in a signal. We don't have to do that on macOS, even with the feature <code>posix-signals-on-macos</code> on[^1]. That is because macOS has <code>thread_suspend</code>, <code>thread_resume</code>, <code>thread_get_state</code> and <code>thread_set_state</code>. Those primitives are the same as Windows provides. Therefore we can do the same sequence as with Windows: suspend, check the fuel, if overflown, modify the PC in the thread's context, and resume. This approach does not depend on any global resources such as signals, so we are golden on macOS and Windows.</p>
<p>[^1]: although we still have to perform the fuel check in the trap to avoid the race condition I mentioned <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134843857">here</a> (grep "There is a potential race between a trap and the detection of OOG. For example, ")</p>
<p>With that here is the second iteration.</p>
<p>The compilation part is almost the same so I quote it.</p>
<blockquote>
<ul>
<li>Add a new configuration option <code>slacked_fuel_metering(bool)</code>. That option can only be enabled together with <code>consume_fuel</code>. It is also saved in tunables so that it's accessible in func_environ.</li>
<li>If <code>consume_fuel</code> is enabled, we also set cranelift flag <code>enabled_pinned_reg</code> to <code>true</code></li>
<li>In func_environ, we would stop relying on cranelift_frontend SSA def-use var for <code>self.fuel_var</code>. Instead, <code>use_var</code> becomes <code>get_pinned_reg(I64)</code> and <code>def_var</code> becomes <code>set_pinned_reg</code>.</li>
<li>In func_environ, if <code>slacked_fuel_metering</code> enabled then we skip <code>fuel_load_into_var</code>, <code>fuel_save_from_var</code> and <code>fuel_check</code>.</li>
<li>In <a href="http://compiler.rs">compiler.rs</a>, we change the trampoline generation for host-to-wasm and wasm-to-host<a href="#user-content-fn-1-78075498117748565b9644aa1a55c4f8">1</a>. In both cases, we surround the code that performs the call with code that flushes/reloads the fuel counter. This code is predicated on the <code>slacked_fuel_metering</code><a href="#user-content-fn-2-78075498117748565b9644aa1a55c4f8">2</a> option. The flush/reload code snippets are very similar to those found in func_environ<a href="#user-content-fn-3-78075498117748565b9644aa1a55c4f8">3</a>, with the addition that a fuel check is made before entering or after leaving the wasm code.</li>
<li>Note that the previous item promotes trampolines from just argument adapters to dealing with the fuel counter. We will have to use the trampolines in some places where they are not needed before. One of such places is calling the <code>start</code> function. It's easily solved, though: just <code>lookup_trampoline</code>, and that's it. As it was <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127988965">mentioned</a>, we will have to fix/remove the <code>host_trampoline</code>.</li>
</ul>
</blockquote>
<p>I say almost the same because pinned_reg, which is essential for this technique, works only on 64-bit platforms currently.</p>
<p>Obviously, we don't need to export <code>wasmtime_runtime::is_wasm_pc</code> as in the first iteration, but we need it internally for the implementation. There is a caveat that I did not see before: in the presence of several engines, it won't be enough to only have the answer if the given PC refers to wasm code, but we also should know if that code was generated with fuel in pinned register.</p>
<p>Then I suppose <code>Engine::current_thread_async_fuel_checker</code> would check if the slacked fuel metering is enabled and also if the current platform and arch are supported. Ultimately, it should be Linux, FreeBSD and macOS on x86_64 and aarch64. If the check does not pass, it returns an <code>Err</code>.</p>
<p>The Linux/FreeBSD side of implementation:</p>
<ol>
<li><code>AsyncFuelChecker::new</code> notes the current thread using <code>pthread_self</code>. </li>
<li><code>AsyncFuelChecker::check</code> bails if <code>pthread_self</code> is equal to <code>self.tid</code>. Otherwise calls <code>pthread_sigqueue(self.tid, SIGUSR1, MAGIC)</code>. <code>MAGIC</code> could be a random number or maybe an address of a private static field for <a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html"><code>sival_ptr</code></a>.</li>
<li>we plumb a bool into <code>platform_init</code> which indicates if <code>slacked_fuel_metering</code> is enabled. If it is, then we <a href="https://github.com/bytecodealliance/wasmtime/blob/20f510671dbaa1c9c41b51f39f6c517461fc08d3/crates/runtime/src/traphandlers/unix.rs#L17"><code>register</code></a> <code>trap_handler</code> for <code>SIGUSR1</code>. Again, we do that only for Linux/FreeBSD. I am not sure about <code>SA_NODEFER</code> though since we don't want reentrancy for SIGUSR1, but the same signal handler is used for other things.</li>
<li>In <code>CallThreadState</code> we add another parameter which indicates if the slacked fuel metering enabled. It's plumbed through <code>catch_traps</code>.</li>
<li>In the signal handler, before <code>jmp_buf_if_trap</code> (or maybe in it, but the important part that we remember that OOG has prevalence over a normal trap) we check if the slacked fuel metering is enabled. If so, then we check if the PC falls in any jit generated wasm code. If so, we extract r15/x21 and check if it is positive. If so, we note the unwind reason (initially, without a backtrace) and jump out via longjmp. If the signum is SIGUSR1 then we swallow the signal (similar to how the signal handler would return if the signal was handled by the user provided signal handler callback).</li>
</ol>
<p>The macOS side of implementation:</p>
<ol>
<li><code>AsyncFuelChecker::new</code> notes the current thread using <code>mach_thread_self</code>.</li>
<li><code>AsyncFuelChecker::check</code> checks if <code>mach_thread_self</code> equals to <code>self.tid</code> and if so bails. Otherwise, calls <code>thread_suspend</code> with the <code>self.tid</code>. Then extract the current thread state through <code>thread_get_state</code>. If the context's pc points into jitted wasm code we examine r15/x21. If it is positive we modify rip/pc to a shim by calling <code>thread_set_state</code> not forgetting to align the stack if needed. The shim will save the unwind reason (currently capture no stacktrace) and longjmp with the buf extracted from tls. After calling <code>thread_resume</code> the function returns. All errors are ignored, in particular the thread non-existance is expected. Other errors may be logged with <code>debug</code> level.</li>
<li>In <code>CallThreadState</code> we add another parameter which indicates if the slacked fuel metering enabled. It's plumbed through <code>catch_traps</code>.</li>
<li>For <code>posix-signals-on-macos</code> we modify the signal handler in the same way as we did for Linux (in fact, it's the same code, we just need to make sure it works in both cases). SIGUSR1 is not involved in this case.</li>
<li>For mach we should check if the slacked fuel metering is enabled. If so, we should check if the pc is in wasm and if the r15/x21 is positive and if so <code>resume</code> to the out-of-gas shim.</li>
</ol>
<p>The Windows implementation is similar to macOS' but with the corresponding APIs and without fuffing with <code>posix-signals-on-macos</code>.</p>
<p>Now, a couple of notes:</p>
<ol>
<li>Probably if I were to implement it I would limit myself to Linux (maybe FreeBSD) x86_64 initially.</li>
<li>The traps can be approached with the mickey-mouse way I described above or directly with landing pads. The doors are open thanks for the high-level API. I'd start with a mickey-mouse impl first.</li>
<li>I am not as worried about debuggability in this case. I am not entirely sure how use<br>
[message truncated]</li>
</ol>
</blockquote>



<a name="285446258"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/285446258" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#285446258">(Jun 08 2022 at 20:05)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1150351393">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>That all sounds great to me, thanks for writing this all up! Personally I don't have any other comments at this time, I'll poke around and see if others have thoughts too though.</p>
</blockquote>



<a name="287723563"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/287723563" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#287723563">(Jun 28 2022 at 14:27)</a>:</h4>
<p>pepyakin <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1168798190">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>Hey @alexcrichton, have you had a chance to source some thoughts on this one? What would be the next steps here? Would a prototype help at this point?</p>
</blockquote>



<a name="287733935"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/287733935" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#287733935">(Jun 28 2022 at 15:37)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1168883074">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I asked around but no one posted here, so I think that's either ETOOBUSY or "seems fine". It seems reasonable to me to start with a prototype unless someone else feels differently.</p>
</blockquote>



<a name="288534510"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/288534510" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#288534510">(Jul 05 2022 at 14:04)</a>:</h4>
<p>pepyakin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1149082809">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>After working on the <code>maybe_handle_out_of_gas</code>-like approach realized that it may be worth exploring the high-level and user-friendly API. Initially, my main concern was that I did not want wasmtime to clash with the user code by reserving a signal. After you gave me the context about the future features, I realized that a high-level API would provide us with more leeway regarding implementation strategy and that reserving a hardcoded signal is not a big issue. Also all complications, like writing async-signal-safe code, are shifted to wasmtime which is a good thing.</p>
<p>The user-friendly API I have in mind now looks like the following:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// A handle bound to a thread. Allows for checking the fuel in the thread it is bound.</span>
<span class="sd">/// Send + Sync</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">AsyncFuelChecker</span><span class="p">(</span><span class="o">..</span><span class="p">.);</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">AsyncFuelChecker</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="sd">/// Schedules the fuel check to be performed on the thread this checker is bound to. Make sure to call it often enough</span>
<span class="w">  </span><span class="sd">/// to avoid the fuel counter wrapping around between the calls.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// The fuel check has effect only if the control is in wasm. It's your responsibility to make sure that host functions take</span>
<span class="w">  </span><span class="sd">/// into account the fuel consumption. Also, wasm may be stuck in libcall impls of instructions like `memory.copy` which</span>
<span class="w">  </span><span class="sd">/// cannot be effectively interrupted. It's your responsibility to mitigate that.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// No-op if is called on the thread its bound to.</span>
<span class="w">  </span><span class="sd">///</span>
<span class="w">  </span><span class="sd">/// We may be courteous to provide feedback on whether the thread does not exist but probably nothing more than that.</span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="sd">/// Returns a async fuel checker for the current thread. Can return `Err` in case the platform unsupported or</span>
<span class="w">  </span><span class="sd">/// the engine is not configured for slacked fuel metering.</span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">current_thread_async_fuel_checker</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">AsyncFuelChecker</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>We could reserve the SIGUSR1 and use <code>pthread_sigqueue</code> with a magic cookie parameter to differentiate signals sent by wasmtime. If the signal handler receives SIGUSR1 without the cookie parameter, it will be passed to the <a href="https://github.com/bytecodealliance/wasmtime/blob/20f510671dbaa1c9c41b51f39f6c517461fc08d3/crates/runtime/src/traphandlers/unix.rs#L146-L164">previously</a> installed, presumably by the user, signal handler.</p>
<p>One caveat here is that macOS <a href="https://github.com/apple/darwin-libpthread/blob/2b46cbcc56ba33791296cd9714b2c90dae185ec7/src/pthread.c">does not</a> really provide anything more than basic <code>pthread_kill</code>. Obviously, one way to solve it is to get away without sending this magic cookie. However, there is another caveat with <code>pthread_kill</code>. Apparently, <code>pthread_kill</code> cannot be used for threads managed by GCD, which is not the end of the world but still annoying. </p>
<p>On Linux/FreeBSD checking and interrupting happens on the same thread in a signal. We don't have to do that on macOS, even with the feature <code>posix-signals-on-macos</code> on[^1]. That is because macOS has <code>thread_suspend</code>, <code>thread_resume</code>, <code>thread_get_state</code> and <code>thread_set_state</code>. Those primitives are the same as Windows provides. Therefore we can do the same sequence as with Windows: suspend, check the fuel, if overflown, modify the PC in the thread's context, and resume. This approach does not depend on any global resources such as signals, so we are golden on macOS and Windows.</p>
<p>[^1]: although we still have to perform the fuel check in the trap to avoid the race condition I mentioned <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134843857">here</a> (grep "There is a potential race between a trap and the detection of OOG. For example, ")</p>
<p>With that here is the second iteration.</p>
<p>The compilation part is almost the same so I quote it.</p>
<blockquote>
<ul>
<li>Add a new configuration option <code>slacked_fuel_metering(bool)</code>. That option can only be enabled together with <code>consume_fuel</code>. It is also saved in tunables so that it's accessible in func_environ.</li>
<li>If <code>consume_fuel</code> is enabled, we also set cranelift flag <code>enabled_pinned_reg</code> to <code>true</code></li>
<li>In func_environ, we would stop relying on cranelift_frontend SSA def-use var for <code>self.fuel_var</code>. Instead, <code>use_var</code> becomes <code>get_pinned_reg(I64)</code> and <code>def_var</code> becomes <code>set_pinned_reg</code>.</li>
<li>In func_environ, if <code>slacked_fuel_metering</code> enabled then we skip <code>fuel_load_into_var</code>, <code>fuel_save_from_var</code> and <code>fuel_check</code>.</li>
<li>In <a href="http://compiler.rs">compiler.rs</a>, we change the trampoline generation for host-to-wasm and wasm-to-host<a href="#user-content-fn-1-78075498117748565b9644aa1a55c4f8">1</a>. In both cases, we surround the code that performs the call with code that flushes/reloads the fuel counter. This code is predicated on the <code>slacked_fuel_metering</code><a href="#user-content-fn-2-78075498117748565b9644aa1a55c4f8">2</a> option. The flush/reload code snippets are very similar to those found in func_environ<a href="#user-content-fn-3-78075498117748565b9644aa1a55c4f8">3</a>, with the addition that a fuel check is made before entering or after leaving the wasm code.</li>
<li>Note that the previous item promotes trampolines from just argument adapters to dealing with the fuel counter. We will have to use the trampolines in some places where they are not needed before. One of such places is calling the <code>start</code> function. It's easily solved, though: just <code>lookup_trampoline</code>, and that's it. As it was <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1127988965">mentioned</a>, we will have to fix/remove the <code>host_trampoline</code>.</li>
</ul>
</blockquote>
<p>I say almost the same because pinned_reg, which is essential for this technique, works only on 64-bit platforms currently.</p>
<p>Obviously, we don't need to export <code>wasmtime_runtime::is_wasm_pc</code> as in the first iteration, but we need it internally for the implementation. There is a caveat that I did not see before: in the presence of several engines, it won't be enough to only have the answer if the given PC refers to wasm code, but we also should know if that code was generated with fuel in pinned register.</p>
<p>Then I suppose <code>Engine::current_thread_async_fuel_checker</code> would check if the slacked fuel metering is enabled and also if the current platform and arch are supported. Ultimately, it should be Linux, FreeBSD and macOS on x86_64 and aarch64. If the check does not pass, it returns an <code>Err</code>.</p>
<p>The Linux/FreeBSD side of implementation:</p>
<ol>
<li><code>AsyncFuelChecker::new</code> notes the current thread using <code>pthread_self</code>. </li>
<li><code>AsyncFuelChecker::check</code> bails if <code>pthread_self</code> is equal to <code>self.tid</code>. Otherwise calls <code>pthread_sigqueue(self.tid, SIGUSR1, MAGIC)</code>. <code>MAGIC</code> could be a random number or maybe an address of a private static field for <a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html"><code>sival_ptr</code></a>.</li>
<li>we plumb a bool into <code>platform_init</code> which indicates if <code>slacked_fuel_metering</code> is enabled. If it is, then we <a href="https://github.com/bytecodealliance/wasmtime/blob/20f510671dbaa1c9c41b51f39f6c517461fc08d3/crates/runtime/src/traphandlers/unix.rs#L17"><code>register</code></a> <code>trap_handler</code> for <code>SIGUSR1</code>. Again, we do that only for Linux/FreeBSD. I am not sure about <code>SA_NODEFER</code> though since we don't want reentrancy for SIGUSR1, but the same signal handler is used for other things.</li>
<li>In <code>CallThreadState</code> we add another parameter which indicates if the slacked fuel metering enabled. It's plumbed through <code>catch_traps</code>.</li>
<li>In the signal handler, before <code>jmp_buf_if_trap</code> (or maybe in it, but the important part that we remember that OOG has prevalence over a normal trap) we check if the slacked fuel metering is enabled. If so, then we check if the PC falls in any jit generated wasm code. If so, we extract r15/x21 and check if it is positive. If so, we note the unwind reason (initially, without a backtrace) and jump out via longjmp. If the signum is SIGUSR1 then we swallow the signal (similar to how the signal handler would return if the signal was handled by the user provided signal handler callback).</li>
</ol>
<p>The macOS side of implementation:</p>
<ol>
<li><code>AsyncFuelChecker::new</code> notes the current thread using <code>mach_thread_self</code>.</li>
<li><code>AsyncFuelChecker::check</code> checks if <code>mach_thread_self</code> equals to <code>self.tid</code> and if so bails. Otherwise, calls <code>thread_suspend</code> with the <code>self.tid</code>. Then extract the current thread state through <code>thread_get_state</code>. If the context's pc points into jitted wasm code we examine r15/x21. If it is positive we modify rip/pc to a shim by calling <code>thread_set_state</code> not forgetting to align the stack if needed. The shim will save the unwind reason (currently capture no stacktrace) and longjmp with the buf extracted from tls. After calling <code>thread_resume</code> the function returns. All errors are ignored, in particular the thread non-existance is expected. Other errors may be logged with <code>debug</code> level.</li>
<li>In <code>CallThreadState</code> we add another parameter which indicates if the slacked fuel metering enabled. It's plumbed through <code>catch_traps</code>.</li>
<li>For <code>posix-signals-on-macos</code> we modify the signal handler in the same way as we did for Linux (in fact, it's the same code, we just need to make sure it works in both cases). SIGUSR1 is not involved in this case.</li>
<li>For mach we should check if the slacked fuel metering is enabled. If so, we should check if the pc is in wasm and if the r15/x21 is positive and if so <code>resume</code> to the out-of-gas shim.</li>
<li>We should keep in mind that the trap handler should also check the fuel register, so that in case of a race with another trap we report OOG since that should've happened first.</li>
</ol>
<p>The Windows implementation is similar to macOS' but with the corresponding APIs and without fuffing with <code>posix-signals-on-macos</code>.</p>
<p>Now, a couple of notes:</p>
<ol>
<li>Probably if I were to implement it I would limit myself to Linux (maybe FreeBSD) x86_64 initially.</li>
<li>The traps can be approached with the mickey-mouse way I described above or directly with landin<br>
[message truncated]</li>
</ol>
</blockquote>



<a name="289221707"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234109%20Slacked%20fuel%20metering/near/289221707" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234109.20Slacked.20fuel.20metering.html#289221707">(Jul 11 2022 at 17:09)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1180657632">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">issue #4109</a>:</p>
<blockquote>
<p>I don't think that <code>pthread_kill</code> is safe in any Rust world so I think it's fine to assume that destructors run in the thread. That'd enable a TLS variable to be created where the destructor sets the flag and then the signal isn't sent if the flag is set. </p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>