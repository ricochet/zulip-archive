<html>
<head><meta charset="utf-8"><title>wasmtime / PR #1490 Implement interrupting wasm code, rei... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html">wasmtime / PR #1490 Implement interrupting wasm code, rei...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="193495704"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193495704" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193495704">(Apr 09 2020 at 19:08)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193498461"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193498461" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193498461">(Apr 09 2020 at 19:29)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193508013"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193508013" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193508013">(Apr 09 2020 at 20:54)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319">PR Review</a>.</p>



<a name="193508014"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193508014" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193508014">(Apr 09 2020 at 20:54)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319">PR Review</a>.</p>



<a name="193508015"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193508015" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193508015">(Apr 09 2020 at 20:54)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406469091" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406469091">PR Review Comment</a>:</p>
<blockquote>
<p>How is this serialized to a .clif file?</p>
</blockquote>



<a name="193513735"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193513735" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193513735">(Apr 09 2020 at 21:49)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391155996" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391155996">PR Review</a>.</p>



<a name="193513736"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193513736" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193513736">(Apr 09 2020 at 21:49)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406497575" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406497575">PR Review Comment</a>:</p>
<blockquote>
<p>It is not.</p>
</blockquote>



<a name="193547661"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193547661" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193547661">(Apr 10 2020 at 08:18)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391325978" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391325978">PR Review</a>.</p>



<a name="193547662"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193547662" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193547662">(Apr 10 2020 at 08:18)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377">PR Review Comment</a>:</p>
<blockquote>
<p>Maybe use a <code>GlobalValue</code> here instead. That way it is serializable.</p>
</blockquote>



<a name="193547678"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193547678" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193547678">(Apr 10 2020 at 08:18)</a>:</h4>
<p>bjorn3 edited <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377">PR Review Comment</a>.</p>



<a name="193587823"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193587823" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193587823">(Apr 10 2020 at 16:23)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193587916"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193587916" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193587916">(Apr 10 2020 at 16:24)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391531715" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391531715">PR Review</a>.</p>



<a name="193587917"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193587917" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193587917">(Apr 10 2020 at 16:24)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406832982" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406832982">PR Review Comment</a>:</p>
<blockquote>
<p>I'm not sure if that would work out because of how manual this is due to how late in the pipeline this executes. I'm also pretty unfamiliar with cranelift itself. If you've got an example of how to do this that would be great!</p>
</blockquote>



<a name="193594690"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594690" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594690">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170">PR Review</a>.</p>



<a name="193594691"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594691" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594691">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170">PR Review</a>.</p>



<a name="193594692"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594692" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594692">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406834338" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406834338">PR Review Comment</a>:</p>
<blockquote>
<p>FWIW, this needs to be <code>[]</code> not <code>()</code>.</p>
</blockquote>



<a name="193594693"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594693" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594693">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406836297" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406836297">PR Review Comment</a>:</p>
<blockquote>
<p>assert that the size is greater than zero? (or some reasonable min)</p>
</blockquote>



<a name="193594694"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594694" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594694">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406848003" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406848003">PR Review Comment</a>:</p>
<blockquote>
<p>What @bjorn3 was hinting at is that all input cranelift accepts (not cranelift-wasm, but cranelift itself) is currently representable in the the clif text format. This is really nice for testing, reproducibility, and test case reduction. For example, see "Don't Lose Our Copy-and-Paste-This-IR-and-it-is-a-Test Property" in <a href="https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342" title="https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342">https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342</a></p>
<p>By providing a closure that is called in the middle of cranelift compilation, and without a text representation, we're losing those nice testing properties.</p>
<p>In this specific case, I'm not sure what alternative is better here. This isn't really generic behavior that makes sense inside cranelift. And we don't have anything like "always inline functions/macros" right now (maybe <a href="https://github.com/bytecodealliance/wasmtime/pull/1267" title="https://github.com/bytecodealliance/wasmtime/pull/1267">https://github.com/bytecodealliance/wasmtime/pull/1267</a> could eventually be that, its motivation was similar, but for GC barriers).</p>
<p>@sunfishcode felt pretty strongly about the everything-is-in-clif-text property, so tagging him for ideas here.</p>
</blockquote>



<a name="193594695"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594695" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594695">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855994" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855994">PR Review Comment</a>:</p>
<blockquote>
<p>This should be four bools because it uses two per config (one for it the swarm is enabled, another for if it actually sets the config flag).</p>
<p>Also the comment above should be updated.</p>
</blockquote>



<a name="193594697"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594697" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594697">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855000" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855000">PR Review Comment</a>:</p>
<blockquote>
<p>Also add a test for this file over here: <a href="https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs" title="https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs">https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs</a></p>
</blockquote>



<a name="193594698"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193594698" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193594698">(Apr 10 2020 at 17:25)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406849627" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406849627">PR Review Comment</a>:</p>
<blockquote>
<p>Would it be possible to add <code>translate_func_prologue</code> to <code>cranelift_wasm::FuncEnviron</code>, where we already have embedder hooks and can side step these issues? I think this would also make it so we wouldn't need to regalloc by hand here.</p>
</blockquote>



<a name="193597852"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193597852" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193597852">(Apr 10 2020 at 17:53)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391575774" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391575774">PR Review</a>.</p>



<a name="193597853"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193597853" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193597853">(Apr 10 2020 at 17:53)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870296" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870296">PR Review Comment</a>:</p>
<blockquote>
<p>Hm I think that <code>()</code> is what's wanted here since that's the destination of the link. I was fixing rustdoc warnings here and this is what was necessary to fix the warning.</p>
</blockquote>



<a name="193597990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193597990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193597990">(Apr 10 2020 at 17:54)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576189" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576189">PR Review</a>.</p>



<a name="193597991"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193597991" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193597991">(Apr 10 2020 at 17:54)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870658" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870658">PR Review Comment</a>:</p>
<blockquote>
<p>I don't think it'd help much to single-out zero here, 1 byte of stack allocation is just as nonsensical in a sense. I personally think it's ok to take everything here, and if someone is toying around with 0-byte wasm stacks for testing that seems like it's fine to allow.</p>
</blockquote>



<a name="193598092"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193598092" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193598092">(Apr 10 2020 at 17:55)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576656" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576656">PR Review</a>.</p>



<a name="193598093"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193598093" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193598093">(Apr 10 2020 at 17:55)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406871045" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406871045">PR Review Comment</a>:</p>
<blockquote>
<p>Hm I don't think this is actually that necessary, we already run all the examples on CI with <code>cargo run -p run-examples</code>?</p>
</blockquote>



<a name="193598167"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193598167" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193598167">(Apr 10 2020 at 17:55)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193598413"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193598413" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193598413">(Apr 10 2020 at 17:57)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391577962" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391577962">PR Review</a>.</p>



<a name="193598414"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193598414" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193598414">(Apr 10 2020 at 17:57)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406872123" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406872123">PR Review Comment</a>:</p>
<blockquote>
<p>I'm not really wed to this particular solution at all, and I agree it's a great property to have everything reflected in the text format. That being said though we need <em>some</em> solution here which actually works and accounts for the wasmtime-specific behavior of where the stack limit is located. I don't know of a great way to do this, but would be totally onboard with alternative ways.</p>
<p>I don't know how to make <code>translate_func_prologue</code> work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>
</blockquote>



<a name="193599397"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193599397" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193599397">(Apr 10 2020 at 18:06)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582084" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582084">PR Review</a>.</p>



<a name="193599398"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193599398" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193599398">(Apr 10 2020 at 18:06)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875502" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875502">PR Review Comment</a>:</p>
<blockquote>
<p>Ah ok, I guess <a href="https://github.com/bytecodealliance/wasmtime/pull/1463" title="https://github.com/bytecodealliance/wasmtime/pull/1463">https://github.com/bytecodealliance/wasmtime/pull/1463</a> was unnecessary</p>
</blockquote>



<a name="193599526"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193599526" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193599526">(Apr 10 2020 at 18:07)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582592" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582592">PR Review</a>.</p>



<a name="193599527"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193599527" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193599527">(Apr 10 2020 at 18:07)</a>:</h4>
<p>fitzgen created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875923" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875923">PR Review Comment</a>:</p>
<blockquote>
<blockquote>
<p>I don't know how to make <code>translate_func_prologue</code> work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>
</blockquote>
<p>I think we would need an instruction to get the current stack frame's size or something. Not sure how well this would work out.</p>
</blockquote>



<a name="193600087"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193600087" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193600087">(Apr 10 2020 at 18:12)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391584950" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391584950">PR Review</a>.</p>



<a name="193600088"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193600088" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193600088">(Apr 10 2020 at 18:12)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406877960" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406877960">PR Review Comment</a>:</p>
<blockquote>
<p>The impression I get though is that representing this in IR is the wrong idea because if we generate IR to do the stack check, then the actual stack adjustment happens in the function's prologue, which is too late then to perform the stack check. This is very machine-specific because it's part of the prologue/epilogue generation at a very particular part of codegen, so afaik it can't be very easily represented in IR without a lot of "magic", but others may know better routes!</p>
</blockquote>



<a name="193873581"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193873581" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193873581">(Apr 14 2020 at 09:53)</a>:</h4>
<p>bnjbvr submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-392774970" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-392774970">PR Review</a>.</p>



<a name="193873582"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193873582" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193873582">(Apr 14 2020 at 09:53)</a>:</h4>
<p>bnjbvr created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408011344" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408011344">PR Review Comment</a>:</p>
<blockquote>
<blockquote>
<p>I don't know how to make translate_func_prologue work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>
</blockquote>
<p>For what it's worth, the way it's dealt with in Spidermonkey is that:</p>
<ol>
<li>Spidermonkey has its own calling convention "baldrdash", used in Cranelift.</li>
<li>Cranelift won't generate the prologue and epilogue if the calling convention is baldrdash; Spidermonkey will.</li>
<li>Then the interrupt check can be done in Cranelift IR from the Spidermonkey side.</li>
<li>In addition to this, Spidermonkey has to use the <code>fallthrough_return</code> instead of a plain return, since it generates its own epilogue.</li>
</ol>
<p>I imagine replicating this behavior for Wasmtime would be quite a hassle, so this might not be the best path here...</p>
</blockquote>



<a name="193904779"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193904779" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193904779">(Apr 14 2020 at 14:23)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193921228"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193921228" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193921228">(Apr 14 2020 at 16:14)</a>:</h4>
<p>pepyakin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666">PR Review</a>.</p>



<a name="193921229"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193921229" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193921229">(Apr 14 2020 at 16:14)</a>:</h4>
<p>pepyakin created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408243887" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408243887">PR Review Comment</a>:</p>
<blockquote>
<p>I think you meant <code>max_wasm_stack</code> here, right?</p>
</blockquote>



<a name="193921230"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193921230" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193921230">(Apr 14 2020 at 16:14)</a>:</h4>
<p>pepyakin submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666">PR Review</a>.</p>



<a name="193921231"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193921231" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193921231">(Apr 14 2020 at 16:14)</a>:</h4>
<p>pepyakin created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408242909" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408242909">PR Review Comment</a>:</p>
<blockquote>
<p>Doesn't this warrant an unsafe marker on <code>update_stack_limit</code> since this only works if <code>self</code> is on the stack. A comment at the call site might do as well.</p>
</blockquote>



<a name="193949173"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193949173" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193949173">(Apr 14 2020 at 19:56)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="193949207"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193949207" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193949207">(Apr 14 2020 at 19:57)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408397568" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408397568">PR Review Comment</a>:</p>
<blockquote>
<p>Oh oops good point. I've updated the comment on the function a bit</p>
</blockquote>



<a name="193949208"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/193949208" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#193949208">(Apr 14 2020 at 19:57)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393249348" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393249348">PR Review</a>.</p>



<a name="194031617"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194031617" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194031617">(Apr 15 2020 at 13:41)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194496378"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194496378" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194496378">(Apr 17 2020 at 20:35)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194499557"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194499557" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194499557">(Apr 17 2020 at 21:03)</a>:</h4>
<p>abrown submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395771124" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395771124">PR Review</a>.</p>



<a name="194499558"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194499558" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194499558">(Apr 17 2020 at 21:03)</a>:</h4>
<p>abrown created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410468638" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410468638">PR Review Comment</a>:</p>
<blockquote>
<p>-1?</p>
</blockquote>



<a name="194501009"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194501009" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194501009">(Apr 17 2020 at 21:16)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395777731" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395777731">PR Review</a>.</p>



<a name="194501011"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194501011" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194501011">(Apr 17 2020 at 21:16)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016">PR Review Comment</a>:</p>
<blockquote>
<p>If you can use a <code>GlobalValueData::Load</code> to load from a <code>GlobalValueData::VMContext</code>. Then you set this field to the <code>GlobalValue</code> of the <code>GlobalValueData</code>. You can then during the stack check codegen use <code>global_value</code> to get the stack limit</p>
</blockquote>



<a name="194501023"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194501023" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194501023">(Apr 17 2020 at 21:16)</a>:</h4>
<p>bjorn3 edited <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016">PR Review Comment</a>.</p>



<a name="194502637"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194502637" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194502637">(Apr 17 2020 at 21:33)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395785536" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395785536">PR Review</a>.</p>



<a name="194502638"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194502638" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194502638">(Apr 17 2020 at 21:33)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410480349" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410480349">PR Review Comment</a>:</p>
<blockquote>
<p>Keeping <code>ir::Function</code> serializable makes it easier for us to extract standalone Cranelift testcases that don't require linking with surrounding applications. And in the future, we also hope to use this property to enable more compilation caching and remote/ipc compilation.</p>
<p>Global values are an expression language which you can use to define code templates that Cranelift can expand into actual code later (<a href="https://github.com/bytecodealliance/wasmtime/pull/1267" title="https://github.com/bytecodealliance/wasmtime/pull/1267">https://github.com/bytecodealliance/wasmtime/pull/1267</a> is a further step toward generalizing the concept and actually renames it to "template"). Currently, you can only do a few simple things with them: <a href="https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/enum.GlobalValueData.html" title="https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/enum.GlobalValueData.html">load, iadd_imm, vmctx addresses, and symbolic addresses</a>. That looks like it may actually be enough for what you need to do here, though we can add more operations if needed.</p>
<p>So the idea is, you create them, one "instruction" at a time, with <a href="https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/function/struct.Function.html#method.create_global_value" title="https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/function/struct.Function.html#method.create_global_value">declare_global_value</a> which returns the index of the global value which you can then use however you want within the <code>ir::Function</code>.</p>
</blockquote>



<a name="194502838"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194502838" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194502838">(Apr 17 2020 at 21:34)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395786342" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395786342">PR Review</a>.</p>



<a name="194502839"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194502839" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194502839">(Apr 17 2020 at 21:34)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410481007" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410481007">PR Review Comment</a>:</p>
<blockquote>
<p>I <a href="https://gist.github.com/alexcrichton/c43e66cc13154a97be2af665dc1aa117" title="https://gist.github.com/alexcrichton/c43e66cc13154a97be2af665dc1aa117">tried that</a> but <a href="https://gist.github.com/alexcrichton/02697129b5a92ad2b8983a74115b244a" title="https://gist.github.com/alexcrichton/02697129b5a92ad2b8983a74115b244a">got a panic</a> that I think means the legalizer needs to run, but this is happening after the legalizer has already run.</p>
</blockquote>



<a name="194503569"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194503569" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194503569">(Apr 17 2020 at 21:41)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395789113" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395789113">PR Review</a>.</p>



<a name="194503570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194503570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194503570">(Apr 17 2020 at 21:41)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410483356" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410483356">PR Review Comment</a>:</p>
<blockquote>
<p>@sunfishcode oh I think that's what @bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016">recommended above</a> a few minutes ago as well, but do you know how to work around the legalizer issue? Expanding a global value seems to require the legalizer to run, but since this is in prologue/epilogue generation that's too late for the legalizer to run it seems.</p>
</blockquote>



<a name="194504475"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194504475" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194504475">(Apr 17 2020 at 21:48)</a>:</h4>
<p>bjorn3 submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395792403" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395792403">PR Review</a>.</p>



<a name="194504476"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194504476" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194504476">(Apr 17 2020 at 21:48)</a>:</h4>
<p>bjorn3 created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410486174" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410486174">PR Review Comment</a>:</p>
<blockquote>
<p>It seems that <code>EncCursor</code> doesn't allow inserting instructions that need to be legalized.</p>
</blockquote>



<a name="194505923"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194505923" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194505923">(Apr 17 2020 at 22:03)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194505935"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194505935" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194505935">(Apr 17 2020 at 22:03)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395799141" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395799141">PR Review</a>.</p>



<a name="194505936"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194505936" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194505936">(Apr 17 2020 at 22:03)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410491892" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410491892">PR Review Comment</a>:</p>
<blockquote>
<p>Oops, updated the comment!</p>
</blockquote>



<a name="194507643"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194507643" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194507643">(Apr 17 2020 at 22:24)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194517569"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517569" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517569">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946">PR Review</a>.</p>



<a name="194517570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517570">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946">PR Review</a>.</p>



<a name="194517571"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517571" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517571">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523700" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523700">PR Review Comment</a>:</p>
<blockquote>
<p>This technique is independent of x86, so we should just say "the stack pointer" rather than "%rsp".</p>
</blockquote>



<a name="194517572"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517572" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517572">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523495" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523495">PR Review Comment</a>:</p>
<blockquote>
<p>s/wasm/Wasmtime/</p>
</blockquote>



<a name="194517573"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517573" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517573">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523838" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523838">PR Review Comment</a>:</p>
<blockquote>
<p>"How does Wasmtime interrupt wasm code"?</p>
</blockquote>



<a name="194517574"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517574" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517574">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410524479" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410524479">PR Review Comment</a>:</p>
<blockquote>
<p>This focuses on how we implement it, but for users, we should say something like "Whether or not to enable the ability to interrupt wasm code dynamically", and also mention the limitation that calls into host code can't be interrupted. And maybe also link to how to perform an interrupt.</p>
</blockquote>



<a name="194517575"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517575" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517575">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527112" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527112">PR Review Comment</a>:</p>
<blockquote>
<p>With this change, we're now overriding Rust's <code>SA_ONSTACK</code> handler with our own non-<code>SA_ONSTACK</code> handler. This means that all Rust code in a program which uses Wasmtime will no longer get the Rust stack overflow handler on stack overflow, but a generic segfault; is that right? That seems like something we should document somewhere; Rust users may be accustomed to not seeing their programs killed by segfault, and may otherwise interpret a segfault as a sign of a more serious problem.</p>
</blockquote>



<a name="194517576"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517576" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517576">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410525292" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410525292">PR Review Comment</a>:</p>
<blockquote>
<p>It's surprising that this is being represented as a signed <code>i32</code>, since the value becomes negative, and elsewhere it's casted to a <code>usize</code> and treated as unsigned.</p>
</blockquote>



<a name="194517577"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194517577" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194517577">(Apr 18 2020 at 00:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527590" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527590">PR Review Comment</a>:</p>
<blockquote>
<p>Would it be difficult to add similar code to the wasmtime-cli as a command-line argument to let users specify <code>--timeout=30s</code> or so?</p>
</blockquote>



<a name="194683911"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194683911" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194683911">(Apr 20 2020 at 14:38)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194683954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194683954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194683954">(Apr 20 2020 at 14:38)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396516772" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396516772">PR Review</a>.</p>



<a name="194683955"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194683955" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194683955">(Apr 20 2020 at 14:38)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411431960" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411431960">PR Review Comment</a>:</p>
<blockquote>
<p>Sure!</p>
<p>I added this as <code>--wasm-timeout=30</code> so in the future we could add <code>--timeout</code> which accounts for both compile time and for wasm execution time.</p>
</blockquote>



<a name="194684174"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194684174" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194684174">(Apr 20 2020 at 14:40)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396518164" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396518164">PR Review</a>.</p>



<a name="194684178"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194684178" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194684178">(Apr 20 2020 at 14:40)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411433170" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411433170">PR Review Comment</a>:</p>
<blockquote>
<p>That's true yeah, and unfortunately I'm not sure there's really anything we can do about it. The only real way to fix this would be to always run on the sigaltstack which brings up the same issues that <em>not</em> running on the sigaltstack is trying to fix. </p>
<p>I'll throw a comment here in signal registration in case anyone is poking around, I'm not really sure where else would be an effective place to comment this.</p>
</blockquote>



<a name="194685160"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194685160" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194685160">(Apr 20 2020 at 14:47)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194685449"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194685449" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194685449">(Apr 20 2020 at 14:49)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194685483"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194685483" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194685483">(Apr 20 2020 at 14:49)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396527305" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396527305">PR Review</a>.</p>



<a name="194685484"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194685484" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194685484">(Apr 20 2020 at 14:49)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411440942" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411440942">PR Review Comment</a>:</p>
<blockquote>
<p>Er I'm basically trying to be too clever by half here, I've updated this to be <code>usize</code>.</p>
</blockquote>



<a name="194689762"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194689762" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194689762">(Apr 20 2020 at 15:18)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322">PR Review</a>.</p>



<a name="194689764"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194689764" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194689764">(Apr 20 2020 at 15:18)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411448540" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411448540">PR Review Comment</a>:</p>
<blockquote>
<p>We already have a dependency on <code>humantime</code> (via <code>env_logger</code>), so could we make this take a string and parse it with <a href="https://docs.rs/humantime/2.0.0/humantime/fn.parse_duration.html" title="https://docs.rs/humantime/2.0.0/humantime/fn.parse_duration.html"><code>parse_duration</code></a>? That way people can specify timeouts less than a second, and large timeouts are more convenient.</p>
</blockquote>



<a name="194689765"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194689765" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194689765">(Apr 20 2020 at 15:18)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322">PR Review</a>.</p>



<a name="194689766"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194689766" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194689766">(Apr 20 2020 at 15:18)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411456237" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411456237">PR Review Comment</a>:</p>
<blockquote>
<p>Typo: tha-&gt;that</p>
</blockquote>



<a name="194693077"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194693077" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194693077">(Apr 20 2020 at 15:38)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194693086"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194693086" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194693086">(Apr 20 2020 at 15:38)</a>:</h4>
<p>alexcrichton submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396573227" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396573227">PR Review</a>.</p>



<a name="194693087"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194693087" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194693087">(Apr 20 2020 at 15:38)</a>:</h4>
<p>alexcrichton created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411480275" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411480275">PR Review Comment</a>:</p>
<blockquote>
<p>Oh nice idea!</p>
<p>Updated now</p>
</blockquote>



<a name="194694503"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194694503" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194694503">(Apr 20 2020 at 15:48)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194727673"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194727673" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194727673">(Apr 20 2020 at 20:22)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396783692" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396783692">PR Review</a>.</p>



<a name="194731649"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194731649" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194731649">(Apr 20 2020 at 20:52)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194732504"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194732504" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194732504">(Apr 20 2020 at 20:58)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194737502"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194737502" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194737502">(Apr 20 2020 at 21:43)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194758592"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194758592" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194758592">(Apr 21 2020 at 03:51)</a>:</h4>
<p>sunfishcode submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396968166" title="https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396968166">PR Review</a>.</p>



<a name="194758593"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194758593" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194758593">(Apr 21 2020 at 03:51)</a>:</h4>
<p>sunfishcode created <a href="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411848258" title="https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411848258">PR Review Comment</a>:</p>
<blockquote>
<p><code>func()</code> has been renamed to <code>into_func()</code>, but this can be simplified to just <code>instance.get_func("foo")</code>.</p>
</blockquote>



<a name="194808447"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194808447" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194808447">(Apr 21 2020 at 14:20)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194831658"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194831658" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194831658">(Apr 21 2020 at 16:58)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>
<blockquote>
<p>This commit is a relatively large change for wasmtime with two main<br>
goals:</p>
<ul>
<li>
<p>Primarily this enables interrupting executing wasm code with a trap,<br>
  preventing infinite loops in wasm code. Note that resumption of the<br>
  wasm code is not a goal of this commit.</p>
</li>
<li>
<p>Additionally this commit reimplements how we handle stack overflow to<br>
  ensure that host functions always have a reasonable amount of stack to<br>
  run on. This fixes an issue where we might longjmp out of a host<br>
  function, skipping destructors.</p>
</li>
</ul>
<p>Lots of various odds and ends end up falling out in this commit once the<br>
two goals above were implemented. The strategy for implementing this was<br>
also lifted from Spidermonkey and existing functionality inside of<br>
Cranelift. I've tried to write up thorough documentation of how this all<br>
works in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>
<p>A brief summary of how this works is that each function and each loop<br>
header now checks to see if they're interrupted. Interrupts and the<br>
stack overflow check are actually folded into one now, where function<br>
headers check to see if they've run out of stack and the sentinel value<br>
used to indicate an interrupt, checked in loop headers, tricks functions<br>
into thinking they're out of stack. An interrupt is basically just<br>
writing a value to a location which is read by JIT code.</p>
<p>When interrupts are delivered and what triggers them has been left up to<br>
embedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>
method to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>
<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>
even a signal handler) to get notified from. It's intended that this<br>
provides a good degree of flexibility when interrupting wasm code. Note<br>
though that this does have a large caveat where interrupts don't work<br>
when you're interrupting host code, so if you've got a host import<br>
blocking for a long time an interrupt won't actually be received until<br>
the wasm starts running again.</p>
<p>Some fallout included from this change is:</p>
<ul>
<li>
<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>
  Instead they run on the native stack the thread was already using.<br>
  This is possible since stack overflow isn't handled by hitting the<br>
  guard page, but rather it's explicitly checked for in wasm now. Native<br>
  stack overflow will continue to abort the process as usual.</p>
</li>
<li>
<p>Unix sigaltstack management is now no longer necessary since we don't<br>
  use it any more.</p>
</li>
<li>
<p>Windows no longer has any need to reset guard pages since we no longer<br>
  try to recover from faults on guard pages.</p>
</li>
<li>
<p>On all targets probestack intrinsics are disabled since we use a<br>
  different mechanism for catching stack overflow.</p>
</li>
<li>
<p>The C API has been updated with interrupts handles. An example has<br>
  also been added which shows off how to interrupt a module.</p>
</li>
</ul>
<p>Closes #139<br>
Closes #860<br>
Closes #900</p>
<p>&lt;!--</p>
<p>Please ensure that the following steps are all taken care of before submitting<br>
the PR.</p>
<ul>
<li>
<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>
  here.</p>
</li>
<li>
<p>[ ] A short description of what this does, why it is needed; if the<br>
  description becomes long, the matter should probably be discussed in an issue<br>
  first.</p>
</li>
<li>
<p>[ ] This PR contains test cases, if meaningful.</p>
</li>
<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>
  If you don't know who could review this, please indicate so. The list of<br>
  suggested reviewers on the right can help you.</li>
</ul>
<p>Please ensure all communication adheres to the <a href="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md" title="https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md">code of
conduct</a>.<br>
--&gt;</p>
</blockquote>



<a name="194840087"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%231490%20Implement%20interrupting%20wasm%20code%2C%20rei.../near/194840087" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.231490.20Implement.20interrupting.20wasm.20code.2C.20rei.2E.2E.2E.html#194840087">(Apr 21 2020 at 18:03)</a>:</h4>
<p>sunfishcode merged <a href="https://github.com/bytecodealliance/wasmtime/pull/1490" title="https://github.com/bytecodealliance/wasmtime/pull/1490">PR #1490</a>.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>