<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4424 Craneline vector shift count seman... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html">wasmtime / issue #4424 Craneline vector shift count seman...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="289053505"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289053505" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289053505">(Jul 09 2022 at 17:38)</a>:</h4>
<p>uweigand opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289216925"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289216925" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289216925">(Jul 11 2022 at 16:31)</a>:</h4>
<p>akirilov-arm labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289216926"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289216926" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289216926">(Jul 11 2022 at 16:31)</a>:</h4>
<p>akirilov-arm labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289216927"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289216927" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289216927">(Jul 11 2022 at 16:31)</a>:</h4>
<p>akirilov-arm labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289216928"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289216928" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289216928">(Jul 11 2022 at 16:31)</a>:</h4>
<p>akirilov-arm labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289216930"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289216930" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289216930">(Jul 11 2022 at 16:31)</a>:</h4>
<p>akirilov-arm labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<a name="289990550"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/289990550" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#289990550">(Jul 18 2022 at 16:34)</a>:</h4>
<p>abrown <a href="https://github.com/bytecodealliance/wasmtime/issues/4424#issuecomment-1187716395">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>I agree that this should be fixed. This was one of my early my contributions to the project (when things were quite different, <a href="https://github.com/bytecodealliance/cranelift/pull/1120">https://github.com/bytecodealliance/cranelift/pull/1120</a>); using Cranelift apart from a WebAssembly translation was not top of mind back. Since both main architectures (x64 and aarch64) needed the mod operation, it seemed reasonable then to have the translation do it. Now it makes more sense to move the extra operations down into each backend that needs them.</p>
</blockquote>



<a name="291084790"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234424%20Craneline%20vector%20shift%20count%20seman.../near/291084790" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234424.20Craneline.20vector.20shift.20count.20seman.2E.2E.2E.html#291084790">(Jul 27 2022 at 17:54)</a>:</h4>
<p>jameysharp closed <a href="https://github.com/bytecodealliance/wasmtime/issues/4424">issue #4424</a>:</p>
<blockquote>
<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>
<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">v0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iconst</span><span class="p">.</span><span class="kt">i32</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">lane</span><span class="w"></span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vconst</span><span class="p">.</span><span class="n">i16x8</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="mi">128</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ishl</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v0</span><span class="w"></span>
</code></pre></div>
<p>However, looking at the documentation, we have this statement:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="w"> </span><span class="n">towards</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MSB</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="err">``</span><span class="n">y</span><span class="err">``</span><span class="w"></span>
<span class="w">        </span><span class="n">places</span><span class="p">.</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LSB</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">The</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">masked</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="err">``</span><span class="n">x</span><span class="err">``</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">When</span><span class="w"> </span><span class="n">shifting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">B</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">computes</span>:

            <span class="nc">s</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span>:<span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">s</span><span class="w"> </span><span class="err">\</span><span class="n">pmod</span><span class="p">{</span><span class="mi">2</span><span class="o">^</span><span class="n">B</span><span class="p">}.</span><span class="w"></span>
</code></pre></div>
<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>
<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>
<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">      </span><span class="n">Operator</span>::<span class="n">I8x16Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I16x8Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I32x4Shl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Operator</span>::<span class="n">I64x2Shl</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">pop2</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitcast_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optionally_bitcast_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">),</span><span class="w"> </span><span class="n">builder</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span>::<span class="n">from</span><span class="p">(</span><span class="n">type_of</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">lane_bits</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>
<span class="w">            </span><span class="c1">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">band_imm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="p">.</span><span class="n">push1</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">ishl</span><span class="p">(</span><span class="n">bitcast_a</span><span class="p">,</span><span class="w"> </span><span class="n">b_mod_bitwidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>
<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>
<p>FYI @cfallin @afonso360 <br>
</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>