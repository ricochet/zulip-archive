<html>
<head><meta charset="utf-8"><title>wasmtime / PR #7713 refactor: allow `Subscribe::ready` to... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html">wasmtime / PR #7713 refactor: allow `Subscribe::ready` to...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="409228668"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409228668" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409228668">(Dec 20 2023 at 17:10)</a>:</h4>
<p>rvolosatovs opened <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a> from <code>rvolosatovs:feat/fallible-ready</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>In the current implementation <a href="https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#tymethod.ready"><code>Subscribe::ready</code></a> is assumed to be infallible, which does not work in a generic case, where the implementation may require, in fact, to cause a trap in the guest.<br>
This is important, because implementations that require ability to trap in host <code>wasi::io::poll/pollable </code>pollable<code> would otherwise require to implement their own </code>wasi::io::poll/pollable<code>, meaning that they would not be able to reuse all the existing WASI crate implementations (https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors), potentially locking developers out of most of WASI functionality (due to the [</code>Pollable`](<a href="https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html">https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html</a>) concrete type being used in signatures, which cannot be externally constructed)</p>
</blockquote>



<a name="409228669"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409228669" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409228669">(Dec 20 2023 at 17:10)</a>:</h4>
<p><strong>rvolosatovs</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>.</p>



<a name="409228670"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409228670" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409228670">(Dec 20 2023 at 17:10)</a>:</h4>
<p><strong>rvolosatovs</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>.</p>



<a name="409228711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409228711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409228711">(Dec 20 2023 at 17:10)</a>:</h4>
<p>rvolosatovs edited <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<p>In the current implementation <a href="https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#tymethod.ready"><code>Subscribe::ready</code></a> is assumed to be infallible, which does not work in a generic case, where the implementation may require, in fact, to cause a trap in the guest.<br>
This is important, because implementations that require ability to trap in host <code>wasi::io::poll/pollable</code> would otherwise require to implement their own <code>wasi::io::poll/pollable</code>, meaning that they would not be able to reuse all the existing WASI crate implementations (<a href="https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors">https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors</a>), potentially locking developers out of most of WASI functionality (due to the <a href="https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html"><code>Pollable</code></a> concrete type being used in signatures, which cannot be externally constructed)</p>
</blockquote>



<a name="409229349"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409229349" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409229349">(Dec 20 2023 at 17:14)</a>:</h4>
<p>rvolosatovs updated <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>.</p>



<a name="409234845"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409234845" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409234845">(Dec 20 2023 at 17:51)</a>:</h4>
<p>rvolosatovs updated <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>.</p>



<a name="409234878"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409234878" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409234878">(Dec 20 2023 at 17:51)</a>:</h4>
<p><strong>rvolosatovs</strong> has marked <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a> as ready for review.</p>



<a name="409390276"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/409390276" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#409390276">(Dec 21 2023 at 13:36)</a>:</h4>
<p>rvolosatovs updated <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>.</p>



<a name="410891276"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/410891276" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#410891276">(Jan 02 2024 at 19:01)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1874424261">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>
</blockquote>



<a name="411743926"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/411743926" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#411743926">(Jan 08 2024 at 14:03)</a>:</h4>
<p>rvolosatovs <a href="https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<blockquote>
<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>
</blockquote>
<p>First I'll comment on this part:</p>
<blockquote>
<p>buffering up the error to get returned from an accessor elsewhere</p>
</blockquote>
<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href="https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461"><code>wasi:http/types.future-trailers</code></a>, for example:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource future-trailers {
  subscribe: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
}
</code></pre></div>
<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>
<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource custom-trailers {
  subscribe-one: func() -&gt; pollable;
  subscribe-two: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
  foo: func() -&gt; string;
}
</code></pre></div>
<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned "ready". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href="https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>
<p>Coming back to the first part:</p>
<p>My exact use case is a "pollable", which is a remote entity accessible via network:<br>
1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>
2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>
3. <code>Subscribe::ready</code> unblocks</p>
<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>
If, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest.</p>
</blockquote>



<a name="411744184"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/411744184" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#411744184">(Jan 08 2024 at 14:04)</a>:</h4>
<p>rvolosatovs edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<blockquote>
<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>
</blockquote>
<p>First I'll comment on this part:</p>
<blockquote>
<p>buffering up the error to get returned from an accessor elsewhere</p>
</blockquote>
<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href="https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461"><code>wasi:http/types.future-trailers</code></a>, for example:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource future-trailers {
  subscribe: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
}
</code></pre></div>
<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>
<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource custom-trailers {
  subscribe-one: func() -&gt; pollable;
  subscribe-two: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
  foo: func() -&gt; string;
}
</code></pre></div>
<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned "ready". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href="https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>
<p>Coming back to the first part:</p>
<p>My exact use case is a "pollable", which is a remote entity accessible via network:<br>
1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>
2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>
3. <code>Subscribe::ready</code> unblocks</p>
<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>
If, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest (and such may not be available even when the interface is known at compile time).</p>
</blockquote>



<a name="411744763"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/411744763" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#411744763">(Jan 08 2024 at 14:07)</a>:</h4>
<p>rvolosatovs edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<blockquote>
<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>
</blockquote>
<p>First I'll comment on this part:</p>
<blockquote>
<p>buffering up the error to get returned from an accessor elsewhere</p>
</blockquote>
<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href="https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461"><code>wasi:http/types.future-trailers</code></a>, for example:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource future-trailers {
  subscribe: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
}
</code></pre></div>
<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>
<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>resource custom-trailers {
  subscribe-one: func() -&gt; pollable;
  subscribe-two: func() -&gt; pollable;
  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;
  foo: func() -&gt; string;
}
</code></pre></div>
<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned "ready". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href="https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>
<p>Coming back to the first part:</p>
<p>My exact use case is a "pollable", which is a remote entity accessible via network:<br>
1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>
2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>
3. <code>Subscribe::ready</code> unblocks</p>
<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>
If, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest (and such may not be available even when the interface is known at compile time). Returning in this case could break assumptions of the Wasm component logic and blocking forever would stall execution forever (e.g. if no timeout is used in the Wasm component poll)</p>
</blockquote>



<a name="411773976"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%237713%20refactor%3A%20allow%20%60Subscribe%3A%3Aready%60%20to.../near/411773976" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.237713.20refactor.3A.20allow.20.60Subscribe.3A.3Aready.60.20to.2E.2E.2E.html#411773976">(Jan 08 2024 at 16:35)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881430009">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/7713">PR #7713</a>:</p>
<blockquote>
<p>Ok makes sense, thanks for explaining. Can this be fixed though by updating the WIT-level APIs? </p>
<p>For example in your <code>custom-trailers</code> I would say that what <code>subscribe</code> and the <code>pollable</code>s mean depends on how the WIT APIs are defined. It would be an API contract that <code>subscribe-one</code> would indicate readiness of <code>get</code> and <code>subscribe-two</code> would indicate readiness of <code>foo</code> where <code>foo</code> would have to semantically define what it means to be called before it's ready, etc.</p>
<p>In your use case of a remote-owned resource, this is something that I'd at least personally expect to go through an error somewhere in the WIT. One option would be that when the pollable says "ready" any future operations on it trap (communicating the fatal error) or by updating the APIs there to surface an error instead.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>