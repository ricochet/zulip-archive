<html>
<head><meta charset="utf-8"><title>wasmtime / issue #1891 Test specific flags in Cranelift f... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.231891.20Test.20specific.20flags.20in.20Cranelift.20f.2E.2E.2E.html">wasmtime / issue #1891 Test specific flags in Cranelift f...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="289770092"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%231891%20Test%20specific%20flags%20in%20Cranelift%20f.../near/289770092" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.231891.20Test.20specific.20flags.20in.20Cranelift.20f.2E.2E.2E.html#289770092">(Jul 15 2022 at 19:09)</a>:</h4>
<p>jameysharp closed <a href="https://github.com/bytecodealliance/wasmtime/issues/1891">issue #1891</a>:</p>
<blockquote>
<p>In #1880 @bnjbvr brought up an issue with how Cranelift's filetests use (or don't use) ISA-specific flags. He was trying to use <code>target x86_64 use_new_backend</code> in a <code>test run</code> filetest but the <code>SingleFunctionCompiler</code> doesn't know anything about ISA-specific <code>Flags</code>, only shared <code>Flags</code>. (Perhaps these two sets of flags should be merged in some way, but what I will propose next doesn't require that).</p>
<p>The current behavior is:</p>
<ul>
<li>check if the default host architecture (used by <code>SingleFunctionCompiler</code>) is the same as the one specified by the <code>target</code> directive; if not, skip the test (though in the future this should print some sort of <code>IGNORED [filename]</code> so the user knows what happened, see #1558)</li>
<li>compile and run the test using the default host <code>TargetIsa</code></li>
</ul>
<p>I propose we change the behavior to:</p>
<ul>
<li>check if the default host <code>TargetIsa</code> _is compatible with_ the one specified by the <code>target</code> directive; if not, skip the test, etc.</li>
<li>compile and run the test using the <code>target</code> directive's <code>TargetIsa</code>--this will use any special flags assigned by the user, e.g. <code>use_new_backend</code></li>
</ul>
<p>To get this "_is compatible with_" behavior, I propose we add a new <code>Flags::matches</code> function to the shared <code>Flags</code> and to each ISA-specific <code>Flags</code> (this likely has to be done as generated code in <code>gen_settings.rs</code> so it only needs to be done once). Then, we expose this function as <code>TargetIsa::matches</code> and implement it in each ISA as <code>self.flags.matches(&amp;other.flags) &amp;&amp; self.isa_flags.matches(&amp;other.isa_flags)</code>. This way we can compare TargetIsa's for compatibility.</p>
<p>How does <code>Flags::matches</code> work? I think it needs to iterate over the field descriptors and compare them both to the default value and to the other value. Remember that <code>matches</code> only goes one way: if <code>a</code> matches <code>b</code> it does not necessarily mean that <code>b</code> matches <code>a</code>. Though it passes some simple tests, I'm not 100% confident that the following is correct so I would appreciate feedback:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span> <span class="nf">get_bit</span><span class="p">(</span><span class="n">byte</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">bit</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bit</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">byte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Flags</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">matches</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">shared_default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared_default</span><span class="p">,</span><span class="w"> </span><span class="n">builder</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Check each detail until we see presets.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">byte_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DESCRIPTORS</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">byte_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">detail</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">detail</span>::<span class="n">Detail</span>::<span class="n">Bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">default_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="n">default</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">other_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">default_bit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">other_bit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">detail</span>::<span class="n">Detail</span>::<span class="n">Num</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">detail</span>::<span class="n">Detail</span>::<span class="n">Enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">self_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">default_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">other_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">self_byte</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">default_byte</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">self_byte</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">other_byte</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">                </span><span class="n">detail</span>::<span class="n">Detail</span>::<span class="n">Preset</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Then check each preset bit.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">byte_offset</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">byte_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="bp">self</span><span class="p">.</span><span class="n">bytes</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">default_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="n">default</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">other_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_bit</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="n">byte_offset</span><span class="p">],</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">default_bit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">self_bit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">other_bit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kc">true</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>