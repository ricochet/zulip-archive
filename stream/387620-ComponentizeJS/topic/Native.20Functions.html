<html>
<head><meta charset="utf-8"><title>Native Functions · ComponentizeJS · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/387620-ComponentizeJS/index.html">ComponentizeJS</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/387620-ComponentizeJS/topic/Native.20Functions.html">Native Functions</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="378782502"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/387620-ComponentizeJS/topic/Native%20Functions/near/378782502" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> backkem <a href="https://bytecodealliance.github.io/zulip-archive/stream/387620-ComponentizeJS/topic/Native.20Functions.html#378782502">(Jul 26 2023 at 12:31)</a>:</h4>
<p>I was wondering what the thinking is to flesh out the 'Native Functions' in the JS runtime? Is the idea to add polyfills for common globals that map to the standard WASI interfaces? In a JS host these would then be the counterpart to the jco/preview2-shims. Meaning a component can use a host function as follows: JS code -&gt; ComponentizeJS polyfill -&gt; JCO shim  -&gt; host implementation.<br>
Taking console.log as an example, you would get: JS code using console.log -&gt; mapped to WASI-logging -&gt; mapped back to host console.log implementation.<br>
Taking SubtleCrypto in the browser as an example, you would get: JS code using JS SubtleCrypto API -&gt; mapped to WASI-crypto -&gt; mapped back to host SubtleCrypto implementation.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>