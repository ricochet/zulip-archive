<html>
<head><meta charset="utf-8"><title>cranelift / Issue #734 Legalization meta-descriptions imp... · git-cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217576-git-cranelift/index.html">git-cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217576-git-cranelift/topic/cranelift.20.2F.20Issue.20.23734.20Legalization.20meta-descriptions.20imp.2E.2E.2E.html">cranelift / Issue #734 Legalization meta-descriptions imp...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="189361431"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217576-git-cranelift/topic/cranelift%20/%20Issue%20%23734%20Legalization%20meta-descriptions%20imp.../near/189361431" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GitHub <a href="https://bytecodealliance.github.io/zulip-archive/stream/217576-git-cranelift/topic/cranelift.20.2F.20Issue.20.23734.20Legalization.20meta-descriptions.20imp.2E.2E.2E.html#189361431">(Feb 28 2020 at 23:25)</a>:</h4>
<p>alexcrichton transferred <a href="https://github.com/bytecodealliance/cranelift/issues/734" target="_blank" title="https://github.com/bytecodealliance/cranelift/issues/734">Issue #734</a>:</p>
<blockquote>
<p>I'll use this issue as a dump for things that I've noticed could be enhanced for the legalization module in the Rust meta crate, probably better to do later once we've ported all of the meta code to Rust.</p>
<ul>
<li>[ ] Remove the ordering hack in the <code>x86</code> legalizer file, which was needed because we want to ensure the same ordering of transform groups as the Python module does (for encodings).</li>
<li>[x] When there are several legalizations available for a given Cranelift opcode (e.g. when the opcode is type-dependent), the generated code does unwrap the arguments from the instruction several times, and generates a predicate too. We could unwrap the arguments at the top once and for all, and then generate predicates for each type the legalization affects.</li>
<li>[x] Remove the condition when the value of <code>predicate</code> is a plain <code>true</code>.</li>
<li>[x] Try to gather the predicate conditions together, instead of refining the predicate (e.g. <code>let predicate = value_type == I64; let predicate = predicate &amp;&amp; type_sets[42].contains(something);</code> etc).</li>
<li>[ ] Allow to bind several times in the <code>def!</code> macro.</li>
<li>[ ] Consider adding a <code>ToRustCode</code> and <code>ToRustComment</code> trait that structs can implement.</li>
</ul>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>