<html>
<head><meta charset="utf-8"><title>isle_opt.rs size · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html">isle_opt.rs size</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="456724196"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456724196" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kirp <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456724196">(Aug 05 2024 at 23:04)</a>:</h4>
<p>Was reading this re rustc stackoverflow and the culprit was the size of <a href="http://isle_opts.rs">isle_opts.rs</a> <a href="https://sunshowers.io/posts/rustc-segfault-illumos/">https://sunshowers.io/posts/rustc-segfault-illumos/</a> - coincidentally was also talking earlier about the size of the rust code being generated by islec resulting in slow compiles - wonder if there is any feasible solution to split or shrink the code?</p>
<div class="message_embed"><a class="message_embed_image" href="https://sunshowers.io/posts/rustc-segfault-illumos/" style="background-image: url(&quot;https://uploads.zulipusercontent.net/975796475157e910c814458abce9362a54820ae4/68747470733a2f2f73756e73686f776572732e696f2f696d616765732f66617669636f6e2e706e67&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://sunshowers.io/posts/rustc-segfault-illumos/" title="Debugging a rustc segfault on illumos :: sunshowers">Debugging a rustc segfault on illumos :: sunshowers</a></div><div class="message_embed_description">Using `mdb` and `pmap` to find the cause of a crash.</div></div></div>



<a name="456727932"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456727932" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456727932">(Aug 05 2024 at 23:38)</a>:</h4>
<p>Well, the ultimate culprit is the uncontrolled recursion in rustc's parser -- we are generating valid Rust, albeit one large function but the language does not specify limits on function size in the semantics so I believe the proper fix is where that post landed, i.e. fixing rustc</p>



<a name="456728063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456728063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456728063">(Aug 05 2024 at 23:39)</a>:</h4>
<p>even moreso given that rustc's parser <em>is</em> making efforts to not overflow the stack, but failed on illumos due to some missing plumbing; that shows the implementation intent</p>



<a name="456728339"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456728339" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456728339">(Aug 05 2024 at 23:41)</a>:</h4>
<p>The code is generated from our set of rewrite rules; fundamentally it all has to be there as long as we have those rules; it's always possible that there are constant-factor improvements in the code we generate, but it's pretty lean already (there are just a lot of cases). "Slow builds" is a little relative IMHO -- we're embodying a large collection of domain-specific logic. For comparison, how long does an LLVM backend take to build, etc... (the problem would be more urgent if we were seeing slowdowns <em>relative to another compiler of the same complexity</em> IMHO)</p>



<a name="456790149"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456790149" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456790149">(Aug 06 2024 at 07:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254389">Chris Fallin</span> <a href="#narrow/stream/217117-cranelift/topic/isle_opt.2Ers.20size/near/456728063">said</a>:</p>
<blockquote>
<p>even moreso given that rustc's parser <em>is</em> making efforts to not overflow the stack, but failed on illumos due to some missing plumbing; that shows the implementation intent</p>
</blockquote>
<p>It is actually missing a place where stacker is used to extend the stack. The reason it crashed on Illumos is not because it didn't extend the stack, but because stacker extended the stack with a small segment when not strictly needed. Rustc runs on a 4MiB(?) stack by default, which masked the missing stacker call, but then on Illumos the first stacker call that would consider enough stack remaining on other OSes would switch to a new stack segment which is much smaller. (128KiB?) If enough stacker calls existed, this would be fine, but as a stacker call somewhere in the parser was missed, it would run out of this 128KiB stack segment and crash.</p>



<a name="456790412"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456790412" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456790412">(Aug 06 2024 at 07:49)</a>:</h4>
<p>Is it possible for ISLE to subdivide large functions into multiple functions. LLVM is much slower at compiling a single huge function than many smaller ones anyway, so it should help with making Cranelift itself be built faster too.</p>



<a name="456887168"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/isle_opt.rs%20size/near/456887168" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/isle_opt.2Ers.20size.html#456887168">(Aug 06 2024 at 15:33)</a>:</h4>
<blockquote>
<p>Is it possible for ISLE to subdivide large functions into multiple functions</p>
</blockquote>
<p>WIth more analysis, yeah, that's theoretically possible; we'd need to analyze for captures to create the arguments. The trickier part is that we'd need to ensure the control flow remained identical: we generate tree-shaped matching code but with fallthroughs so we'd need to get the backtracking right</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>