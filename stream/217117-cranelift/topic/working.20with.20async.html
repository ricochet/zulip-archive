<html>
<head><meta charset="utf-8"><title>working with async · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html">working with async</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="361196733"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361196733" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JT <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361196733">(May 26 2023 at 01:20)</a>:</h4>
<p>Has anyone had a chance to explore calling async functions from cranelift? Also, are there plans for creating async functions from cranelift?</p>
<p>I've been poking around a bit, and was wondering just how much of Rust we might be able to call into. Async is definitely a big one that I wasn't sure if cranelift supported.</p>



<a name="361197735"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361197735" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361197735">(May 26 2023 at 01:27)</a>:</h4>
<p>The concept of "async functions" doesn't really exist at the Cranelift level. An async function in Rust, for example, is transformed by the Rust compiler into a function that looks kind of like a state machine and keeps its state in an anonymous type that implements the <code>Future</code> trait. Other languages may implement async differently. Cranelift has no knowledge of the Rust async semantics or stdlib, nor any other language's async, and so it wouldn't make sense to talk about "async functions" at the Cranelift level.</p>
<p>As a parallel example, while Rust supports async functions, the IR presented to LLVM when you compile the Rust program has no "async" functions either. Think of Cranelift as similar to LLVM: you need to translate whatever higher-level notions you have into standard functions that take primitive args (floats/ints/pointers) and return primitive results. Does that make sense?</p>



<a name="361197865"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361197865" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361197865">(May 26 2023 at 01:29)</a>:</h4>
<p>On the topic of calling into Rust specifically: there are a bunch of Rust-level notions, like aggregate types (structs) for example, that Cranelift doesn't support. You can look at <code>cg_clif</code> (the rustc backend that uses Cranelift) to see how it implements all of this one abstraction layer up from Cranelift. (cc <span class="user-mention" data-user-id="264278">@bjorn3</span> for more on this!)</p>



<a name="361197867"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361197867" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jamey Sharp <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361197867">(May 26 2023 at 01:29)</a>:</h4>
<p>I haven't tried it, but it boils down to calling <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll">poll</a> on whatever implementation of the <code>Future</code> trait your async function returns, where the actual type is auto-generated by the Rust compiler. So if you know how to call trait methods, and can figure out the size of the generated type so you can allocate enough space to store it, then you're set. Except that is so many levels of unstable Rust ABIs that I hate to imagine trying to generate correct Cranelift calls for it without hooking deep into the Rust compiler.</p>
<p>The usual trick for hiding away all those ABIs works here too though: construct a <code>Box&lt;dyn Future&gt;</code> in Rust code, then pass it to Cranelift-generated code through an <code>extern "C"</code> interface, and pass the box back into another Rust function when you want to call <code>poll</code>.</p>



<a name="361198017"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361198017" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jamey Sharp <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361198017">(May 26 2023 at 01:31)</a>:</h4>
<p>(Actually you probably want <code>Box&lt;Box&lt;dyn Future&gt;&gt;</code> so that you have a thin pointer to pass around instead of a fat pointer.)</p>



<a name="361216005"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361216005" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JT <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361216005">(May 26 2023 at 05:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254389">Chris Fallin</span> <a href="#narrow/stream/217117-cranelift/topic/working.20with.20async/near/361197735">said</a>:</p>
<blockquote>
<p>The concept of "async functions" doesn't really exist at the Cranelift level. An async function in Rust, for example, is transformed by the Rust compiler into a function that looks kind of like a state machine and keeps its state in an anonymous type that implements the <code>Future</code> trait. Other languages may implement async differently. Cranelift has no knowledge of the Rust async semantics or stdlib, nor any other language's async, and so it wouldn't make sense to talk about "async functions" at the Cranelift level.</p>
<p>As a parallel example, while Rust supports async functions, the IR presented to LLVM when you compile the Rust program has no "async" functions either. Think of Cranelift as similar to LLVM: you need to translate whatever higher-level notions you have into standard functions that take primitive args (floats/ints/pointers) and return primitive results. Does that make sense?</p>
</blockquote>
<p>yeah, this was also my assumption but I wanted to confirm with y'all to be sure. Thanks, that's helpful.</p>



<a name="361216121"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/working%20with%20async/near/361216121" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> JT <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/working.20with.20async.html#361216121">(May 26 2023 at 05:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="504918">Jamey Sharp</span> <a href="#narrow/stream/217117-cranelift/topic/working.20with.20async/near/361197867">said</a>:</p>
<blockquote>
<p>I haven't tried it, but it boils down to calling <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll">poll</a> on whatever implementation of the <code>Future</code> trait your async function returns, where the actual type is auto-generated by the Rust compiler. So if you know how to call trait methods, and can figure out the size of the generated type so you can allocate enough space to store it, then you're set. Except that is so many levels of unstable Rust ABIs that I hate to imagine trying to generate correct Cranelift calls for it without hooking deep into the Rust compiler.</p>
<p>The usual trick for hiding away all those ABIs works here too though: construct a <code>Box&lt;dyn Future&gt;</code> in Rust code, then pass it to Cranelift-generated code through an <code>extern "C"</code> interface, and pass the box back into another Rust function when you want to call <code>poll</code>.</p>
</blockquote>
<p>this makes me a'feard <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>  I think I'll stick to simpler paths.</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>