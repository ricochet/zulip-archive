<html>
<head><meta charset="utf-8"><title>papers · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html">papers</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="279670637"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/279670637" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#279670637">(Apr 21 2022 at 12:07)</a>:</h4>
<p>The abstract of <a href="https://arxiv.org/abs/2011.13127">https://arxiv.org/abs/2011.13127</a> seems interesting:</p>
<blockquote>
<p>Copy-and-Patch Compilation: A fast compilation algorithm for high-level languages and bytecode</p>
<p>[...]</p>
<p>The generated code runs an order of magnitude faster than interpretation and 14% faster than LLVM -O0. Our WebAssembly compiler generates code 4.9X-6.5X faster than Liftoff, the WebAssembly baseline compiler in Google Chrome. The generated code also outperforms Liftoff's by 39%-63% on the Coremark and PolyBenchC WebAssembly benchmarks.</p>
</blockquote>



<a name="280039592"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280039592" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280039592">(Apr 25 2022 at 08:41)</a>:</h4>
<p>i came here to share that too!  i think cranelift could be useful to generate a stencil library.  could be a nice improvement for baseline compilation in wasmtime</p>



<a name="280093385"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280093385" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280093385">(Apr 25 2022 at 16:22)</a>:</h4>
<p>It's a really interesting technique, thanks!</p>



<a name="280093517"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280093517" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Lloyd <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280093517">(Apr 25 2022 at 16:23)</a>:</h4>
<p>is the full text available anywhere?</p>



<a name="280093760"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280093760" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280093760">(Apr 25 2022 at 16:25)</a>:</h4>
<p>At the arxiv link above, I think! "PDF" in the right bar</p>



<a name="280093861"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280093861" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Lloyd <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280093861">(Apr 25 2022 at 16:26)</a>:</h4>
<p>oh, I missed it. thanks</p>



<a name="280119283"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280119283" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> lqd <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280119283">(Apr 25 2022 at 19:45)</a>:</h4>
<p>in the same area, there's the classic "multi-level quickening" <a href="https://arxiv.org/abs/2109.02958">https://arxiv.org/abs/2109.02958</a></p>



<a name="280168711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/280168711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#280168711">(Apr 26 2022 at 07:04)</a>:</h4>
<p>better link: <a href="http://fredrikbk.com/publications/copy-and-patch.pdf">http://fredrikbk.com/publications/copy-and-patch.pdf</a></p>



<a name="285232303"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/285232303" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sam Parker <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#285232303">(Jun 07 2022 at 10:51)</a>:</h4>
<p><span class="user-mention" data-user-id="452638">@Alexa VanHattum</span> <span class="user-mention" data-user-id="254389">@Chris Fallin</span> continuing this thread, but not quite a paper, there's been some interesting work verification work on the LLVM side of things for aarch64: <a href="https://blog.regehr.org/archives/2265">https://blog.regehr.org/archives/2265</a></p>



<a name="285271916"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/285271916" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#285271916">(Jun 07 2022 at 15:49)</a>:</h4>
<p>Super cool, thank you!</p>



<a name="298531796"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/298531796" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#298531796">(Sep 13 2022 at 08:00)</a>:</h4>
<p><a href="https://drops.dagstuhl.de/opus/volltexte/2022/15933/pdf/dagrep_v011_i010_p173_21481.pdf">https://drops.dagstuhl.de/opus/volltexte/2022/15933/pdf/dagrep_v011_i010_p173_21481.pdf</a></p>
<blockquote>
<p>Secure compilation is an emerging field that puts together advances in security, programming languages, compilers, verification, systems, and hardware architectures in order to devise more secure compilation chains that eliminate many of today’s security vulnerabilities and that allow sound reasoning about security properties in the source language. For a concrete example, all modern languages provide a notion of structured control flow and an invoked procedure is expected to return to the right place. However, today’s compilation chains (compilers, linkers, loaders, runtime systems, hardware) cannot efficiently enforce this abstraction against linked low-level code, which can call and return to arbitrary instructions or smash the stack, blatantly violating the high-level abstraction. Other problems arise because today’s languages fail to specify security policies, such as data confidentiality, and the compilation chains thus fail to enforce them, especially against powerful side-channel attacks. The emerging secure compilation community aims to address such problems by identifying precise security goals and attacker models, designing more secure languages, devising efficient enforcement and mitigation mechanisms, and developing effective verification techniques for secure compilation chains.<br>
This seminar strived to take a broad and inclusive view of secure compilation and to provide a forum for discussion on the topic. The goal was to identify interesting research directions and open challenges by bringing together people working on building secure compilation chains, on designing security enforcement and attack-mitigation mechanisms in both software and hardware, and on developing formal verification techniques for secure compilation.</p>
</blockquote>



<a name="299175339"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/299175339" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#299175339">(Sep 16 2022 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="452638">@Alexa VanHattum</span> <a href="https://stefanheule.com/s/projects/strata/">https://stefanheule.com/s/projects/strata/</a> seems relevant for your work on verifying ISLE lowering rules. It has formal semantics for a lot of x86_64 instructions that were semi-automatically discovered. In all cases where the discovered semantics didn't match hand-written semantics, the hand-written semantics were in fact incorrect.</p>



<a name="302327459"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302327459" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302327459">(Oct 04 2022 at 18:59)</a>:</h4>
<p>Not exactly a paper and possibly not all that practical, but <a href="https://www.mattkeeter.com/blog/2022-10-04-ssra/">https://www.mattkeeter.com/blog/2022-10-04-ssra/</a> shows a register allocator that is supposedly very fast, but does have some limitations.</p>



<a name="302328493"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302328493" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302328493">(Oct 04 2022 at 19:04)</a>:</h4>
<p>Interesting write-up for sure; have seen this in LuaJIT before (as they mention) and it's a very effective technique for trace compilers. I don't see any mention of control-flow in the post, and that's one of the confounders for any single-pass algorithm; curious if they have more thoughts on it</p>



<a name="302328650"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302328650" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302328650">(Oct 04 2022 at 19:05)</a>:</h4>
<p>It explicitly mentions that it doesn't work with control-flow. Of course you can always spill everything on any kind of control-flow, but that is probably very flow at runtime.</p>



<a name="302351809"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302351809" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302351809">(Oct 04 2022 at 21:40)</a>:</h4>
<p>It also produces sub-optimal results if you have fixed-reg constraints since you only have one pass through the code.</p>



<a name="302352407"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302352407" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302352407">(Oct 04 2022 at 21:45)</a>:</h4>
<p>But I guess you could remedy that by adding a pre-processing pass that gathers register hints for each vreg.</p>



<a name="302352517"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/302352517" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#302352517">(Oct 04 2022 at 21:46)</a>:</h4>
<p>It's somewhat like what I had in mind for <a href="https://github.com/bytecodealliance/regalloc2/issues/81">https://github.com/bytecodealliance/regalloc2/issues/81</a>.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/regalloc2/issues/81" style="background-image: url(https\:\/\/uploads\.zulipusercontent\.net\/d6c5b6387f3e34ffba73cb0fb0216ec64c6a261d\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393265396361623230623634636562326431653431656332613631313533613336343966646363386564376131323965303239303163363532633931366630302f62797465636f6465616c6c69616e63652f726567616c6c6f63322f6973737565732f3831)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/regalloc2/issues/81" title="Alternative regalloc backends · Issue #81 · bytecodealliance/regalloc2">Alternative regalloc backends · Issue #81 · bytecodealliance/regalloc2</a></div><div class="message_embed_description">The regalloc2 crate provides a good API (VReg, PReg, Operand, Function, etc) for interacting with a register allocator. It would be nice if other register allocator backends could be made available...</div></div></div>



<a name="369258946"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/369258946" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#369258946">(Jun 24 2023 at 20:20)</a>:</h4>
<p><a href="https://www.cs.cmu.edu/~dkoes/research/CGO08-NOLTIS.pdf">https://www.cs.cmu.edu/~dkoes/research/CGO08-NOLTIS.pdf</a> looks interesting. It is a near-optimal instruction selector running in linear time.</p>



<a name="369258992"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/369258992" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#369258992">(Jun 24 2023 at 20:21)</a>:</h4>
<p>(linked from <a href="https://lobste.rs/s/p93jau/e_graph_extraction_problem_is_np_complete">https://lobste.rs/s/p93jau/e_graph_extraction_problem_is_np_complete</a>)</p>



<a name="444913683"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/444913683" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Afonso Bordado <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#444913683">(Jun 15 2024 at 21:48)</a>:</h4>
<p>Hydra: Generalizing Peephole Optimizations with Program Synthesis</p>
<p><a href="https://users.cs.utah.edu/~regehr/generalization-oopsla24.pdf">https://users.cs.utah.edu/~regehr/generalization-oopsla24.pdf</a></p>
<p>Pretty cool! Bolting this onto souper/souper-harvest would be neat.</p>



<a name="445458094"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/papers/near/445458094" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/papers.html#445458094">(Jun 18 2024 at 20:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="410955">Afonso Bordado</span> <a href="#narrow/stream/217117-cranelift/topic/papers/near/444913683">said</a>:</p>
<blockquote>
<p>Hydra: Generalizing Peephole Optimizations with Program Synthesis</p>
<p><a href="https://users.cs.utah.edu/~regehr/generalization-oopsla24.pdf">https://users.cs.utah.edu/~regehr/generalization-oopsla24.pdf</a></p>
</blockquote>
<p>See also <a href="https://github.com/bytecodealliance/wasmtime/issues/5783">https://github.com/bytecodealliance/wasmtime/issues/5783</a> -- would be great to land those already-generalized-for-us rules as a first step!</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/issues/5783" style="background-image: url(&quot;https://uploads.zulipusercontent.net/ccdaab11be09dacf808a4f07e71ed29a0e5df3d2/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313638653365643933366433363334396161373064643739313739626662646365636265366335633465353266393961646530646438666338316336343733642f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f35373833&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/issues/5783" title="Souper-synthesized optimizations that we should investigate generalizing and adding to the mid-end · Issue #5783 · bytecodealliance/wasmtime">Souper-synthesized optimizations that we should investigate generalizing and adding to the mid-end · Issue #5783 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">Here are some synthesized optimizations for CLIF harvested from spidermonkey.wasm with explicit bounds checks enabled. I won't have time to investigate, generalize, or implement them before I go on...</div></div></div>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>