<html>
<head><meta charset="utf-8"><title>rfcs / issue #13 Pre-RFC: Instruction Selector DSL for Cr... · rfc-notifications · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/index.html">rfc-notifications</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html">rfcs / issue #13 Pre-RFC: Instruction Selector DSL for Cr...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="248536348"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/248536348" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#248536348">(Aug 05 2021 at 21:04)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-893798479">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>A note to frame things a bit: this pre-RFC contains what I think are a reasonable set of requirements to consider, but the requirements themselves are very much up for discussion, and I'm interested to hear what others think about their relative importance, or if this is missing any important requirements.</p>
<p>The discussion questions in the last part are also what I believe to be relevant design axes to talk about, but there may be others as well; please discuss!</p>
</blockquote>



<a name="249596964"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249596964" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249596964">(Aug 16 2021 at 14:38)</a>:</h4>
<p>sparker-arm <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-899564589">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>My gut feeling is that using an existing DSL (peepmatic), and having a layer that tries the generated patterns first, falling back to the existing matchers, would provide the lowest barrier to entry for users as well as keeping the build system simple. Any finger in the air guesses how compilation time would be effected against the simple match strategy used currently?  I also would wonder whether a DSL for _just__ isel would be a big enough carrot for getting people to port over... Considering the amount of C++ in LLVM used for isel, even though tablegen has been there for as long as I know, should not be underestimated :) So, I feel at least half of tablegens value is the ease in which it enables the encodings to be described and it would be great if we had something like that too.</p>
</blockquote>



<a name="249596986"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249596986" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249596986">(Aug 16 2021 at 14:38)</a>:</h4>
<p>sparker-arm edited a <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-899564589">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>My gut feeling is that using an existing DSL (peepmatic), and having a layer that tries the generated patterns first, falling back to the existing matchers, would provide the lowest barrier to entry for users as well as keeping the build system simple. Any finger in the air guesses how compilation time would be effected against the simple match strategy used currently?  I also would wonder whether a DSL for _just isel would be a big enough carrot for getting people to port over... Considering the amount of C++ in LLVM used for isel, even though tablegen has been there for as long as I know, should not be underestimated :) So, I feel at least half of tablegens value is the ease in which it enables the encodings to be described and it would be great if we had something like that too.</p>
</blockquote>



<a name="249597026"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249597026" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249597026">(Aug 16 2021 at 14:38)</a>:</h4>
<p>sparker-arm edited a <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-899564589">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>My gut feeling is that using an existing DSL (peepmatic), and having a layer that tries the generated patterns first, falling back to the existing matchers, would provide the lowest barrier to entry for users as well as keeping the build system simple. Any finger in the air guesses how compilation time would be effected against the simple match strategy used currently?  I also would wonder whether a DSL for _just_ isel would be a big enough carrot for getting people to port over... Considering the amount of C++ in LLVM used for isel, even though tablegen has been there for as long as I know, should not be underestimated :) So, I feel at least half of tablegens value is the ease in which it enables the encodings to be described and it would be great if we had something like that too.</p>
</blockquote>



<a name="249777243"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249777243" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249777243">(Aug 17 2021 at 20:52)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-900622162">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<blockquote>
<p>having a layer that tries the generated patterns first, falling back to the existing matchers, would provide the lowest barrier to entry for users as well as keeping the build system simple.</p>
</blockquote>
<p>This is the "horizontal" integration in the pre-RFC, and I am inclined to agree, unless the vertical integration happens to fall out of the DSL's compilation/execution model "for free".</p>
<blockquote>
<p>Any finger in the air guesses how compilation time would be effected against the simple match strategy used currently?</p>
</blockquote>
<p>I wouldn't expect any significant slow downs, assuming that the DSL also compiles down to Rust code similar to what you would otherwise have written by hand (e.g. a <code>match</code> that switches on opcode). Maaaayyyybe a little bit of overhead related to icache because there are now two code paths rather than one, but I wouldn't expect too much.</p>
</blockquote>



<a name="249778407"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249778407" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249778407">(Aug 17 2021 at 21:02)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-900628088">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>@sparker-arm the goal is certainly to generate code equivalent to what we have today, so ideally we have zero slowdown in the Cranelift compile time, and in the future, possibly improvements that are enabled by more centralized control of the backend code's idioms (i.e., right now if we come up with a new way of matching, we have to modify all of the open-coded use sites; but if we generate this from patterns then we can transition instantly). The latter is especially interesting to me as it will let us eventually move to the native SSA-based API of <a href="http://bytecodealliance/regalloc2">regalloc2</a> which should give some speedups.</p>
<p>I've got a reasonable design down on paper now and am working on refining the writeup before posting the RFC -- hope to have it up in the next few days :-)</p>
</blockquote>



<a name="249944615"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2313%20Pre-RFC%3A%20Instruction%20Selector%20DSL%20for%20Cr.../near/249944615" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2313.20Pre-RFC.3A.20Instruction.20Selector.20DSL.20for.20Cr.2E.2E.2E.html#249944615">(Aug 19 2021 at 05:51)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/13#issuecomment-901629963">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/13">issue #13</a>:</p>
<blockquote>
<p>I will go ahead and close this pre-RFC, as I think it has served its purpose well in starting discussions and getting early feedback on ideas that have gone into a now more fully-formed RFC, #15. Thanks all for the input and please do give any thoughts you might have on the new RFC!</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>