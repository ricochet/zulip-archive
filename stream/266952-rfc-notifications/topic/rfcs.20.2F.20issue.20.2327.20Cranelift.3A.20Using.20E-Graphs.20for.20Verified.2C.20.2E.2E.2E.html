<html>
<head><meta charset="utf-8"><title>rfcs / issue #27 Cranelift: Using E-Graphs for Verified, ... · rfc-notifications · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/index.html">rfc-notifications</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html">rfcs / issue #27 Cranelift: Using E-Graphs for Verified, ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="287971640"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/287971640" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#287971640">(Jun 30 2022 at 04:01)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1170724763">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>cc @fitzgen @jameysharp @elliottt @abrown @avanhatt @mlfbrown</p>
</blockquote>



<a name="287971673"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/287971673" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#287971673">(Jun 30 2022 at 04:01)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1170725051">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Current prototype is <a href="https://github.com/bytecodealliance/wasmtime/issues/4249">bytecodealliance/wasmtime#4249</a>; it implements the e-graph roundtripping but not (yet) the rewriting described in this RFC.</p>
</blockquote>



<a name="288209338"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288209338" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288209338">(Jul 01 2022 at 18:35)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172615995">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>For example, the <a href="https://github.com/bytecodealliance/wasmtime/pull/1647">https://github.com/bytecodealliance/wasmtime/pull/1647</a> tooling included tools to "harvest" potential patterns to rewrite from real programs, and then use the superoptimization engine <a href="https://github.com/google/souper">Souper</a> to find rewrite rules offline. We could revisit such tooling and use it to build a significantly more effective body of rules semi-automatically.</p>
</blockquote>
<p>FWIW, the harvester still exists and is independent of Peepmatic, it just extracts Souper IR from CLIF.</p>
<p>The only tool we are missing would be a Souper IR to ISLE(CLIF) translator for Souper's synthesized optimizations back to ISLE/this new framework.</p>
</blockquote>



<a name="288212288"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288212288" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288212288">(Jul 01 2022 at 19:05)</a>:</h4>
<p>philzook58 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172639252">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>This is incredibly cool work and I am very interested in following it! I also have appreciated your very thorough blog posts in the past. I'm seeing if it useful for people to have a place for egraph discussion, so I made a nascent but fairly quiet so far zulip. <a href="https://egraphs.zulipchat.com/join/q7bjayghbdw66xsnzgwc2hjb/">https://egraphs.zulipchat.com/join/q7bjayghbdw66xsnzgwc2hjb/</a></p>
</blockquote>



<a name="288212869"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288212869" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288212869">(Jul 01 2022 at 19:10)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172645038">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Super happy with how simple and obvious-after-the-fact your proposed e-graph destruction algorithm is (cycle breaking + scoped elaboration).</p>
</blockquote>



<a name="288213095"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288213095" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288213095">(Jul 01 2022 at 19:13)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172646781">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>We will thus need a system of "optimization fuel" that limits rewrite steps overall and possibly per-rule or per-eclass. It is not yet certain what policies will work best; this is a question that we will need to experiment with. We simply wish to acknowledge now that it will be a problem that we will need to solve.</p>
</blockquote>
<p>Note that <code>egg</code> already has a few knobs we can experiment with before trying to create our own custom thing here. In addition to perform-at-most-N-rewrite-iterations, you can also give it optional limits on the number of e-classes and e-nodes, and halt equality saturation once those are reached. I think the latter will be important for limiting the e-graph's memory overhead.</p>
</blockquote>



<a name="288213633"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288213633" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288213633">(Jul 01 2022 at 19:18)</a>:</h4>
<p>mwillsey <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172650042">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hey all, egg author here. Very, very exciting stuff ahead! I will dive into the RFC soon and try to grok the details. I'm happy to help out as well!</p>
</blockquote>



<a name="288215216"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288215216" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288215216">(Jul 01 2022 at 19:32)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172658052">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>How will e-graph-based optimization affect compile time?</p>
</blockquote>
<p>Have you run <code>spidermonke.wasm</code> through sightglass with and without your prototype that just does round tripping through an e-graph? That could give us a tiny taste of what compile time overheads might look like (also I imagine you'd disable the old GVN when it is subsumed by the e-graph round trip). I'd also expect that, in theory, execution time of the generated code would be unchanged, but that would also be a good thing to empirically check.</p>
</blockquote>



<a name="288215233"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288215233" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288215233">(Jul 01 2022 at 19:32)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172658052">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>How will e-graph-based optimization affect compile time?</p>
</blockquote>
<p>Have you run <code>spidermonkye.wasm</code> through sightglass with and without your prototype that just does round tripping through an e-graph? That could give us a tiny taste of what compile time overheads might look like (also I imagine you'd disable the old GVN when it is subsumed by the e-graph round trip). I'd also expect that, in theory, execution time of the generated code would be unchanged, but that would also be a good thing to empirically check.</p>
</blockquote>



<a name="288215247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288215247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288215247">(Jul 01 2022 at 19:33)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172658052">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>How will e-graph-based optimization affect compile time?</p>
</blockquote>
<p>Have you run <code>spidermonkey.wasm</code> through sightglass with and without your prototype that just does round tripping through an e-graph? That could give us a tiny taste of what compile time overheads might look like (also I imagine you'd disable the old GVN when it is subsumed by the e-graph round trip). I'd also expect that, in theory, execution time of the generated code would be unchanged, but that would also be a good thing to empirically check.</p>
</blockquote>



<a name="288216088"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288216088" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288216088">(Jul 01 2022 at 19:41)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172663238">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>How will e-graph-based optimization affect compile time?</p>
</blockquote>
<p>Have you run <code>spidermonkey.wasm</code> through sightglass with and without your prototype that just does round tripping through an e-graph? That could give us a tiny taste of what compile time overheads might look like (also I imagine you'd disable the old GVN when it is subsumed by the e-graph round trip). I'd also expect that, in theory, execution time of the generated code would be unchanged, but that would also be a good thing to empirically check.</p>
</blockquote>
<p>Nope, not yet, but that's next on my plate! Before doing measurements I want to do some basic optimizations to the scheme that I know how to do -- mainly, reuse existing CLIF insts rather than repopulating -- which should dramatically lower overhead. If with that we are "at parity" or "not much worse" than LICM (assuming LICM tweaks here) + GVN today, then I'd be very happy, but I guess how much overhead to accept there (in exchange for having an optimization framework) is another good discussion point.</p>
</blockquote>



<a name="288221276"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288221276" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288221276">(Jul 01 2022 at 20:35)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172695651">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>I feel like this RFC is a little different from many of our other RFCs. Usually<br>
we know we can implement the thing, and the RFC process is more about API design<br>
and determining whether to implement the thing as described or in some<br>
alternative way. Merging most RFCs is essentially committing to "yes we will do<br>
this". This RFC, on the other hand, has relatively large open questions around<br>
compilation overhead and whether we will actually solve phase ordering the way<br>
we believe we should in theory. I think merging this RFC doesn't necessarily<br>
mean "yes we will do this" because we still aren't 100% sure we <em>can</em> do<br>
this. We <em>think</em> we can, but we need to actually build more to prove it out. So<br>
I think merging this RFC should mean something more like "we will start landing<br>
(<code>cfg</code>'d off) code in <code>main</code> and when we (hopefully) reach X, Y, and Z<br>
acceptance criteria, we will stop hiding the code behind <code>cfg</code>s and remove the<br>
old, non-egraph code paths."</p>
<p>And I would love this RFC to define and document our ahead-of-time consensus on<br>
what exactly those acceptance criteria are so that we don't have moving goal<br>
posts later on down the line when we are deciding whether to actually, fully,<br>
100% commit to the e-graphs mid-end framework or not.</p>
<hr>
<p>Just to spark discussion, I'll throw some stuff out there:</p>
<ul>
<li>
<p>What kind of compile time overhead is acceptable for when we first turn this<br>
  on (with the expectation that we will have potential compile time wins down<br>
  the line as documented in the "Overall Cranelift Structure and Migration Path"<br>
  section)? 5% overhead? 10%?</p>
</li>
<li>
<p>What kind of memory overhead during compilation is acceptable? Unlike compile<br>
  time, I don't think we have any obvious possibilities for improving this in<br>
  the future other than limiting e-nodes/e-classes. (Please correct me if I'm<br>
  wrong!) 50% additional max RSS? 20%? 10%?</p>
</li>
<li>
<p>Finally, what should the acceptance criteria be for generated code quality?<br>
  How about: none of our Real World benchmarks in sightglass (SpiderMonkey,<br>
  markdown, bz2, meshoptimizer, and maybe intgemm-simd but I'm less familiar<br>
  with that one) get statistically significantly worse execution times and at<br>
  least one of them gets statistically significantly better execution<br>
  time. Additionally, we verify by hand that the alias analysis and GVN phase<br>
  ordering example you mention in the RFC actually gets resolved in practice by<br>
  our e-graphs framework.</p>
</li>
</ul>
<p>What do other Cranelift stakeholders think our acceptance criteria should be?</p>
<p>Does compile time/space and code quality cover everything we need to keep an eye<br>
on as far as acceptance quality goes or am I missing something else?<br>
</p>
</blockquote>



<a name="288222315"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288222315" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288222315">(Jul 01 2022 at 20:46)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172701559">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>These are great questions, thanks @fitzgen -- I should've included more details around what I think the actual decisions should be (now and later)!</p>
<p>I actually am somewhat optimistic that we're close (a-few-weeks-to-a-month-ish?) to a point where we can evaluate the prototype plus basic rewriting rules that have functional parity to today's GVN, LICM, and simple_preopt, and make a decision with this RFC (merge or not) that means "we will actually do this". And to be clear I do want to get that far in the prototype before I personally advocate for merging; I want to ensure there are no unknown-unknowns in the rewrite step. I'd personally favor an acceptance criteria that is something like:</p>
<ol>
<li>Replicates GVN, LICM, and simple_preopt (and clear path for alias analysis);</li>
<li>Is clearly an improvement in ease of contributing further optimizations;</li>
<li>Meets some compile-time threshold.</li>
</ol>
<p>Open discussion how we balance items 2 and 3 above, but I <em>hope</em> we will have minimal overhead when we have only today's functionality. That would mean that additional compile-time cost is only a factor when actually adding interesting additional rules/optimizations.</p>
<p>On the flipside, I don't know if it necessarily makes sense to have a "something must speed up on initial merge" criterion, though I'm open to that if a bunch of other folks disagree! The reason is that I think once we have (i) a framework and (ii) a replica of today's rewrites, the future upside is clear enough that the work to come up with those additional optimizations can happen as a second step. But, I can see how we might want to require such a speedup <em>if</em> the compile-time overhead is also non-negligible.</p>
<p>Anyway all this is open to a bunch of discussion and, on that note, I'll put an item on the agenda for our next biweekly :-)</p>
</blockquote>



<a name="288224702"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288224702" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288224702">(Jul 01 2022 at 21:13)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172701559">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>These are great questions, thanks @fitzgen -- I should've included more details around what I think the actual decisions should be (now and later)!</p>
<p>I actually am somewhat optimistic that we're close (a-few-weeks-to-a-month-ish?) to a point where we can evaluate the prototype plus basic rewriting rules that have functional parity to today's GVN, LICM, and simple_preopt, and make a decision with this RFC (merge or not) that means "we will actually do this". And to be clear I do want to get that far in the prototype before I personally advocate for merging; I want to ensure there are no unknown-unknowns in the rewrite step. I'd personally favor acceptance criteria that is something like:</p>
<ol>
<li>Replicates GVN, LICM, and simple_preopt (and clear path for alias analysis);</li>
<li>Is clearly an improvement in ease of contributing further optimizations;</li>
<li>Meets some compile-time threshold.</li>
</ol>
<p>Open discussion how we balance items 2 and 3 above, but I <em>hope</em> we will have minimal overhead when we have only today's functionality. That would mean that additional compile-time cost is only a factor when actually adding interesting additional rules/optimizations.</p>
<p>On the flipside, I don't know if it necessarily makes sense to have a "something must speed up on initial merge" criterion, though I'm open to that if a bunch of other folks disagree! The reason is that I think once we have (i) a framework and (ii) a replica of today's rewrites, the future upside is clear enough that the work to come up with those additional optimizations can happen as a second step. But, I can see how we might want to require such a speedup <em>if</em> the compile-time overhead is also non-negligible.</p>
<p>Anyway all this is open to a bunch of discussion and, on that note, I'll put an item on the agenda for our next biweekly :-)</p>
</blockquote>



<a name="288224711"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288224711" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288224711">(Jul 01 2022 at 21:13)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1172701559">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>These are great questions, thanks @fitzgen -- I should've included more details around what I think the actual decisions should be (now and later)!</p>
<p>I actually am somewhat optimistic that we're close (a-few-weeks-to-a-month-ish?) to a point where we can evaluate the prototype plus basic rewriting rules that have functional parity to today's GVN, LICM, and simple_preopt, and make a decision with this RFC (merge or not) that means "we will actually do this". And to be clear I do want to get that far in the prototype before I personally advocate for merging; I want to ensure there are no unknown-unknowns in the rewrite step. I'd personally favor acceptance criteria that are something like:</p>
<ol>
<li>Replicates GVN, LICM, and simple_preopt (and clear path for alias analysis);</li>
<li>Is clearly an improvement in ease of contributing further optimizations;</li>
<li>Meets some compile-time threshold.</li>
</ol>
<p>Open discussion how we balance items 2 and 3 above, but I <em>hope</em> we will have minimal overhead when we have only today's functionality. That would mean that additional compile-time cost is only a factor when actually adding interesting additional rules/optimizations.</p>
<p>On the flipside, I don't know if it necessarily makes sense to have a "something must speed up on initial merge" criterion, though I'm open to that if a bunch of other folks disagree! The reason is that I think once we have (i) a framework and (ii) a replica of today's rewrites, the future upside is clear enough that the work to come up with those additional optimizations can happen as a second step. But, I can see how we might want to require such a speedup <em>if</em> the compile-time overhead is also non-negligible.</p>
<p>Anyway all this is open to a bunch of discussion and, on that note, I'll put an item on the agenda for our next biweekly :-)</p>
</blockquote>



<a name="288726119"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288726119" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288726119">(Jul 06 2022 at 20:28)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176689988">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>So I did some quick-and-dirty compile-time measurements. On SpiderMonkey.wasm, the overhead of roundtripping through the egraph adds about 23% to compile time (when opts are enabled). All current handwritten opts account for about 10% of compile time.</p>
<p>That's not terrible (not a doubling, for example) but it's not great either, so I dug into which parts were slow. It turns out that the extraction and elaboration take very little time (less than 10% of the egraph addition); most of the time is in the initial egraph build.</p>
<p>I suspect that we'll need to do some careful data-structure engineering to get things within acceptable overheads, but fortunately it looks like there's some relatively low-hanging fruit. Right now in <code>egg</code> the <code>EClass</code> struct keeps two <code>Vec</code>s, one for nodes and one for parents; the <code>Id</code>-to-<code>EClass</code> map is a <code>HashMap</code> while I would expect the <code>Id</code> space to be somewhat dense (maybe this is to clear out eclasses that have been merged?); and the <code>Node</code> interface forces us to keep args internally in separate lists (I use <code>SmallVec</code> currently for this). All of this could be refactored to use central <code>Vec</code>s in a pseudo-arena way (like Cranelift does for CLIF args/results currently), at the cost of passing around the "backing <code>Vec</code>".</p>
<p>I'll work on that for a bit, then return to hacking on the ISLE integration; once I prove out both of these, I'm happy to make a bunch more measurements!</p>
</blockquote>



<a name="288730414"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288730414" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288730414">(Jul 06 2022 at 21:03)</a>:</h4>
<p>mwillsey <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176744241">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>@cfallin Awesome! At first glance, 23% isn't so bad, and I think there's you're right: a lot that could be done to get that down. Some quick points:</p>
<ul>
<li>While the <code>Id</code> space is initially dense, you actually hope that it ends up sparse because many e-classes are getting merged.</li>
<li>I think you are right, we could get some perf back by using more arenas in <code>EClass</code>.</li>
</ul>
<p>Also, the way the e-graph is being used in the prototype is basically a worst-case scenario for performance; for every <code>Func</code>, you build an e-graph, do e-graph stuff, extract and throw away. One big way we've improved performance in other egg applications is by batching many optimization queries at once. That would obviously require re-architecting the way egg and clif interact, which is probably something to do down the road. </p>
<p>Overall, I think this means that there are some serious "high-level" ways to improve performance as well as the lower-level ways you mentioned.<br>
</p>
</blockquote>



<a name="288742100"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288742100" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288742100">(Jul 06 2022 at 23:08)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176842019">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Thanks @mwillsey! By the way I'm planning to continue hacking on my fork of <code>egg</code> but I plan to upstream everything in due time, once plans are stable...</p>
<p>Re: this point:</p>
<blockquote>
<p>Also, the way the e-graph is being used in the prototype is basically a worst-case scenario for performance; for every Func, you build an e-graph, do e-graph stuff, extract and throw away. One big way we've improved performance in other egg applications is by batching many optimization queries at once. That would obviously require re-architecting the way egg and clif interact, which is probably something to do down the road.</p>
</blockquote>
<p>I want to dig a bit deeper: it seems you're saying that one way of tolerating overheads is to amortize the construction and extraction over more use of the egraph. I guess that's true in a "fraction of time spent in construction+extraction" sense, but I'm thinking in an absolute sense here: the time spent building the egraph and extracting from it, with no work between the two, is the bare minimum in additional overhead, no? At least as long as we have a separate egraph per function, and given that the overall problem we are solving is "compile this CLIF to machine code"? Or it's possible I'm missing some other way of batching or amortization that you mean to suggest...</p>
</blockquote>



<a name="288742411"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288742411" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288742411">(Jul 06 2022 at 23:12)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176844731">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Oh also a quick calibration point re:</p>
<blockquote>
<p>At first glance, 23% isn't so bad</p>
</blockquote>
<p>In Cranelift context this would be a huge deal actually: the whole regalloc rewrite (0.5 engineer-years) bought us about 20% compile-time improvement, and I fight to not give up 0.5% regularly. This is an open question above but I'll venture a ballpark number on this now just to calibrate (or at least give my own opinion): <em>maybe</em> 5% would be OK, but 20% would require a large increase in generated-code quality to justify, I think.</p>
</blockquote>



<a name="288744423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288744423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288744423">(Jul 06 2022 at 23:40)</a>:</h4>
<p>mwillsey <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176859809">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>I'm planning to continue hacking on my fork of egg</p>
</blockquote>
<p>Makes perfect sense. I'm happy to help hack on the fork if that's useful.</p>
<blockquote>
<p>as long as we have a separate egraph per function</p>
</blockquote>
<p>As long the e-graph optimization workflow is per-function, you can't really amortize. The batching I'm talking about is across functions: there's nothing stopping you from adding 1000 functions to the same e-graph (hopefully there's some sharing in there!) and optimizing them simultaneously. I suspect that even just adding 1000 functions to one e-graph is faster than adding 1000 functions to 1000 e-graphs because there is likely some sharing, but I could be wrong here.</p>
<p>Obviously one e-graph per function is cleaner for how the optimization workflow is right now. It just comes with the unfortunate overhead of basically copying your whole program twice: once into the e-graph and once out. Even outside of batching, another way of improving performance would be to eliminate one or both of these copies by increasing the part of the pipeline where you use e-graphs, ideally to some other "translation" boundary where you'd have to lower to another IR anyway. This is clearly a big task, though.<br>
</p>
</blockquote>



<a name="288745064"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288745064" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288745064">(Jul 06 2022 at 23:49)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1176864189">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>That's a really interesting idea; we can certainly play with it at some point!</p>
<p>We currently have a hard boundary between each function compilation, in order to allow for parallel compilation, but we'll need to break that boundary (optionally) eventually for inlining as well. And, actually, now that these two ideas are next to each other: putting the inlining and inlined function in the same egraph, linking up the dataflow, and then elaborating out of that is a <em>really nice</em> clean way of doing inlining. So, you've spawned some thoughts here, thanks!</p>
<p>One potentially complicating factor toward deduplicating efficiency between function bodies is that the "roots" (terminal nodes) will differ: both <code>f</code> and <code>g</code> may contain <code>complex_expr(x, y, z)</code> but where <code>x</code>, <code>y</code>, and <code>z</code> are <em>different</em> block params, or side-effecting ops (calls, loads), or whatever, in the two functions. I wonder if there is some sort of canonicalization that could help (in the extreme case this feels like a graph isomorphism problem though). In the egraph literature I mostly see expressions in terms of variable terminals <code>x</code>, <code>y</code>, etc and so this doesn't seem to be as big a deal. Any thoughts?</p>
</blockquote>



<a name="288903420"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288903420" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288903420">(Jul 08 2022 at 06:36)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1178610579">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>A brief update: I hacked up a <a href="https://github.com/cfallin/wasmtime/commit/80b6e6579e4859cec25397ac5546055ac1a6302c">custom egraph implementation</a> designed to be more memory-efficient and allocation-light, and got the overhead down to 9%.</p>
<p>The key differences are in how it avoids ever cloning <code>Node</code>s, using <code>indexmap</code> to allow both node-to-ID dedup and ID-to-node access and using these IDs in eclasses' list of nodes (the use of IDs to name nodes is itself different from <code>egg</code> too); and using Cranelift's <code>EntityList</code> to store lists of node IDs and eclass IDs in pooled storage; and using <code>bumpalo</code> (an arena allocator) to allocate the argument lists of eclass IDs. All of this is to implement the principles (i) O(1) memory allocations, i.e. we should grow single large containers rather than have nested containers per node or eclass (entity-component-system style) and (ii) avoid copies and store nodes only once. There's a little more we could do in theory with a custom hashmap that doesn't require <code>Hash</code>+<code>Eq</code> (namely, allows us to provide context for those; that would allow us to provide the backing pool separately and not store a fat-pointer slice for args and types in every <code>Node</code>, but only a <code>u32</code> index).</p>
<p>I haven't built the merging or rule-application bits yet but the roundtripping (without any rule applications) actually never merges eclasses so this is enough to evaluate the overhead of this part of the pipeline.</p>
<p>Given this, and given that GVN+LICM add around 10% to compile time, I'm actually cautiously optimistic that we can slip into the hole left by removing these stages and be almost neutral when no rewrite rules are applied. That's the ideal case in my mind. Or at least have small enough overhead that this roundtrip is always on when opts are on. Later we can remove half the roundtrip by generating egraph nodes straight from the frontend/builder API, as noted in the last section of the RFC (and as you note as well @mwillsey) for further savings, but for now anchoring both ends of the transform in CLIF (which can be printed, manipulated, used for testing, etc) has substantial pragmatic benefits I think.</p>
<p>(I'm not sure if the path forward is to actually use <code>cranelift-egraph</code> or <code>egg</code> with a bunch of hacks; as a general principle I don't like to go all NIH and hack up my own versions of things; but the data structures and tradeoffs are different enough that this may be the right way, I'm not sure. Right now I just want to pathfind wrt "is this performance profile possible".)</p>
<p>After dropping this tidbit I'm now promptly going to disappear for a week of PTO (...sorry!) but wanted to get that data point out first. More later!</p>
</blockquote>



<a name="288910964"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/288910964" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#288910964">(Jul 08 2022 at 08:17)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1178695501">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<p>There's a little more we could do in theory with a custom hashmap that doesn't require Hash+Eq (namely, allows us to provide context for those; that would allow us to provide the backing pool separately and not store a fat-pointer slice for args and types in every Node, but only a u32 index).</p>
</blockquote>
<p>hashbrown's <code>RawTable</code> might help with that.</p>
</blockquote>



<a name="289919682"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/289919682" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#289919682">(Jul 18 2022 at 03:47)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1186733243">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>There's a little more we could do in theory with a custom hashmap that doesn't require Hash+Eq (namely, allows us to provide context for those; that would allow us to provide the backing pool separately and not store a fat-pointer slice for args and types in every Node, but only a u32 index).</p>
</blockquote>
<p>hashbrown's <code>RawTable</code> might help with that.</p>
</blockquote>
<p>Indeed! I pushed a new implementation that does just that over <a href="https://github.com/cfallin/wasmtime/commit/ff48dcd72e8955cf35e80aabd25c11b22b7ba82d">here</a>. (That could probably use a lot of cleanup, and is a bit lifetime-heavy, but proves out what I wanted to!) Thanks for the pointer to that.</p>
</blockquote>



<a name="291627805"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291627805" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291627805">(Aug 01 2022 at 20:17)</a>:</h4>
<p>RDambrosio016 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201668850">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>This RFC is very interesting to me, i plan to use e-graphs too for a large part of the optimizer for a math-heavy language im writing. I considered using ISLE as well for writing patterns, i think it would work pretty well. However ran into a couple of open questions i could not resolve:</p>
<ul>
<li>Egg by default uses exponential backoff for rules to avoid dominating rewrite time with rules like associativity, but if we just use a single gigantic pattern matching trie for the rules, how would we disable rules? This is probably doable by keeping some arrays for counting rule "hits", and checking those arrays before matching/falling through, but the matching and memory overhead for this needs to be explored. Using indirect jumps through a lookup table could probably also work (indirect-threaded interpreter style kinda). Would love to hear if @mwillsey has any ideas for this.</li>
<li>Is ISLE capable of expressing rules common to multiple types easily? for example, <code>x * 1 =&gt; x</code> can be applied to floats, ints, and uints of any size. I presume ISLE has a way to handle this, but i haven't explored it much.</li>
<li>Is it potentially possible to store e-class data separate to the actual language? I.e the <code>Language</code> enum would be 64/128-bit sized and only contain data required for matching, for example, <code>Add([Id; 2])</code>, To potentially match rules much faster by exploiting vectorized pattern matching.</li>
</ul>
<p>But overall this approach seems promising, and it would be awesome to share rulesets/ideas with cranelift.</p>
</blockquote>



<a name="291628044"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291628044" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291628044">(Aug 01 2022 at 20:19)</a>:</h4>
<p>RDambrosio016 edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201668850">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>This RFC is very interesting to me, i plan to use e-graphs too for a large part of the optimizer for a math-heavy language im writing. I considered using ISLE as well for writing patterns, i think it would work pretty well. I however ran into a couple of open questions i could not resolve:</p>
<ul>
<li>Egg by default uses exponential backoff for rules to avoid dominating rewrite time with rules like associativity, but if we just use a single gigantic pattern matching trie for the rules, how would we disable rules? This is probably doable by keeping some arrays for counting rule "hits", and checking those arrays before matching/falling through, but the matching and memory overhead for this needs to be explored. Using indirect jumps through a lookup table could probably also work (indirect-threaded interpreter style kinda). Would love to hear if @mwillsey has any ideas for this.</li>
<li>Is ISLE capable of expressing rules common to multiple types easily? for example, <code>x * 1 =&gt; x</code> can be applied to floats, ints, and uints of any size. I presume ISLE has a way to handle this, but i haven't explored it much.</li>
<li>Is it potentially possible to store e-class data separate to the actual language? I.e the <code>Language</code> enum would be 64/128-bit sized and only contain data required for matching, for example, <code>Add([Id; 2])</code>, To potentially match rules much faster by exploiting vectorized pattern matching.</li>
<li>Is egg/ISLE capable of tracking optimization invariants through <code>Analysis</code> in a performant manner? this would allow for much deeper optimization potential by allowing the optimizer to track invariants, for example, eliminating <code>normalize</code> for vectors if a value is known to already be normalized.</li>
</ul>
<p>But overall this approach seems promising, and it would be awesome to share rulesets/ideas with cranelift.</p>
</blockquote>



<a name="291644014"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291644014" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291644014">(Aug 01 2022 at 22:54)</a>:</h4>
<p>mwillsey <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201814446">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi @RDambrosio016,</p>
<p>egg doesn't use trie-based pattern matching, so you'd essentially have to re-implement e-matching to support this. I believe Z3 does do something like this (<a href="http://leodemoura.github.io/files/ematching.pdf">Efficient E-matching for SMT Solvers</a>, section 4). We prototyped it at some point, and found it was slower because the rules we were using didn't significantly "overlap". In a high-performance setting, what I would try before tries is just running rules using the <code>SimpleScheduler</code>, but with a fixed, small number of iterations.</p>
<p>As far as using <code>Analysis</code> for tracking invariants, sure! Just be careful, an analysis is per e-class, so it depends on your notion of equivalence.<br>
</p>
</blockquote>



<a name="291645540"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291645540" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291645540">(Aug 01 2022 at 23:14)</a>:</h4>
<p>RDambrosio016 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201828439">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Interesting, i did a small experiment generating rules with my own DSL, and, while decently fast, it definitely seems like egg spends a lot of its time on rules that could never match if you have a ruleset that is somewhat larger as a consequence of duplicating rules for numerous numeric types. In this particular ruleset i have ~61 unique rules (including bidirectionality), which after being duplicated for multiple numeric types, result in <code>240</code> total rules, and this is how long egg takes on each step:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">rules</span>: <span class="mi">240</span><span class="w"></span>
<span class="n">Time</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">runner</span><span class="w"> </span><span class="n">creation</span>: <span class="mf">2.6857</span><span class="n">ms</span><span class="w"></span>

<span class="n">Runner</span><span class="w"> </span><span class="n">report</span><span class="w"></span>
<span class="o">=============</span><span class="w"></span>
<span class="w">  </span><span class="n">Stop</span><span class="w"> </span><span class="n">reason</span>: <span class="nc">Saturated</span><span class="w"></span>
<span class="w">  </span><span class="n">Iterations</span>: <span class="mi">7</span><span class="w"></span>
<span class="w">  </span><span class="n">Egraph</span><span class="w"> </span><span class="n">size</span>: <span class="mi">148</span><span class="w"> </span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="mi">177</span><span class="w"> </span><span class="n">memo</span><span class="w"></span>
<span class="w">  </span><span class="n">Rebuilds</span>: <span class="mi">4</span><span class="w"></span>
<span class="w">  </span><span class="n">Total</span><span class="w"> </span><span class="n">time</span>: <span class="mf">0.0026048</span><span class="w"></span>
<span class="w">    </span><span class="n">Search</span>:  <span class="p">(</span><span class="mf">0.82</span><span class="p">)</span><span class="w"> </span><span class="mf">0.0021298000000000003</span><span class="w"></span>
<span class="w">    </span><span class="n">Apply</span>:   <span class="p">(</span><span class="mf">0.17</span><span class="p">)</span><span class="w"> </span><span class="mf">0.0004338</span><span class="w"></span>
<span class="w">    </span><span class="n">Rebuild</span>: <span class="p">(</span><span class="mf">0.02</span><span class="p">)</span><span class="w"> </span><span class="mf">0.0000397</span><span class="w"></span>

<span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="o">---</span>-&gt; <span class="nc">fma</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">neg</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">fma</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">recip</span><span class="p">(</span><span class="n">z</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"></span>
<span class="n">Cost</span>: <span class="mf">26.5</span><span class="w"> </span>-&gt; <span class="mi">12</span><span class="w"></span>
</code></pre></div>
<p>This is on release with 1 CGUs and LTO on, on an i9-10850k. Search time making up the bulk of the time is not unexpected, but to me it seemed a little bit high considering how small the expression is. So i re-tried it but without duplicating rules, and i got these results:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">rules</span>: <span class="mi">50</span><span class="w"></span>
<span class="n">Time</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">runner</span><span class="w"> </span><span class="n">creation</span>: <span class="mf">1.0181</span><span class="n">ms</span><span class="w"></span>

<span class="n">Runner</span><span class="w"> </span><span class="n">report</span><span class="w"></span>
<span class="o">=============</span><span class="w"></span>
<span class="w">  </span><span class="n">Stop</span><span class="w"> </span><span class="n">reason</span>: <span class="nc">Saturated</span><span class="w"></span>
<span class="w">  </span><span class="n">Iterations</span>: <span class="mi">7</span><span class="w"></span>
<span class="w">  </span><span class="n">Egraph</span><span class="w"> </span><span class="n">size</span>: <span class="mi">148</span><span class="w"> </span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="mi">177</span><span class="w"> </span><span class="n">memo</span><span class="w"></span>
<span class="w">  </span><span class="n">Rebuilds</span>: <span class="mi">4</span><span class="w"></span>
<span class="w">  </span><span class="n">Total</span><span class="w"> </span><span class="n">time</span>: <span class="mf">0.0009838</span><span class="w"></span>
<span class="w">    </span><span class="n">Search</span>:  <span class="p">(</span><span class="mf">0.66</span><span class="p">)</span><span class="w"> </span><span class="mf">0.0006475000000000001</span><span class="w"></span>
<span class="w">    </span><span class="n">Apply</span>:   <span class="p">(</span><span class="mf">0.30</span><span class="p">)</span><span class="w"> </span><span class="mf">0.0002992</span><span class="w"></span>
<span class="w">    </span><span class="n">Rebuild</span>: <span class="p">(</span><span class="mf">0.04</span><span class="p">)</span><span class="w"> </span><span class="mf">0.000035999999999999994</span><span class="w"></span>

<span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="o">---</span>-&gt; <span class="nc">fma</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">neg</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">fma</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">recip</span><span class="p">(</span><span class="n">z</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"></span>
<span class="n">Cost</span>: <span class="mf">26.5</span><span class="w"> </span>-&gt; <span class="mi">12</span><span class="w"></span>
</code></pre></div>
<p>So it definitely seems like hierarchical matching of some sort would be required to avoid spending a ton of time searching the graph. It's odd that your experiment in trie matching ended up being slower, was it using generated rust code like ISLE creates, or was it dynamically matched at runtime?</p>
</blockquote>



<a name="291646351"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291646351" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291646351">(Aug 01 2022 at 23:26)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201835593">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>@RDambrosio016 I'd be happy to talk more about sharing efforts once the Cranelift work here is more mature; for now there is still exploration going on. I suspect that a lot of what we do is going to be fairly Cranelift-specific: there is a large semantic gap between "x*1 == x" at the conceptual level, and the particular matchers, node formats, and idiosyncrasies of the framework. My experience in the past is that trying to paper over such details to give a nice high-level view can sometimes be counterproductive because it either creates subtle bugs, or sweeps efficiency concerns under the rug. But once we've built more, perhaps there's something to be used for your effort too :-)</p>
<p>In the meantime perhaps it's best if we keep this discussion thread scoped to the Cranelift effort? It's likely to get much longer in time anyway (I have some more updates cooking at the moment) but side-discussions about other projects might pull us a bit too far off course... thanks!</p>
</blockquote>



<a name="291646522"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291646522" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291646522">(Aug 01 2022 at 23:28)</a>:</h4>
<p>RDambrosio016 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201837438">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Absolutely <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> , didnt mean to steer it into more minute details, i was just wondering if you considered/discussed this problem in the past, since i looked at the RFC but it did not seem to mention it.</p>
</blockquote>



<a name="291646892"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291646892" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291646892">(Aug 01 2022 at 23:34)</a>:</h4>
<p>RDambrosio016 edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201837438">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Absolutely <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span> , didnt mean to steer it into more minute details, i was just wondering if you considered/discussed this problem in the past, since i looked at the RFC but it did not seem to mention it. Anyways, im excited about this RFC, and interested in maybe contributing to implementing it/making it better.</p>
</blockquote>



<a name="291647227"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291647227" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291647227">(Aug 01 2022 at 23:38)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201843427">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>For sure, performance is my main concern right now and I'm working to make the whole thing competitive with handwritten optimizations, so you'll here more about that in a bit!</p>
</blockquote>



<a name="291648191"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291648191" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291648191">(Aug 01 2022 at 23:50)</a>:</h4>
<p>RDambrosio016 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1201849809">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Beating hand-written optimizations is definitely an achievable goal, considering the e-graph approach would have a much easier time knowing when to stop optimizing vs a standard pass-based optimizer. It will also be an interesting problem trying to figure out a good cost metric that maximizes generated code quality. Having a complete e-graph to choose from is great, but trying to select the ideal version from that will definitely prove to be a challenge.</p>
</blockquote>



<a name="291901984"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291901984" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291901984">(Aug 03 2022 at 18:35)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1204334799">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>As an update here, on the running prototype/experimental branch <a href="https://github.com/bytecodealliance/wasmtime/pull/4249">here</a>, I've gotten overhead of Cranelift-with-egraphs (including elaboration that subsumes GVN and LICM, and rewrite rules using ISLE that encompass basic const propagation and algebraic simplifications) vs Cranelift-with-handwritten-opts down to ~1% slower on parallel compile time (and actually slightly <em>faster</em> in terms of total CPU time across cores):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">cfallin</span><span class="o">@</span><span class="n">min</span>:<span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">output</span><span class="w"> </span><span class="o">--</span><span class="w">  </span><span class="s">"target/release/wasmtime compile --cranelift-set use_egraphs=true ../wasm-tests/spidermonkey.wasm"</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.693</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.098</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">10.747</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.234</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.621</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.951</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">cfallin</span><span class="o">@</span><span class="n">min</span>:<span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">output</span><span class="w"> </span><span class="o">--</span><span class="w">  </span><span class="s">"target/release/wasmtime compile --cranelift-set use_egraphs=false ../wasm-tests/spidermonkey.wasm"</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.671</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.035</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">10.888</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.236</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.606</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.707</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>
</code></pre></div>
<p>(That's measuring on an M1 laptop with SpiderMonkey.wasm, a large Wasm module testcase.)</p>
<p>This is using a new acyclic-egraph approach that I'm calling the "aegraph" (or ægraph for those who love digraphs). I got the conventional egraph rewriting to work last week, and measured it and found compilation time was inflating significantly once rewrites occur -- something like 5x. I then had a series of realizations that the way that we're using egraphs here is more limited than perhaps a conventional full-equality-saturation approach, and had a series of realizations about simplifications we could make.</p>
<p>Basically an ægraph contains eclasses as nodes where each node contains an enode, an enode and a parent-eclass pointer, or two parent-eclass pointers. The union operation joins two eclasses together only by adding nodes (or as an optimization, replacing an enode node with an enode-and-parent node). An eclass node can refer only to earlier eclasses. We maintain the acyclicity invariant when adding enodes and unioning eclasses. Rule application occurs immediately when a new node is added. In a sense, eclasses are split into "levels" and a given level of an eclass refers only to the levels of argument eclasses that existed when it was created. It's thus a persistent immutable data structure. An eclass is represented by the id of its <em>latest</em> version (highest id), whereas the traditional union-find approach tends to push ids downward to the lowest id.</p>
<p>This data structure has some really compelling properties:</p>
<ul>
<li>Because eclass nodes are immutable once created, we only need to apply rules to a node once. This "single pass" rule application is at the heart of its speed.</li>
<li>We don't re-canonicalize and re-intern enodes, so we don't need parent pointers and we don't need a rebuild step.</li>
<li>It plays really nicely with the scoped elaboration, in that we can keep a parallel scoped map with the "best node" (extraction information) and memoize; extraction doesn't need cycle removal any more.</li>
</ul>
<p>The tradeoff is that it's not at all a full equality saturation (see above re: no recanonicalization). But I think that's OK for our use-case: we mainly (i) introduce new expressions then (ii) apply rules that introduce alternate forms of those expressions, and union them together.  In this case the ægraph is pretty ideal: it's like a streaming journal of nodes and we add a new node from the build, then add a few more nodes that are equivalent to it and union them in-place, then keep going, referring to the just-built expression by the latest id. So the ægraph is sort of a "multi-version IR" where every value can have multiple representations, combined with GVN.</p>
<p>(The case it misses that a traditional egraph with parent pointers, recanonicalization, and the rebuild step would get is where we introduce some node A that gets a new eclass, a rewrite rule adds a node B and unions it with A, and B happens to dedup to an already-existing eclass. The new ID for A will point to a union node that joins A and B's existing eclass, but other users of B will not see A because it's "newer". This seems to be of limited use <em>for our specific rules</em> because our rewrite rules <em>tend</em> to go from more expensive/complex expressions to simpler ones, so A is likely not better than B. That's not always the case and I'm sure there are cases where a full egraph does do better. But the multiple-version-representation and ability of rules to match on all versions seems like the key thing that we want from the data structure.)</p>
<p>Anyway, I'll write this up more properly but that's where I'm at now: a prototype that works and is fast. I'll add a bit more to it (integration with alias analysis! and other rules I haven't added yet) and then start to look at generated code quality too.</p>
</blockquote>



<a name="291902818"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291902818" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291902818">(Aug 03 2022 at 18:42)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1204334799">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>As an update here, on the running prototype/experimental branch <a href="https://github.com/bytecodealliance/wasmtime/pull/4249">here</a>, I've gotten overhead of Cranelift-with-egraphs (including elaboration that subsumes GVN and LICM, and rewrite rules using ISLE that encompass basic const propagation and algebraic simplifications) vs Cranelift-with-handwritten-opts down to ~1% slower on parallel compile time (and actually slightly <em>faster</em> in terms of total CPU time across cores):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">cfallin</span><span class="o">@</span><span class="n">min</span>:<span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">output</span><span class="w"> </span><span class="o">--</span><span class="w">  </span><span class="s">"target/release/wasmtime compile --cranelift-set use_egraphs=true ../wasm-tests/spidermonkey.wasm"</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.693</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.098</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">10.747</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.234</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.621</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.951</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">cfallin</span><span class="o">@</span><span class="n">min</span>:<span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">output</span><span class="w"> </span><span class="o">--</span><span class="w">  </span><span class="s">"target/release/wasmtime compile --cranelift-set use_egraphs=false ../wasm-tests/spidermonkey.wasm"</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.671</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.035</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">10.888</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.236</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.606</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.707</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>
</code></pre></div>
<p>(That's measuring on an M1 laptop with SpiderMonkey.wasm, a large Wasm module testcase.)</p>
<p>This is using a new acyclic-egraph approach that I'm calling the "aegraph" (or ægraph for those who love digraphs). I got the conventional egraph rewriting to work last week, and measured it and found compilation time was inflating significantly once rewrites occur -- something like 5x. I then had a series of realizations that the way that we're using egraphs here is more limited than perhaps a conventional full-equality-saturation approach, and there are simplifications we could make.</p>
<p>Basically an ægraph contains eclasses as nodes where each node contains an enode, an enode and a parent-eclass pointer, or two parent-eclass pointers. The union operation joins two eclasses together only by adding nodes (or as an optimization, replacing an enode node with an enode-and-parent node). An eclass node can refer only to earlier eclasses. We maintain the acyclicity invariant when adding enodes and unioning eclasses. Rule application occurs immediately when a new node is added. In a sense, eclasses are split into "levels" and a given level of an eclass refers only to the levels of argument eclasses that existed when it was created. It's thus a persistent immutable data structure. An eclass is represented by the id of its <em>latest</em> version (highest id), whereas the traditional union-find approach tends to push ids downward to the lowest id.</p>
<p>This data structure has some really compelling properties:</p>
<ul>
<li>Because eclass nodes are immutable once created, we only need to apply rules to a node once. This "single pass" rule application is at the heart of its speed.</li>
<li>We don't re-canonicalize and re-intern enodes, so we don't need parent pointers and we don't need a rebuild step.</li>
<li>It plays really nicely with the scoped elaboration, in that we can keep a parallel scoped map with the "best node" (extraction information) and memoize; extraction doesn't need cycle removal any more.</li>
</ul>
<p>The tradeoff is that it's not at all a full equality saturation (see above re: no recanonicalization). But I think that's OK for our use-case: we mainly (i) introduce new expressions then (ii) apply rules that introduce alternate forms of those expressions, and union them together.  In this case the ægraph is pretty ideal: it's like a streaming journal of nodes and we add a new node from the build, then add a few more nodes that are equivalent to it and union them in-place, then keep going, referring to the just-built expression by the latest id. So the ægraph is sort of a "multi-version IR" where every value can have multiple representations, combined with GVN.</p>
<p>(The case it misses that a traditional egraph with parent pointers, recanonicalization, and the rebuild step would get is where we introduce some node A that gets a new eclass, a rewrite rule adds a node B and unions it with A, and B happens to dedup to an already-existing eclass. The new ID for A will point to a union node that joins A and B's existing eclass, but other users of B will not see A because it's "newer". This seems to be of limited use <em>for our specific rules</em> because our rewrite rules <em>tend</em> to go from more expensive/complex expressions to simpler ones, so A is likely not better than B. That's not always the case and I'm sure there are cases where a full egraph does do better. But the multiple-version-representation and ability of rules to match on all versions seems like the key thing that we want from the data structure.)</p>
<p>Anyway, I'll write this up more properly but that's where I'm at now: a prototype that works and is fast. I'll add a bit more to it (integration with alias analysis! and other rules I haven't added yet) and then start to look at generated code quality too.</p>
</blockquote>



<a name="291908072"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291908072" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291908072">(Aug 03 2022 at 19:26)</a>:</h4>
<p>RDambrosio016 <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1204383296">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Very interesting! im curious to see if that specific limitation will end up limiting any optimization potential in the future. It may be worth it to try running generated code benchmarks both without rebuilding, and with. Although it's definitely possible that associativity rules will hide that limitation. Nevertheless, the performance on something as large as the spidermonkey wasm file is impressive! Did you happen to measure how much memory the e-graphs/program overall took?</p>
<p>Excited to try out this approach, i was thinking about perhaps working on algebraic identities for mul/div/rem mostly based on this <a href="http://groups.csail.mit.edu/commit/papers/99/mdopt-TM.pdf">paper</a>. Would you accept a PR to your experimental branch to add such rules?</p>
</blockquote>



<a name="291931721"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/291931721" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#291931721">(Aug 03 2022 at 23:01)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1204565424">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Sure; more opts are definitely welcome in a PR, thanks!</p>
<p>I haven't done any more detailed measurements; I'm polishing things wrt integrations now and once I have it in a state where I'm happy, I'll do a full comparison and set of measurements (with Sightglass) on compile- and runtime performance.</p>
</blockquote>



<a name="292681364"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292681364" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292681364">(Aug 10 2022 at 01:10)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1210040665">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- I have some updates. It's kind of a mixed bag -- tl;dr, code quality matches existing Cranelift (all optimizations have been reproduced), compilation speed is ~1-5% slower. Theoretical benefits of everything-in-one-fixpoint (GVN and alias analysis and LICM and algebraic simplifications all cooperating) work in filetests, but don't seem to do much to Wasm-based benchmarks in Sightglass.</p>
<p>So the current status of the WIP branch is:</p>
<ul>
<li>"acyclic egraph" (ægraph) implementation is working;</li>
<li>producing and lowering out of this aegraph works fine;</li>
<li>ISLE-based rewrite rules operate on this aegraph, and cost-based extraction picks the best option for each node after rewrites are done;<ul>
<li>rewrites in the aegraph apply immediately (because of acyclicity, there's no need to revisit a node);</li>
<li>ISLE itself has been extended to support "multiplicity" in extractors and constructors, so multiple rules can match and matchers on eclass IDs see all available enodes for each eclass;</li>
</ul>
</li>
<li>The aegraph construction and "scoped elaboration" subsume GVN (global value numbering, a form of common-subexpression elimination) by means of the deduplication map;</li>
<li>The aegraph elaboration automatically does LICM (loop-invariant code motion) implicitly, by way of loop-nest awareness when traversing the domtree;</li>
<li>The alias analysis feeds into the rewrite rules and there are rules for redundant-load elimination and store-to-load forwarding;</li>
<li>Rewrite rules have been written for a bunch of constant-propagation and algebraic-simplification cases, and some other slightly more ad-hoc ones (e.g. reassociating loads to try to make LICM on partially-loop-invariant sums work)</li>
<li>A simple form of rematerialization has been implemented, where adds-with-one-immediate, and immediates themselves, are regenerated in the block they are used rather than maximally hoisted by GVN, in order to reduce register pressure.</li>
</ul>
<p>All this works -- and IMHO the data structures and algorithms are pretty beautiful actually! -- but it's not any <em>faster</em>. It is <em>nicer</em> to update with more rewrite rules -- see <a href="https://github.com/cfallin/wasmtime/blob/cfc1137fc3efae06e7753a158b6fae6b17686b0c/cranelift/codegen/src/opts/cprop.isle">cprop.isle</a> and <a href="https://github.com/cfallin/wasmtime/blob/cfc1137fc3efae06e7753a158b6fae6b17686b0c/cranelift/codegen/src/opts/algebraic.isle">algebraic.isle</a> -- and if it were completely at parity performance-wise, this would be an interesting benefit still IMHO. But there is still a small compile-time penalty, around 5% on average, with everything above incorporated.</p>
<p>I have some more thoughts in my <a href="https://github.com/cfallin/wasmtime/blob/cfc1137fc3efae06e7753a158b6fae6b17686b0c/TODO">running TODO list</a> but most of the remaining ones are for compile speed, not code quality (runtime speed).</p>
<p>Given all that, I think I'm running up against a wall that's actually mostly supported by some other limits:</p>
<ul>
<li>There is actually not a ton of remaining "low-hanging fruit" when running Wasm modules produced by an optimizing compiler. (Any strength reduction or other clever "instcombine"-type optimization I would expect to be done by LLVM before producing the <code>.wasm</code>.)</li>
<li>Lowering, once it occurs, disallows any further optimizations, because we can't edit VCode currently.</li>
</ul>
<p>The first is just a fact of our benchmarking conditions (but we're oriented this way because we care very much about Wasm performance -- we can't just choose to focus on poorly-optimized CLIF instead and say "see look opts work!"). But the second is where a lot of my thoughts are going lately. In other words, from first principles, if we start with highly-optimized Wasm bytecode, where do we expect inefficiencies and redundancies to creep in? Probably one of the three areas:</p>
<ul>
<li>The semantic gap between Wasm bytecode and CLIF, and how it is bridged (heap bounds checks, table accesses, and the like);</li>
<li>The semantic gap between CLIF and the machine, and how it is bridged (our lowering rules in our backends);</li>
<li>regalloc quality.</li>
</ul>
<p>My forehead is already dented from banging against item 3 (regalloc quality) for a long time, and item 1 (Wasm to CLIF) is largely addressed already by designing CLIF semantics to be close to those of Wasm; but item 2 (lowering) presents unharvested opportunities IMHO.</p>
<p>In looking at disassemblies of "hot blocks" when profiling runtime I see a lot of not-great code, and it comes in several varieties: redundant flags computations (cmp / setnp / cmp / sete for float comparisons is a common one); redundant trap conditions that cprop could optimize away, or GVN could combine between multiple ops; address-mode junk produced by our "match up the operand tree and then regenerate an <code>add</code> tree for the parts we can't incorporate" logic in both x64 and aarch64; a bunch of "spill x+1, x+3, x+10, x+15 to separate spillslots for use later" (hence my attempt at remat above); and others. A lot of this comes from the inability to optimize code once we lower a CLIF op into multiple MachInsts, or one pseudo-MachInst.</p>
<p>(Those who have been around a while might be screaming: legalization and post-opt! Yes, you're right. I think we threw out some of the value of those in exchange for the speed and simplicity of the single-pass lowering, and the real value that we <em>do</em> get from a two-level IR. But we lost something too.)</p>
<p>So: I'm taking a little time to think about what might make sense as a way to optimize VCode. I <em>don't</em> think this means throwing out the aegraph and ISLE-based mid-end framework; I think instead there may be a way to write some mid-end legalizations that do a lot of expansion that we currently do in lowering, and then let lowering be simpler; or in the extreme, even have a <code>Node::MachInst { ... }</code> in the aegraph, though that has potential efficiency issues. More thought needed.</p>
<p>Anyway, I'd love to hear more thoughts on this, and we can talk about it more in the next Cranelift meeting, but there's my report on what I've learned in the last few weeks :-)</p>
</blockquote>



<a name="292683629"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292683629" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292683629">(Aug 10 2022 at 01:55)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1210062090">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>... and in a typical show of my luck, I discover just <em>after</em> writing the above that my remat was doing something wrong (LICM was overriding its decision). I now have the result:</p>
<ul>
<li>on spidermonkey.wasm I see an 11.4% speedup, with 5% extra compile time (the latter I can optimize a bit more I think);</li>
<li>on bz2.wasm I see a 7.3% speedup, also with 5% extra compile time.</li>
</ul>
<p>More measurements later but IMHO if I can get the compile time overhead a bit lower this <em>should</em> be compelling on its own (then the post-lowering optimization ideas above become the next step).</p>
</blockquote>



<a name="292883674"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292883674" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292883674">(Aug 11 2022 at 08:05)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1211672382">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>I did some optimization on compiler runtime tonight -- both low-level things like inline pragmas, refactoring some data structures to allow holding borrows rather than lookups, using dense rather than sparse maps in places, preallocating with correct sizes, and similar, and high-level things like algorithmic improvements to memoize more, trim the extraction search space (running upper bound and early exit/pruning), "subsume" all nodes in an eclass with one "final" version (for e.g. cprop), and the like.</p>
<p>In the end I got SpiderMonkey.wasm down to a ~1% compile-time regression (relative to baseline Cranelift), and bz2.wasm to a... 15% compile-time <em>speedup</em> (yeah, I know; it's wild; I was focusing entirely on SpiderMonkey and then just checked bz2 now, and would have fallen off my chair if gravity were slightly stronger):</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w">  </span><span class="o">-</span><span class="n">L</span><span class="w"> </span><span class="n">egraphs</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="kc">true</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="p">{</span><span class="n">egraphs</span><span class="p">}</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.106</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.051</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">15.034</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.505</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.043</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.201</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Benchmark</span><span class="w"> </span><span class="mi">2</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.115</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.033</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">15.915</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.510</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.077</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.162</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Summary</span><span class="w"></span>
<span class="w">  </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"> </span><span class="n">ran</span><span class="w"></span>
<span class="w">    </span><span class="mf">1.01</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">faster</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">-</span><span class="n">r</span><span class="w"> </span><span class="mi">200</span><span class="w">  </span><span class="o">-</span><span class="n">L</span><span class="w"> </span><span class="n">egraphs</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="kc">true</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="p">{</span><span class="n">egraphs</span><span class="p">}</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">82.1</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">10.8</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">203.2</span><span class="w"> </span><span class="n">ms</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">58.4</span><span class="w"> </span><span class="n">ms</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">71.4</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="mf">106.5</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="mi">200</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Benchmark</span><span class="w"> </span><span class="mi">2</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">71.4</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">10.2</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">191.0</span><span class="w"> </span><span class="n">ms</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">58.7</span><span class="w"> </span><span class="n">ms</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">59.6</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">96.3</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="mi">200</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Summary</span><span class="w"></span>
<span class="w">  </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"> </span><span class="n">ran</span><span class="w"></span>
<span class="w">    </span><span class="mf">1.15</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="mf">0.22</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">faster</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="o">'</span><span class="w"></span>
</code></pre></div>
<p>And for completeness, yesterday's <em>runtime</em> numbers were on my M1 laptop, while today's work is on a Linux/x86-64 desktop (Ryzen 3900X); on this system, SpiderMonkey.wasm sees a 13% speedup, and bz2.wasm a 3% speedup:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">spidermonkey</span><span class="p">.</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">-</span><span class="n">L</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="n">egraphs</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="o">--</span><span class="n">dir</span><span class="o">=</span><span class="p">.</span><span class="w"> </span><span class="p">{</span><span class="n">file</span><span class="p">}.</span><span class="n">cwasm</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">fib</span><span class="p">.</span><span class="n">js</span><span class="o">'</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="o">--</span><span class="n">dir</span><span class="o">=</span><span class="p">.</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">fib</span><span class="p">.</span><span class="n">js</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.345</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.023</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">1.338</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.005</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.317</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.384</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Benchmark</span><span class="w"> </span><span class="mi">2</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="o">--</span><span class="n">dir</span><span class="o">=</span><span class="p">.</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">fib</span><span class="p">.</span><span class="n">js</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:      <span class="mf">1.195</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">0.010</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">1.189</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">0.003</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:    <span class="mf">1.181</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="err">…</span><span class="w">  </span><span class="mf">1.205</span><span class="w"> </span><span class="n">s</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Summary</span><span class="w"></span>
<span class="w">  </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="o">--</span><span class="n">dir</span><span class="o">=</span><span class="p">.</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">fib</span><span class="p">.</span><span class="n">js</span><span class="o">'</span><span class="w"> </span><span class="n">ran</span><span class="w"></span>
<span class="w">    </span><span class="mf">1.13</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="mf">0.02</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">faster</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="o">--</span><span class="n">dir</span><span class="o">=</span><span class="p">.</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">fib</span><span class="p">.</span><span class="n">js</span><span class="o">'</span><span class="w"></span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">false</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="o">--</span><span class="n">cranelift</span><span class="o">-</span><span class="n">set</span><span class="w"> </span><span class="n">use_egraphs</span><span class="o">=</span><span class="kc">true</span><span class="w"> </span><span class="o">../</span><span class="n">wasm</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">bz2</span><span class="p">.</span><span class="n">wasm</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="p">[</span><span class="n">cfallin</span><span class="o">@</span><span class="n">xap</span><span class="p">]</span><span class="o">~/</span><span class="n">work</span><span class="o">/</span><span class="n">wasmtime</span><span class="o">%</span><span class="w"> </span><span class="n">hyperfine</span><span class="w"> </span><span class="o">-</span><span class="n">L</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="n">egraphs</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="p">{</span><span class="n">file</span><span class="p">}.</span><span class="n">cwasm</span><span class="o">'</span><span class="w"></span>
<span class="n">Benchmark</span><span class="w"> </span><span class="mi">1</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:     <span class="mf">428.3</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">±</span><span class="w">   </span><span class="mf">9.7</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">425.3</span><span class="w"> </span><span class="n">ms</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">1.7</span><span class="w"> </span><span class="n">ms</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:   <span class="mf">416.6</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="mf">441.6</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Benchmark</span><span class="w"> </span><span class="mi">2</span>: <span class="nc">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="w"></span>
<span class="w">  </span><span class="n">Time</span><span class="w"> </span><span class="p">(</span><span class="n">mean</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="err">σ</span><span class="p">)</span>:     <span class="mf">414.5</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">±</span><span class="w">  </span><span class="mf">12.8</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="p">[</span><span class="n">User</span>: <span class="mf">411.5</span><span class="w"> </span><span class="n">ms</span><span class="p">,</span><span class="w"> </span><span class="n">System</span>: <span class="mf">1.9</span><span class="w"> </span><span class="n">ms</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>:   <span class="mf">403.1</span><span class="w"> </span><span class="n">ms</span><span class="w"> </span><span class="err">…</span><span class="w"> </span><span class="mf">440.7</span><span class="w"> </span><span class="n">ms</span><span class="w">    </span><span class="mi">10</span><span class="w"> </span><span class="n">runs</span><span class="w"></span>

<span class="n">Summary</span><span class="w"></span>
<span class="w">  </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="n">egraphs</span><span class="p">.</span><span class="n">cwasm</span><span class="o">'</span><span class="w"> </span><span class="n">ran</span><span class="w"></span>
<span class="w">    </span><span class="mf">1.03</span><span class="w"> </span><span class="err">±</span><span class="w"> </span><span class="mf">0.04</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">faster</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="o">'</span><span class="na">target</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">wasmtime</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="n">base</span><span class="p">.</span><span class="n">cwasm</span><span class="o">'</span><span class="w"></span>
</code></pre></div>
<p>I think we're at the point where we can discuss this in the next Cranelift meeting, then hopefully, if consensus exists, I'll start cleaning this up and preparing it for merging (in small, more easily-digestible pieces!).</p>
</blockquote>



<a name="292970663"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292970663" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292970663">(Aug 11 2022 at 17:07)</a>:</h4>
<p>mwillsey <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1212258994">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>@cfallin Amazing work! These are killer results!  I think specializing to the ægraph (great name) is definitely the right decision for this use case; the trade-offs seem to be worth it. Although, it does make me wonder what it would take to make "normal" equality saturation usable in this setting. Exciting future work!</p>
</blockquote>



<a name="292977832"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292977832" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292977832">(Aug 11 2022 at 17:50)</a>:</h4>
<p>oflatt <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1212297305">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>This is so cool!<br>
Would be really interested to see how much better results are with different tweaks. Does full egraph-style matching do much good? I'm thinking about the case where an enode creates a new match in a parent eclass.</p>
</blockquote>



<a name="292981117"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292981117" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292981117">(Aug 11 2022 at 18:09)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1212320313">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Thanks @mwillsey! I'm definitely curious what other design points may be possible here. I suspect that benefits of more strongly normalizing approaches (full recanonicalize/rebuild as in a traditional egraph or egg) will become more apparent the more we add interesting rules. Right now I have rules I wrote with my traditional-compiler-author brain, so mostly constant prop and the like where the right-hand side is unambiguously better. (There are a few cases of reassociation where I let the extractor do the right thing though, and also scoped elaboration can make things interesting when another expression forces evaluation of some otherwise-expensive node, shorting its cost to 0 for subsequent uses and altering the best choice. (This is why extraction is done lazily and memoized.) In those cases I suspect having multiple versions around actually helps.)</p>
<p>There are definitely some experiments I'd like to run, if I were to put on my old grad-student hat (it has collected some dust!) -- among them, putting together a full rebuild step as @oflatt suggests, and maybe also a "rewrites always subsume" mode (ie no multi-version capability) with the rules. My day-job means I need to focus on getting this "makes compiler faster and better" magic into production shape first, of course, but I do want to experiment some as time allows :-)</p>
</blockquote>



<a name="292994807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292994807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292994807">(Aug 11 2022 at 19:33)</a>:</h4>
<p>remysucre <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1212403626">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hello! Yet another egg contributor here. @mwillsey and I had a great chat with Nico Bruno, who was a main engineer of SQLServer. It turns out one main difference between equality saturation and <a href="https://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/Papers/Cascades-graefe.pdf">cascade-style</a> DB query optimization is that the latter maintains the acyclicity of the e-graph, just like aegraph. Acyclicity enables many powerful optimizations like branch-and-bound, and usually runs very fast. I highly recommend checking out some of the literature there, as well as some modern implementations like <a href="https://github.com/cockroachdb/cockroach/blob/master/pkg/sql/opt/doc.go">cockroach</a> and <a href="https://github.com/greenplum-db/gporca">orca</a>. </p>
</blockquote>



<a name="292996047"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/292996047" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#292996047">(Aug 11 2022 at 19:40)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1212413489">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>@remysucre thanks for the pointers! (As with many other topics in systems work, the database folks got there first... why am I not surprised?!). I'm happy to hear there are similar approaches in use and I'll read up more.</p>
</blockquote>



<a name="293626261"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/293626261" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#293626261">(Aug 15 2022 at 21:48)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1215890949">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- I've updated the RFC to refer to ægraphs and include the numbers above. A full writeup of how ægraphs work is IMHO out-of-scope here but I will include a bunch of detail somewhere in <code>cranelift/codegen/docs/</code> if this merges. The important decision points here, IMHO, are:</p>
<ul>
<li>Should we have a mid-end?</li>
<li>Should it operate based on rewriting rules?</li>
<li>Is an implementation based on the prototype acceptable, given its numbers (with polish in a bunch of production details before merging)?</li>
</ul>
<p>I'd like to kick off a round of discussion and (hopefully!) consensus-building on that. Happy to talk more about this in the next Cranelift meeting but let's see what folks think here first. Thanks!</p>
</blockquote>



<a name="293914397"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/293914397" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#293914397">(Aug 17 2022 at 14:59)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1218128181">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Thanks @avanhatt! Updated based on feedback.</p>
</blockquote>



<a name="294907721"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/294907721" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#294907721">(Aug 23 2022 at 16:49)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[ ] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[ ] @cfallin</li>
<li>[ ] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[ ] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[ ] @bjorn3</li>
</ul>
</blockquote>



<a name="294907729"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/294907729" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#294907729">(Aug 23 2022 at 16:49)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[ ] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[ ] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[ ] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[ ] @bjorn3</li>
</ul>
</blockquote>



<a name="294913920"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/294913920" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#294913920">(Aug 23 2022 at 17:25)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[ ] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[ ] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[ ] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="294917176"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/294917176" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#294917176">(Aug 23 2022 at 17:45)</a>:</h4>
<p>fitzgen edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[ ] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[ ] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="295093680"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/295093680" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#295093680">(Aug 24 2022 at 17:31)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[ ] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="295093983"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/295093983" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#295093983">(Aug 24 2022 at 17:33)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1226030546">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Given approvals from multiple stakeholder groups, we <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/rfc-process.md#making-a-decision-merge-or-close">now enter</a> the 10-day <em>final comment period</em>.</p>
<p>If no objections are registered by 2022-09-03, we will merge this RFC. Thanks all for the discussion!</p>
</blockquote>



<a name="295100286"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/295100286" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#295100286">(Aug 24 2022 at 18:11)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[ ] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[x] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="295110376"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/295110376" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#295110376">(Aug 24 2022 at 19:17)</a>:</h4>
<p>jameysharp edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[ ] @elliottt </li>
<li>[x] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[x] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="295151649"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/295151649" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#295151649">(Aug 25 2022 at 02:13)</a>:</h4>
<p>elliottt edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[ ] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[x] @elliottt </li>
<li>[x] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[x] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="296087427"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/296087427" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#296087427">(Aug 30 2022 at 12:09)</a>:</h4>
<p>akirilov-arm edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[x] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[ ] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[x] @elliottt </li>
<li>[x] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[x] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="296124168"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/296124168" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#296124168">(Aug 30 2022 at 14:08)</a>:</h4>
<p>alexcrichton edited a <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1224336246">comment</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>Hi all -- after discussing this briefly yesterday it sounds like no one has any major objections; so given that, and the positive results we've found, I would like to make a</p>
<h1>Motion to finalize with a disposition to merge</h1>
<p>I've updated the list below to contain all stakeholders who have committed to Cranelift within the past three months, or participated in RFC discussions in the same timeframe.</p>
<h1>Stakeholders sign-off</h1>
<h2>Arm</h2>
<ul>
<li>[x] @akirilov-arm</li>
<li>[ ] @sparker-arm</li>
<li>[ ] @dheaton-arm</li>
</ul>
<h2>Cornell</h2>
<ul>
<li>[x] @avanhatt</li>
</ul>
<h2>Embark Studios</h2>
<ul>
<li>[ ] @bnjbvr </li>
</ul>
<h2>Fastly</h2>
<ul>
<li>[x] @alexcrichton </li>
<li>[x] @cfallin</li>
<li>[x] @fitzgen </li>
<li>[ ] @sunfishcode </li>
<li>[x] @elliottt </li>
<li>[x] @jameysharp </li>
<li>[ ] @iximeow</li>
</ul>
<h2>IBM</h2>
<ul>
<li>[x] @uweigand</li>
</ul>
<h2>Intel</h2>
<ul>
<li>[ ] @abrown </li>
<li>[ ] @jlb6740</li>
</ul>
<h2>Unaffiliated</h2>
<ul>
<li>[x] @bjorn3</li>
</ul>
</blockquote>



<a name="297619624"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/266952-rfc-notifications/topic/rfcs%20/%20issue%20%2327%20Cranelift%3A%20Using%20E-Graphs%20for%20Verified%2C%20.../near/297619624" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> RFC notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/266952-rfc-notifications/topic/rfcs.20.2F.20issue.20.2327.20Cranelift.3A.20Using.20E-Graphs.20for.20Verified.2C.20.2E.2E.2E.html#297619624">(Sep 07 2022 at 15:58)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/rfcs/pull/27#issuecomment-1239584705">commented</a> on <a href="https://github.com/bytecodealliance/rfcs/pull/27">issue #27</a>:</p>
<blockquote>
<p>The FCP has now (more than) elapsed; with no objections, I will now merge this RFC! Thanks all for the spirited discussion and ideas. Hopefully soon now we can get a proper implementation into Cranelift; my next task is to clean up the prototype and start to submit pieces for review.</p>
</blockquote>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>