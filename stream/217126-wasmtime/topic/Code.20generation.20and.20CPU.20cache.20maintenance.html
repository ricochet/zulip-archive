<html>
<head><meta charset="utf-8"><title>Code generation and CPU cache maintenance · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html">Code generation and CPU cache maintenance</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="244731252"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244731252" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244731252">(Jul 02 2021 at 17:06)</a>:</h4>
<p>I am trying to determine if any CPU cache maintenance is performed after code generation finishes and before execution starts, and currently it <a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/jit/src/code_memory.rs#L148">looks</a> like only the memory region is changed from readable and writable to readable and executable. Am I missing something?</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/jit/src/code_memory.rs#L148" style="background-image: url(https://opengraph.githubassets.com/2be0c53399a5d987161c88755192869fb9ba7d39a1213b1c8867bd37f5df2a89/bytecodealliance/wasmtime)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/jit/src/code_memory.rs#L148" title="bytecodealliance/wasmtime">bytecodealliance/wasmtime</a></div><div class="message_embed_description">Standalone JIT-style runtime for WebAssembly, using Cranelift - bytecodealliance/wasmtime</div></div></div>



<a name="244731607"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244731607" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244731607">(Jul 02 2021 at 17:10)</a>:</h4>
<p>I think that is indeed all we do. On x86 at least the coherence model handles self-modifying code in the most programmer-friendly way (i.e. a write to code memory is immediately seen by fetch, architecturally, causing great pain and suffering in the icache logic) but I imagine this isn't the case on other architectures; do we need to do something special here for e.g. aarch64?</p>



<a name="244733194"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244733194" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244733194">(Jul 02 2021 at 17:23)</a>:</h4>
<p>Yes, we do. The 64-bit Arm architecture requires two actions - cache maintenance and context synchronization (usually an <code>ISB</code> instruction). The full sequence can be seen in GCC's <a href="https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/config/aarch64/sync-cache.c;h=41151e861d7fc32a77772b7f09b5f88779cbfd4c">implementation</a> of <code>__builtin___clear_cache</code>, for example. Alternatively, section B2.4.4 of the Arm Architecture Reference Manual provides the appropriate instruction sequence.</p>



<a name="244733572"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244733572" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244733572">(Jul 02 2021 at 17:26)</a>:</h4>
<p>The Arm Neoverse cores actually have coherent data and instruction caches, so cache maintenance is not necessary in that case (and the GCC code does the appropriate thing), but that's an optional feature of the architecture.</p>



<a name="244734324"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244734324" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244734324">(Jul 02 2021 at 17:32)</a>:</h4>
<p>Context synchronization is still necessary and is indeed the trickier bit because it must be performed by all processors (in practice that would mean threads) that may execute the modified code. I remember that <span class="user-mention" data-user-id="254393">@Benjamin Bouvier</span> had some fun implementing that in Spidermonkey <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.</p>



<a name="244734507"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244734507" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244734507">(Jul 02 2021 at 17:34)</a>:</h4>
<p>Happy to take a PR for this, and thanks for raising the issue!</p>
<p>And yes, I was just about to ask about the multicore case, especially as we compile on a thread pool. Is it enough to flush dcache out (write back dirty lines, which broadly speaking looks like the first half of that code sequence) at the end of compile, and flush icache (second half of sequence) on all cores?</p>



<a name="244734549"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244734549" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244734549">(Jul 02 2021 at 17:34)</a>:</h4>
<p>I can imagine a lazy design for the latter where we track "code generation number" and latest generation seen on each core, and flush only when needed</p>



<a name="244734588"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244734588" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244734588">(Jul 02 2021 at 17:35)</a>:</h4>
<p>I guess I should go read SpiderMonkey's code to see how <span class="user-mention" data-user-id="254393">@Benjamin Bouvier</span> solved this :-)</p>



<a name="244734857"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244734857" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244734857">(Jul 02 2021 at 17:37)</a>:</h4>
<p>The instruction cache invalidation is not an issue because it broadcasts in the whole coherency domain.</p>



<a name="244735032"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735032" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735032">(Jul 02 2021 at 17:39)</a>:</h4>
<p>ah, cool, so we don't need the equivalent of the linux kernel's "run this code on all cores" primitive</p>



<a name="244735045"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735045" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735045">(Jul 02 2021 at 17:39)</a>:</h4>
<p>this looks like the right bit?: <a href="https://searchfox.org/mozilla-central/rev/60c185194386e8e44bbeb09f5547ad5994d4c774/js/src/jit/ProcessExecutableMemory.cpp#785-791">https://searchfox.org/mozilla-central/rev/60c185194386e8e44bbeb09f5547ad5994d4c774/js/src/jit/ProcessExecutableMemory.cpp#785-791</a></p>



<a name="244735224"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735224" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735224">(Jul 02 2021 at 17:40)</a>:</h4>
<p>Well, we don't need it for cache maintenance, but we need it for context synchronization.</p>



<a name="244735570"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735570" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735570">(Jul 02 2021 at 17:43)</a>:</h4>
<p>The code snippet that you linked to doesn't look like what I had in mind.</p>



<a name="244735658"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735658" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735658">(Jul 02 2021 at 17:44)</a>:</h4>
<p>So there is some interesting discussion in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1529933">https://bugzilla.mozilla.org/show_bug.cgi?id=1529933</a> about how Firefox's scheme is safe due to ordering around an atomic code-pointer update</p>



<a name="244735726"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735726" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735726">(Jul 02 2021 at 17:44)</a>:</h4>
<p>but I haven't fully internalized this and in any case you would know best what is actually needed -- so please do send a PR if you've got an idea of a reasonable fix :-)</p>



<a name="244735788"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735788" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735788">(Jul 02 2021 at 17:45)</a>:</h4>
<p>(fwiw we don't update code pointers with atomic stores because we don't do the racy swap-out-new-code thing that FF does between tiers, but we could easily add a fence in the right place)</p>



<a name="244735925"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244735925" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244735925">(Jul 02 2021 at 17:46)</a>:</h4>
<p>cranelift-jit also doesn't do cache maintenance or context synchronization.</p>



<a name="244736555"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244736555" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244736555">(Jul 02 2021 at 17:51)</a>:</h4>
<p>Right, I've read through the same discussion before when discussing with <span class="user-mention" data-user-id="254393">@Benjamin Bouvier</span>, so I'll just repeat my points - I don't necessarily disagree with what my colleague Jacob Bramley has said, but my feeling is that this is relying on implementation details, which is IMHO fragile.</p>



<a name="244736789"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244736789" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244736789">(Jul 02 2021 at 17:53)</a>:</h4>
<p>Basically the idea is that if the only way for a core to see the updated code is via an update to a function pointer, then context synchronization might not be necessary.</p>



<a name="244736920"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244736920" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244736920">(Jul 02 2021 at 17:54)</a>:</h4>
<p>The key idea being that an update to a function pointer is a <strong>data</strong> update, not a <strong>code</strong> update.</p>



<a name="244737082"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737082" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737082">(Jul 02 2021 at 17:55)</a>:</h4>
<p>This assumes that the buffer holding the updated code is "fresh", i.e. no one has ever executed code from it before.</p>



<a name="244737288"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737288" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737288">(Jul 02 2021 at 17:57)</a>:</h4>
<p>Point of clarification: what do you mean by "context synchronization" exactly? (I understand cache coherence and weak memory models but am not familiar with that exact term)</p>



<a name="244737398"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737398" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737398">(Jul 02 2021 at 17:58)</a>:</h4>
<p>and, yes, I agree, relying on the incidental synchronization edges that occur because of the data-structure updates is more fragile than I would prefer as well</p>



<a name="244737529"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737529" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737529">(Jul 02 2021 at 17:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300050">Anton Kirilov</span> <a href="#narrow/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance/near/244737082">said</a>:</p>
<blockquote>
<p>This assumes that the buffer holding the updated code is "fresh", i.e. no one has ever executed code from it before.</p>
</blockquote>
<p>Is <code>mmap(PROT_EXEC)</code> enough to make it fresh?</p>



<a name="244737663"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737663" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737663">(Jul 02 2021 at 18:00)</a>:</h4>
<p>For application programmers "context synchronization" almost always means "execution of an <code>ISB</code> instruction". That's a good point, I'll just say that from now on to make things clearer - I am obviously used to the Arm architecture terminology <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.</p>



<a name="244737826"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737826" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737826">(Jul 02 2021 at 18:01)</a>:</h4>
<p>Ah, OK, so this just means "happens-before edge exists according to the memory model"</p>



<a name="244737926"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244737926" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244737926">(Jul 02 2021 at 18:02)</a>:</h4>
<p><span class="user-mention" data-user-id="264278">@bjorn3</span> Do you mean <code>mprotect()</code>? Either way, the answer is no, and part of the reason is that TLB invalidations also broadcast (so there is no need for inter-processor interrupts).</p>



<a name="244738453"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244738453" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244738453">(Jul 02 2021 at 18:07)</a>:</h4>
<p><span class="user-mention" data-user-id="254389">@Chris Fallin</span> <code>ISB</code> is not so much about the memory model (which is covered by cache maintenance), but about speculative execution and the associated buffers/caches.</p>



<a name="244738642"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244738642" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244738642">(Jul 02 2021 at 18:08)</a>:</h4>
<p>right, specifically in-flight instructions in the pipeline that may have already been fetched from stale cache lines are an issue, and data in store buffers, and ... (I worked on hardware details related to this in a past life :-) )</p>



<a name="244738676"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244738676" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244738676">(Jul 02 2021 at 18:08)</a>:</h4>
<p><code>ISB</code> is just a full pipeline synchronization/fence?</p>



<a name="244738697"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244738697" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244738697">(Jul 02 2021 at 18:09)</a>:</h4>
<p>Yes, that's right</p>



<a name="244739162"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244739162" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244739162">(Jul 02 2021 at 18:12)</a>:</h4>
<p>Basically, what people need is a broadcast <code>ISB</code>, which doesn't exist in the architecture.</p>



<a name="244739296"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244739296" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244739296">(Jul 02 2021 at 18:13)</a>:</h4>
<p>(and I don't think that's an accidental omission - pretty sure it has been discussed before)</p>



<a name="244739384"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244739384" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244739384">(Jul 02 2021 at 18:14)</a>:</h4>
<p>On Linux at least there is a straightforward equivalent system call - <code>membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE, 0)</code>.</p>



<a name="244739902"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244739902" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244739902">(Jul 02 2021 at 18:16)</a>:</h4>
<p>OK, great. Happy to take a PR to add that. We should look into whether there is an equivalent on macOS/aarch64 as well (sadly I don't have hardware to test this; friendly ping to <span class="user-mention" data-user-id="254393">@Benjamin Bouvier</span> if interested)</p>



<a name="244740274"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740274" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740274">(Jul 02 2021 at 18:20)</a>:</h4>
<p>BTW <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1661016">bug 1661016</a> covers the work by <span class="user-mention" data-user-id="254393">@Benjamin Bouvier</span> I mentioned.</p>



<a name="244740555"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740555" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740555">(Jul 02 2021 at 18:22)</a>:</h4>
<p>I think I can look into adding the cache maintenance, but the <code>ISB</code> part is more complicated because <code>membarrier()</code> doesn't just interrupt all threads in the process.</p>



<a name="244740609"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740609" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740609">(Jul 02 2021 at 18:23)</a>:</h4>
<p>Actually, threads that are interested in the notification have to register first and they are the ones that are interrupted.</p>



<a name="244740796"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740796" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740796">(Jul 02 2021 at 18:25)</a>:</h4>
<p>So, in Wasmtime, for example, threads that just compile functions don't need to execute <code>ISB</code> - I am not sure, do we distinguish between them and the threads that might run generated code?</p>



<a name="244740967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740967">(Jul 02 2021 at 18:27)</a>:</h4>
<p>I think that the thread pool management happens under the hood in Rayon (library)</p>



<a name="244740997"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244740997" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244740997">(Jul 02 2021 at 18:27)</a>:</h4>
<p>so potentially any compilation task or async wasm function invocation could happen on any thread</p>



<a name="244741143"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741143" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741143">(Jul 02 2021 at 18:29)</a>:</h4>
<p>I'm kind of thinking again about the lazy-ISB / "code generation number" approach. Could we just have a conditional and ISB in the wasm-entry thunk that triggers the first time we execute wasm after someone else generates some code?</p>



<a name="244741173"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741173" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741173">(Jul 02 2021 at 18:29)</a>:</h4>
<p>that's a cost for sure but if code almost never changes then the branch should be predictable</p>



<a name="244741294"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741294" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741294">(Jul 02 2021 at 18:30)</a>:</h4>
<p>First thought - you'd need to switch between RX and RW permissions in the middle of execution, though.</p>



<a name="244741358"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741358" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741358">(Jul 02 2021 at 18:31)</a>:</h4>
<p>Oh, no, sorry, you have a conditional branch.</p>



<a name="244741374"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741374" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741374">(Jul 02 2021 at 18:31)</a>:</h4>
<p>right, code itself is static, no patching in an ISB or anything</p>



<a name="244741376"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741376" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741376">(Jul 02 2021 at 18:31)</a>:</h4>
<p>I was thinking of optimizing it <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.</p>



<a name="244741406"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741406" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741406">(Jul 02 2021 at 18:32)</a>:</h4>
<p>two different thunks? or some sort of dynamic patching?</p>



<a name="244741605"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741605" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741605">(Jul 02 2021 at 18:33)</a>:</h4>
<p>Well, the architecture also allows a very limited form of instruction patching that doesn't require any synchronization.</p>



<a name="244741660"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741660" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741660">(Jul 02 2021 at 18:34)</a>:</h4>
<p>One particular case is turning an <code>ISB</code> into a <code>NOP</code>.</p>



<a name="244741823"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244741823" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244741823">(Jul 02 2021 at 18:36)</a>:</h4>
<p>Still, I think the <code>membarrier()</code> solution is cleaner and simpler, so I'll just have to read up on Rayon a bit.</p>



<a name="244742250"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244742250" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244742250">(Jul 02 2021 at 18:39)</a>:</h4>
<p>Ah, I see, then the nop-ification of the ISB lazily propagates into reality, and it's ok if we get a spurious ISB before it is fully synchronized. makes sense!</p>



<a name="244742351"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244742351" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244742351">(Jul 02 2021 at 18:40)</a>:</h4>
<p>I would actually lean a bit toward the generation-and-ISB approach because it avoids a syscall, and is more portable (any aarch64 OS)</p>



<a name="244742373"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244742373" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244742373">(Jul 02 2021 at 18:40)</a>:</h4>
<p>but if you want to do the membarrier thing first that's fine, I think, as it is simpler</p>



<a name="244743945"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244743945" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244743945">(Jul 02 2021 at 18:54)</a>:</h4>
<p>Hm, I am reading the documentation again and I might be misremembering - the opt-in done by the <code>membarrier()</code> call might be process-wide, so there would be no need for individual threads to opt in, which makes things even easier.</p>



<a name="244947605"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244947605" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Benjamin Bouvier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244947605">(Jul 05 2021 at 15:14)</a>:</h4>
<p>Oh yes, I do remember this stuff <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> I do remember that the <code>membarrier</code> was process-wide, and past-me seemed to confirm this in the changeset message:</p>
<blockquote>
<p>On real hardware, when a background thread finishes compilation, it must signal<br>
to the other executing threads that they need to reload a new version of the<br>
code. Ideally, each executing thread would run an ISB instruction to do so. We<br>
hereby use a system call membarrier that interrupts every other running thread,<br>
and will cause the same effect as a local ISB would. It is heavyweight, so we<br>
make sure to only run it in the case where we're on a background thread.</p>
</blockquote>



<a name="244947655"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244947655" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Benjamin Bouvier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244947655">(Jul 05 2021 at 15:15)</a>:</h4>
<p>That being said, it is not clear what needs to be done on MacOS aarch64.</p>



<a name="244964934"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/244964934" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#244964934">(Jul 05 2021 at 18:50)</a>:</h4>
<p><a href="https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon">Here</a> is Apple's developer documentation on porting JIT compilers.</p>



<a name="252348180"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252348180" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252348180">(Sep 07 2021 at 18:15)</a>:</h4>
<p>I opened <a href="https://github.com/bytecodealliance/wasmtime/issues/3310">issue #3310</a> to track this. We can also continue the discussion there.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/issues/3310" style="background-image: url(https://opengraph.githubassets.com/c6f9b4634c004ca5dccd966f7ab707b39017e6ce60a0d08a956534ec342d8c1f/bytecodealliance/wasmtime/issues/3310)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/issues/3310" title="Missing cache maintenance and context synchronization operations after JIT compilation is completed on AArch64 · Issue #3310 · bytecodealliance/wasmtime">Missing cache maintenance and context synchronization operations after JIT compilation is completed on AArch64 · Issue #3310 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">Currently (as of commit 164835e), after code generation is finished and before execution from the newly generated code starts on AArch64, both cranelift-jit and wasmtime-jit do not perform any acti...</div></div></div>



<a name="252351744"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252351744" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252351744">(Sep 07 2021 at 18:40)</a>:</h4>
<p>I believe that in order to have a clean solution some additions are necessary to the <code>compiler-builtins</code> and the <code>libc</code> crates (I really don't think that hardcoding the assembly sequence for cache maintenance in Wasmtime is the best approach), which is going to take a while, so it is useful to have a tracking issue.</p>



<a name="252352199"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252352199" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252352199">(Sep 07 2021 at 18:43)</a>:</h4>
<p>Having builtins would be ideal, but fwiw, I don't think it would be too much of a problem to just write the assembly in the meantime. The <code>wasmtime-fiber</code> crate for example has an assembly file per architecture</p>



<a name="252354685"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252354685" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton Kirilov <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252354685">(Sep 07 2021 at 18:57)</a>:</h4>
<p>I considered adding helpers to the <code>crates/runtime/src/helpers.c</code> file (one helper for the cache maintenance operations and another for <code>membarrier()</code>; in fact, in the former case we can just call the C function, I suppose), but it seemed wrong to make <code>cranelift-jit</code> use that crate, so I decided to pursue what is in any case the proper solution (which would benefit other JIT runtimes implemented in Rust).</p>



<a name="252357510"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252357510" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252357510">(Sep 07 2021 at 19:15)</a>:</h4>
<p>Yeah, that's true, it should be factored out somewhere. If getting things into libc or compiler-builtins becomes a bottleneck, I could see the case for a separate <code>jit-icache-coherence</code> crate (either as part of wasmtime or maybe even as an independent thing on <a href="http://crates.io">crates.io</a>)</p>



<a name="252357530"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Code%20generation%20and%20CPU%20cache%20maintenance/near/252357530" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance.html#252357530">(Sep 07 2021 at 19:15)</a>:</h4>
<p>or possibly it could belong in <code>region-rs</code></p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>