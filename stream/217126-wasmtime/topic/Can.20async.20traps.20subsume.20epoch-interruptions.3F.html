<html>
<head><meta charset="utf-8"><title>Can async traps subsume epoch-interruptions? · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F.html">Can async traps subsume epoch-interruptions?</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="288442632"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20async%20traps%20subsume%20epoch-interruptions%3F/near/288442632" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Sergei Pepyakin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F.html#288442632">(Jul 04 2022 at 19:23)</a>:</h4>
<p>During the work on slacked/async fuel metering, see <a href="https://github.com/bytecodealliance/wasmtime/issues/4109">#4109</a>, we converged on an idea of checking the fuel asynchronously. TL;DR: Slacked fuel metering allows to achieve overhead close to zero in many cases while preserving  determinism if the user can accept some concessions. </p>
<p>It works roughly like this. We reserve a register for the fuel counter. The fuel counter is incremented at each BB. The thread executing wasm will be periodically interrupted. The interrupt handler would check if the thread was interrupted in wasm based on the value of the PC register. If it was, then the handler can read the fuel register. Then, the handler can initiate a trap. Semantically, that means a wasm module can be interrupted at any wasm PC. </p>
<p>For macOS and Windows we would stop the thread, inspect its thread state, and if there is out-of-gas then modify the thread state, to land on a handler that would initiate unwinding.</p>
<p>Which made me realize: this looks equivalent to what <a href="https://github.com/bytecodealliance/wasmtime/pull/3699">epoch-interruption</a> aims to achieve. Specifically, it provides an efficient way to interrupt wasm code non-deterministically (but 2-3x faster) based on some periodic signal by the embedder.</p>
<p>Unlike epoch-interruption, async traps do not require inline synchronous checks on each epilogue and back edges. Instead, if we don't care about pretty stack traces during such async traps, then we don't need any modifications of compiled code. Or we can follow suggestion by <span class="user-mention" data-user-id="253994">@Alex Crichton</span> <a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134902184">here</a>. In any case, this has ≈0 overhead.</p>
<p>Also, I think async traps are a simpler and less-opinionated. Instead of having a single per-<code>Engine</code> counter that interrupts code in all stores that reached the deadline, per thread interruption is possible.</p>
<p>Probably I am missing something here and it might have been perhaps discussed. If so, why did the mechanism that involves synchronous checks won compared to async traps? Similar to Alex's logic in the linked issue?</p>
<p>cc <span class="user-mention" data-user-id="254389">@Chris Fallin</span></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/issues/4109" style="background-image: url(https\:\/\/uploads\.zulipusercontent\.net\/5666ec2a7551b39213020dce52c17580f277e222\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663639623766616264623061646266303630363437653236646636613466363866323930626639616432653330343764396134356230303433356632313937312f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f34313039)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/issues/4109" title="Slacked fuel metering · Issue #4109 · bytecodealliance/wasmtime">Slacked fuel metering · Issue #4109 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather ...</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/3699" style="background-image: url(https\:\/\/uploads\.zulipusercontent\.net\/3df55359d93ad6a7561b51536ebdc6e1246f1ac4\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663763396463653335396463363166646563653933393564343431643732366430323532383663616631613037383539383866353665336636323661326530382f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f33363939)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/3699" title="Add epoch-based interruption for cooperative async timeslicing. by cfallin · Pull Request #3699 · bytecodealliance/wasmtime">Add epoch-based interruption for cooperative async timeslicing. by cfallin · Pull Request #3699 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">(Builds on #3698)
This PR introduces a new way of performing cooperative timeslicing that
is intended to replace the "fuel" mechanism. The tradeoff is that this
mechanism interrupts with less preci...</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134902184" style="background-image: url(https\:\/\/uploads\.zulipusercontent\.net\/5666ec2a7551b39213020dce52c17580f277e222\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663639623766616264623061646266303630363437653236646636613466363866323930626639616432653330343764396134356230303433356632313937312f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f34313039)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/issues/4109#issuecomment-1134902184" title="Slacked fuel metering · Issue #4109 · bytecodealliance/wasmtime">Slacked fuel metering · Issue #4109 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather ...</div></div></div>



<a name="288552314"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20async%20traps%20subsume%20epoch-interruptions%3F/near/288552314" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F.html#288552314">(Jul 05 2022 at 16:07)</a>:</h4>
<p>I wondered the same thing myself as the async traps work unfolded. To me though the answer is not clear. Integration of epochs is quite simple where a thread simply increments a single counter. Integration of async traps seems more complicated where handles to threads-running-wasm need to be maintained and the periodic thread iterates this list. This implies at least some degree of synchronization depending on system setup.</p>
<p>Cost-wise given the benefits of async traps it may be worth investing in this design given how low-overhead they are!</p>



<a name="288553106"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20async%20traps%20subsume%20epoch-interruptions%3F/near/288553106" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F.html#288553106">(Jul 05 2022 at 16:13)</a>:</h4>
<p>For a little more context, at least in our embedding there was serious concern about any async thread interruption at all; partly due to historical experience and partly due to the real inherent subtleties one has to worry about (signal-safety, etc). So I guess epoch interruption fills a niche where we want pretty-fast interruptible code but no dependence on OS-specific thread interruption mechanisms</p>



<a name="288553203"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20async%20traps%20subsume%20epoch-interruptions%3F/near/288553203" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F.html#288553203">(Jul 05 2022 at 16:14)</a>:</h4>
<p>others may very well have different tradeoffs or complexity profiles though and be willing to build that out; it'd be interesting to see more options supported by wasmtime in general</p>



<hr><p>Last updated: Jan 20 2025 at 06:04 UTC</p>
</html>