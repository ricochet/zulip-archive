[
    {
        "content": "<p>Hi there! I'm working on porting our bindings over to the latest wit-bindgen (cd9d253d115040a8474eba6350340d7491e3183f) and a recent-ish wasmtime (b5e9fb710ba73bde295eec5ab57f6ef4f6459e79, there's a bindgen output discrepancy that I wanted to figure out later), and am sketching out how to best handle code sharing between worlds.</p>\n<p>I have a <code>main.wit</code> that defines two worlds:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>world client {\n    import types: pkg.types\n\n    import component: pkg.component\n    import entity: pkg.entity\n    import player: pkg.player\n    import event: pkg.event\n\n    export guest: pkg.guest\n}\n\nworld server {\n    import types: pkg.types\n\n    import component: pkg.component\n    import entity: pkg.entity\n    import player: pkg.player\n    import physics: pkg.physics\n    import event: pkg.event\n    import asset: pkg.asset\n\n    export guest: pkg.guest\n}\n</code></pre></div>\n<p>I'm defining two worlds as there's two versions of this API (one for clientside WASM logic, one for serverside WASM logic). However, the interfaces that are shared use the same logic on both the host and the guest - that is, the host implementation for the functions defined in <code>pkg.entity</code> is identical, and the guest would access them the same way.</p>\n<p>However, wit-bindgen on the guest and wasmtime's bindgen both require me to specify a world. That means I can't specify both worlds in the same bindgen call, so I'd have to use two separate bindgen calls which would create duplicate non-interoperable types.</p>\n<hr>\n<p>What would the best way to share common types while still ensuring that the bits that aren't common aren't dragged in as well?</p>\n<p>I was thinking of defining a <code>shared</code> world and moving the commonalities in there, but would I be able to use the types from that world, and would they be compatible? My ideal scenario here is defining my host / guest logic once for the shared functionality, and then defining them separately for the specific per-world functionality.</p>\n<p>If all fails, I'll just chuck it all in the same world and use convention with the interface names to delineate what belongs to each domain, but I'd like to avoid that if possible.</p>",
        "id": 338835090,
        "sender_full_name": "Philpax",
        "timestamp": 1677676305
    },
    {
        "content": "<p>you might be interested in <a href=\"https://github.com/WebAssembly/component-model/issues/169\">this feature</a> perhaps, but otherwise the rough intention is that guest programs and hosts are generated with the same world as a world describes a concrete component. Can you say a bit more about why you've got two worlds and how they're going to be used?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/169\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/2b7ef58a659faabe2c0d93793f9d2f595f23f525\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393966326638346330383162373635383239653635653637326234653362363962626463636130356638666563356531623538343030626562323038383166642f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f313639)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/169\" title=\"Proposal: Union of Worlds 路 Issue #169 路 WebAssembly/component-model\">Proposal: Union of Worlds 路 Issue #169 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">I want to raise this issue to propose a new syntax for the union of Worlds. The primary motivation for this proposal is that we want to be able to form a more compresive world by unionizing / combi...</div></div></div>",
        "id": 338880432,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1677685812
    },
    {
        "content": "<p>That proposal looks great! Will keep an eye on it.</p>\n<p>No problem on the clarification. I built out the WASM integration for <a href=\"https://github.com/AmbientRun/Ambient\">Ambient</a>, which is a game runtime that loads games powered by WASM on the server; clients can then join the server and receive assets. At present, we have server-side only WASM and I've implemented bindings for that. Our host is in Rust, and our guest is currently also Rust (with some higher-level wrappers around the raw WIT types).</p>\n<p>In the near-future, though, we'd like to send WASM to the client and have them run it, too. The API for both the client and the server (will) share a lot of functionality, and I'd like to avoid having to reimplement the common functionality. On the other hand, they also have points of divergence; there's functionality only one of the two sides will have access to.</p>\n<p>So one host executable (ambient) can provide export bindings for both the client and server API, depending on which mode it's running on. There can be two guest modules, compiled against the same API crate wrapping WIT types (but with different feature flags to expose the different portions of the API).</p>\n<p>That is: </p>\n<ul>\n<li>Ambient (host application running in server mode) consumes a <code>server.wasm</code> component, which was compiled with the Ambient API (<code>server</code> feature), which wraps the <code>server</code> WIT world seen above.</li>\n<li>An Ambient client (host application running in client mode) then joins that Ambient server, and is sent a WASM component to run - similar story, except now with <code>client</code> feature and the <code>client</code> WIT world.</li>\n</ul>\n<p>The host in both cases should provide the same <code>entity.set-component</code> implementation, and ideally the guest would use the same path to access it (i.e. so that I don't have to do <code>cfg(feature = \"server\") use server as wit;</code> etc). However, <code>physics.apply-force</code> wouldn't be available when building guest WASM for <code>client</code>.</p>\n<p>Let me know if you need any further clarification, but I'm thinking I'll probably have to use the same world for these at the moment.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/AmbientRun/Ambient\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/136830af0c45764b4604eca557068f26bf484084\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383064323066383264666338646339616135396533636339303339613736646133323264663461623036373636643362316334616638623931396331633966382f416d6269656e7452756e2f416d6269656e74)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/AmbientRun/Ambient\" title=\"GitHub - AmbientRun/Ambient: The multiplayer game engine\">GitHub - AmbientRun/Ambient: The multiplayer game engine</a></div><div class=\"message_embed_description\">The multiplayer game engine. Contribute to AmbientRun/Ambient development by creating an account on GitHub.</div></div></div>",
        "id": 338896307,
        "sender_full_name": "Philpax",
        "timestamp": 1677689220
    },
    {
        "content": "<p>Where does the sharing become necessary? With two wasm binaries you'd generate one world in each but there's no need to share types since they're separate binaries. Are you thinking the embedder code, though, would conditionally use types from either world?</p>",
        "id": 338942784,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1677700819
    },
    {
        "content": "<p>That's right. On the guest side, it would be nice to share types/functions for convenience (so that I can have <code>fn spawn(...) { wit::spawn(...) }</code> without having to alias <code>wit</code> depending on the world), but that can be worked around. The more pressing issue is for the host.</p>\n<p>I'd like to avoid reimplementing the interface functions and the code that consumes the WIT types on the host, as that's a lot of duplication for all of the code that interfaces with WIT. e.g. if I have <code>entity.spawn: func(data: list&lt;tuple&lt;u32, component-value&gt;&gt;) -&gt; entity-id</code> for both the client and server worlds, the host would have to reimplement <code>spawn</code> twice, conversion from <code>server.component-value</code> and <code>client.component-value</code> to the host representation, and conversion from the host's <code>entity-id</code> to <code>server.entity-id</code> and <code>client.entity-id</code>(and vice versa)  - and this would have to happen for everything that's shared between the worlds.</p>",
        "id": 339082617,
        "sender_full_name": "Philpax",
        "timestamp": 1677759431
    },
    {
        "content": "<p>Hm ok, I think it's basically the case that this isn't well supported today. Not to say it can't be, it would require work on the code generators though</p>",
        "id": 339207316,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1677792115
    },
    {
        "content": "<p>Yeah, fair enough - I'll see how I go with using a single world, thanks!</p>",
        "id": 339286084,
        "sender_full_name": "Philpax",
        "timestamp": 1677834351
    }
]