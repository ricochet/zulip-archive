[
    {
        "content": "<p>I am going through the steps here:  <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/export_native_api.md\">https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/export_native_api.md</a> to create a c++ native host which exposes functions to the wasm.<br>\nIs there a c/c++ generator similar to JCO?<br>\nIf not does anyone know if someone is already planning / discussing it?<br>\nIf not and someone was inclined to create one, is there an official antlr grammar?  <br>\nOr would it be better to extend something like the JCO or the rust bindgen macro?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/export_native_api.md\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/655286d8dd0af78caf61501a83890cd1ab3acab1\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383134386333646330326661356130383562623336666366383136636133343763623834643436623533383963653161313930396230623135653961653633362f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/export_native_api.md\" title=\"wasm-micro-runtime/export_native_api.md at main · bytecodealliance/wasm-micro-runtime\">wasm-micro-runtime/export_native_api.md at main · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">WebAssembly Micro Runtime (WAMR). Contribute to bytecodealliance/wasm-micro-runtime development by creating an account on GitHub.</div></div></div>",
        "id": 350691408,
        "sender_full_name": "Gordon Smith",
        "timestamp": 1681802192
    },
    {
        "content": "<p>I think that the engine independent C API <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md\">https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md</a> would be a better target for a C/++ host code generator.<br>\nAlso as we plan to work with WIT on adaptive AUTOSAR, a higher-level C++ binding (leveraging expected, optional and variant) would be something I could cooperate on.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/d6d47d572f545cb7a23fb6faeba5677e9162deb7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643665316263363038613661333034316335386435313630336561373331393339373139316134626437353136343434626263626463353337306632353630302f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md\" title=\"wasm-micro-runtime/wasm_c_api.md at main · bytecodealliance/wasm-micro-runtime\">wasm-micro-runtime/wasm_c_api.md at main · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">WebAssembly Micro Runtime (WAMR). Contribute to bytecodealliance/wasm-micro-runtime development by creating an account on GitHub.</div></div></div>",
        "id": 355271249,
        "sender_full_name": "Christof Petig",
        "timestamp": 1683064037
    },
    {
        "content": "<p>We've unfortunately found the engine-independent C/C++ API not to be a good fit for many use cases of Wasmtime, and have decided to limit our support for it to somewhat basic functionality. That means that we'll not bring Components support to it (which would entail substantially expanding the API in any case.)</p>\n<p>In addition to the severe limitations listed in the <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md#fyi\">FYI</a> section of the document you linked to, you can read more about the reasons <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#the-new-wasmtime-c-api\">here</a> and <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#motivation\">here</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md#fyi\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/4b5a2c8a08cc501a8010ba8f56879eae0f2102a9\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303264353266643061333338663436396462643730626536306163306133626464393837623762396335653362613136646164393339393766643233643261612f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/wasm_c_api.md#fyi\" title=\"wasm-micro-runtime/wasm_c_api.md at main · bytecodealliance/wasm-micro-runtime\">wasm-micro-runtime/wasm_c_api.md at main · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">WebAssembly Micro Runtime (WAMR). Contribute to bytecodealliance/wasm-micro-runtime development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#the-new-wasmtime-c-api\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/24447277c6bd21329127c529461993fd9f580cc2\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353036636638323765656433383764666234383438613838383866353037383866326662663539663537336536353834343831326563373431383064636535632f62797465636f6465616c6c69616e63652f72666373)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#the-new-wasmtime-c-api\" title=\"rfcs/new-api.md at main · bytecodealliance/rfcs\">rfcs/new-api.md at main · bytecodealliance/rfcs</a></div><div class=\"message_embed_description\">RFC process for Bytecode Alliance projects. Contribute to bytecodealliance/rfcs development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#motivation\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/24447277c6bd21329127c529461993fd9f580cc2\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353036636638323765656433383764666234383438613838383866353037383866326662663539663537336536353834343831326563373431383064636535632f62797465636f6465616c6c69616e63652f72666373)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/new-api.md#motivation\" title=\"rfcs/new-api.md at main · bytecodealliance/rfcs\">rfcs/new-api.md at main · bytecodealliance/rfcs</a></div><div class=\"message_embed_description\">RFC process for Bytecode Alliance projects. Contribute to bytecodealliance/rfcs development by creating an account on GitHub.</div></div></div>",
        "id": 355347690,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1683099865
    },
    {
        "content": "<p>Till - Thanks for this insight!  Should I be focusing on <a href=\"https://github.com/bytecodealliance/wasmtime-cpp\">https://github.com/bytecodealliance/wasmtime-cpp</a>?  My other question still stands, does anyone know if there is any work being done on generating a c/c++ host bindings from WIT files?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime-cpp\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/6b2b364f9a4dbbf4a55d7ba3134c0475a6904c72\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363363323263666339336133666135343666636262323333343636646363343466643935356538323731303065613937393733313565343534616238653662392f62797465636f6465616c6c69616e63652f7761736d74696d652d637070)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime-cpp\" title=\"GitHub - bytecodealliance/wasmtime-cpp\">GitHub - bytecodealliance/wasmtime-cpp</a></div><div class=\"message_embed_description\">Contribute to bytecodealliance/wasmtime-cpp development by creating an account on GitHub.</div></div></div>",
        "id": 355358200,
        "sender_full_name": "Gordon Smith",
        "timestamp": 1683102658
    },
    {
        "content": "<p>I'm at least not personally aware of any C/C++ host generator for WIT at this time. Not because it can't be done, though, just because it's work and that takes some time. Whether or not the C API itself or the C++ is the right way to go is somewhat up to you. I would ideally recommend Rust as embeddings of WebAssembly probably aren't dealing with trusted code and having as much safety as you can probably helps, but otherwise I'd recommend going with C++ to handle most of the resource management, such as strings into components, for you.</p>",
        "id": 355459866,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1683123846
    },
    {
        "content": "<p>we're going to need one. That doesn't mean the team here needs to provide it.</p>",
        "id": 355578993,
        "sender_full_name": "Ralph",
        "timestamp": 1683138654
    },
    {
        "content": "<p>This is something which I wouldn't mind taking a stab at and have some experience with ANTLR, code generators and associated IDE support.  Has anyone done an ANTLR grammar yet?</p>",
        "id": 355707819,
        "sender_full_name": "Gordon Smith",
        "timestamp": 1683191263
    },
    {
        "content": "<p>Oh. <span class=\"user-mention\" data-user-id=\"234973\">@Till Schneidereit</span> thank you for this interesting material. You can clearly see at <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/pull/2173\">https://github.com/bytecodealliance/wasm-micro-runtime/pull/2173</a> that there are problems with wamr as well...</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/pull/2173\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b7aa151202a8b5af508927b92e9bd022dab393ec\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633538643565626661636437646166633433356337666464333261626533323931633439643031633037373165613139333466383434303362343634623862332f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d652f70756c6c2f32313733)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/pull/2173\" title=\"Fix three threading+callback issues by cpetig · Pull Request #2173 · bytecodealliance/wasm-micro-runtime\">Fix three threading+callback issues by cpetig · Pull Request #2173 · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">Testcase is available at #2172 , fixes also #2149 and an unreported mistake in the original code I copied the fix from.</div></div></div>",
        "id": 355739431,
        "sender_full_name": "Christof Petig",
        "timestamp": 1683198638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268586\">Ralph</span> <a href=\"#narrow/stream/327223-wit-bindgen/topic/c.2Fc.2B.2B.20host.20generator.3F/near/355578993\">said</a>:</p>\n<blockquote>\n<p>we're going to need one. That doesn't mean the team here needs to provide it.</p>\n</blockquote>\n<p>Oh of course! And contributions are of course always welcome, and I think it's natural and inevitable to have wit-bindgen-generated-bindings for many languages, including C/C++!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"577690\">Gordon Smith</span> <a href=\"#narrow/stream/327223-wit-bindgen/topic/c.2Fc.2B.2B.20host.20generator.3F/near/355707819\">said</a>:</p>\n<blockquote>\n<p>Has anyone done an ANTLR grammar yet?</p>\n</blockquote>\n<p>Not currently, no. I'll say though that parsing WIT is the easy part, the code generation part is much more involved (in my personal opinion at least). Many code generators are currently written in Rust because all the WIT tooling is written in Rust right now. For example the wasmtime-py host generator is written in Rust and then compiled to WebAssembly to get run in Python.</p>",
        "id": 355792731,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1683210521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/stream/327223-wit-bindgen/topic/c.2Fc.2B.2B.20host.20generator.3F/near/355792731\">said</a>:</p>\n<blockquote>\n<p>Not currently, no. I'll say though that parsing WIT is the easy part, the code generation part is much more involved (in my personal opinion at least). Many code generators are currently written in Rust because all the WIT tooling is written in Rust right now. For example the wasmtime-py host generator is written in Rust and then compiled to WebAssembly to get run in Python.</p>\n</blockquote>\n<p>Shame ANTLR doesn't have target support for Rust, but it would be a nice single point of truth WRT the grammar.  Also it makes life a lot easier when creating support for things like VSCode extensions...</p>\n<p>Unfortunately, I haven't had time learn Rust, but wonder if a practical approach would be to \"simply\" generate the Rust host bindings and then expose them to c via the techniques outlined here: <br>\n<a href=\"https://docs.rust-embedded.org/book/interoperability/rust-with-c.html\">https://docs.rust-embedded.org/book/interoperability/rust-with-c.html</a>?</p>",
        "id": 355940671,
        "sender_full_name": "Gordon Smith",
        "timestamp": 1683263820
    },
    {
        "content": "<p>My hunch is that the \"simply\" would not be so simple there. The devil is in the details of memory management and understanding structures on the C/C++ side of things, so that would all still need to be taken care of</p>",
        "id": 356125532,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1683307699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577690\">Gordon Smith</span> <a href=\"#narrow/stream/327223-wit-bindgen/topic/c.2Fc.2B.2B.20host.20generator.3F/near/355940671\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, I haven't had time learn Rust, but wonder if a practical approach would be to \"simply\" generate the Rust host bindings and then expose them to c via the techniques outlined here: <br>\n<a href=\"https://docs.rust-embedded.org/book/interoperability/rust-with-c.html\">https://docs.rust-embedded.org/book/interoperability/rust-with-c.html</a>?</p>\n</blockquote>\n<p>Given that you started this thread with a link to the wamr specific host interface document, I feel that wrapping the Rust host binding for wasmtime in C++ won't help you that much. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> <br>\nI started a fork to create unified C API host targeted bindings at <a href=\"https://github.com/cpetig/wit-bindgen\">https://github.com/cpetig/wit-bindgen</a> and hope to get something simple ready during this weekend. This should work fine for host directed calls even with threads, but for calls into wasm some infrastructure argument will be necessary to use thread specific instances of the runtime. [We had our share of thread issues calling into wasmer on veloren, see #plugins for more details.]</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/c7e1d75211b5e5315707cde57362f8bd287a9f9e\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646532346561623239623130353533626462373539653063386133323538323961333530306464613137323437643232326363383833653530373038333636652f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen\" title=\"GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types\">GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types</div></div></div>",
        "id": 356304954,
        "sender_full_name": "Christof Petig",
        "timestamp": 1683379870
    },
    {
        "content": "<p>I ended up at the, probably expected, dead-end of trying to access the correct store from a callback in a portable way. <br>\nWhile I was able to get wasm calls and memory access working with multiple threads on wamr, and I was able to access the store from wasmer (FunctionEnvMut), you can't portably create a mere trap inside the callback. I see that wasmtime has provided its own solution to work around this (wasmtime_trap_new).</p>",
        "id": 356555084,
        "sender_full_name": "Christof Petig",
        "timestamp": 1683498295
    },
    {
        "content": "<p>I now have a fully working prototype of a multi-threaded guest program which calls host functions, some of which allocate memory via cabi_realloc - using the wamr native API. The code has become much more readable compared to the C API and can work without global variables. I will now continue work on my wit-bindgen backend for <em>this</em> environment.</p>",
        "id": 356794682,
        "sender_full_name": "Christof Petig",
        "timestamp": 1683573524
    }
]