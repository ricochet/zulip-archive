[
    {
        "content": "<p>I really love the more consistent system interface of preview2 (including wit-bindgen) over the old witx based one known as <code>wasi_snapshot_preview1</code>, but SDKs for C++ and Rust only support the old one, as does WAMR.</p>\n<p>I found a way to bend wasmtime's <code>wasi-preview1-component-adapter</code> into crating a static library which will redirect preview1 calls to preview2 - without requiring a component linker at runtime. Additionally linking to this library generates a normal wasm module (no component) using the newer APIs. <a href=\"/user_uploads/15107/t_8FimXY8-tKfePXo5hU7iGg/preview1_adapter.patch.gz\">preview1_adapter.patch.gz</a></p>\n<p>If you combine this with a wit-bindgen tailored towards generating a WAMR host stub (I have pieces of this ready in my fork at <a href=\"http://github.com/cpetig/wit-bindgen\">github.com/cpetig/wit-bindgen</a>) you get close to supporting preview2 APIs with manageable effort, that is without needing import/export alignment (#1353).</p>\n<p>I just wanted to share this information on how to use preview2 APIs in case it could be of help. </p>\n<p>PS: There is some indication that it might only work with C/++ SDK though due to the linker trick used to implement other-module imports.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"http://github.com/cpetig/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/7f0897f81fc528586a1a83381419203709bdcefb\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313931316263616539666162343935653831376261383464306534666635376431313438343162663733653533643561313864306664323166353739313337662f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"http://github.com/cpetig/wit-bindgen\" title=\"GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types\">GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - cpetig/wit-bindgen: A language binding generator for WebAssembly interface types</div></div></div>",
        "id": 379752247,
        "sender_full_name": "Christof Petig",
        "timestamp": 1690626468
    },
    {
        "content": "<p>Thanks for your contribution.</p>\n<p>IIUC,  the adapter, mentioned above,  is a kind of wrapper to bridge the original <code>wasi_snapshot_preivew1</code> import functions into new <code>wasi_snapshot_preview2</code> functions.  Therefore,  toolchains, like <em>wasm-tool component new</em>, are able to create a <em>component model file</em> from an existing <em>core WebAssembly</em> file.</p>\n<p>About the patch, <a href=\"https://github.com/bytecodealliance/wit-bindgen/commit/8ca4054013af612c4aca91a44c09dbfe455c73b2\">https://github.com/bytecodealliance/wit-bindgen/commit/8ca4054013af612c4aca91a44c09dbfe455c73b2</a>, I got some confusion on the concept level.</p>\n<ul>\n<li>the patch won't change the behavior of mentioned <em>adapter</em>. It actually changes the generation of host implementation. Generated \"host.cpp\" will include \"wasm_export.h\" additionally.</li>\n<li>Since \"wasm_export.h\" doesn't actually contain \"type\" information, I guess it is a trial to combine \"native symbol\" and \"component type\"</li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/commit/8ca4054013af612c4aca91a44c09dbfe455c73b2\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/90e69e676bf4866f0c7df4243b8f8712e12a20a3\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653164393835613232646332666162643531666435353139343733383033316537663536663661306630643930623239383764653433663835313936393739302f62797465636f6465616c6c69616e63652f7769742d62696e6467656e2f636f6d6d69742f38636134303534303133616636313263346163613931613434633039646266653435356337336232)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/commit/8ca4054013af612c4aca91a44c09dbfe455c73b2\" title=\"c host skeletal support · bytecodealliance/wit-bindgen@8ca4054\">c host skeletal support · bytecodealliance/wit-bindgen@8ca4054</a></div><div class=\"message_embed_description\">early smoke test\ncode reduction\ncleanup\nfmt\ncpp code skeleton\ncorrect file names\nstill working on understanding the structure\nworking typedef and struct\npascal case and enums\nbetter function names\n...</div></div></div>",
        "id": 381441865,
        "sender_full_name": "lum1n0us",
        "timestamp": 1691060983
    },
    {
        "content": "<p>This adapter library will, when linked to a wasm module using the normal wasi-SDK-20 (preview1 functions), redirect these calls to the preview2 functions (e.g. wasi:poll/poll.drop-pollable, wasi:clocks/monotonic-clock.subscribe) which use the modern canonical ABI - which wit-bindgen can create call bindings for, if you pass it the matching wit files.</p>\n<p>The c++ host code generator in my repository is far from complete, but once it is ready it would be able to generate matching bindgen code, with a function calling <code>wasm_runtime_register_natives</code> - the actual implementation of course needs to be provided by a host \"c library\". A plain C host code generator is also possible, I just needed C++ first.</p>",
        "id": 381617333,
        "sender_full_name": "Christof Petig",
        "timestamp": 1691099950
    },
    {
        "content": "<p><a href=\"/user_uploads/15107/kLC4_roMlfaxT0pOkmDRS7fl/poll_host_binding.tgz\">poll_host_binding.tgz</a><br>\nThis archive contains the generated bindings for the new poll interface - the implementation of the functions is out of scope for this tool.</p>",
        "id": 381617918,
        "sender_full_name": "Christof Petig",
        "timestamp": 1691100144
    },
    {
        "content": "<p>(oh, I see that the poll_oneoff function's binding is still incomplete, I later learned that I need to connect it to the cabi module of wit-parser)</p>",
        "id": 381618638,
        "sender_full_name": "Christof Petig",
        "timestamp": 1691100390
    },
    {
        "content": "<p>But my original intention was to tell how to create a module which imports preview2 functions and which tool helps with creating the host implementation.</p>",
        "id": 381618802,
        "sender_full_name": "Christof Petig",
        "timestamp": 1691100434
    },
    {
        "content": "<p>Also compared to <code>wasm-tool component new --adapt</code> this method still creates a single module - not a component of modules with linking information. Wamr can't parse components, but modules work.</p>",
        "id": 381619392,
        "sender_full_name": "Christof Petig",
        "timestamp": 1691100592
    },
    {
        "content": "<p>does this mean to make wamr implement core-wasm level abi directly?</p>",
        "id": 393599658,
        "sender_full_name": "YAMAMOTO Takashi",
        "timestamp": 1695867036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"567999\">YAMAMOTO Takashi</span> <a href=\"#narrow/stream/290350-wamr/topic/WASI.20preview2.20with.20WAMR.2C.20more.20easily/near/393599658\">said</a>:</p>\n<blockquote>\n<p>does this mean to make wamr implement core-wasm level abi directly?</p>\n</blockquote>\n<p>I think the answer is more complicated than I originally expected.</p>\n<p>I was able to get parts of WASI preview2 working with WAMR using several workarounds:</p>\n<ul>\n<li>as long as the resulting binary is still a single module and not a component it can be loaded into the current WAMR without full component model support (new binary format, one linear memory per module and a linker implementation)</li>\n<li>using a modified preview2 adapter from wasmtime compiled as a static library I was able to get a <em>module</em> which only uses preview2 interfaces using the normal wasi-sdk (preview2 is still a moving target, resources were added last week)</li>\n<li>I can create C++ wamr host bindings using my wit-bindgen fork (very much work in progress), generating the bindings for WASI preview2 should be possible soon</li>\n<li>but the largest gap would be the implementation of the new WASI calls using libc-uvwasi</li>\n</ul>\n<p>PS: Perhaps <a href=\"https://github.com/DouglasDwyer/wasm_component_layer\">https://github.com/DouglasDwyer/wasm_component_layer</a> can offer some more short cuts towards component model support.<br>\nPPS: WASI preview2 feels much more portable and coherent in comparison to preview1, preview1 still was very POSIX centric and I never fully grasped the witx to binding rules (e.g. when results are mapped to integers).</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/DouglasDwyer/wasm_component_layer\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/02b4420d6301ec9bc8ccee1870276dbe248e58eb\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353532326165333965613963623536393830643038666133343861353061303561363930646335343930343261323535313239333733643464313065303563322f446f75676c617344777965722f7761736d5f636f6d706f6e656e745f6c61796572)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/DouglasDwyer/wasm_component_layer\" title=\"GitHub - DouglasDwyer/wasm_component_layer: WebAssembly component model implementation for any backend.\">GitHub - DouglasDwyer/wasm_component_layer: WebAssembly component model implementation for any backend.</a></div><div class=\"message_embed_description\">WebAssembly component model implementation for any backend. - GitHub - DouglasDwyer/wasm_component_layer: WebAssembly component model implementation for any backend.</div></div></div>",
        "id": 394520539,
        "sender_full_name": "Christof Petig",
        "timestamp": 1696284829
    },
    {
        "content": "<p>what your single module imports is the canon-abi projection of preview2 (or whatever wit-defined interfaces) and wamr needs to provide the abi to make it work, right? it's what i meant by \"implement core-wasm level abi directly\".</p>",
        "id": 394558966,
        "sender_full_name": "YAMAMOTO Takashi",
        "timestamp": 1696307903
    },
    {
        "content": "<p>Yes, is C++ an option for the host side (you can see how easy an implementation is in my resource demo repo) or would you need plain C? <br>\nI have been toying with extending wit-bindgen to create resource bindings for a C wamr host, but this is very low priority for now.</p>",
        "id": 394581995,
        "sender_full_name": "Christof Petig",
        "timestamp": 1696320442
    },
    {
        "content": "<p>ok. ideally we need plain C i guess.</p>",
        "id": 394957118,
        "sender_full_name": "YAMAMOTO Takashi",
        "timestamp": 1696477193
    },
    {
        "content": "<p>I am currently rewriting the c++ code generation from scratch (copying over only the necessary code from the previous implementation), later I will also take a look into C for resources on the host, but I don't expect a full solution ready within this month.</p>",
        "id": 394971196,
        "sender_full_name": "Christof Petig",
        "timestamp": 1696486378
    },
    {
        "content": "<p>Update: The rewrite can already create correct guest C++ code. Host code needs more work. </p>\n<p>And I just uploaded a statically linkable preview2 adapter to <a href=\"https://github.com/cpetig/wasmtime-adapter\">https://github.com/cpetig/wasmtime-adapter</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wasmtime-adapter\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/bae23093cb8f89bdbc5e888759a065dbdaf277e5\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f326566323639373439663231343133303462646562396663646338346335396461326261663137643336323361386635393537666663616633306335343738612f6370657469672f7761736d74696d652d61646170746572)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wasmtime-adapter\" title=\"GitHub - cpetig/wasmtime-adapter: Preview2 adapter forked from wasmtime\">GitHub - cpetig/wasmtime-adapter: Preview2 adapter forked from wasmtime</a></div><div class=\"message_embed_description\">Preview2 adapter forked from wasmtime. Contribute to cpetig/wasmtime-adapter development by creating an account on GitHub.</div></div></div>",
        "id": 401612861,
        "sender_full_name": "Christof Petig",
        "timestamp": 1699794855
    },
    {
        "content": "<p>Also  so far I was unable to test the adapter, because wasmtime doesn't yet implement all of the preview2 interfaces used by the adapter. I will give it another try with jco, but that will take time.</p>\n<p>Ideally this adapter would consist of multiple (object) files, so that only used interfaces are linked in. wasm-opt (binaryen) can reduce unused dependencies for now.</p>",
        "id": 401612932,
        "sender_full_name": "Christof Petig",
        "timestamp": 1699794949
    },
    {
        "content": "<p>Please feel free to correct me.  Just want to be very clear about the functionality of <em>lwasi_snapshot_preview1</em>. </p>\n<p><a href=\"/user_uploads/15107/Z9ZKhSOF9cXHaPE1F7JqHFEv/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/Z9ZKhSOF9cXHaPE1F7JqHFEv/image.png\" title=\"image.png\"><img src=\"/user_uploads/15107/Z9ZKhSOF9cXHaPE1F7JqHFEv/image.png\"></a></div>",
        "id": 401877557,
        "sender_full_name": "lum1n0us",
        "timestamp": 1699924683
    },
    {
        "content": "<p>I would stack it differently :<br>\nC hello world<br>\nWasi sdk libc.a<br>\nLibwasi_snapshot_preview2.a<br>\n=&gt; a single classical module importing preview2 interfaces, you can still use wabt on this</p>\n<p>While the traditional way is to use the classical preview1 module with the Wasi snapshot preview2 module into a component (of two modules) with preview2 interfaces, you can only use wasm-tools to inspect this binary</p>",
        "id": 401920354,
        "sender_full_name": "Christof Petig",
        "timestamp": 1699945951
    },
    {
        "content": "<p>I successfully tested the resulting binary with wasmtime, although I need to create a component out of it. If you want to take a look, here is a C hello world compiled with wasi-SDK 20. Due to linking with the adapter it imports only preview2 interfaces, but is still a normal module.<br>\n<a href=\"/user_uploads/15107/REZULo-YQka4TEYQs37LW9dz/test_r.wasm\">test_r.wasm</a><br>\nAnd I just uploaded the used static adapter libraries to <a href=\"https://github.com/cpetig/wasmtime-adapter/releases/tag/2023-11-15\">https://github.com/cpetig/wasmtime-adapter/releases/tag/2023-11-15</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wasmtime-adapter/releases/tag/2023-11-15\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/048df0ec475d150a4d7851ce92d47647af17190c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f306137336338323339386565616634646231643130616336663333306337656538663437383862313362616638316533393738393930383831353030373636372f6370657469672f7761736d74696d652d616461707465722f72656c65617365732f7461672f323032332d31312d3135)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wasmtime-adapter/releases/tag/2023-11-15\" title=\"Release Initial binary release · cpetig/wasmtime-adapter\">Release Initial binary release · cpetig/wasmtime-adapter</a></div><div class=\"message_embed_description\">Preview2 adapter forked from wasmtime. Contribute to cpetig/wasmtime-adapter development by creating an account on GitHub.</div></div></div>",
        "id": 402320989,
        "sender_full_name": "Christof Petig",
        "timestamp": 1700079748
    },
    {
        "content": "<p>That's great. Would u mind uploading an introduction/guide to <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/tree/main/doc\">WAMR repo doc</a>.</p>",
        "id": 402588142,
        "sender_full_name": "lum1n0us",
        "timestamp": 1700182542
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> I feel this adds most value once you can also easily implement preview2 interfaces in wamr, which is exactly what I plan to add to wit bindgen (host side C or C++ with wamr function registration) in the upcoming weeks.<br>\nI had this working for C++ and a small wit subset, but the code became too awkward before the ongoing rewrite to use more of bindgen's core for lowering and lifting logic.</p>",
        "id": 402846818,
        "sender_full_name": "Christof Petig",
        "timestamp": 1700293908
    },
    {
        "content": "<p>if we can provide any help, do let us know. This is an area where I have \"interested parties\"</p>",
        "id": 403638569,
        "sender_full_name": "Ralph",
        "timestamp": 1700674897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268586\">Ralph</span> <a href=\"#narrow/stream/290350-wamr/topic/WASI.20preview2.20with.20WAMR.2C.20more.20easily/near/403638569\">said</a>:</p>\n<blockquote>\n<p>if we can provide any help, do let us know. This is an area where I have \"interested parties\"</p>\n</blockquote>\n<p>I find it quite hard to predict the next steps for the code generation, as I basically rewrote my initial C++ code generation to use a <code>Bindgen</code>interface for lowering and lifting. It works for very simple types (e.g. <a href=\"https://github.com/cpetig/resource-demo\">https://github.com/cpetig/resource-demo</a> ) but structured data types are in progress. Please keep in mind that this code supports both the guest and host side (previously this was a separated crate with lots of code duplication).</p>\n<p>The difference between importing and exporting resources is more complex than I initially thought. And the variety of data structures and encoding rules (flattening, variants) adds complexity as well.</p>\n<p>You can find the current state of the rewrite at <a href=\"https://github.com/cpetig/wit-bindgen\">https://github.com/cpetig/wit-bindgen</a> while the non-resource older version is at <a href=\"https://github.com/cpetig/wit-bindgen/tree/old\">https://github.com/cpetig/wit-bindgen/tree/old</a> .</p>\n<p>Also the mapping to C++ is very interesting as Result is supported in C++23, move semantics map to rvalue references (forwarding references) and how to generate user objects (exporting resources) is difficult to balance. I have iterated between abstract base classes, private Implementation and including user classes in generated code; I like the last solution best.</p>\n<p>My guess is that I should have a starting point within a few days and then missing parts could be parallelized. Feel free to already take a look and propose solutions.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/resource-demo\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/1272e7b621ba578c8a1d5916cc946dfa93b6acdd\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343563366630636234366464636232623837326430303436666132393965653830383434633064626531643161376333353264636437393366383635623834332f6370657469672f7265736f757263652d64656d6f)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/resource-demo\" title=\"GitHub - cpetig/resource-demo: A demo showing WASM component model resources in various environments\">GitHub - cpetig/resource-demo: A demo showing WASM component model resources in various environments</a></div><div class=\"message_embed_description\">A demo showing WASM component model resources in various environments - GitHub - cpetig/resource-demo: A demo showing WASM component model resources in various environments</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/58ccc484406a74c288c593c714496fb9e2c852b7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333430646333626537373039646661343630343461306163343661623565616166616637303433346534616366633436333761646666373733633961636465332f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen\" title=\"GitHub - cpetig/wit-bindgen: A (C++) language binding generator for WebAssembly interface types\">GitHub - cpetig/wit-bindgen: A (C++) language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A (C++) language binding generator for WebAssembly interface types - GitHub - cpetig/wit-bindgen: A (C++) language binding generator for WebAssembly interface types</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen/tree/old\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/58ccc484406a74c288c593c714496fb9e2c852b7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333430646333626537373039646661343630343461306163343661623565616166616637303433346534616366633436333761646666373733633961636465332f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen/tree/old\" title=\"GitHub - cpetig/wit-bindgen at old\">GitHub - cpetig/wit-bindgen at old</a></div><div class=\"message_embed_description\">A (C++) language binding generator for WebAssembly interface types - GitHub - cpetig/wit-bindgen at old</div></div></div>",
        "id": 403681531,
        "sender_full_name": "Christof Petig",
        "timestamp": 1700696690
    },
    {
        "content": "<p>I posted an update at <a href=\"#narrow/stream/394175-SIG-Guest-Languages/topic/C.2B.2B.20language.20binding/near/404294769\">https://bytecodealliance.zulipchat.com/#narrow/stream/394175-SIG-Guest-Languages/topic/C.2B.2B.20language.20binding/near/404294769</a> , now even more complex data types are stubbed but already generated for C++ host.</p>\n<p><span class=\"user-mention\" data-user-id=\"268586\">@Ralph</span> would C++ be a potential solution or do you need plain C host code?<br>\nAt least the code to register host functions is operational with C++ (although most data types aren't correctly mapped to wamr character notation, yet).</p>",
        "id": 404295067,
        "sender_full_name": "Christof Petig",
        "timestamp": 1701037411
    },
    {
        "content": "<p>I promised an update on the progress here.  <span class=\"user-mention\" data-user-id=\"614853\">@Ayako Akasaka</span> <span class=\"user-mention\" data-user-id=\"234973\">@Till Schneidereit</span> <span class=\"user-mention\" data-user-id=\"569438\">@Thomas Trenner</span>  (I wasn't quick enough to write down all interested names from the chat before the eSIG call ended, so I hope I remember you correctly)</p>\n<p>The C++ bindgen in the <a href=\"https://github.com/cpetig/wit-bindgen\">repo above</a> targets WAMR when using the <code>--host</code> CLI switch. Very simple WIT setups generate fully usable code, see the <a href=\"https://github.com/cpetig/wit-bindgen/issues\">issues</a> for known deficiencies.</p>\n<p>I found the support for data types and resource support much more complex than anticipated last year, so I am nowhere near ready, but with the recent improvements I will give the WASI WITs another try and report back here.</p>\n<p>Using the <a href=\"https://github.com/cpetig/wasmtime-adapter\">wasmtime-adapter</a> you can already create p1 modules using the p2 WASI interfaces, but these of course can't conpose of several modules, unless you create a component. This file format isn't recognized by WAMR, yet. And it would require multi-memory support (or more specific \"one memory per module inside the component\" support), a shared everything object could create a shortcut here, but this hasn't been investigated into … although I have been using shared objects for natively compiled components <a href=\"https://github.com/cpetig/wit-bindgen/tree/main/crates/cpp/tests/native_resources\">successfully</a>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/c9f30a02c80e9742791dd30538eea8b706781cf7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663761653365373736356263636265346536313337313262323839313331633737373461306630323565623663653534316339373939333030613733373130662f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen\" title=\"GitHub - cpetig/wit-bindgen: A (C++) language binding generator for WebAssembly interface types\">GitHub - cpetig/wit-bindgen: A (C++) language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A (C++) language binding generator for WebAssembly interface types - cpetig/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen/issues\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/c9f30a02c80e9742791dd30538eea8b706781cf7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663761653365373736356263636265346536313337313262323839313331633737373461306630323565623663653534316339373939333030613733373130662f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen/issues\" title=\"Issues · cpetig/wit-bindgen\">Issues · cpetig/wit-bindgen</a></div><div class=\"message_embed_description\">A (C++) language binding generator for WebAssembly interface types - Issues · cpetig/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wasmtime-adapter\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/cdf321a68fff15595c7c644a96858a1d84850a55\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333638303534313536616161306636336133616330633266343730346530373763313365306538393430613035373936323134326664623835656536396133662f6370657469672f7761736d74696d652d61646170746572)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wasmtime-adapter\" title=\"GitHub - cpetig/wasmtime-adapter: Preview2 adapter forked from wasmtime\">GitHub - cpetig/wasmtime-adapter: Preview2 adapter forked from wasmtime</a></div><div class=\"message_embed_description\">Preview2 adapter forked from wasmtime. Contribute to cpetig/wasmtime-adapter development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cpetig/wit-bindgen/tree/main/crates/cpp/tests/native_resources\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/c9f30a02c80e9742791dd30538eea8b706781cf7\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663761653365373736356263636265346536313337313262323839313331633737373461306630323565623663653534316339373939333030613733373130662f6370657469672f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cpetig/wit-bindgen/tree/main/crates/cpp/tests/native_resources\" title=\"wit-bindgen/crates/cpp/tests/native_resources at main · cpetig/wit-bindgen\">wit-bindgen/crates/cpp/tests/native_resources at main · cpetig/wit-bindgen</a></div><div class=\"message_embed_description\">A (C++) language binding generator for WebAssembly interface types - cpetig/wit-bindgen</div></div></div>",
        "id": 432357283,
        "sender_full_name": "Christof Petig",
        "timestamp": 1712704256
    },
    {
        "content": "<p>Thank you for updateing the information about C++ bindgen . <span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span> </p>\n<blockquote>\n<p>I found the support for data types and resource support much more complex than anticipated last year, so I am nowhere &gt;  near ready, but with the recent improvements I will give the WASI WITs another try and report back here.</p>\n</blockquote>\n<p>I would be happy if you could someday explain the difficult points while looking at the code in  e-SIG meeting or maybe tomorrow's meeting or..  some other meeting</p>",
        "id": 435417468,
        "sender_full_name": "Ayako Akasaka",
        "timestamp": 1714059609
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"614853\">@Ayako Akasaka</span> <br>\nThe problem basically was that I didn't expect the complexity of resources to be that high. It took me several tries to understand how guest exported resources are handled on the canonical ABI level. And then I had to implement both the guest and host side for both guest and host based resources. But today I got close to having working host bindings for resources, in the most simple case.</p>\n<p>Also I ran into the exact same problem as Rust when it comes to references and ownership: Shall an <code>option&lt;list&lt;u8&gt;&gt;</code> argument map to <code>optional&lt;std::vector&lt;uint8_t&gt; const&amp;</code> or <code>optional&lt;std::span&lt;uint8_t&gt;&gt; const&amp;</code>- or even define its own struct types. This gets more interesting once you put resources in the vector - because you might not have a vector of the right type around to pass to the function.</p>",
        "id": 437153865,
        "sender_full_name": "Christof Petig",
        "timestamp": 1714934629
    },
    {
        "content": "<blockquote>\n<p>a shared everything object could create a shortcut here, but this hasn't been investigated into …</p>\n</blockquote>\n<p><a href=\"https://github.com/lum1n0us/about_shared_everything_linking/blob/main/example/build.sh\"><code>wasm-tools component link</code></a> will create a <em>component</em> in which all <em>core instances</em> share one memory.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/lum1n0us/about_shared_everything_linking/blob/main/example/build.sh\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/89dd6744fe9ab0d7ba07939f3100afc1bba1341f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633638353933396366316166393061663866376562623832333731313936643861383437336532393232383164613161383433303438373464346237343438622f6c756d316e3075732f61626f75745f7368617265645f65766572797468696e675f6c696e6b696e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/lum1n0us/about_shared_everything_linking/blob/main/example/build.sh\" title=\"about_shared_everything_linking/example/build.sh at main · lum1n0us/about_shared_everything_linking\">about_shared_everything_linking/example/build.sh at main · lum1n0us/about_shared_everything_linking</a></div><div class=\"message_embed_description\">Contribute to lum1n0us/about_shared_everything_linking development by creating an account on GitHub.</div></div></div>",
        "id": 437751227,
        "sender_full_name": "lum1n0us",
        "timestamp": 1715215081
    },
    {
        "content": "<p>To further precise my statement: I am not aware of any attempt to combine the canonical ABI with shared everything linking on wasm to get wamr compatible core modules. I just know about my above mentioned PoC with native binaries.</p>\n<p>I think that this would be a good way to support components in wamr without requiring <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\">https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353</a> and full wasip2 binary format support. These components would be source code identical to wasip2 but use a different file format. </p>\n<p>(this compilation target I would associate with the name wasit2)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/65066f25f19e5e390b23eb9a2c9c2c9f7dbeace0/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f656132643161656438306164386130636136356563383464303139333239666331303433643637653831333433313331356338316632633733353338663061382f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d652f6973737565732f31333533&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\" title=\"import/export issue · Issue #1353 · bytecodealliance/wasm-micro-runtime\">import/export issue · Issue #1353 · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">i wrote a test case to experiment memory import. (see below) my intention is to share a single \"mem\" instance. i believe it's the spec-wise correct behavior. it works as i expected for other engine...</div></div></div>",
        "id": 437763233,
        "sender_full_name": "Christof Petig",
        "timestamp": 1715225651
    },
    {
        "content": "<p>I really need to look into <code>component link</code>, I haven't used it before, and I can't tell which type of input and output files are supported.</p>",
        "id": 437763427,
        "sender_full_name": "Christof Petig",
        "timestamp": 1715225842
    },
    {
        "content": "<p>I just looked into <code>component link</code> and found that it won't merge modules, it will just stack them inside a component and create another module redirecting and listing the calls. I feel a shared everything dynamic link object of this type could help with component model implementations for wamr, where you want to combine pre-linked binaries at load time.</p>\n<p>In this case the .wasm component would contain one classical app and multiple shared everything dynamic objects and simply act as a container for these files, with linking information.</p>\n<p>I now understand that wamr's inability to import memory <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\">https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353</a> will also prevent shared dynamic linking as described in <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\">https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md</a> - thus there is no easier solution, right?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/65066f25f19e5e390b23eb9a2c9c2c9f7dbeace0/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f656132643161656438306164386130636136356563383464303139333239666331303433643637653831333433313331356338316632633733353338663061382f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d652f6973737565732f31333533&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/issues/1353\" title=\"import/export issue · Issue #1353 · bytecodealliance/wasm-micro-runtime\">import/export issue · Issue #1353 · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">i wrote a test case to experiment memory import. (see below) my intention is to share a single \"mem\" instance. i believe it's the spec-wise correct behavior. it works as i expected for other engine...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/833510db034ba9f33b12ae50e7c6852c36822f0c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f366337393230626537383563636138376362633930353036633239353663346662613737366330353662616337373838323061633966303562616630393837382f576562417373656d626c792f746f6f6c2d636f6e76656e74696f6e73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\" title=\"tool-conventions/DynamicLinking.md at main · WebAssembly/tool-conventions\">tool-conventions/DynamicLinking.md at main · WebAssembly/tool-conventions</a></div><div class=\"message_embed_description\">Conventions supporting interoperatibility between tools working with WebAssembly. - WebAssembly/tool-conventions</div></div></div>",
        "id": 438205366,
        "sender_full_name": "Christof Petig",
        "timestamp": 1715540773
    }
]