[
    {
        "content": "<p>Hi all, we are going to have a WAMR open TSC meeting. This time we will be focused on the topic of moving WASI to component model:<br>\n<a href=\"https://github.com/WebAssembly/WASI/pull/549\">https://github.com/WebAssembly/WASI/pull/549</a>.</p>\n<p>Anyone who is interested in this topic is welcome to join the meeting.</p>\n<p>Meeting Bridge info: <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/wiki/TSC-meeting-notes#wamr-tsc-meeting-2023-08-29-900-am-utc\">https://github.com/bytecodealliance/wasm-micro-runtime/wiki/TSC-meeting-notes#wamr-tsc-meeting-2023-08-29-900-am-utc</a></p>\n<p>Sorry for that the meeting time is bad for US timezone, we will make video record. Please be free to forward the invitation.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/WASI/pull/549\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/a35bf12b7ff522b6cd13a54ed17983ba01681250\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303663386137393632333339363566393532313064613731336562323963383664613934363163623133636235653835386237393766373530343562633030312f576562417373656d626c792f574153492f70756c6c2f353439)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/WASI/pull/549\" title=\"Rebase the Phase Process description on the CG's current process by sunfishcode 路 Pull Request #549 路 WebAssembly/WASI\">Rebase the Phase Process description on the CG's current process by sunfishcode 路 Pull Request #549 路 WebAssembly/WASI</a></div><div class=\"message_embed_description\">The CG Phase Process document has recently split out the entry requirements for each stage from the activities that happen within each stage, fixing an ambiguity about what happens before a stage a...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/wiki/TSC-meeting-notes#wamr-tsc-meeting-2023-08-29-900-am-utc\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/6ca1ea6af75ff1ccef2b96d0907bf9c8540b6c58\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f316533376562303534333833393463623231626234323238663465643063313234313132626331363164373030656337383935366563623532373061663439322f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/wiki/TSC-meeting-notes#wamr-tsc-meeting-2023-08-29-900-am-utc\" title=\"TSC meeting notes\">TSC meeting notes</a></div><div class=\"message_embed_description\">WebAssembly Micro Runtime (WAMR). Contribute to bytecodealliance/wasm-micro-runtime development by creating an account on GitHub.</div></div></div>",
        "id": 387585123,
        "sender_full_name": "Wang Xin",
        "timestamp": 1693189901
    },
    {
        "content": "<p>Thank you for the excellent presentation. </p>\n<p>Let me bring several questions here. Sorry if I was missing your explanation</p>\n<ol>\n<li>I really want to have dynamic linking for tiny devices. Presentation said Shared memory will be achieved by WasmGC or mem.ref, but will it be possible to provide natural I/F for the Wasm module developer? And is it possible to share only a part of memory?  </li>\n<li>I fail to understand which part of the component model spec consumes a footprint. Multi-memory feature?</li>\n<li>I want to agree with the co-existence of the preview1 module and preview2 component. I guess WasmCG is also promoting this way. Is there any blocker to this idea? </li>\n<li>Who is going to share the performance measurement data? without data, no one can judge, right?</li>\n</ol>",
        "id": 387855544,
        "sender_full_name": "Ayako Akasaka",
        "timestamp": 1693305887
    },
    {
        "content": "<p>I may not be the best person to answer, but just to provide a few partial answers:</p>\n<ol>\n<li>I'm not aware of how to use WasmGC to achieve better performance or less runtime footpring vs. the Component Model for dynamic linking or passing data between modules using linear memory languages (e.g., for C, C++, Go, Rust, ...): you'll need to copy from linear memory to GC memory or vice versa or both, and this can end up doing more total copies than the Component Model (in addition to generating garbage).  Additionally, if runtime footprint is a concern, WasmGC will have significantly more impact than the Component Model.  Separately, on the topic of mem.ref: because most linear-memory languages don't have a good language-native way to refer to multiple memories at the same time, I think mem.ref will end up having a similar amount of copying as the Component Model in practice (but without the benefit of a static component signature to enable tooling and virtualization).</li>\n<li>A single component containing a single core module should have essentially the same runtime behavior/footprint as just the core module (if the preview1-to-2 adapter is used, that will add overhead, but our goal is to have wasi-libc target preview2 directly, avoiding the need for this adapter).  Two linked components (each containing a core module) can be fused into a single core module embedding both original core modules (therefore, with multiple memories) plus a small amount of additional synthesized wasm thunks that sit in-between the two original core modules and perform the copying between memories.  It's not clear if this should be considered \"overhead\", though, since the component model still enables you to link multiple .o's, .a's or .wasm's that want to share memory into a single component with a single memory (using wasm-ld, the same as with core wasm today).  Thus, these multi-component scenarios represent new use cases, not regressions on existing use cases.</li>\n<li>Yes, I think co-existence is possible and expected, in two ways: (1) engines can support both preview1 modules and preview2 components at the same time (Wasmtime is), (2) new preview2 interfaces specified in Wit can be translated to equivalent Witx interfaces by applying the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\">Canonical ABI</a> to the Wit, allowing single core modules to execute using new Preview2 interfaces.</li>\n</ol>",
        "id": 387934896,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1693331832
    },
    {
        "content": "<p>meeting notes and shared materials: <a href=\"https://github.com/bytecodealliance/meetings/blob/main/wamr/2023/wamr-08-29.md\">https://github.com/bytecodealliance/meetings/blob/main/wamr/2023/wamr-08-29.md</a></p>",
        "id": 388040390,
        "sender_full_name": "Wang Xin",
        "timestamp": 1693376929
    },
    {
        "content": "<p>good stuff. I believe my MegaCorp can use wamr in some key situations with wasi/components, so I am really looking forward to this, and to contributing code to wamr as well.</p>",
        "id": 388054256,
        "sender_full_name": "Ralph",
        "timestamp": 1693383351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"614853\">@Ayako Akasaka</span>, <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span>   I would like to share the understanding on performance impacts from my recently study and I may be wrong. We should distinguish two major situations here:</p>\n<ol>\n<li><strong>Using single memory</strong> for static linking or shared everything dynamic linking.  It doesn't require data copy between two memories, so it is the fastest approach, however the problem is it is mostly limited to C/C++/Rust today.  </li>\n<li><strong>Using two memories</strong>: this enables isolation and multi-langauges interoperation, and doing data copy between two memories seems a neccessary cost. In WAMR's dynamical linking implementation, we basically copy stack args between two instances for a inter-module call. The cost for implementing the exact method defined in component model proposal may largely depend on the runtime design technique.   For example I am curious whether the wasmtime can quickly copy the list/string data without bearing the burden of refering meta  data type for every call.</li>\n</ol>\n<p>About using WasmGC for two memories case, if I remember it correctly, WasmGC operation is between the wasm stack and gc object, linear memory is not involved. Assuming the GC objects are located a global heap managed by the runtime and handles can be shared by multiple instances, the execution path for passing data will be short.  On another hand, component will require malloc and free in the linear memory some times, like when flatten argments is more than the max number (15) or types list/string is used in the function type. If the function body is short execution, then malloc/free could be a big overhead. In such situation, WasmGC is expected to be more efficient.</p>",
        "id": 388120653,
        "sender_full_name": "Wang Xin",
        "timestamp": 1693404851
    },
    {
        "content": "<p><strong>Single memory based linking</strong> is probably not what component model intends to address and actually it is more relavent to the compiler toolchain.  But single memory based linking is always important usage in my view, in some situations either per-module isolation or multi-languages is not that critical but performance can be critical in the most time. I am hoping it can be also covered in the CM proposal. A big reason is after WASI is turned to CM,  people will start to develop and ship components since their work eventually  has dependency on WASI. Given everything is component, it will be great and also important that we can reuse shared components from registry service for doing static linking of Wasm.</p>",
        "id": 388124412,
        "sender_full_name": "Wang Xin",
        "timestamp": 1693405745
    },
    {
        "content": "<p>Those are great points <span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span>.  I agree with your description of the two major cases and that both are important to support well in the toolchain when producing components that use WASI.  I also think that, while more work may be required to flesh out and polish, we can support both very well, including reuse of shared-everything libraries distributed as core modules in a registry.  I also think that good support of both will be important not just for WAMR and embedded use cases, but for plenty of other use cases across the wasm ecosystem as well, ultimately giving developers more choices for how to build their applications.</p>\n<p>That is an interesting use case for WasmGC that I hadn't considered, thanks for explaining.  My expectation is that the &gt;15-flattened-parameter case will be relatively rare, and that the majority of Wit functions will flatten to a small number of parameters that point into linear memory for any variable-sized (list or string) parameters.  Moreover, even in these many-parameter cases, due to strong spatial and temporal locality, I expect the cost of copying parameters between linear memories would be low and amortized by the cost of the overall call.  That being said, if we were to find the use of WasmGC to be a measurable win, the design of lifting and lowering in the Component Model allow us to add WasmGC as an additional canonical ABI option (<code>canonopt</code> in the grammar) in an interoperable, backwards-compatible manner in the future.</p>\n<blockquote>\n<p>The cost for implementing the exact method defined in component model proposal may largely depend on the runtime design technique. For example I am curious whether the wasmtime can quickly copy the list/string data without bearing the burden of refering meta data type for every call.</p>\n</blockquote>\n<p>You're right, it does depend on the implementation technique.  In the current implementation, Wasmtime's AOT \"fusion\" of lifting+lowering adapters avoids any use of type metadata at runtime, by construction: fusion essentially produces a single loop for every <code>list</code> in the function type that reads from the source linear memory, performs any data-type coercion or validation, and writes directly into the destination linear memory, all guided by the type and the <code>canonopt</code>s of the lifting and lowering side, which are also statically known at AOT compilation time.</p>",
        "id": 388129602,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1693407037
    },
    {
        "content": "<p>I have some doubts about the two allocations per call constant overhead of poll_oneoff, especially when used frequently for async signaling. I wish it would be able to receive a borrow&lt;list&gt; <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> and return a bit flag in the common &lt;64 descriptor case.</p>",
        "id": 388178687,
        "sender_full_name": "Christof Petig",
        "timestamp": 1693422543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span> I agree; I've also suggested changing that particular interface, and we still can in the Preview 2 timeframe.  Dan is already talking about changing wasi-poll in <a href=\"https://github.com/WebAssembly/wasi-poll/issues/22\">this</a> issue, so maybe comment there with what you'd like to see.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/wasi-poll/issues/22\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/cdb87a5888d1f932ebbca4d82547c1f8255477fd\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663061646436623231633035633734616161303764346666393431356132623337303033373433666263373232373865386633633237323436376365663139322f576562417373656d626c792f776173692d706f6c6c2f6973737565732f3232)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/wasi-poll/issues/22\" title=\"Rename poll_oneoff to poll_list, add poll_one 路 Issue #22 路 WebAssembly/wasi-poll\">Rename poll_oneoff to poll_list, add poll_one 路 Issue #22 路 WebAssembly/wasi-poll</a></div><div class=\"message_embed_description\">The name \"oneoff\" was never very evocative, so I propose we rename it to poll_list because it polls a list of pollables. Also, for convenience because it's a common case when writing simple example...</div></div></div>",
        "id": 388207700,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1693435460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> <a href=\"#narrow/stream/290350-wamr/topic/WAMR.20Open.20TSC.20meeting.20-.202023-08-29.20.209.3A00.20AM.28UTC.29/near/388178687\">said</a>:</p>\n<blockquote>\n<p>I have some doubts about the two allocations per call constant overhead of poll_oneoff, especially when used frequently for async signaling. I wish it would be able to receive a borrow&lt;list&gt; <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> and return a bit flag in the common &lt;64 descriptor case.</p>\n</blockquote>\n<p>Oh, I realize I confused im- and export ABIs, for imported functions a list argument is borrowed by default. So the allocation happens only for the result, overriding a one time result for cabi_realloc like in the adapter would be possible but still adds overhead.</p>",
        "id": 388547341,
        "sender_full_name": "Christof Petig",
        "timestamp": 1693581905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span> <br>\nThank you for your answer. then let me clarify this part.</p>\n<blockquote>\n<p><strong>Single memory based</strong> linking is probably not what component model intends to address and actually it is more relavent to the compiler toolchain. But single memory based linking is always important usage in my view, in some situations either per-module isolation or multi-languages is not that critical but performance can be critical in the most time. I am hoping it can be also covered in the CM proposal.</p>\n</blockquote>\n<p><a href=\"https://github.com/WebAssembly/wasi-libc/pull/429\">wasi-libc shared library support</a> is what you are saying as \"Single memory based linking\". isn't it? <br>\nIsn't this within the scope of the Component Model's module-linking specification? <br>\nFrom the previous <a href=\"https://github.com/WebAssembly/component-model/issues/74#issuecomment-1624008424\">answer</a>, componentize-py is using the same <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\">method</a>, I thought this was the method implicitly, just because it wasn't explicitly stated.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/wasi-libc/pull/429\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/ea2d28f319592f827d2c66a16f97e2f0e665193a\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f366665393866323764313438323263346461643533623532336664363963396135326465323839356666383234623065313932353832363564393765636364612f576562417373656d626c792f776173692d6c6962632f70756c6c2f343239)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/wasi-libc/pull/429\" title=\"add shared library support by dicej 路 Pull Request #429 路 WebAssembly/wasi-libc\">add shared library support by dicej 路 Pull Request #429 路 WebAssembly/wasi-libc</a></div><div class=\"message_embed_description\">This adds support for building WASI shared libraries per https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md.\nFor the time being, the goal is to allow \"pseudo-dynamic\" linki...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/74#issuecomment-1624008424\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/95a22b745c02cc787520da8a1d45ad1080217ee8\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f346537656234313738653063643831633731356266383136373039653962626266633963613264323136306236646665323731336639646437353137333537642f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f3734)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/74#issuecomment-1624008424\" title=\"A question about &quot;Libc&quot; example in Explainer.md 路 Issue #74 路 WebAssembly/component-model\">A question about \"Libc\" example in Explainer.md 路 Issue #74 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">i'm reading https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md namely, the example cited below. if i read it correctly, in the example libc instance exports its memory...</div></div></div>",
        "id": 397946314,
        "sender_full_name": "Ayako Akasaka",
        "timestamp": 1697982668
    },
    {
        "content": "<p>sorry. my question is not clear. Let me revise it later.</p>",
        "id": 397955004,
        "sender_full_name": "Ayako Akasaka",
        "timestamp": 1697990892
    }
]