[
    {
        "content": "<p>Hi all,</p>\n<p>I am looking into implementing some sort of checkpoint-restore functionality with WAMR for WebAssembly modules, akin to what CRIU [1] does for Linux processes. This functionality would allow to (i) take a snapshot (or checkpoint) of WAMR's execution environment, (ii) serialise it , and (iii) restore the module's execution environment from the snapshot.</p>\n<p>An initial proof-of-concept would consist of the following:<br>\ni) WASM App: a simple counter written in C that sleeps for one second and prints the counter value.<br>\nii) Initially, and to simplify the implementation, at a hardcoded iteration (e.g. 5) the program calls a native symbol (e.g. <code>void __checkpoint(bool stop)</code>).<br>\nii) WASM runtime: a stripped down version of <code>iwasm</code> with the additional <code>__checkpoint</code> native symbol.<br>\niii) The stripped down version of <code>iwasm</code> would allow a new command line argument <code>--restore</code> or <code>--restore-from-file</code> where <code>iwasm</code> restores a module from its serialised state.<br>\niv) This functionality should work for both the classic interpreter and AOT. For classic interpreter, we have already done something similar for the wazero runtime [2].<br>\nNote that this PoC, deliberately, does no external calls other than <code>__checkpoint</code>.</p>\n<p>Before getting too deep into the implementation rabbit hole, I wanted to post this message here to gather some ideas into how to implement the outlined PoC. My questions are:<br>\ni) Is all the execution state (assuming no external calls) contained in the <code>exec_env</code> defined in [3]?<br>\nii) Is the answer to i) the same for AoT and Interpreter mode?<br>\niii) Assuming all execution state is contained in the <code>exec_env</code>, would a deep copy suffice to checkpoint all the state (modulo some masking of areas that don't change e.g. funcs).<br>\niv) What would be the best way to restore execution from where we left off? (Assuming, initially, only one call to <code>__checkpoint</code>.</p>\n<p>Thanks in advance for your help!</p>\n<p>[1] <a href=\"https://github.com/checkpoint-restore/criu\">https://github.com/checkpoint-restore/criu</a><br>\n[2] <a href=\"https://github.com/mmathys/wasmsr\">https://github.com/mmathys/wasmsr</a><br>\n[3] <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md\">https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/checkpoint-restore/criu\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/79bf467b2fad13310e2bf38eecd8596046dbd2b3\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373364613836336139616266623339336337386432373137643739393031353738626435353366363532346133613731613639313437306134653536393566362f636865636b706f696e742d726573746f72652f63726975)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/checkpoint-restore/criu\" title=\"GitHub - checkpoint-restore/criu: Checkpoint/Restore tool\">GitHub - checkpoint-restore/criu: Checkpoint/Restore tool</a></div><div class=\"message_embed_description\">Checkpoint/Restore tool. Contribute to checkpoint-restore/criu development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/mmathys/wasmsr\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/0d2ed0704e3221cf37c49c7dd9bc6a0989c3264f\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363164333361373839616464303061333432653965326534326662333532386430333661376530643461633030623931303730336531313466653432396334352f6d6d61746879732f7761736d7372)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/mmathys/wasmsr\" title=\"GitHub - mmathys/wasmsr\">GitHub - mmathys/wasmsr</a></div><div class=\"message_embed_description\">Contribute to mmathys/wasmsr development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/9402a1bc7d43d3d3ad811b8c452e8c0bc5914789\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323865383730373535646262353138363139363133646536366564323437656266663339646134376135353066653331393062346235303164356564623136372f62797465636f6465616c6c69616e63652f7761736d2d6d6963726f2d72756e74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md\" title=\"wasm-micro-runtime/memory_tune.md at main · bytecodealliance/wasm-micro-runtime\">wasm-micro-runtime/memory_tune.md at main · bytecodealliance/wasm-micro-runtime</a></div><div class=\"message_embed_description\">WebAssembly Micro Runtime (WAMR). Contribute to bytecodealliance/wasm-micro-runtime development by creating an account on GitHub.</div></div></div>",
        "id": 342130573,
        "sender_full_name": "Carlos",
        "timestamp": 1678903251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"558832\">@Carlos</span> This is an exciting idea! Thanks for providing the informational links to related projects.  Alougth I see using the project <a href=\"https://github.com/checkpoint-restore/criu\">https://github.com/checkpoint-restore/criu</a> can help to transfer the whole runtime process, I understand you implementing a simlar function for Wasm without using criu (not envolving kernel), right?</p>\n<p>Where is the point for resuming from new environment? the code line after calling __check_point?</p>\n<p>We may have a online meeting for sharing the idea and related knowledge quickly. It is really a great idea, we would be happy to support you.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/checkpoint-restore/criu\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/614c1385ce0281a13c80b966096362f184f6deeb\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613762663735633063303339636536366431666232393963373937316265326533313262323932393437343531323665326233353338313939646634306264392f636865636b706f696e742d726573746f72652f63726975)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/checkpoint-restore/criu\" title=\"GitHub - checkpoint-restore/criu: Checkpoint/Restore tool\">GitHub - checkpoint-restore/criu: Checkpoint/Restore tool</a></div><div class=\"message_embed_description\">Checkpoint/Restore tool. Contribute to checkpoint-restore/criu development by creating an account on GitHub.</div></div></div>",
        "id": 342186482,
        "sender_full_name": "Wang Xin",
        "timestamp": 1678922700
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span> thanks for the quick reply and for showing interest!</p>\n<p>Exactly, CRIU checkpoints the whole Linux process (or process tree) which means that it would checkpoint the whole <code>iwasm</code> process. And, as you guessed, it involves a lot of interaction with the kernel to dump all the process state.</p>\n<p>Our goal is to implement this at the WebAssembly module level. Our WASM runtime using WAMR may have multiple WASM modules running in the same Linux process, so we are interested in a solution that can checkpoint just one module and not the other ones.</p>\n<blockquote>\n<p>Where is the point for resuming from new environment? the code line after calling __check_point?</p>\n</blockquote>\n<p>Yes!</p>\n<blockquote>\n<p>We may have a online meeting for sharing the idea and related knowledge quickly. It is really a great idea, we would be happy to support you.</p>\n</blockquote>\n<p>That would be great! I am in GMT and have a fairly flexible schedule.</p>",
        "id": 342253276,
        "sender_full_name": "Carlos",
        "timestamp": 1678958424
    },
    {
        "content": "<p>Great! We can find a time in the next week.  Could you please leave your email address for sending invitation? we will prepare a few digrams for the current memory model of WAMR. <span class=\"user-mention\" data-user-id=\"558832\">@Carlos</span> </p>\n<p><span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> <span class=\"user-mention\" data-user-id=\"569438\">@Thomas Trenner</span>  not sure if you are interested in this topic.</p>",
        "id": 342301833,
        "sender_full_name": "Wang Xin",
        "timestamp": 1678971189
    },
    {
        "content": "<p>Sounds good <span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span> !</p>\n<p>I should be available any time 9AM-6PM GMT Mon-Fri, so feel free to pick the slot that works best for you.</p>\n<p>My email is: <a href=\"mailto:carlossegarragonzalez@gmail.com\">carlossegarragonzalez@gmail.com</a></p>",
        "id": 342303696,
        "sender_full_name": "Carlos",
        "timestamp": 1678971628
    },
    {
        "content": "<p>Hello all! I'm also interested in having a look at these diagrams of the current memory model of WAMR, and listening to the talk. :)</p>\n<p>Do you guys mind if I join as well? I have a similar availability to Carlos, so you can just email me at <a href=\"mailto:james.menetrey@unine.ch\">james.menetrey@unine.ch</a>.</p>\n<p>Cheers!</p>",
        "id": 342353233,
        "sender_full_name": "Jämes Ménétrey",
        "timestamp": 1678981491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488581\">@Jämes Ménétrey</span> sure, we will keep you invited! We will also publish the memory model diagrams. We wanted to do it long time ago but never really spend time on it.</p>",
        "id": 342440903,
        "sender_full_name": "Wang Xin",
        "timestamp": 1679008943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268650\">Wang Xin</span> <a href=\"#narrow/stream/290350-wamr/topic/checkpoint-restore/near/342301833\">schrieb</a>:</p>\n<blockquote>\n<p>Great! We can find a time in the next week.  Could you please leave your email address for sending invitation? we will prepare a few digrams for the current memory model of WAMR. <span class=\"user-mention silent\" data-user-id=\"558832\">Carlos</span> </p>\n<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <span class=\"user-mention silent\" data-user-id=\"569438\">Thomas Trenner</span>  not sure if you are interested in this topic.</p>\n</blockquote>\n<p>In general: Everything that helps in diagnosing and observing wasm modules is interesting from our point of view. But, as said for the GPIO/I2C/SPI API discussions, as of now we are not in the situation that we can contribute a lot for it.</p>",
        "id": 343109050,
        "sender_full_name": "Thomas Trenner",
        "timestamp": 1679316410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"558832\">Carlos</span> <a href=\"#narrow/stream/290350-wamr/topic/checkpoint-restore/near/342130573\">said</a>:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I am looking into implementing some sort of checkpoint-restore functionality with WAMR for WebAssembly modules, akin to what CRIU [1] does for Linux processes. This functionality would allow to (i) take a snapshot (or checkpoint) of WAMR's execution environment, (ii) serialise it , and (iii) restore the module's execution environment from the snapshot.</p>\n<p>An initial proof-of-concept would consist of the following:<br>\ni) WASM App: a simple counter written in C that sleeps for one second and prints the counter value.<br>\nii) Initially, and to simplify the implementation, at a hardcoded iteration (e.g. 5) the program calls a native symbol (e.g. <code>void __checkpoint(bool stop)</code>).<br>\nii) WASM runtime: a stripped down version of <code>iwasm</code> with the additional <code>__checkpoint</code> native symbol.<br>\niii) The stripped down version of <code>iwasm</code> would allow a new command line argument <code>--restore</code> or <code>--restore-from-file</code> where <code>iwasm</code> restores a module from its serialised state.<br>\niv) This functionality should work for both the classic interpreter and AOT. For classic interpreter, we have already done something similar for the wazero runtime [2].<br>\nNote that this PoC, deliberately, does no external calls other than <code>__checkpoint</code>.</p>\n<p>Before getting too deep into the implementation rabbit hole, I wanted to post this message here to gather some ideas into how to implement the outlined PoC. My questions are:<br>\ni) Is all the execution state (assuming no external calls) contained in the <code>exec_env</code> defined in [3]?<br>\nii) Is the answer to i) the same for AoT and Interpreter mode?<br>\niii) Assuming all execution state is contained in the <code>exec_env</code>, would a deep copy suffice to checkpoint all the state (modulo some masking of areas that don't change e.g. funcs).<br>\niv) What would be the best way to restore execution from where we left off? (Assuming, initially, only one call to <code>__checkpoint</code>.</p>\n<p>Thanks in advance for your help!</p>\n<p>[1] <a href=\"https://github.com/checkpoint-restore/criu\">https://github.com/checkpoint-restore/criu</a><br>\n[2] <a href=\"https://github.com/mmathys/wasmsr\">https://github.com/mmathys/wasmsr</a><br>\n[3] <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md\">https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md</a></p>\n</blockquote>\n<p>Hi, I'm Yiwei Yang, Ph.D. student from UCSC, we as a group is doing heterogenous live migration based on WAMR and has already implemented a working Interpreter and WIP JIT migration. Looking forward to have collaboration!</p>",
        "id": 363212115,
        "sender_full_name": "Yiwei Yang",
        "timestamp": 1685769046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"600730\">Yiwei Yang</span> <a href=\"#narrow/stream/290350-wamr/topic/checkpoint-restore/near/363212115\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"558832\">Carlos</span> <a href=\"#narrow/stream/290350-wamr/topic/checkpoint-restore/near/342130573\">said</a>:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I am looking into implementing some sort of checkpoint-restore functionality with WAMR for WebAssembly modules, akin to what CRIU [1] does for Linux processes. This functionality would allow to (i) take a snapshot (or checkpoint) of WAMR's execution environment, (ii) serialise it , and (iii) restore the module's execution environment from the snapshot.</p>\n<p>An initial proof-of-concept would consist of the following:<br>\ni) WASM App: a simple counter written in C that sleeps for one second and prints the counter value.<br>\nii) Initially, and to simplify the implementation, at a hardcoded iteration (e.g. 5) the program calls a native symbol (e.g. <code>void __checkpoint(bool stop)</code>).<br>\nii) WASM runtime: a stripped down version of <code>iwasm</code> with the additional <code>__checkpoint</code> native symbol.<br>\niii) The stripped down version of <code>iwasm</code> would allow a new command line argument <code>--restore</code> or <code>--restore-from-file</code> where <code>iwasm</code> restores a module from its serialised state.<br>\niv) This functionality should work for both the classic interpreter and AOT. For classic interpreter, we have already done something similar for the wazero runtime [2].<br>\nNote that this PoC, deliberately, does no external calls other than <code>__checkpoint</code>.</p>\n<p>Before getting too deep into the implementation rabbit hole, I wanted to post this message here to gather some ideas into how to implement the outlined PoC. My questions are:<br>\ni) Is all the execution state (assuming no external calls) contained in the <code>exec_env</code> defined in [3]?<br>\nii) Is the answer to i) the same for AoT and Interpreter mode?<br>\niii) Assuming all execution state is contained in the <code>exec_env</code>, would a deep copy suffice to checkpoint all the state (modulo some masking of areas that don't change e.g. funcs).<br>\niv) What would be the best way to restore execution from where we left off? (Assuming, initially, only one call to <code>__checkpoint</code>.</p>\n<p>Thanks in advance for your help!</p>\n<p>[1] <a href=\"https://github.com/checkpoint-restore/criu\">https://github.com/checkpoint-restore/criu</a><br>\n[2] <a href=\"https://github.com/mmathys/wasmsr\">https://github.com/mmathys/wasmsr</a><br>\n[3] <a href=\"https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md\">https://github.com/bytecodealliance/wasm-micro-runtime/blob/main/doc/memory_tune.md</a></p>\n</blockquote>\n<p>Hi, I'm Yiwei Yang, Ph.D. student from UCSC, we as a group is doing heterogenous live migration based on WAMR and has already implemented a working Interpreter and WIP JIT migration. Looking forward to have collaboration!</p>\n</blockquote>\n<p>Our final artifact and result are listed here <a href=\"https://github.com/Multi-V-VM/MVVM\">https://github.com/Multi-V-VM/MVVM</a>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Multi-V-VM/MVVM\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/79270fd9bc0c3711ad072531d74e19466e27b318/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f306365626364313938343663633538396562303330323530386431386366363834626466363334346132333037626236303638306539326366626435303933652f4d756c74692d562d564d2f4d56564d&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Multi-V-VM/MVVM\" title=\"GitHub - Multi-V-VM/MVVM: Seemlessly Migrate Process without boundary.\">GitHub - Multi-V-VM/MVVM: Seemlessly Migrate Process without boundary.</a></div><div class=\"message_embed_description\"> Seemlessly Migrate Process without boundary. Contribute to Multi-V-VM/MVVM development by creating an account on GitHub.</div></div></div>",
        "id": 476606500,
        "sender_full_name": "Yiwei Yang",
        "timestamp": 1728826121
    }
]