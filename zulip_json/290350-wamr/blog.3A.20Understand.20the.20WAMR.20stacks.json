[
    {
        "content": "<p>Understand the WAMR stacks<br>\n<a href=\"https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/\">https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/8c54c649f4409f2cc38adadf3d6f8d43a782c48f\\/68747470733a2f2f62797465636f6465616c6c69616e63652e6769746875622e696f2f77616d722e6465762f77616d722e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://bytecodealliance.github.io/wamr.dev/blog/understand-the-wamr-stacks/\" title=\"Understand the WAMR stacks\">Understand the WAMR stacks</a></div><div class=\"message_embed_description\">The status of stacks # During the WAMR executes a Wasm function, there will be a Wasm stack created and used. For interpreter mode, as the Wasm functions intercall, the Wasm stack frames will grow, while the native stack keeps unchanged.\nWhen the Wasm calls into a imported native function and the native function then call into some Wasm function, the native stack will add a frame, and an empty frame will be inserted into wasm stack to indicate the function is imported from native.</div></div></div>",
        "id": 342860479,
        "sender_full_name": "Wang Xin",
        "timestamp": 1679188075
    }
]