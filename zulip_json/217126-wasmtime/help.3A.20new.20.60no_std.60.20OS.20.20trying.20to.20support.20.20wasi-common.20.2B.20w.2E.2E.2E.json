[
    {
        "content": "<p>Hi wasmtime gurus! Over the last several months, I have been working on porting wasmtime to a <code>no_std</code> environment atop <a href=\"https://github.com/theseus-os/Theseus\">Theseus OS</a>, and as of a few weeks ago I have an <a href=\"https://github.com/theseus-os/wasmtime/tree/theseus\">initial working version</a>. For the sake of transparency, this work is part of a project sponsored by Futurewei.</p>\n<p>AFAIK, this is the first port of wasmtime to a <code>no_std</code> platform, though technically we did add some std-like features to Theseus to get it to work.</p>\n<p>Anyway, the next step is to integrate our implementation of WASI into the wasmtime ecosystem. We have an <a href=\"https://github.com/theseus-os/Theseus/blob/13406ed975d54b5d72afb313df370d0a4477ce01/kernel/wasi_interpreter/src/wasi_syscalls.rs#L120\">existing WASI implementation</a> that was written to be plugged into the <code>wasmi</code> interpreter crate (some parts borrowed from Redshirt).</p>\n<p>This brings me to my primary question: how do I add support for a new host OS to the <code>wasi-common</code> crate in a way that <code>wasmtime</code> can use it to fulfill dependencies on WASI?</p>\n<p>I am quite confused on how everything fits together: <code>crates/wasi</code>, <code>crates/wasi-common</code>, and especially code generation with <code>wiggle</code>. I'm unsure if I have to port all of these crates to <code>no_std</code>, which I'm trying to avoid because it would be another massive effort. Perhaps I can just port <code>wasi</code> and <code>wasi-common</code> and skip <code>wiggle</code>, which seems like a proc_macro sort of thing that isn't an actual runtime dependency of wasmtime?</p>\n<p>Thanks in advance!</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/theseus-os/Theseus\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/9776c19ec244deb3ed3069a14c67738bae613188\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333036646433313438366134613064393361363539666532343261313365376465393961666366643837386534663735323064373236303431393162373439392f746865736575732d6f732f54686573657573)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/theseus-os/Theseus\" title=\"GitHub - theseus-os/Theseus: Theseus is a modern OS written from scratch in Rust that explores ğ¢ğ§ğ­ğ«ğšğ¥ğ¢ğ§ğ ğ®ğšğ¥ ğğğ¬ğ¢ğ ğ§, novel OS structure, and state management. It strives to close the semantic gap between compiler and hardware to maximally leverage the power of language safety, and thus shift OS responsibilities like resource management into the compiler.\">GitHub - theseus-os/Theseus: Theseus is a modern OS written from scratch in Rust that explores ğ¢ğ§ğ­ğ«ğšğ¥ğ¢ğ§ğ ğ®ğšğ¥ ğğğ¬ğ¢ğ ğ§, novel OS structure, and state management. It strives to close the semantic gap between compiler and hardware to maximally leverage the power of language safety, and thus shift OS responsibilities like resource management into the compiler.</a></div><div class=\"message_embed_description\">Theseus is a modern OS written from scratch in Rust that explores ğ¢ğ§ğ­ğ«ğšğ¥ğ¢ğ§ğ ğ®ğšğ¥ ğğğ¬ğ¢ğ ğ§, novel OS structure, and state management. It strives to close the semantic gap between compiler and hardware t...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/theseus-os/wasmtime/tree/theseus\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/bf5d3efeff4bb73b136396044af0a7b76eddc2a2\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343164666265306538393533383632656435383732393630333966363837303464386632656463323264653935613831383130653036353631386239623939392f746865736575732d6f732f7761736d74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/theseus-os/wasmtime/tree/theseus\" title=\"GitHub - theseus-os/wasmtime at theseus\">GitHub - theseus-os/wasmtime at theseus</a></div><div class=\"message_embed_description\">(Ported to Theseus) Standalone JIT-style runtime for WebAssembly, using Cranelift - GitHub - theseus-os/wasmtime at theseus</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/theseus-os/Theseus/blob/13406ed975d54b5d72afb313df370d0a4477ce01/kernel/wasi_interpreter/src/wasi_syscalls.rs#L120\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/9776c19ec244deb3ed3069a14c67738bae613188\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333036646433313438366134613064393361363539666532343261313365376465393961666366643837386534663735323064373236303431393162373439392f746865736575732d6f732f54686573657573)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/theseus-os/Theseus/blob/13406ed975d54b5d72afb313df370d0a4477ce01/kernel/wasi_interpreter/src/wasi_syscalls.rs#L120\" title=\"Theseus/wasi_syscalls.rs at 13406ed975d54b5d72afb313df370d0a4477ce01 Â· theseus-os/Theseus\">Theseus/wasi_syscalls.rs at 13406ed975d54b5d72afb313df370d0a4477ce01 Â· theseus-os/Theseus</a></div><div class=\"message_embed_description\">Theseus is a modern OS written from scratch in Rust that explores ğ¢ğ§ğ­ğ«ğšğ¥ğ¢ğ§ğ ğ®ğšğ¥ ğğğ¬ğ¢ğ ğ§, novel OS structure, and state management. It strives to close the semantic gap between compiler and hardware t...</div></div></div>",
        "id": 286263445,
        "sender_full_name": "Kevin Boos",
        "timestamp": 1655322306
    },
    {
        "content": "<p>I should also add that I have read <a href=\"https://bytecodealliance.org/articles/implementing-wasi-nn-in-wasmtime\">this excellent blog post about WASI-nn</a> by Andrew, but am not sure I fully understood everything therein. Naturally, it doesn't mention anything about <code>no_std</code>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://bytecodealliance.org/articles/implementing-wasi-nn-in-wasmtime\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b666ca74a20745aca2566cd241108afdcfa09d04\\/68747470733a2f2f62797465636f6465616c6c69616e63652e6f72672f696d616765732f6176617461722e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://bytecodealliance.org/articles/implementing-wasi-nn-in-wasmtime\" title=\"Implementing a WASI Proposal in Wasmtime: wasi-nn\">Implementing a WASI Proposal in Wasmtime: wasi-nn</a></div><div class=\"message_embed_description\">In a previous post, Machine Learning in WebAssembly: Using wasi-nn inWasmtime, we described thewasi-nn specification and a user-level view of its usage in Wasmtime. In this post, we dive intothe details of implementing the proposal using...</div></div></div>",
        "id": 286264564,
        "sender_full_name": "Kevin Boos",
        "timestamp": 1655322887
    },
    {
        "content": "<p><code>wiggle</code> is the bindings generator that wasmtime's WASI implementation uses to generate bindings from <code>witx</code> API descriptions. It takes care of a lot of the boilerplate of building a WASI implementation. But, if you have your own WASI implementation already, you may not need it. You may be able to just use the <a href=\"https://docs.wasmtime.dev/examples-rust-embed.html\">embedding API</a> to expose the WASI functions to wasm.</p>",
        "id": 286288823,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1655336166
    },
    {
        "content": "<p>Also, for context, there is a major push happening right now to build up <a href=\"https://github.com/bytecodealliance/wit-bindgen\">wit-bindgen</a> to the point where it can be the new way that we implemen WASI APIs in Wasmtime, replacing the current <code>witx</code> system.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/f19b81323d92098bdc74a3c463497ec8f8df049f\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383865303532633834393762333537633466653132313439316133613539616361303037353864663661363339643231356430343138393935326236636236372f62797465636f6465616c6c69616e63652f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen\" title=\"GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types\">GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types</div></div></div>",
        "id": 286288910,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1655336256
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> for the reply! I did indeed consider using the embedding API's <code>Linker</code> to add our WASI implementation as custom host state. That's a good first step to take, but I would ideally like to be able to use the default <code>wasmtime_wasi</code> functionality like <code>add_to_linker()</code> and the <code>WasiCtx</code> types, as is possible with other existing host OSes.</p>\n<blockquote>\n<p>[wiggle] takes care of a lot of the boilerplate of building a WASI implementation</p>\n</blockquote>\n<p>That's great to hear. However, where does the actual implementation come from, e.g., for a host target like <code>x86_64-unknown-linux</code>? </p>\n<p>Perhaps I'm misunderstanding things, but there must be a platform-specific implementation of the WASI syscall trait(s) generated from the <code>witx</code> spec (?). I presume the same set of<code>wiggle</code>-generated WASI bindings is generated for the major tier 1 platforms, and then implemented in a <code>unix</code>- or <code>windows</code>-specific manner.</p>\n<p>Our WASI implementation likely needs to be redesigned, so I'm totally fine with making major changes to support the existing wasmtime infrastructure surrounding WASI.</p>",
        "id": 286292437,
        "sender_full_name": "Kevin Boos",
        "timestamp": 1655339072
    },
    {
        "content": "<p>If you look at crates/wasi-common/src/snapshots/preview_1.rs, you'll see a <code>wiggle::from_witx!</code> invocation which parses a witx file and generates a trait, and a little further down, <code>impl wasi_snapshot_preview1::WasiSnapshotPreview1 for WasiCtx </code></p>",
        "id": 286292568,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1655339187
    },
    {
        "content": "<p>That said we're working on transitioning away from all the witx infrastructure, so unless you have short-term needs, I wouldn't take the current witx organization as something to make major organizational changes for</p>",
        "id": 286292701,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1655339295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/217126-wasmtime/topic/help.3A.20new.20.60no_std.60.20OS.20.20trying.20to.20support.20.20wasi-common.20.2B.20w.2E.2E.2E/near/286292568\">said</a>:</p>\n<blockquote>\n<p>If you look at crates/wasi-common/src/snapshots/preview_1.rs, you'll see a <code>wiggle::from_witx!</code> invocation which parses a witx file and generates a trait, and a little further down, <code>impl wasi_snapshot_preview1::WasiSnapshotPreview1 for WasiCtx </code></p>\n</blockquote>\n<p>Ah, thanks so much! That's exactly what I was looking for, can't believe I missed it.</p>",
        "id": 286292943,
        "sender_full_name": "Kevin Boos",
        "timestamp": 1655339531
    }
]