[
    {
        "content": "<p>Is the Component Model implementation in Wasmtime in a state where it's ready to be exposed via the C-API? I haven't looked at what all this will entail, but wanted to get someone's thoughts before going down the rabbit hole</p>",
        "id": 403504952,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1700621364
    },
    {
        "content": "<p>More-or-less yeah, although it's not a trivial undertaking by any means. It'll require pretty significant design of how values are represented and communicated. Nothing fundamental to overcome though, just a chunk of work!</p>",
        "id": 403505381,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1700621545
    },
    {
        "content": "<p>Cool - I probably won't have time to look into it until the start of the new year, but I'll poke around and I may have some questions later about how it all works.</p>",
        "id": 403506716,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1700622112
    },
    {
        "content": "<p>This would be most welcome, and would make it much easier to bring e.g. <code>wasmtime-py</code> and <code>wasmtime-go</code> up-to-speed with respect to WASI Preview 2, resources, composed components, etc.</p>",
        "id": 403608125,
        "sender_full_name": "Joel Dice",
        "timestamp": 1700664639
    },
    {
        "content": "<p>For sure - I have my own embedding in C++ that I'm keen on using the component model in the future, although I'll have lots of benchmarking and the like to do first</p>",
        "id": 403610233,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1700665262
    },
    {
        "content": "<p>It seems most of the component model uses the typed API (for example the code generated by bindgen!). Is there an example anywhere of how to use the \"untyped\" or \"dynamic\" API? That's going to be easier to plumb through the C API</p>",
        "id": 412990928,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705335403
    },
    {
        "content": "<p>Ah I see some examples in fuzzing and wast code, looks like types are always looked up by using the function that is being called. I think I see how we can map this to the C API.</p>",
        "id": 412991913,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705335748
    },
    {
        "content": "<p>I guess I question I have is to why some of the values are optional, for example, why is ResultVal's value an <code>Option</code>? I get the need for boxing, but I don't understand when that could be <code>None</code>.</p>\n<p><a href=\"/user_uploads/15107/YdAMNKn8ODBHKd7m6yz_4isD/Screenshot-2024-01-15-at-10.40.58AM.png\">Screenshot-2024-01-15-at-10.40.58AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/YdAMNKn8ODBHKd7m6yz_4isD/Screenshot-2024-01-15-at-10.40.58AM.png\" title=\"Screenshot-2024-01-15-at-10.40.58AM.png\"><img src=\"/user_uploads/15107/YdAMNKn8ODBHKd7m6yz_4isD/Screenshot-2024-01-15-at-10.40.58AM.png\"></a></div>",
        "id": 412995195,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705336912
    },
    {
        "content": "<p>In WIT (and in the binary representation of a component), a <code>result</code> might not have a payload, or might only have a payload for the <code>ok</code> case but not the <code>err</code> case (or vice versa).  In WIT this is expressed as e.g. <code>result</code> (no payload for <code>ok</code> or <code>err</code>), <code>result&lt;foo&gt;</code> (no payload for <code>err</code>), or <code>result&lt;_, foo&gt;</code> (no payload for <code>ok</code>).  Thus, the <code>Option</code> in <code>ResultVal</code> represents the possibility of no payload.</p>\n<p>In earlier versions of WIT and the component model, there was a <code>unit</code> type which was used to represent \"no payload\", but that has since been removed.</p>",
        "id": 413190553,
        "sender_full_name": "Joel Dice",
        "timestamp": 1705421792
    },
    {
        "content": "<p>I have a proof of concept for the C API + Component Model here (needs a lot more work): <a href=\"https://github.com/bytecodealliance/wasmtime/compare/main...rockwotj:wasmtime:main\">https://github.com/bytecodealliance/wasmtime/compare/main...rockwotj:wasmtime:main</a></p>\n<p>A few things:</p>\n<ol>\n<li>It's not clear to me if the name of index of enums, flags and variants is the stable interface. The rust impl uses the strings, but that's a little awkward in the C-API compared to integers, and the underlying runtime type is the integer.</li>\n<li>The conversion between C-API types and wasmtime::component::Val is less than ideal. I think there could be a <code>new_unchecked</code> for things like <code>List</code>, <code>Record</code>, etc OR there could be a <code>wasmtiem::component::RawVal</code> enum that the C-API could expose that would allow more efficient conversions with less (or no!) copies and no duplicated typechecking.</li>\n<li>I haven't wrapped my head around resources enough to incorporate those.</li>\n<li>The \"normal\" Rust generated bindings write their custom types directly using canoncial lifting/lowering and while that would be nice to expose through the C-API, I don't have resources to work on that at the moment. It would require coordination with some code generation tooling, and I'm guessing the C-API would just expose an interface for reading/writing the canonical ABI directly from/to guest memory.</li>\n</ol>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/compare/main...rockwotj:wasmtime:main\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/33766febb3982dab415a8c05d56729c85ada5bcd\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613265383837616361363939383432633032303966666432613831653837376362363966636265643033393237616565633766633836346561656662316461392f62797465636f6465616c6c69616e63652f7761736d74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/compare/main...rockwotj:wasmtime:main\" title=\"Comparing bytecodealliance:main...rockwotj:main · bytecodealliance/wasmtime\">Comparing bytecodealliance:main...rockwotj:main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A fast and secure runtime for WebAssembly. Contribute to bytecodealliance/wasmtime development by creating an account on GitHub.</div></div></div>",
        "id": 415948599,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705464238
    },
    {
        "content": "<p>Thanks for this! Would you be up for making a PR to continue discussions on? I haven't reviewed your branch yet but that's probably a good starting point.</p>\n<p>Additionally, would you have the appetite for helping us out to test this? Right now we very few tests for the C API beyond the relatively simplistic examples in the repository. Given the (what I expect is there) complexity of the component model version it'd be best if we could have tests in-repo to showcase as both examples and ensuring things keep working. Also given that this doesn't currently exist though it might be a bit of a big ask for you, so I don't want to necessarily require it but wanted to probe your thinking on this.</p>",
        "id": 416062220,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705507316
    },
    {
        "content": "<p>Yeah, I'd be good with moving to a PR for discussions, it will just be a draft, because I don't actually intend to merge this POC, but would like to discuss a couple alternatives.</p>\n<p>As for testing, yes we should certainly have real tests for the C API instead of just having the examples run and exit with status 0 :) Is there any formal plan you'd like to see or have opinions on? Personally I'd love to setup a little CMake project with GoogleTest to ensure stuff works correctly. The examples are good too, but at some level you probably need a real unit test framework. I'm not sure what other testing you had in mind, but starting with some unit tests on the C-API is probably a good first step.</p>",
        "id": 416333012,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705524258
    },
    {
        "content": "<p>Oh I guess another question I have is if these tests need to be written in C or if writing stuff in C++ is OK. I prefer C++ for a variety of reasons, but ya'll will be maintaining this, so am happy to get your thoughts too.</p>\n<p>I guess another option is to write tests in rust using these APIs, I'm not sure how desirable that is.</p>\n<p>Would love some opinions here for what maintainers would prefer to see, I can certainly enumerate what I prefer, but that's not necessarily the best for wasmtime and maintainers.</p>",
        "id": 416334672,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705525053
    },
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7801\">https://github.com/bytecodealliance/wasmtime/pull/7801</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/7801\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/537a0af0d76f2dde56aa5b182a2842ae850aad48\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653264653138653264393037363034353235363863613661306234323238653763653930663333666537653261316562326538616230393364366436616330632f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f37383031)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7801\" title=\"c-api/component-model: proof of concept by rockwotj · Pull Request #7801 · bytecodealliance/wasmtime\">c-api/component-model: proof of concept by rockwotj · Pull Request #7801 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Zulip link\nThis is a proof of concept for the component model exposed in the C API. I mostly took the approach of \"how would I want this to look in the C API\" and let the rust implementation fall o...</div></div></div>",
        "id": 416997174,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705762626
    },
    {
        "content": "<p>Sorry I've been dragging my feet getting back to this, I'll try to review that PR today or tomorrow. Thanks for it!</p>",
        "id": 417293628,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705949150
    },
    {
        "content": "<p>No worries! I am not in any rush here. Just FYI I'm <strong>not</strong> really looking to have that PR merged or the code really thoroughly reviewed. I am more interested in discussing some of the points that I brought up in this thread or in the PR description.</p>",
        "id": 417294415,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705949450
    },
    {
        "content": "<p>Ok I'm taking a look at things, I'll respond to the PR on the PR but to respond to some questions you had here:</p>\n<blockquote>\n<p>'m not sure what other testing you had in mind, but starting with some unit tests on the C-API is probably a good first step.</p>\n</blockquote>\n<p>CMake + GoogleTest sounds good to me. I don't have any preference here due to lack of experience of tackling this task (testing C/C++ APIs), and I suspect many other Wasmtime folks are in the same bucket. So long as it's easy to set up and test locally I think it'll work out ok.</p>",
        "id": 417310797,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705955695
    },
    {
        "content": "<blockquote>\n<p>Oh I guess another question I have is if these tests need to be written in C or if writing stuff in C++ is OK.</p>\n</blockquote>\n<p>I think C++ is fine, it's \"close enough\" to C and gets us the coverage we want of \"this C header file parses and can be used from C++\" well</p>",
        "id": 417310846,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705955719
    },
    {
        "content": "<p>I wouldn't recommend Rust because the main purpose of the tests would be to test that it works from C/C++ and we can have at least one example of wrangling build systems</p>",
        "id": 417310914,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705955751
    },
    {
        "content": "<p>basically I'd do whatever you're comfortable with and you seem to know more about this space than us so we're happy to pick up the idioms you set forth</p>",
        "id": 417311019,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1705955781
    },
    {
        "content": "<p>Awesome thanks. I'll make sure whatever gets setup has copious amounts of documentations for folks new to C/C++ so hopefully it isn't a maintenance burden.</p>",
        "id": 417311367,
        "sender_full_name": "Tyler Rockwood",
        "timestamp": 1705955941
    }
]