[
    {
        "content": "<p>As I mentioned at last week's meeting, I'm planning to do an overview of the implementation work described in the <a href=\"https://github.com/bytecodealliance/rfcs/pull/38\">Async RFC</a> I posted a couple of months ago.  It's currently scheduled for <time datetime=\"2024-12-12T18:00:00Z\">2024-12-12T11:00:00-07:00</time>.</p>\n<p>I've sent an invite to those who have already expressed interest.  Please DM me your email address if you want me to add it to the invite.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/rfcs/pull/38\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/cc56fdc33b0027e1485c9908bc104ddb4e2502dd/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f336238626438376464313432353839623139356135626361303435313666613936623836336335366165366462633562316432653536636362383633386463352f62797465636f6465616c6c69616e63652f726663732f70756c6c2f3338&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/rfcs/pull/38\" title=\"Add support for the Component Model Async ABI by dicej · Pull Request #38 · bytecodealliance/rfcs\">Add support for the Component Model Async ABI by dicej · Pull Request #38 · bytecodealliance/rfcs</a></div><div class=\"message_embed_description\">Add support for the Component Model Async ABI to wasm-tools, wit-bindgen, and wasmtime.\nRendered RFC</div></div></div>",
        "id": 487124084,
        "sender_full_name": "Joel Dice",
        "timestamp": 1733788319
    },
    {
        "content": "<p>Here's the recording: <a href=\"https://www.youtube.com/watch?v=N9GS76yxgUY\">YouTube -  - YouTube</a><br>\nand document: <a href=\"https://hackmd.io/LQhcwqb9QiyH-YNMyikMHA?view\">https://hackmd.io/LQhcwqb9QiyH-YNMyikMHA?view</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"N9GS76yxgUY\" href=\"https://www.youtube.com/watch?v=N9GS76yxgUY\"><img src=\"https://uploads.zulipusercontent.net/d4c3330f25b266e17e5eca2921fe9363e54785bc/68747470733a2f2f692e7974696d672e636f6d2f76692f4e394753373679786755592f64656661756c742e6a7067\"></a></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://hackmd.io/LQhcwqb9QiyH-YNMyikMHA?view\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f8833a4340ab1f5f4b067117308223870fca5545/68747470733a2f2f6861636b6d642e696f2f696d616765732f6d656469612f4861636b4d442d6e656f2d6f672e6a7067&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://hackmd.io/LQhcwqb9QiyH-YNMyikMHA?view\" title=\"Component Model Async Implementation Overview - HackMD\">Component Model Async Implementation Overview - HackMD</a></div><div class=\"message_embed_description\">or</div></div></div>",
        "id": 488707493,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734033154
    },
    {
        "content": "<p>Thanks I had a conflict with that meeting time so I really appreciate the recording!</p>",
        "id": 488708326,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1734033494
    },
    {
        "content": "<p>I just wanted to say thanks again! That was very informative!<br>\nThe only things I haven't fully understood, I expect to understand them by reading the RFCs and checking the PRs <span aria-label=\"praise\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"praise\">:praise:</span> !</p>",
        "id": 488715044,
        "sender_full_name": "raskyld",
        "timestamp": 1734036301
    },
    {
        "content": "<p>Regarding:</p>\n<ul>\n<li>\n<blockquote>\n<p><code>Promise</code>: like <code>Future</code>, but requires a <code>StoreContextMut&lt;T&gt;</code> to make progress</p>\n</blockquote>\n</li>\n<li>and the \"fun\" signature of <code>func_wrap_concurrent</code></li>\n</ul>\n<p>This reminds me of an <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7812\">old PR</a> of mine where  I ran into nearly the same problem; namely that WASI pollables need temporary mutable access to the ResourceTable, only for the duration of the <code>poll</code> method, but not in between. <br>\nThe referenced PR bounced back-and-forth between different solutions, and ultimately didn't land anything. Anyhow, one of the solutions was to have a custom<code>WasiFuture</code> trait which has an additional <code>&amp;mut Store</code> parameter on its poll method. Also, the <code>WasiFuture</code> trait was auto-implemented for all regular <code>Future</code>s. Of course this bifurcates the Futures ecosystem. But just throwing it out there</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/7812\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/1e703c20fcde44e607caac7f8816d281d531dc11/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616564366134666630303830343433376563306335306465363662623236646534653835336332383735663263333230666532356162616237646638343432352f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f37383132&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7812\" title=\"wasi-io: Reimplement wasi-io/poll using a Pollable trait by badeend · Pull Request #7812 · bytecodealliance/wasmtime\">wasi-io: Reimplement wasi-io/poll using a Pollable trait by badeend · Pull Request #7812 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Prior discussion: https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime/topic/Change.20Subscribe.20trait\n\nRenamed the existing Pollable struct to PollableResource\nReimplemented wasi...</div></div></div>",
        "id": 488725197,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734040322
    },
    {
        "content": "<p>Yeah, I was thinking of something similar.  What I couldn't figure out was how to interoperate ergonomically with regular <code>Future</code>s and <code>async</code>/<code>await</code>.</p>",
        "id": 488725432,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734040429
    },
    {
        "content": "<p>The blanket <code>WasiFuture</code> implementation sounds interesting; hadn't thought of that.</p>",
        "id": 488725570,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734040479
    },
    {
        "content": "<p>Here's an example of using <code>Promise</code> and <code>PromisesUnordered</code> (akin to <code>futures::FuturesUnordered</code>, used to multiplex multiple <code>Promise</code>s concurrently) to juggle multiple concurrent streams, futures, and export calls in a somewhat realistic wasi-http scenario: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR929-R1121\">https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR929-R1121</a><br>\nIt's not super idiomatic, but it's not horrible either, IMHO.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR929-R1121\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5611024d6fdea11ea63f57055866e15e11c2f661/68747470733a2f2f617661746172732e67697468756275736572636f6e74656e742e636f6d2f752f313234333135333f733d34303026763d34&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR929-R1121\" title=\"Add support for async/streams/futures by dicej · Pull Request #9582 · bytecodealliance/wasmtime\">Add support for async/streams/futures by dicej · Pull Request #9582 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This adds support for loading, compiling, linking, and running components which use the Async ABI along with the stream, future, and error-context types. It also adds support for generating host bi...</div></div></div>",
        "id": 488726387,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734040842
    },
    {
        "content": "<p>And here's a simpler example where we just start three concurrent calls to the same exported function and wait for them all to complete: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR481-R492\">https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR481-R492</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR481-R492\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5611024d6fdea11ea63f57055866e15e11c2f661/68747470733a2f2f617661746172732e67697468756275736572636f6e74656e742e636f6d2f752f313234333135333f733d34303026763d34&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/9582/files#diff-3c649a56157956a049a3450ccba943197b5b50dde10bcd1917a6c236bd7329ecR481-R492\" title=\"Add support for async/streams/futures by dicej · Pull Request #9582 · bytecodealliance/wasmtime\">Add support for async/streams/futures by dicej · Pull Request #9582 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This adds support for loading, compiling, linking, and running components which use the Async ABI along with the stream, future, and error-context types. It also adds support for generating host bi...</div></div></div>",
        "id": 488726649,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734040938
    },
    {
        "content": "<p>BTW, Those links don't link to anything specific for me. They both load the entire diff, from the top</p>",
        "id": 488726993,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734041086
    },
    {
        "content": "<p>Yeah, maybe the diff is too huge for GH to allow deep linking; just fixed the first one; will fix the second</p>",
        "id": 488727086,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734041137
    },
    {
        "content": "<p>Regarding the async/await ergonomics;<br>\nIf I summarize correctly; for the regular non-async case, passing the store as a mutable reference is fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">blabla1</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">blabla2</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>(heavily pseudo coding here :P )</p>",
        "id": 488729004,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734042003
    },
    {
        "content": "<p>The problem in the async variant is that the async method should get access to the Store somehow, but isn't allowed to hold it across await boundaries. Ie. this is not ok:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap_concurrent</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">blabla1</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">something</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">blabla2</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// `store` shouldn't be used across await-points!</span>\n<span class=\"p\">});</span>\n</code></pre></div>",
        "id": 488729131,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734042061
    },
    {
        "content": "<p>Right; non-awaiting host functions are easy: they can have exclusive access to the store since they will return immediately (unless it goes off and does a long computation, I guess; in that case it should spawn a task on Tokio's blocking thread pool and await that).  And if a host function needs to await, we can't let it hold exclusive access to the store that whole time since it prevents anything else from happening for that component instance.</p>",
        "id": 488729466,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042212
    },
    {
        "content": "<p>So, instead of passing the store directly, maybe we can pass kind of \"accessor\" (which _can_ be used across awaits) which yields temporary accesses to the store (which can _not_ be used across await points).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap_concurrent</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">store_acc</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">StoreAccessor</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">guard</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">StoreGuard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">store_acc</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">blabla1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">guard</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">something</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">blabla2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">guard</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// `guard` can not be used across await points</span>\n<span class=\"p\">})</span>\n</code></pre></div>\n<p>similar-ish to Mutex &amp; MutexGuard? With the exception that we don't actually need any locking here</p>",
        "id": 488729561,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734042248
    },
    {
        "content": "<p>How would <code>StoreAccessor</code> be implemented? (and keep in mind we have to include a <code>&lt;T&gt;</code> where <code>T</code> might not be <code>'static</code>, so that makes things more interesting)</p>",
        "id": 488729987,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042447
    },
    {
        "content": "<p>I recall exploring something like that myself, but I think it was a dead-end; could be that I missed something, though.</p>",
        "id": 488730067,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042482
    },
    {
        "content": "<p>I also thought about using thread- or task-locals, but that was also a dead-end due to lifetime-related issues.</p>",
        "id": 488730227,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042560
    },
    {
        "content": "<p>Under the hood, we can pass a <code>*mut dyn VMStore</code> around with impunity, but wrapping a safe, correct API around that seems impossible given the lifetime issues</p>",
        "id": 488730384,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042624
    },
    {
        "content": "<p>I even considered experimenting with <a href=\"https://github.com/rust-lang/rust/issues/123392\">this unstable feature</a>, but again I ran into lifetime issues (can't use <code>dyn Any</code> for non-<code>'static</code> types)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/rust-lang/rust/issues/123392\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/501d4ce9e410d2b3198913d0dc081abb2ccbd6f1/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393165353834623234333465663539313538336336623664653465366333353439396239613935366165326430343263343466303462303537356532373634642f727573742d6c616e672f727573742f6973737565732f313233333932&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/rust-lang/rust/issues/123392\" title=\"Tracking Issue for `context_ext` · Issue #123392 · rust-lang/rust\">Tracking Issue for `context_ext` · Issue #123392 · rust-lang/rust</a></div><div class=\"message_embed_description\">Feature gate: #![feature(context_ext)] This is a tracking issue for allowing std::task::Context to carry arbitrary extension data. Public API impl Context { fn ext(&amp;mut self) -&gt; &amp;mut dyn Any; } imp...</div></div></div>",
        "id": 488730604,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042716
    },
    {
        "content": "<p>If we were to start adding <code>T: 'static</code> bounds everywhere, we'd have a lot more options, but that's a tough sell.</p>",
        "id": 488730791,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042790
    },
    {
        "content": "<p>And maybe it wouldn't help much anyway given that we're still talking about raw pointers and all the attendant dangers.</p>",
        "id": 488731048,
        "sender_full_name": "Joel Dice",
        "timestamp": 1734042909
    },
    {
        "content": "<p>I was thinking in terms of some kind of task-local, and indeed hadn't thought about non-static T's :)</p>",
        "id": 488731103,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1734042947
    }
]