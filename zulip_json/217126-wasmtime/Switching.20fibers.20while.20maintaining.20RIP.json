[
    {
        "content": "<p>I'm looking at <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/fiber/src/unix/x86_64.rs\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/fiber/src/unix/x86_64.rs</a> to better understand how it switches between fibers. Now my knowledge of assembly is very limited, but on first sight it seems this code doesn't restore RIP. At least, on line 30 in the switch function it _seems_ to do something that might be related, but I'm having a hard time understanding how this updates the instruction pointer.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/fiber/src/unix/x86_64.rs\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/5a70f00b7809d08417d0c704034d7585bf1b6295\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653134643538356264373665333763616331646334663266646566363738383062363030346434313234353830316639623465353465393539356633653634652f62797465636f6465616c6c69616e63652f7761736d74696d65)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/fiber/src/unix/x86_64.rs\" title=\"wasmtime/x86_64.rs at main · bytecodealliance/wasmtime\">wasmtime/x86_64.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A fast and secure runtime for WebAssembly. Contribute to bytecodealliance/wasmtime development by creating an account on GitHub.</div></div></div>",
        "id": 306757193,
        "sender_full_name": "Yorick Peterse",
        "timestamp": 1666994522
    },
    {
        "content": "<p>Basically I have similar code I'm playing around with, and it works fine for starting a fiber and yielding back to the original OS thread/context, but my grug brain can't figure out how to make it work to then be able to resume the fiber. For that I'd have to save RIP, but the various examples I've found (<a href=\"https://github.com/gpderetta/libtask/blob/master/details/switch_base.hpp\">https://github.com/gpderetta/libtask/blob/master/details/switch_base.hpp</a> is another) don't seem to explicitly/clearly handle this</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/gpderetta/libtask/blob/master/details/switch_base.hpp\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b160a95933238b74f8c8380782fbce6ffd614d27\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396533326461316138626166646132383463343631646234316231306565386364393463353463383362653065613535343966323531393735313063626664322f6770646572657474612f6c69627461736b)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/gpderetta/libtask/blob/master/details/switch_base.hpp\" title=\"libtask/switch_base.hpp at master · gpderetta/libtask\">libtask/switch_base.hpp at master · gpderetta/libtask</a></div><div class=\"message_embed_description\">Contribute to gpderetta/libtask development by creating an account on GitHub.</div></div></div>",
        "id": 306757333,
        "sender_full_name": "Yorick Peterse",
        "timestamp": 1666994591
    },
    {
        "content": "<p>The old value of RIP (also known as pc) is stored on the stack for x86_64. Whatever calls <code>wasmtime_fiber_switch</code> will push the return address onto the stack, and that's basically the old value of the pc. The <code>wasmtime_fiber_switch</code> function \"returns\" but that's actually where the switch completes since the return address is not the same return address as when the function was entered</p>",
        "id": 306757741,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1666994815
    },
    {
        "content": "<p>Ah gotcha, I hadn't thought of the callers being response for saving RIP somewhere <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 306758069,
        "sender_full_name": "Yorick Peterse",
        "timestamp": 1666994988
    },
    {
        "content": "<p>Hello! I’m not sure if this is the right channel for this question, (and if it’s not feel free to direct me to a place that makes more sense). Lately when browsing rust tooling that is deciding on a plug-in system, people common suggest using wasm as the solution. Usually the threads are accompanied by a suggested script involving WASMTime (hence why I’m asking here). I was hoping to understand what it actually means from an implementation perspective to use wasm for managing plugins. Would that involve spawning a new runtime for each plugin? Or is it more like FFI? I’ve been trying to search around for a blog or wiki page on it but I can’t really find any answers. Thanks :)</p>",
        "id": 307019890,
        "sender_full_name": "Lukas Hermann",
        "timestamp": 1667174947
    },
    {
        "content": "<p>you can make a new thread for your issue. but anyway, here's some references:<br>\n<a href=\"https://freemasen.com/blog/wasmer-plugin-pt-1/\">https://freemasen.com/blog/wasmer-plugin-pt-1/</a><br>\n<a href=\"https://nullderef.com/blog/plugin-tech/#wasm\">https://nullderef.com/blog/plugin-tech/#wasm</a></p>\n<p>basically, you use it just like you use lua. you spawn an embedded runtime, load the wasm binary, call functions from it depending on your usecase. although, I would recommend against webassembly plugins for now. there's a lot of hype and people echoing random generalized statements, but we are not there yet. component-model is still being worked on and meanwhile, you can try joining communities like <a href=\"https://extism.org/\">https://extism.org/</a> which actually are trying to make the experience smoother.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://nullderef.com/blog/plugin-tech/#wasm\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/e68a7c2c4266119d8926cbf92a838c9bc5d0e318\\/68747470733a2f2f6e756c6c64657265662e636f6d2f626c6f672f706c7567696e2d746563682f746563686e6f6c6f676965732e6a7067)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://nullderef.com/blog/plugin-tech/#wasm\" title=\"Plugins in Rust: The Technologies\">Plugins in Rust: The Technologies</a></div><div class=\"message_embed_description\">A more in-depth look at Rust plugin systems</div></div></div>",
        "id": 307674325,
        "sender_full_name": "code red art",
        "timestamp": 1667462831
    }
]