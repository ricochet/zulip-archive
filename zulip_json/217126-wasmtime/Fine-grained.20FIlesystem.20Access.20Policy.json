[
    {
        "content": "<p>Hi! Let's say you would like to permit filesystem access to a <code>wasi:cli</code> component, to do so, you <code>preopens</code> a directory which (with the current <code>wasmtime-wasi</code> implementation, IIUC) gives the component an handle backed by a <code>cap_std::fs::Dir</code>.</p>\n<p>Now, let's say you need more control over the invocation made on this capability. In my specific use-case, I would like to deny access to a specific file beneath the preopened <code>Dir</code>(whether direct access or the result of symlink resolution(s)).<br>\nIt seems like it is not possible to do something like that ATM, and I would need to re-implement <code>filesystem</code> host-functions to do so. </p>\n<p>The <a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/struct.WasiCtxBuilder.html#method.socket_addr_check\"><code>WasiCtxBuilder::socker_addr_check()</code></a> func allows the caller to implement advanced access policies through the usage of closures.</p>\n<p>Do you think such a mechanism could be implementable / desirable (more likely in <code>cap-fs-ext</code>) for wasmtime? If not, do you have any suggestion on how to deal with the problem? <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<p>Thanks!</p>",
        "id": 440633657,
        "sender_full_name": "raskyld",
        "timestamp": 1716640943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> we talked about this some a couple weeks ago in relation to <code>wow</code>. What do you think the best way to move forward with this kind of policy feature would be. Also, I think we'd want to make the file read-only specifically.</p>",
        "id": 440738985,
        "sender_full_name": "Robin Brown",
        "timestamp": 1716756266
    },
    {
        "content": "<p>that would be the preferred approach to reading in auth tokens for example....</p>",
        "id": 440823580,
        "sender_full_name": "Ralph",
        "timestamp": 1716805268
    },
    {
        "content": "<p>We don't have anything that can do \"deny acccess to a specific file\" today.</p>",
        "id": 441120547,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1716932981
    },
    {
        "content": "<p>In addition to symlinks and <code>..</code> paths, there's also case sensitivity, Unicode normalization in some host filesystems, and special rules on the Wonderful World of Windows <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#trim-characters\">(example)</a>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#trim-characters\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/841fabdc60f6bbb20edb690fc1dc73c32e24a729/68747470733a2f2f6c6561726e2e6d6963726f736f66742e636f6d2f646f746e65742f6d656469612f646f742d6e65742d63726f73732d706c6174666f726d2e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#trim-characters\" title=\"File path formats on Windows systems - .NET\">File path formats on Windows systems - .NET</a></div><div class=\"message_embed_description\">In this article, learn about file path formats on Windows systems, such as traditional DOS paths, DOS device paths, and universal naming convention (UNC) paths.</div></div></div>",
        "id": 441122254,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1716933819
    },
    {
        "content": "<p>So in theory this might be doable, but I think it would be tricky to get right.</p>",
        "id": 441122937,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1716934170
    },
    {
        "content": "<p>Windows.... <em>sigh</em></p>",
        "id": 441190675,
        "sender_full_name": "Ralph",
        "timestamp": 1716971021
    },
    {
        "content": "<p>It will be tricky for sure, the question to me is about at what layer tools should solve this.</p>\n<p>As I see it there are 4 options</p>\n<ol>\n<li>At the OS level (e.g. have <code>wow</code> exec the command as a user who has read only permissions on the file)</li>\n<li>At the cap-std level (e.g. have a cap-std type that lets a policy trait be defined that controls this)</li>\n<li>At the wasmtime-wasi / bindings level (e.g. build in policy support like exists for sockets, but would be much more sophisticated, for files that supports this)</li>\n<li>At the guest level (e.g. build a component adapter that implements this policy on file-system)</li>\n</ol>\n<p>What direction would you recommend <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> ?</p>",
        "id": 441286183,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717004214
    },
    {
        "content": "<p>The OS level is probably going to be really inconvenient, because you have to have elevated privileges to create new users.</p>",
        "id": 441290608,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717006094
    },
    {
        "content": "<p>The guest level may be complex because if you don't have the ability to directly query what kind of host filesystem you're on, it may be tricky to know which path aliasing rules apply.</p>",
        "id": 441292191,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717006768
    },
    {
        "content": "<p>And any layer above the OS will need some way to detect directory symlinks. For example, in a path like <code>a/b/c/d/e/f/g/h/secrets.txt</code>, any of those path components could be a symlink, and there's no way to know without <code>openat</code>ing them one path component at a time (because <code>O_NOFOLLOW</code> only applies to the last component of a path string). So maybe the options look like:</p>\n<ul>\n<li>cap-std has code that does this one-component-at-a-time opening, so if you go with cap-std, you could potentially reuse that code. But, this would require cap-std's <code>File</code> would to change from being a trivial wrapper around a <code>std::fs::File</code> to also having a list of prohibited paths, and we'd need to have some form of Unicode dependency in order to do case conversion and Unicode normalization. Maybe it could be made an optional feature, to avoid encumbering cap-std's other users?</li>\n<li>wasmtime-wasi could do its own <code>openat</code>-one-at-a-time logic.</li>\n</ul>",
        "id": 441293523,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717007311
    },
    {
        "content": "<p>And for any option, it would requiring finding someone who can speak authoritatively on all Windows issues, as I have chosen as a life goal to never learn about how Windows filesystem paths work in sufficient detail.</p>",
        "id": 441293648,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717007364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/217126-wasmtime/topic/Fine-grained.20FIlesystem.20Access.20Policy/near/441293648\">said</a>:</p>\n<blockquote>\n<p>And for any option, it would requiring finding someone who can speak authoritatively on all Windows issues, as I have chosen as a life goal to never learn about how Windows filesystem paths work in sufficient detail.</p>\n</blockquote>\n<p>That's an healthy way of life <span aria-label=\"praise\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"praise\">:praise:</span></p>",
        "id": 441298710,
        "sender_full_name": "raskyld",
        "timestamp": 1717009271
    },
    {
        "content": "<p>For the moment, <code>wow</code> runs on any platform as long as it's <code>unix</code>. The next target I'm actually interested in are virtual workspaces (e.g. the browser). I'm honestly not sure if Windows support is even in the medium-term future.</p>",
        "id": 441299404,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717009555
    },
    {
        "content": "<p>What I was thinking about is adding a <em>hook</em>, there: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/host/filesystem.rs#L591\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/host/filesystem.rs#L591</a></p>\n<p>That is, post path-resolution when we have a std <code>File</code> resolved and pass it to the user provided policy (which could be a closure or a trait object) as an argument. Then, let it returns a decision (allow / deny), that way, we benefit from the fact <code>File</code> is <em>almost</em> platform-agnostic to make the policies agnostic aswell.</p>\n<p>Of course, in the future, if we want to even avoid the resolution from happening we can have another hook, something like:<br>\n<code>pre_open_at</code> and <code>post_open_at</code>.</p>\n<p>What I don't know, is whether it should be done in <code>wasmtime</code> only, or if it should be implemented as a <code>cap-std</code> OpenOptions or somethings that would be \"attached\" to the capability handle (i.e. <code>cap_std::fs::Dir</code>).</p>\n<p>WDYT?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/host/filesystem.rs#L591\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/01fa1539e9e2a124e42e15a0ff922b3c529d41f8/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303463613862653639656139666639366337343864393936393134346134333530623463373933656532316435383639346366666634623937346430633264652f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/host/filesystem.rs#L591\" title=\"wasmtime/crates/wasi/src/host/filesystem.rs at main · bytecodealliance/wasmtime\">wasmtime/crates/wasi/src/host/filesystem.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A fast and secure runtime for WebAssembly. Contribute to bytecodealliance/wasmtime development by creating an account on GitHub.</div></div></div>",
        "id": 441300571,
        "sender_full_name": "raskyld",
        "timestamp": 1717010046
    },
    {
        "content": "<p>fortunately, there is a company that knows something you've chosen not to know about Windows.</p>",
        "id": 441308447,
        "sender_full_name": "Ralph",
        "timestamp": 1717013606
    },
    {
        "content": "<p>and it is not me, either. <em>phew</em></p>",
        "id": 441308484,
        "sender_full_name": "Ralph",
        "timestamp": 1717013624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"723701\">@raskyld</span> You likely also need to prevent users from using a rename to replace the contents of one file with another, and rename operates directly on paths, so there is no <code>open</code> and no std <code>File</code> gets created.</p>",
        "id": 441321205,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717018164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/217126-wasmtime/topic/Fine-grained.20FIlesystem.20Access.20Policy/near/441321205\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"723701\">raskyld</span> You likely also need to prevent users from using a rename to replace the contents of one file with another, and rename operates directly on paths, so there is no <code>open</code> and no std <code>File</code> gets created.</p>\n</blockquote>\n<p>You are right!<br>\nI think it all comes down to what are the attributes we want the policies to operate on.<br>\nThe paths are the most \"straight-forward\" one indeed, but also the most complex to get right due to aliasing rules and the fact each platform resolves paths differently. This would make writing correct policies error-prone and challenging..</p>\n<p>I think the path should definitely be passed to the policy engine (more likely a closure expect if you have another idea? a CEL interpreter? <a href=\"https://github.com/google/cel-spec\">https://github.com/google/cel-spec</a>) but we may also consider passing <code>Metadata</code> which would allow the users to use Unixes' inodes or Windows Volume Serial + File Index to identify the files they want to protect.</p>\n<p>EDIT: If I am correct, <code>cap-std</code> calls <code>stat</code> on both paths during a rename.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/google/cel-spec\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a5ec51d3b21404c7072f0dba93b11615bf900517/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3130323339303934332f66623735666164342d343336622d346331332d613363612d623365653534383931316234&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/google/cel-spec\" title=\"GitHub - google/cel-spec: Common Expression Language -- specification and binary representation\">GitHub - google/cel-spec: Common Expression Language -- specification and binary representation</a></div><div class=\"message_embed_description\">Common Expression Language -- specification and binary representation - google/cel-spec</div></div></div>",
        "id": 441521953,
        "sender_full_name": "raskyld",
        "timestamp": 1717092342
    },
    {
        "content": "<p>Even inode numbers come with some subtle concerns. Something as innocuous as editing a config file in vim changes the config file's inode number. And on Windows there are caveats like \"In some cases, the file ID for a file can change over time.\" (<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information#remarks\">source</a>)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information#remarks\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/3ce17f2b2911dcb735720cc46e75758679339053/68747470733a2f2f6c6561726e2e6d6963726f736f66742e636f6d2f656e2d75732f6d656469612f6f70656e2d67726170682d696d6167652e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information#remarks\" title=\"BY_HANDLE_FILE_INFORMATION (fileapi.h) - Win32 apps\">BY_HANDLE_FILE_INFORMATION (fileapi.h) - Win32 apps</a></div><div class=\"message_embed_description\">Contains information that the GetFileInformationByHandle function retrieves.</div></div></div>",
        "id": 441527725,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717094277
    },
    {
        "content": "<p>It turns out that cap-std does not call <code>stat</code> on either path in a rename.</p>",
        "id": 441532563,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717095775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/217126-wasmtime/topic/Fine-grained.20FIlesystem.20Access.20Policy/near/441532563\">said</a>:</p>\n<blockquote>\n<p>It turns out that cap-std does not call <code>stat</code> on either path in a rename.</p>\n</blockquote>\n<p>Sorry, I should have linked source as well: <a href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\">https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30</a></p>\n<p>It seemed to me that it does stat but I may misunderstand the linked code.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/217126-wasmtime/topic/Fine-grained.20FIlesystem.20Access.20Policy/near/441527725\">said</a>:</p>\n<blockquote>\n<p>Even inode numbers come with some subtle concerns. Something as innocuous as editing a config file in vim changes the config file's inode number. And on Windows there are caveats like \"In some cases, the file ID for a file can change over time.\" (<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information#remarks\">source</a>)</p>\n</blockquote>\n<p>So the only real \"secure\" way would be to resolve the file you want to protect, then resolve the path requested by the guest and compare their identifier to see if they resolve to the same. You couldn't just store the identifier at the start of the process because we have no guarantee they stay stable in time? <span aria-label=\"tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"tear\">:tear:</span> </p>\n<p>For example, for <code>wow</code>, it is paramount to protect <code>./wow.kdl</code>, so each hook invocation should resolve <code>./wow.kdl</code>, then resolve the path requested by the guest (e.g. <code>wow.kdl.symlink</code> which point to the same inode than <code>./wow.kdl</code>) and compare their identifier to deliver a decision (allow/deny).</p>\n<p>At the end of the day, that just means it is the responsibility of the embedder to write correct policies.. but platform behaviour makes that kind of complicated <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/8c011e558353b58817d6e8844e1ee39c28fe94b5/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3237353031333336332f35623163343030302d633834382d313165612d386564622d383737333935663638303635&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\" title=\"cap-std/cap-primitives/src/fs/rename.rs at main · bytecodealliance/cap-std\">cap-std/cap-primitives/src/fs/rename.rs at main · bytecodealliance/cap-std</a></div><div class=\"message_embed_description\">Capability-oriented version of the Rust standard library - bytecodealliance/cap-std</div></div></div>",
        "id": 441536208,
        "sender_full_name": "raskyld",
        "timestamp": 1717096981
    },
    {
        "content": "<p>At the end of the day, we could also check whether we can write abstractions to help the embedders write correct policies, but trying to write platform agnostic helpers to deal with file authentication may leads us to <a href=\"http://learn.microsoft.com\">learn.microsoft.com</a>, and so, to insanity. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"http://learn.microsoft.com\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/3ce17f2b2911dcb735720cc46e75758679339053/68747470733a2f2f6c6561726e2e6d6963726f736f66742e636f6d2f656e2d75732f6d656469612f6f70656e2d67726170682d696d6167652e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"http://learn.microsoft.com\" title=\"Microsoft Learn: Build skills that open doors in your career\">Microsoft Learn: Build skills that open doors in your career</a></div><div class=\"message_embed_description\">Gain technical skills through documentation and training, earn certifications and connect with the community</div></div></div>",
        "id": 441536943,
        "sender_full_name": "raskyld",
        "timestamp": 1717097226
    },
    {
        "content": "<p>Can you move <code>wow.kdl</code> out of the directory that should be writable by the wasm module? For example to it's parent directory/move all writable files to a subdirectory.</p>",
        "id": 441539754,
        "sender_full_name": "bjorn3",
        "timestamp": 1717098121
    },
    {
        "content": "<p>the idea is that the <code>wow.kdl</code> defines the workspace in much the same way as a <code>.python-version</code> (pyenv), <code>package.json</code>, etc. do and makes tools available in that same directory so that you can clone it, install, and start using them right there. I don't think it's realistic to ask people to add a layer of nesting to their repos for this.</p>",
        "id": 441540763,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717098433
    },
    {
        "content": "<p>Is the set of files in the root of the workspace expected to stay constant for the duration of the wasi program or is the wasi program expected to add/remove files from the workspace? If the former you could enumerate all files and directories at the root at startup and individually give the wasi program permission to access them all with the exception of wow.kdl.</p>",
        "id": 441544763,
        "sender_full_name": "bjorn3",
        "timestamp": 1717099538
    },
    {
        "content": "<p>It is expected to add files (e.g. a compiler) and theoretically move/remove files (though I don't have examples in mind).</p>",
        "id": 441546728,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717100057
    },
    {
        "content": "<p>Would a compiler place them in a subdirectory? If so giving full access to this subdirectory should be fine.</p>",
        "id": 441546959,
        "sender_full_name": "bjorn3",
        "timestamp": 1717100122
    },
    {
        "content": "<p>and just to make it explicit in case anyone thinks these concerns are too pessimistic/picky: there have been - and continue to be - many vulnerabilities due to filesystem races and file identity confusion</p>",
        "id": 441548469,
        "sender_full_name": "Lann Martin",
        "timestamp": 1717100525
    },
    {
        "content": "<p>I would want it to be possible for someone to run <code>my-compiler -i foo.my -o foo.wasm</code> if they wanted to.</p>\n<p>That said, I could see doing something clever like giving them a different directory (temp OS dir or virtual) that contains all the files that were in the workspace (via symlinks or references of some kind) except for <code>wow.kdl</code>. Then at the end of the execution copy over any new files into the workspace.</p>\n<p>Alternatively, we could go all in on <a href=\"https://github.com/esoterra/wow/blob/main/docs/security.md#separation-of-read-and-write-locations\">separate source and target areas</a> (though it makes things like formatters impossible) or focus <code>wow</code> on completely virtual workspaces where we can make the file-system behave nicely and be completely portable (maybe with a way to sync things between the real and virtual file-systems?).</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/esoterra/wow/blob/main/docs/security.md#separation-of-read-and-write-locations\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/e0d9c182f41ea42d2d885bdadd624b8b2642710e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353334653636653031623535653961363230343361363266303062393030326238313738386135393461323964633566616531303538346231373439653537352f65736f74657272612f776f77&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/esoterra/wow/blob/main/docs/security.md#separation-of-read-and-write-locations\" title=\"wow/docs/security.md at main · esoterra/wow\">wow/docs/security.md at main · esoterra/wow</a></div><div class=\"message_embed_description\">Workspaces on Wasm. Contribute to esoterra/wow development by creating an account on GitHub.</div></div></div>",
        "id": 441549001,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717100675
    },
    {
        "content": "<p>In the virtual option, maybe you'd have to drop into a virtual shell and when you do it copies the state of the workspace into a virtual file system. Then you run your wow commands against this and somewhere (maybe as you go maybe at the end?) you apply changes back to the real file-system/repo.</p>",
        "id": 441549441,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717100793
    },
    {
        "content": "<p>It seems like it should be possible to have a \"hybrid virtual filesystem\" where directories (entries) are virtualized but files aren't. I think that would serve a lot of purposes like these.</p>",
        "id": 441569661,
        "sender_full_name": "Lann Martin",
        "timestamp": 1717107221
    },
    {
        "content": "<p>It would certainly be handy for some code I maintain where I currently copy (or hardlink, where possible) files out of a content-addressed dir into a tempdir just to reconstruct the file tree for wasi</p>",
        "id": 441570249,
        "sender_full_name": "Lann Martin",
        "timestamp": 1717107426
    },
    {
        "content": "<p>I wonder if that could even be done lazily as guests attempt to access paths</p>",
        "id": 441611156,
        "sender_full_name": "Robin Brown",
        "timestamp": 1717129219
    },
    {
        "content": "<p>I have been watching this issue: <a href=\"https://github.com/bytecodealliance/cap-std/issues/352\">https://github.com/bytecodealliance/cap-std/issues/352</a></p>\n<p>I think it would serve our purpose to be able to create a <code>Dir</code> that is not a direct handle to a physical directory but to a virtual mapping defined programatically by the embedder.  This would allow us to map the root workspace dir 1:1 with the exception that <code>wow.kdl</code> wouldn't be resolvable.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/cap-std/issues/352\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/85631ea65a513626973ab30e3ab1b98dbe735636/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333139613434353765383864623433666536353632313964633137393138313762366462623566353939646238373366356530636234663862303161313435622f62797465636f6465616c6c69616e63652f6361702d7374642f6973737565732f333532&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/cap-std/issues/352\" title=\"Ability to construct virtual `Dir`s to mount files and subdirectories into · Issue #352 · bytecodealliance/cap-std\">Ability to construct virtual `Dir`s to mount files and subdirectories into · Issue #352 · bytecodealliance/cap-std</a></div><div class=\"message_embed_description\">Specifically with the option for those files/dirs to just be paths that don’t need to be opened when mounted. Note: When I say “mount” here this would only be internal to the Dir struct and not act...</div></div></div>",
        "id": 441635865,
        "sender_full_name": "raskyld",
        "timestamp": 1717140115
    },
    {
        "content": "<p>Hi all! Week-end is there finally <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span> </p>\n<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> I've seen on the linked issue that you have some concerns about implementing such virtual <code>Dir</code> in <code>cap_std</code>. Which is understandable because it would break the current API. If we were to create a new crate for that, do you have an idea how much work that would represent on <code>wasmtime-wasi</code>-crate?</p>",
        "id": 441881482,
        "sender_full_name": "raskyld",
        "timestamp": 1717234555
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"723701\">@raskyld</span> (the stat calls <a href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\">here</a> are conditional with <code>#[cfg(racy_asserts)]</code>, which is an option used in testing and fuzzing but not enabled in normal builds)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/8c011e558353b58817d6e8844e1ee39c28fe94b5/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3237353031333336332f35623163343030302d633834382d313165612d386564622d383737333935663638303635&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/cap-std/blob/main/cap-primitives/src/fs/rename.rs#L30\" title=\"cap-std/cap-primitives/src/fs/rename.rs at main · bytecodealliance/cap-std\">cap-std/cap-primitives/src/fs/rename.rs at main · bytecodealliance/cap-std</a></div><div class=\"message_embed_description\">Capability-oriented version of the Rust standard library - bytecodealliance/cap-std</div></div></div>",
        "id": 442545426,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717511952
    },
    {
        "content": "<p>It sounded like there might be a way to use <code>https://learn.microsoft.com/en-us/windows/win32/devnotes/ntopendirectoryobject</code> to obtain a handle representing a unified root containing all the Windows drive letters. If that's what you want, and if that turns out to be feasible, then it should be straightforward to implement within cap-std and have everything else \"just work\".</p>",
        "id": 442545470,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1717511965
    },
    {
        "content": "<p>I was quoting the issue but what I was thinking about was more general: In cap-std,  a <code>Dir</code> directly map to a std file.<br>\nWhat about a feature allowing <code>wasmtime</code> user to build a virtual dir to back WASI <code>preopens</code> that doesn't map to a file directly. It would be a virtual tree where nodes are mapping to either another virtual tree or a real host's fd/handle.</p>\n<p>In the case of <code>wow</code>, we would just need to map the virtual dir to the real host's dir with a filter that avoid mapping the <code>wow.kdl</code> at all. I don't have all the implementation details, but I am looking for a path to start trying to find a solution to the problem.</p>",
        "id": 442714327,
        "sender_full_name": "raskyld",
        "timestamp": 1717572603
    },
    {
        "content": "<p>Hey all, small <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> , what do you think about this approach?</p>",
        "id": 444631256,
        "sender_full_name": "raskyld",
        "timestamp": 1718347877
    },
    {
        "content": "<p>I'm not sure. We've tended to avoid having elaborate configurable filesystem APIs at the Wasmtime host API level, because a lot of use cases should be better off implemented by virtualization via guest code. But maybe some of these hybrid schemes point to a use case that can be more effectively done in host code, so perhaps we should consider it.</p>",
        "id": 444768039,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1718391204
    }
]