[
    {
        "content": "<p>I'm working on a project that is essentially using web assembly components as plugins, so I have mutliple wasm components, all with the same interface. Functions like <code>update</code> need to be called each instance at a regular interval, so I'm looking to speed up that process. This is similar to yonil's thread from a few days ago, but different layout</p>\n<ol>\n<li>Each component will only have a single instance</li>\n<li>Each instance has it's own store, so components don't sharing data</li>\n<li>I'm supporting WASI, so I'm currently using part of preview2-prototyping. So I'm trying to also work around async restrictions that are there currently</li>\n</ol>\n<p>Questions:<br>\nWhat are ways I can improve the speed? <br>\nCould creating engines/linkers per instance improve performance when running in parallel? <br>\nHow can I parallelize them in an async environment?<br>\nHow expensive is the <code>instantiate_pre</code> from <code>wasmtime::component::bindgen!</code>? I want it to be extensible, where a plugin can add extra binding types, so if I can leave it in that state it makes it easier to generate additional bindings. Otherwise, I can just generate the any extra bindings ahead of time.</p>",
        "id": 343580542,
        "sender_full_name": "Mason Ginter",
        "timestamp": 1679464081
    },
    {
        "content": "<blockquote>\n<p>What are ways I can improve the speed? </p>\n</blockquote>\n<p>I think the best place to start here would be to profile the current implementation. Without a concrete idea of where the bottleneck is it's tough to recommend various options/strategies.</p>\n<blockquote>\n<p>Could creating engines/linkers per instance improve performance when running in parallel? </p>\n</blockquote>\n<p>This souldn't be the case. Using one engine and linker for parallel instnatiations vs many engines/linkers should be the same performance. That being said this hasn't been rigorously tested, so if profiling shows a bottleneck here, it may be a bug for us to fix.</p>\n<blockquote>\n<p>How can I parallelize them in an async environment?</p>\n</blockquote>\n<p>This is a very broad question that is somewhat outside of the scope of Wasmtime itself. I'd recommend taking a look at <code>tokio</code> which enables running futures on multiple threads and then Wasmtime's async support will plug into Tokio well.</p>\n<blockquote>\n<p>How expensive is the instantiate_pre from wasmtime::component::bindgen!?</p>\n</blockquote>\n<p>It's not something that has had much effort put into optimizing it. It's not intentionally slow but at the same time it's not designed to be lightning fast. The fastest operation in Wasmtime is to acquire an <code>InstancePre&lt;T&gt;</code> and then instantiate it. That's tried-and-true and is the go-to method of instantiating something quickly. The general idea is for <code>InstancePre&lt;T&gt;</code> to represent pre-computed state of \"everything is ready to go and all that's necessary is to create a new instance\", so it's up to the application where this work goes and how to amortize it.</p>",
        "id": 343713997,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1679499376
    }
]