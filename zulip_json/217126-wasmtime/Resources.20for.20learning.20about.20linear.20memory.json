[
    {
        "content": "<p>I am interested in learning more about the wasmtime linear memory for a project. I have been going through <code>memory.rs</code> and <code>mmap.rs</code> a little, but I think I am lacking a bigger picture. Are there any online resources you can recommend (documentation going into more detail)?<br>\nA more specific question: What is the difference between the <code>accessible_size</code> and <code>mapping_size</code> (called for instance in <code>accessible_reserved</code>)? As far as I understand, the accessible size represents memory that is guaranteed to be accessible/usable, so it should always be allowed to dereference the pointer to the regions that are accessible. I am not sure what <code>mapping_size</code> is for.</p>",
        "id": 376434053,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689703255
    },
    {
        "content": "<p>Unfortunately there's not really documentation besides what's in the code, so the best way to know how things work is to study the implementation -- though we're happy to answer questions here too</p>",
        "id": 376440841,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689705006
    },
    {
        "content": "<p><code>accessible_size</code> is indeed the size of memory that is legal to access -- it corresponds to the size of the Wasm heap (which can grow during runtime)</p>",
        "id": 376440902,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689705025
    },
    {
        "content": "<p><code>mapping_size</code> is, as name suggests, the size of the total memory region we reserve. This can be larger than <code>accessible_size</code> because we want to allow growth without relocating the heap</p>",
        "id": 376441000,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689705057
    },
    {
        "content": "<p>Ok, thanks. What is the purpose/use of the <code>pre_guard_bytes</code>?</p>",
        "id": 376455870,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689709025
    },
    {
        "content": "<p>It's a configuration for guaranteed-unmapped memory before the start of linear memory which is a small defense-in-depth mechanism against possible compiler bugs which accidentally go before linear memory, otherwise it has no other runtime effect</p>",
        "id": 376459267,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689709876
    },
    {
        "content": "<p>Thanks! Another question: The bounds checking that ensure nothing is accessed beyong the bounds of the linear memory is done both at compile time and runtime, right? So far,  I found <code>validate_bounds</code> in <code>runtime/src/instance.rs</code> (runtime) and <code>bounds_check_and_compute_addr</code> in <code>cranelift/wasm/src/code_translator/bounds_checks.rs</code> (compile-time). Are there any more locations relevant to bounds checking?</p>",
        "id": 376791701,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689801082
    },
    {
        "content": "<p>Runtime bounds are really validated by code generated by what you've listed as \"compile-time\" checks. Since addresses aren't known until runtime, it's not really possible to do bounds-checking purely at compile-time. In more detail, we have two kinds of bounds-checking, \"dynamic\" and \"static\" (the names may not be the best, but that's what they are). Static bounds-checking is implemented by mapping a virtual-memory region to be accessible only as far as the memory's length, and a \"guard region\" after, so if the guest accesses out-of-bounds, we get (and catch) a SIGSEGV. The guard needs to be as large as the 32-bit offset can allow</p>",
        "id": 376795257,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689802392
    },
    {
        "content": "<p>and then dynamic is what you describe, with actual comparison operators</p>",
        "id": 376795321,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689802426
    },
    {
        "content": "<p>Where in the code is this \"guard region\" implemented? Are those all these special cases in <a href=\"http://bound_checks.rs\">bound_checks.rs</a>?</p>",
        "id": 377048464,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689871514
    },
    {
        "content": "<p>it's not really a single line of code we can point at; it's an overall design</p>",
        "id": 377048798,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689871585
    },
    {
        "content": "<p>the memory map creates the guard region</p>",
        "id": 377048833,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689871594
    },
    {
        "content": "<p>and then we compile in a way that has no dynamic bounds check, but rather adds a 32-bit offset</p>",
        "id": 377048915,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1689871613
    },
    {
        "content": "<p>Maybe some more context on why I am asking these questions: In a previous thread, I already mentionned that we are working on a prototype for adding MTE to wasm(time) for increased memory safety (it's part of a software stack that also involves/requires llvm to do some analysis). MTE requires aarch64 and 64 bit pointers, so we had to adapt wasmtime to use that, and that worked well. Since we no longer only have 32 bit addresses, we had to insert 64 bit runtime out of bounds checks. Now, we were thinking of a way to remove the overhead of these bounds checks. We came up with the idea of replacing these runtime bounds checks by using MTE (MTE adds tag bits to the upper bits of addresses) as well, by tagging the entire linear memory itself (with the stg instruction) and all pointers to the linear memory. Then, MTE would trap at a tag mismatch at runtime. We already realized that we should only be tagging the accessible linear memory (our changes here were mostly made to <a href=\"http://mmap.rs\">mmap.rs</a> and <a href=\"http://memory.rs\">memory.rs</a>). We've also already modified the bounds checks in the functions/files that I mentionned in the previous message. However, it seems like we have missed adjusting some code related to the bounds checks (not sure if it's the \"dynamic\" or \"static\" bounds-checking you mentionned), since I still get an out of bounds exception when running a simple test program, probably because we haven't masked out the tag bits somewhere.</p>",
        "id": 377062569,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689874586
    },
    {
        "content": "<p>you may be interested in this issue and its discussion as well: <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6094\">https://github.com/bytecodealliance/wasmtime/issues/6094</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/6094\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/8b603dd42df9d5792ef229983bd8d8fada491008\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f346231363136323639333339666436313430623235326163393565623861383532353239363965363461326238393931373937616166316363663037396331362f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f36303934)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/6094\" title=\"Further Improve Execution Speed with Explicit Bounds Checks 路 Issue #6094 路 bytecodealliance/wasmtime\">Further Improve Execution Speed with Explicit Bounds Checks 路 Issue #6094 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">I've been digging into Cranelift's and Wasmtime's code quality and Wasm execution throughput when \"dynamic memories\" with explicit bounds checks are used to implement Wasm linear memories. Here I'm...</div></div></div>",
        "id": 377063605,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689874826
    },
    {
        "content": "<p>when you say you had to insert 64 bit addresses, do you mean you switched to using wasm64?</p>",
        "id": 377063757,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689874869
    },
    {
        "content": "<p>because wasm32 loads/stores already end up as 64 bit addresses after translation, so I am a bit confused</p>",
        "id": 377063859,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689874899
    },
    {
        "content": "<p>Yes, we switched to wasm64.</p>",
        "id": 377067083,
        "sender_full_name": "Fritz Rehde",
        "timestamp": 1689875692
    }
]