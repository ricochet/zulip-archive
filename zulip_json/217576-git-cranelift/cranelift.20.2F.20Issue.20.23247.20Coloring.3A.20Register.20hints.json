[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/247\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/247\">Issue #247</a>:</p>\n<blockquote>\n<p>See also the discussion of biased coloring in #189.</p>\n<p>The register coloring pass is currently assigning simply the first available register to new register values. This can be improved with <em>register hints</em> to reduce the amount of register shuffling needed in the following cases:</p>\n<ul>\n<li>An instruction requires an input operand in a specific register. For example, Intel's dynamic shift instructions require the shift amount in <code>%rcx</code>.</li>\n<li>A value passed as a call argument must be in a register specified by the ABI.</li>\n<li>Values belonging to the same virtual register should preferably be assigned the same physical register to minimize shuffling before branches.</li>\n</ul>\n<p>There are also cases where the register hint is not a specific register, but rather a subset of the top-level register class:</p>\n<ul>\n<li>Some instructions only accept a subset of registers. For example some of Intel's addressing modes can't use <code>%r12</code> and others can't use <code>%r13</code>.</li>\n<li>If a value is live across a call, it should be in one of the callee-saved registers. (SpiderMonkey doesn't have CSRs).</li>\n</ul>\n<p>The <code>LiveRange::affinity</code> field is already used to track register class hints. When a value is used by an instruction with a reduced register class constraint, the affinity is intersected with the constraint. These hints are currently ignored, and we just assign registers from the top-level register class.</p>\n<p>Individual register hints are not tracked anywhere. They could be computed by the reload pass.</p>\n<h2>Constraint processing</h2>\n<p>Hints, whether for register sets or singletons, require the constraint solver to be a bit more clever. It should use the hints as much as possible, but ignore them before failing to find a solution.</p>\n<h2>Anti-hints</h2>\n<p>Sometimes a hint can't be used because another value is already using the register we want. We can prevent this by trying to avoid assigning value to registers where they will get in the way later.</p>\n<p>This can be done using a data structure similar to LLVM's register matrix. Whenever a value is given a hint (during the reload pass), its live range is inserted into the register matrix for the corresponding unit. The coloring pass can then check live ranges against the matrix to see if there is a conflict with other hinted values.</p>\n</blockquote>",
        "id": 189361332,
        "sender_full_name": "GitHub",
        "timestamp": 1582932264
    }
]