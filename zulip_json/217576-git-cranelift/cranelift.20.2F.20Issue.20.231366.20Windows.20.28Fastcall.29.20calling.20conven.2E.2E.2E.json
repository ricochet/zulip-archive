[
    {
        "content": "<p>hrydgard opened <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We're having issues, only on Windows, with floating point variables becoming corrupt across calls into Cranelift from Wasmer.</p>\n<p>The following function <code>callee_saved_gprs</code> in the codegen is supposed to return a list of the callee-saved registers:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\">https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370</a></p>\n<p>However, it, nor its callers, seem to concern themselves with saving the floating point callee-saved registers. Quoth <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers</a>:</p>\n<blockquote>\n<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-15 are considered nonvolatile and must be saved and restored by a function that uses them.</p>\n</blockquote>\n<p><code>callee_saved_gprs</code> only lists RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, ignoring XMM6-15.</p>\n<p>I believe this may be the cause of our troubles, it definitely looks wrong. What do you think?</p>\n</blockquote>",
        "id": 186689863,
        "sender_full_name": "GitHub",
        "timestamp": 1580137485
    },
    {
        "content": "<p>hrydgard labeled <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We're having issues, only on Windows, with floating point variables becoming corrupt across calls into Cranelift from Wasmer.</p>\n<p>The following function <code>callee_saved_gprs</code> in the codegen is supposed to return a list of the callee-saved registers:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\">https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370</a></p>\n<p>However, it, nor its callers, seem to concern themselves with saving the floating point callee-saved registers. Quoth <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers</a>:</p>\n<blockquote>\n<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-15 are considered nonvolatile and must be saved and restored by a function that uses them.</p>\n</blockquote>\n<p><code>callee_saved_gprs</code> only lists RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, ignoring XMM6-15.</p>\n<p>I believe this may be the cause of our troubles, it definitely looks wrong. What do you think?</p>\n</blockquote>",
        "id": 186689864,
        "sender_full_name": "GitHub",
        "timestamp": 1580137486
    },
    {
        "content": "<p>hrydgard edited <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We're having issues, only on Windows, with floating point variables becoming corrupt across calls into Cranelift from Wasmer.</p>\n<p>The following function <code>callee_saved_gprs</code> in the codegen is supposed to return a list of the callee-saved registers:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\">https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370</a></p>\n<p>However, it, nor its callers, seem to concern themselves with saving the floating point callee-saved registers. Quoth <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers</a>:</p>\n<blockquote>\n<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-15 are considered nonvolatile and must be saved and restored by a function that uses them.</p>\n</blockquote>\n<p><code>callee_saved_gprs</code> only lists RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, ignoring XMM6-15.</p>\n<p>I believe this may be the cause of our troubles, it definitely looks wrong. What do you think?</p>\n<p>(If the reserved stack spaced for this would be prohibitive and code is generated assuming no callee saved registers, things could still work internally as they do now, but you'd still need to save XMM6-15 on entering Cranelift and restore them when exiting Cranelift).</p>\n</blockquote>",
        "id": 186691500,
        "sender_full_name": "GitHub",
        "timestamp": 1580138392
    },
    {
        "content": "<p>hrydgard edited <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We're having issues, only on Windows, with floating point variables becoming corrupt across calls into Cranelift from Wasmer.</p>\n<p>The following function <code>callee_saved_gprs</code> in the codegen is supposed to return a list of the callee-saved registers:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\">https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370</a></p>\n<p>However, it, nor its callers, seem to concern themselves with saving the floating point callee-saved registers (with gprs in its name, that kind makes sense). Quoth <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers</a>:</p>\n<blockquote>\n<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-15 are considered nonvolatile and must be saved and restored by a function that uses them.</p>\n</blockquote>\n<p><code>callee_saved_gprs</code> only lists RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, ignoring XMM6-15.</p>\n<p>I believe this may be the cause of our troubles, it definitely looks wrong. What do you think?</p>\n<p>(If the reserved stack spaced for this would be prohibitive and code is generated assuming no callee saved registers, things could still work internally as they do now, but you'd still need to save XMM6-15 on entering Cranelift and restore them when exiting Cranelift).</p>\n</blockquote>",
        "id": 186694854,
        "sender_full_name": "GitHub",
        "timestamp": 1580140385
    },
    {
        "content": "<p>sstangl <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579072230\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579072230\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Windows does indeed require restoring those registers on exit if changed.</p>\n<p>IonMonkey implementation for reference: <a href=\"https://searchfox.org/mozilla-central/rev/cbd110d718bc89a499d3f996af24532abbf6f8ea/js/src/jit/x64/Trampoline-x64.cpp#72\" target=\"_blank\" title=\"https://searchfox.org/mozilla-central/rev/cbd110d718bc89a499d3f996af24532abbf6f8ea/js/src/jit/x64/Trampoline-x64.cpp#72\">https://searchfox.org/mozilla-central/rev/cbd110d718bc89a499d3f996af24532abbf6f8ea/js/src/jit/x64/Trampoline-x64.cpp#72</a></p>\n</blockquote>",
        "id": 186752143,
        "sender_full_name": "GitHub",
        "timestamp": 1580185224
    },
    {
        "content": "<p>hrydgard <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We've done more investigation, and manually saving and restoring the registers around calls into Cranelift using some inline assembly fixes our variable corruption issues. </p>\n<p>I don't know if this is actually a real security issue, since values are leaking from VM to host, and the host is in control of the VM's memory anyway. I guess it's possible that values could leak from host to VM if there are bugs in the register allocator, since nothing seems to wipe the XMM registers when entering the VM (though I haven't looked closely for that).</p>\n<p>Either way, this clearly needs to be addressed!</p>\n</blockquote>",
        "id": 186762254,
        "sender_full_name": "GitHub",
        "timestamp": 1580200667
    },
    {
        "content": "<p>hrydgard edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We've done more investigation, and manually saving and restoring the XMM registers around calls into Cranelift using some inline assembly fixes our variable corruption issues. </p>\n<p>I don't know if this is actually a real security issue, since values are leaking from VM to host, and the host is in control of the VM's memory anyway. I guess it's possible that values could leak from host to VM if there are bugs in the register allocator, since nothing seems to wipe the XMM registers when entering the VM (though I haven't looked closely for that).</p>\n<p>Either way, this clearly needs to be addressed!</p>\n</blockquote>",
        "id": 186762303,
        "sender_full_name": "GitHub",
        "timestamp": 1580200685
    },
    {
        "content": "<p>hrydgard edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We've done more investigation, and manually saving and restoring the XMM registers around calls into Cranelift using some inline assembly fixes our variable corruption issues. </p>\n<p>I don't know if this is actually a real security issue, since values are leaking from VM to host, and the host is in control of the VM's memory anyway. I guess it's possible that values could leak from host to VM if there are bugs in the register allocator, since nothing seems to wipe the XMM registers when entering the VM (though I haven't looked closely for that).</p>\n<p>Either way, this clearly needs to be addressed!</p>\n<p>For reference, here's our terrifying workaround (call store_xmm before calling into cranelift, restore_xmm afterwards):</p>\n<div class=\"codehilite\"><pre><span></span>// XMM6-15\npub fn store_xmm(temp: &amp;mut [f32; 10 * 4]) {\n    unsafe {\n        asm!(r#&quot;\n            vmovdqu %xmm6, 0($0)\n            vmovdqu %xmm7, 16($0)\n            vmovdqu %xmm8, 32($0)\n            vmovdqu %xmm9, 48($0)\n            vmovdqu %xmm10, 64($0)\n            vmovdqu %xmm11, 80($0)\n            vmovdqu %xmm12, 96($0)\n            vmovdqu %xmm13, 112($0)\n            vmovdqu %xmm14, 128($0)\n            vmovdqu %xmm15, 144($0)\n            &quot;#\n            : : &quot;r&quot;(temp) );\n    }\n}\n\npub fn restore_xmm(temp: &amp;[f32; 10 * 4]) {\n    unsafe {\n        asm!(r#&quot;\n            vmovdqu 0($0), %xmm6\n            vmovdqu 16($0), %xmm7\n            vmovdqu 32($0), %xmm8\n            vmovdqu 48($0), %xmm9\n            vmovdqu 64($0), %xmm10\n            vmovdqu 80($0), %xmm11\n            vmovdqu 96($0), %xmm12\n            vmovdqu 112($0), %xmm13\n            vmovdqu 128($0), %xmm14\n            vmovdqu 144($0), %xmm15\n            &quot;#\n            : : &quot;r&quot;(temp) );\n    }\n}\n</pre></div>\n\n\n</blockquote>",
        "id": 186762570,
        "sender_full_name": "GitHub",
        "timestamp": 1580201018
    },
    {
        "content": "<p>hrydgard edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579137266\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We've done more investigation, and manually saving and restoring the XMM registers around calls into Cranelift using some inline assembly fixes our variable corruption issues. </p>\n<p>I don't know if this is actually a real security issue, since values are leaking from VM to host, and the host is in control of the VM's memory anyway. I guess it's possible that values could leak from host to VM if there are bugs in the register allocator, since nothing seems to wipe the XMM registers when entering the VM (though I haven't looked closely for that).</p>\n<p>Either way, this clearly needs to be addressed!</p>\n<p>For reference, here's our (nightly-only) terrifying workaround (call store_xmm before calling into cranelift, restore_xmm afterwards):</p>\n<div class=\"codehilite\"><pre><span></span>// XMM6-15\npub fn store_xmm(temp: &amp;mut [f32; 10 * 4]) {\n    unsafe {\n        asm!(r#&quot;\n            vmovdqu %xmm6, 0($0)\n            vmovdqu %xmm7, 16($0)\n            vmovdqu %xmm8, 32($0)\n            vmovdqu %xmm9, 48($0)\n            vmovdqu %xmm10, 64($0)\n            vmovdqu %xmm11, 80($0)\n            vmovdqu %xmm12, 96($0)\n            vmovdqu %xmm13, 112($0)\n            vmovdqu %xmm14, 128($0)\n            vmovdqu %xmm15, 144($0)\n            &quot;#\n            : : &quot;r&quot;(temp) );\n    }\n}\n\npub fn restore_xmm(temp: &amp;[f32; 10 * 4]) {\n    unsafe {\n        asm!(r#&quot;\n            vmovdqu 0($0), %xmm6\n            vmovdqu 16($0), %xmm7\n            vmovdqu 32($0), %xmm8\n            vmovdqu 48($0), %xmm9\n            vmovdqu 64($0), %xmm10\n            vmovdqu 80($0), %xmm11\n            vmovdqu 96($0), %xmm12\n            vmovdqu 112($0), %xmm13\n            vmovdqu 128($0), %xmm14\n            vmovdqu 144($0), %xmm15\n            &quot;#\n            : : &quot;r&quot;(temp) );\n    }\n}\n</pre></div>\n\n\n</blockquote>",
        "id": 186762982,
        "sender_full_name": "GitHub",
        "timestamp": 1580201434
    },
    {
        "content": "<p>sstangl <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579291896\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579291896\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<blockquote>\n<p>We've done more investigation, and manually saving and restoring the XMM registers around calls into Cranelift using some inline assembly fixes our variable corruption issues.</p>\n</blockquote>\n<p>Well yes, that's logically equivalent to fixing Cranelift's Microsoft x64 calling convention implementation. Except in the case of Cranelift ever calling out to native code, in which case that boundary would also need to know to save/restore registers.</p>\n<p>The workaround isn't terrifying -- that's pretty much what Cranelift needs to do internally, except that Cranelift can know what XMM regs were actually allocated and therefore can skip saving/restoring unused volatile registers.</p>\n</blockquote>",
        "id": 186791470,
        "sender_full_name": "GitHub",
        "timestamp": 1580224293
    },
    {
        "content": "<p>hrydgard <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579297406\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579297406\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Right, though I suspect that the calling-out-to-native-code scenario is not actually an issue, at least not a correctness one, because Cranelift internally doesn't seem to be aware of the concept of callee-save FP/SIMD registers, so they would simply already be making sure that they're all \"dead\" when calling out.</p>\n</blockquote>",
        "id": 186792579,
        "sender_full_name": "GitHub",
        "timestamp": 1580224931
    },
    {
        "content": "<p>hrydgard edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579297406\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-579297406\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Right, though I suspect that the calling-out-to-native-code scenario is not actually an issue, at least not a correctness one, because Cranelift internally doesn't seem to be aware of the concept of callee-saved FP/SIMD registers, so they would simply already be making sure that they're all \"dead\" when calling out.</p>\n</blockquote>",
        "id": 186792610,
        "sender_full_name": "GitHub",
        "timestamp": 1580224951
    },
    {
        "content": "<p>hrydgard <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582459346\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582459346\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>So is anyone from Cranelift going to look at this, or should I just mash together a hacky PR that saves the registers on entrance and restores them on exit, like we did in our code? That way Cranelift can keep pretending that the Windows ABI does not have callee-save FP registers...</p>\n</blockquote>",
        "id": 187462726,
        "sender_full_name": "GitHub",
        "timestamp": 1580916159
    },
    {
        "content": "<p>hrydgard edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582459346\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582459346\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>So is anyone from Cranelift going to look at this, or should I just mash together a hacky PR that saves the registers on entrance and restores them on exit, like we did in our surrounding code? That way Cranelift can keep pretending that the Windows ABI does not have callee-save FP registers...</p>\n</blockquote>",
        "id": 187462742,
        "sender_full_name": "GitHub",
        "timestamp": 1580916173
    },
    {
        "content": "<p>sstangl <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582477515\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582477515\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Although I suppose we'd take a hacky-but-correct patch, the real patch shouldn't be much more work.</p>\n<p>You'd just need to make an analogue of the <code>callee_saved_gprs_used()</code> in <a href=\"https://github.com/bytecodealliance/cranelift/blob/master/cranelift-codegen/src/isa/x86/abi.rs#L507\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/master/cranelift-codegen/src/isa/x86/abi.rs#L507\">fastcall_prologue_epilogue()</a>. Probably get that function to return both GPRs and FPRs used, so that you don't walk the CFG twice.</p>\n<p><code>insert_common_epilogue()</code> would need to learn about FPRs also.</p>\n</blockquote>",
        "id": 187466337,
        "sender_full_name": "GitHub",
        "timestamp": 1580918371
    },
    {
        "content": "<p>hrydgard <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582647866\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582647866\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Oh, you're actually part of the project, I misunderstood from your tone before that you were just another passersby :)  I mean, this is a critical bug that can cause really tricky secondary bugs and could possibly (although not super likely) be a CVE-worthy security issue, I initially kind of expected you guys to pretty much take this and run with it.</p>\n<p>Anyway, I don't have the time to go deep here, so a patch from us would likely just be what I said before, just save and restore all the registers on entry/exit. I agree that it's probably not that much work to fix it properly, but I don't know this code base at all - I've written JIT compilers before, things are not always as easy as they first seem...</p>\n</blockquote>",
        "id": 187502722,
        "sender_full_name": "GitHub",
        "timestamp": 1580942391
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582677150\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366#issuecomment-582677150\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>Having read the MSDN x86_64 calling convention page more than a few times I didn't remember it mentioning XMM registers being nonvolatile before... it turns out even in January of last year they weren't mentioned: so says <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\">the page via archive.org</a>. It got added somewhere between then and <a href=\"https://web.archive.org/web/20191030045048/https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\" target=\"_blank\" title=\"https://web.archive.org/web/20191030045048/https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\">October</a>. Not a huge fan of this getting a few words added towards the end of one page!!</p>\n<p>Regardless, I'm putting together a change to preserve xmm6-xmm15.</p>\n</blockquote>",
        "id": 187509577,
        "sender_full_name": "GitHub",
        "timestamp": 1580948548
    },
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1366\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1366\">Issue #1366</a>:</p>\n<blockquote>\n<p>We're having issues, only on Windows, with floating point variables becoming corrupt across calls into Cranelift from Wasmer.</p>\n<p>The following function <code>callee_saved_gprs</code> in the codegen is supposed to return a list of the callee-saved registers:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370\">https://github.com/bytecodealliance/cranelift/blob/23e9bdb2d99fb8f554793cb87f1578cc543c355f/cranelift-codegen/src/isa/x86/abi.rs#L370</a></p>\n<p>However, it, nor its callers, seem to concern themselves with saving the floating point callee-saved registers (with gprs in its name, that kind makes sense). Quoth <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers\">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019#callercallee-saved-registers</a>:</p>\n<blockquote>\n<p>The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-15 are considered nonvolatile and must be saved and restored by a function that uses them.</p>\n</blockquote>\n<p><code>callee_saved_gprs</code> only lists RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, ignoring XMM6-15.</p>\n<p>I believe this may be the cause of our troubles, it definitely looks wrong. What do you think?</p>\n<p>(If the reserved stack spaced for this would be prohibitive and code is generated assuming no callee saved registers, things could still work internally as they do now, but you'd still need to save XMM6-15 on entering Cranelift and restore them when exiting Cranelift).</p>\n</blockquote>",
        "id": 189361775,
        "sender_full_name": "GitHub",
        "timestamp": 1582932526
    }
]