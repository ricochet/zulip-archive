[
    {
        "content": "<p>hotsphink <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567180969\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567180969\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<blockquote>\n<p>SpiderMonkey GC (incremental and generational; has both pre-write and post-write barriers; if we include various weak caches, it also has read barriers, but these are used rarely, and are only used in C++ VM code AFAIK)</p>\n</blockquote>\n<p>This isn't entirely true. SpiderMonkey very commonly uses read barriers in the interface with the Gecko embedding, for integrating with the cycle collector. Any embedding object that might be a  member of a collectible cycle will have a read barrier that prevents it from being cycle collected.</p>\n<p>Specifically, <code>JS::Heap&lt;T&gt;</code> has a read barrier that does <code>UnmarkGrayGCThingRecursively</code> aka <code>ExposeGCThingToActiveJS</code>, though note that \"gray\" in that name is \"CC gray\", not at all the same as the \"gray\" in <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-566790342\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-566790342\">https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-566790342</a>. It's not a weak reference, it's more a workaround for not having write barriers throughout the embedding.</p>\n<p>I don't know if that's at all relevant here, though.</p>\n</blockquote>",
        "id": 183783246,
        "sender_full_name": "GitHub",
        "timestamp": 1576698030
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567233780\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567233780\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<p>In support of the plan here, I've now submitted <a href=\"https://github.com/bytecodealliance/cranelift/pull/1299\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1299\">https://github.com/bytecodealliance/cranelift/pull/1299</a> to start generalizing global values into templates.</p>\n</blockquote>",
        "id": 183795379,
        "sender_full_name": "GitHub",
        "timestamp": 1576706771
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567638992\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567638992\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<p>First off: thanks for the detailed responses everyone!</p>\n<hr>\n<p>@eqrion great! Sounds like we can work in parallel :)</p>\n<p>A good incremental stepping stone might be using templates (once we have them working with <code>store_ref</code>) to simply emit a call to the out of line functions you're implementing now.</p>\n<hr>\n<p>@bnjbvr</p>\n<blockquote>\n<p>Since WeakRefs are making their way into JS, I'd expect that we'd have them in wasm too, and they'll probably require the read barrier (later).</p>\n</blockquote>\n<p>@hotsphink</p>\n<blockquote>\n<p>SpiderMonkey very commonly uses read barriers in the interface with the Gecko embedding, for integrating with the cycle collector. Any embedding object that might be a member of a collectible cycle will have a read barrier that prevents it from being cycle collected.</p>\n</blockquote>\n<p>Great points! It probably does make sense to support read barriers from the get-go then.</p>\n<p>Out of curiosity, does ion ever emit inline read barriers for objects in its JIT'd code, similar to those used by <code>JS::Heap&lt;T&gt;</code>, or do those read barriers only exist in C++ code?</p>\n<hr>\n<p>@bnjbvr</p>\n<blockquote>\n<p>There would be an alias kind for GC objects, a different alias kind for others, and a safepoint would be a write of the GC object alias kind. If the alias kinds are controlled by the embedder, then it would also address the last item (An embedder might want slightly different write barriers for references that it knows are different kinds of objects).</p>\n</blockquote>\n<p>Yes, this would work perfectly.</p>\n<blockquote>\n<p><code>store_ref</code></p>\n</blockquote>\n<p>Sure :)</p>\n</blockquote>",
        "id": 183879395,
        "sender_full_name": "GitHub",
        "timestamp": 1576785340
    },
    {
        "content": "<p>hotsphink <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567651739\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176#issuecomment-567651739\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<blockquote>\n<p>Out of curiosity, does ion ever emit inline read barriers for objects in its JIT'd code, similar to those used by <code>JS::Heap&lt;T&gt;</code>, or do those read barriers only exist in C++ code?</p>\n</blockquote>\n<p>From my shaky understanding, there are no read barriers in JIT code. I think a plain property read, for example, would not need a read barrier, at least not until the value read makes its way out to the calling C++ Gecko code. SpiderMonkey code won't read barrier \"internal\" things even in C++ code, it relies on Gecko to read barrier things that get returned from the JS engine.</p>\n<p>The JIT does generate code for both pre- and post-write barriers, when it can't prove they aren't needed.</p>\n</blockquote>",
        "id": 183882300,
        "sender_full_name": "GitHub",
        "timestamp": 1576787510
    },
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1176\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<p>Most likely global.set/.get or table.set/.get for reference types will be translated into regular memory load and store instructions. Currently, their implementations are missing at codegen side. The <a href=\"https://github.com/CraneStation/cranelift/pull/1073\" target=\"_blank\" title=\"https://github.com/CraneStation/cranelift/pull/1073\">https://github.com/CraneStation/cranelift/pull/1073</a> performs the translation of the wasm, but CL validator fails when ref types and globals/tables operations are present (see e.g. <a href=\"https://github.com/WebAssembly/wasm-c-api/blob/master/example/hostref.wat\" target=\"_blank\" title=\"https://github.com/WebAssembly/wasm-c-api/blob/master/example/hostref.wat\">example</a>)</p>\n</blockquote>",
        "id": 189361639,
        "sender_full_name": "GitHub",
        "timestamp": 1582932449
    }
]