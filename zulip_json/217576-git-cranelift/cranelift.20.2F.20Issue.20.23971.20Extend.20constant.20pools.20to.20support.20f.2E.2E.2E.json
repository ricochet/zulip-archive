[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/971\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/971\">Issue #971</a>:</p>\n<blockquote>\n<p>As of today, there's a concept of constant pools in Cranelift, that works for SIMD 128-bits values. I'd like to extend it to work also for float32 and float64 values, to avoid the need for the bitcast, which I'm sure is pretty terrible performance-wise (and doesn't help register allocation either, since it requires one GPR register with a very short lifetime).</p>\n<p>My current plan is the following:</p>\n<ul>\n<li>the <code>uimm128</code> immediate could be reused to store any kind of constants, since it contains an <code>ir::Constant</code> (handle to a vector of bytes of any size); it would be renamed to <code>constant</code>.</li>\n<li>a new instruction <code>load_from_constant_pool</code> would be introduced, taking an input <code>constant</code> value.</li>\n<li>vconst right now can be inserted in the constant pool only from the parser. It'd be nice if this were done during codegen itself. We could recycle \"expand_fconst\" to do this and legalize vconst / f32const / f64const into a <code>load_from_constant_pool</code> with the right Constant.</li>\n<li>we switch the encodings of vconst to work for load_from_constant_pool on the same types; and we add encodings for f32/f64.</li>\n</ul>\n<p>Aligning the constant pool values would be nice to have but not required at this point; it would just be a performance fault on x86.</p>\n<p>@abrown Does it sound reasonable to you?</p>\n</blockquote>",
        "id": 189361570,
        "sender_full_name": "GitHub",
        "timestamp": 1582932398
    }
]