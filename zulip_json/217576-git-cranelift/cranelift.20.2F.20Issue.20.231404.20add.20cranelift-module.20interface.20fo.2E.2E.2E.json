[
    {
        "content": "<p>froydnj opened <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p><code>lucetc</code> needs some way of accessing the trap sites for every function it compiles:</p>\n<p><a href=\"https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89\" target=\"_blank\" title=\"https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89\">https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89</a></p>\n<p>In the above snippet, the trap site access happens after <code>Module::finish</code> has been called, so we're working with <code>faerie</code> interfaces.</p>\n<p>We are trying to port <code>lucetc</code> to use <code>object</code> instead of <code>faerie</code> underneath, mostly so <code>lucetc</code> can start generating PE/COFF objects with ease.  It would reduce risk somewhat to be able to use <code>cranelift-module</code> as a high-level interface, swap between <code>cranelift-object</code> and <code>cranelift-faerie</code> with as few lines of code as possible, and deal with <code>object</code> and <code>faerie</code> themselves as little as possible (probably just to write out the .o file).  Therefore, it would be convenient if this information about traps associated with each function were accessible through <code>cranelift-module</code> interfaces, rather than through lower-level interfaces.</p>\n<h4>Benefit</h4>\n<p>Trap information would be more easily accessible prior to module finalization.  Though I don't know of anybody else who needs this kind of information about besides <code>lucetc</code> at this point.</p>\n<h4>Implementation</h4>\n<p>This is the tricky bit, because the three in-tree implementations differ substantially in their approach to trap collection:</p>\n<ul>\n<li><code>cranelift-faerie</code> collects essentially <code>(string-name, Vec&lt;TrapSite&gt;)</code> pairs.</li>\n<li><code>cranelift-object</code> collects a mapping of <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code>.</li>\n<li><code>cranelift-simplejit</code> ignores traps entirely.</li>\n</ul>\n<p>I don't think there is a single method that all three interfaces could easily implement to iterate over <code>(string-name, &amp;Vec&lt;TrapSite&gt;)</code> pairs.  To implement such an interface, <code>cranelift-object</code> would need to have a way to map from <code>FuncId</code> to <code>string-name</code>, and that's awkward to do, given that <code>object</code> itself doesn't deal with symbol names as strings, but as <code>Vec&lt;u8&gt;</code>.</p>\n<p>The alternative, iterating over <code>(FuncId, &amp;Vec&lt;TrapSite&gt;)</code> pairs, would require some kind of modification to <code>cranelift-faerie</code>.  We could change <code>cranelift-faerie</code> to map from <code>string-name</code> to <code>FuncId</code>: <code>cranelift-faerie</code> could grow a separate table for storing that mapping, but <code>cranelift-module</code> is already storing that mapping, and requiring <code>cranelift-faerie</code> to store it seems like wasted effort.  Alternatively, the way <code>cranelift-faerie</code> stores its traps could be modified to look more like <code>cranelift-object</code>.</p>\n<p>But then maybe the right thing to do is just moving trap collection into <code>cranelift-module</code> itself?  <code>Module::new</code> would then grow a flag for indicating whether trap collection should be done.  <code>Module</code> itself would probably contain a <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code> mapping similar to <code>cranelift-object</code>, and then <code>Backend::define_function</code> would receive <code>Option&lt;&amp;mut Vec&lt;TrapSite&gt;&gt;</code> for potentially accumulating traps.</p>\n<p>Since <code>cranelift-simplejit</code> doesn't collect traps, it doesn't matter too much what interface gets decided on.</p>\n<p>I think I prefer moving trap collection into <code>cranelift-module</code> itself, but modifying <code>cranelift-faerie</code> to make it more like <code>cranelift-object</code> and the implementing some sort of common iterator interface works, too.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to keep the status quo, and <code>lucetc</code> would need to write two sets of code for defining certain pieces of information: one that defines those pieces with <code>faerie</code> and another that defines them with <code>object</code>.</p>\n</blockquote>",
        "id": 188951059,
        "sender_full_name": "GitHub",
        "timestamp": 1582568089
    },
    {
        "content": "<p>philipc <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590618409\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590618409\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<blockquote>\n<p>To implement such an interface, cranelift-object would need to have a way to map from FuncId to string-name</p>\n</blockquote>\n<p><code>cranelift-module</code> already has a <a href=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-module/src/module.rs#L221\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-module/src/module.rs#L221\">map from <code>FuncId</code> to <code>ModuleFunction</code></a> which includes a <a href=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-module/src/module.rs#L120\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-module/src/module.rs#L120\">name</a> and is accessible via the <code>ModuleNamespace</code> that is commonly passed to backend methods.</p>\n<p>Another alternative is to return the traps when defining functions, instead of storing them in the backend.  So <code>lucetc</code> will need to build its trap tables as it goes, instead of doing it all at then end. I haven't looked deeply to see how nicely this would work out, but it seems that each function trap table gets its own independent symbol so I think it could be okay.</p>\n</blockquote>",
        "id": 188980888,
        "sender_full_name": "GitHub",
        "timestamp": 1582590529
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590636512\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590636512\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<p>Returning the traps when defining functions seems like a good way to divide the responsibilities into cranelift-module and lucet. That would mean changing the codegen model of cranelift-module to do it at definition, rather than at finalize, but I don't think that is necessarily a bad thing.</p>\n</blockquote>",
        "id": 188984201,
        "sender_full_name": "GitHub",
        "timestamp": 1582594576
    },
    {
        "content": "<p>pchickey edited a <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590636512\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-590636512\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<p>Returning the traps when defining functions seems like a good way to divide the responsibilities into cranelift-module and lucet. That would mean changing cranelift-module to perform codegen at definition time, rather than at finalize, but I don't think that is necessarily a bad thing.</p>\n</blockquote>",
        "id": 188984221,
        "sender_full_name": "GitHub",
        "timestamp": 1582594603
    },
    {
        "content": "<p>froydnj <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-591033651\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-591033651\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<blockquote>\n<p>That would mean changing cranelift-module to perform codegen at definition time, rather than at finalize, but I don't think that is necessarily a bad thing.</p>\n</blockquote>\n<p>Doesn't <code>cranelift-module</code> already do this?  <code>cranelift-object</code>'s <code>define_function</code> says:</p>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-object/src/backend.rs#L177-L211\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-object/src/backend.rs#L177-L211\">https://github.com/bytecodealliance/cranelift/blob/ea922e17f9c5febffe8f43019bc8697cf4656f04/cranelift-object/src/backend.rs#L177-L211</a></p>\n<p>and <code>cranelift-faerie</code>/<code>cranelift-simplejit</code> do very similar things.  I guess they don't <em>have</em> to, but the documentation on <code>cranelift-module::define_function</code> says \"Define a function, producing the function body from the given <code>Context</code>.\"</p>\n</blockquote>",
        "id": 189053345,
        "sender_full_name": "GitHub",
        "timestamp": 1582659831
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-591509300\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404#issuecomment-591509300\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<p>Sorry, bad memory on my part, cranelift-module does do it that way, the system in lucet that preceeded it waited until the end.</p>\n</blockquote>",
        "id": 189129035,
        "sender_full_name": "GitHub",
        "timestamp": 1582733606
    },
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1404\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1404\">Issue #1404</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p><code>lucetc</code> needs some way of accessing the trap sites for every function it compiles:</p>\n<p><a href=\"https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89\" target=\"_blank\" title=\"https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89\">https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89</a></p>\n<p>In the above snippet, the trap site access happens after <code>Module::finish</code> has been called, so we're working with <code>faerie</code> interfaces.</p>\n<p>We are trying to port <code>lucetc</code> to use <code>object</code> instead of <code>faerie</code> underneath, mostly so <code>lucetc</code> can start generating PE/COFF objects with ease.  It would reduce risk somewhat to be able to use <code>cranelift-module</code> as a high-level interface, swap between <code>cranelift-object</code> and <code>cranelift-faerie</code> with as few lines of code as possible, and deal with <code>object</code> and <code>faerie</code> themselves as little as possible (probably just to write out the .o file).  Therefore, it would be convenient if this information about traps associated with each function were accessible through <code>cranelift-module</code> interfaces, rather than through lower-level interfaces.</p>\n<h4>Benefit</h4>\n<p>Trap information would be more easily accessible prior to module finalization.  Though I don't know of anybody else who needs this kind of information about besides <code>lucetc</code> at this point.</p>\n<h4>Implementation</h4>\n<p>This is the tricky bit, because the three in-tree implementations differ substantially in their approach to trap collection:</p>\n<ul>\n<li><code>cranelift-faerie</code> collects essentially <code>(string-name, Vec&lt;TrapSite&gt;)</code> pairs.</li>\n<li><code>cranelift-object</code> collects a mapping of <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code>.</li>\n<li><code>cranelift-simplejit</code> ignores traps entirely.</li>\n</ul>\n<p>I don't think there is a single method that all three interfaces could easily implement to iterate over <code>(string-name, &amp;Vec&lt;TrapSite&gt;)</code> pairs.  To implement such an interface, <code>cranelift-object</code> would need to have a way to map from <code>FuncId</code> to <code>string-name</code>, and that's awkward to do, given that <code>object</code> itself doesn't deal with symbol names as strings, but as <code>Vec&lt;u8&gt;</code>.</p>\n<p>The alternative, iterating over <code>(FuncId, &amp;Vec&lt;TrapSite&gt;)</code> pairs, would require some kind of modification to <code>cranelift-faerie</code>.  We could change <code>cranelift-faerie</code> to map from <code>string-name</code> to <code>FuncId</code>: <code>cranelift-faerie</code> could grow a separate table for storing that mapping, but <code>cranelift-module</code> is already storing that mapping, and requiring <code>cranelift-faerie</code> to store it seems like wasted effort.  Alternatively, the way <code>cranelift-faerie</code> stores its traps could be modified to look more like <code>cranelift-object</code>.</p>\n<p>But then maybe the right thing to do is just moving trap collection into <code>cranelift-module</code> itself?  <code>Module::new</code> would then grow a flag for indicating whether trap collection should be done.  <code>Module</code> itself would probably contain a <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code> mapping similar to <code>cranelift-object</code>, and then <code>Backend::define_function</code> would receive <code>Option&lt;&amp;mut Vec&lt;TrapSite&gt;&gt;</code> for potentially accumulating traps.</p>\n<p>Since <code>cranelift-simplejit</code> doesn't collect traps, it doesn't matter too much what interface gets decided on.</p>\n<p>I think I prefer moving trap collection into <code>cranelift-module</code> itself, but modifying <code>cranelift-faerie</code> to make it more like <code>cranelift-object</code> and the implementing some sort of common iterator interface works, too.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to keep the status quo, and <code>lucetc</code> would need to write two sets of code for defining certain pieces of information: one that defines those pieces with <code>faerie</code> and another that defines them with <code>object</code>.</p>\n</blockquote>",
        "id": 189361788,
        "sender_full_name": "GitHub",
        "timestamp": 1582932539
    }
]