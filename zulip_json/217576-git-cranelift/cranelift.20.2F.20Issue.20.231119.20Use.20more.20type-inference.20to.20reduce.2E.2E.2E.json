[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1119\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1119\">Issue #1119</a>:</p>\n<blockquote>\n<p>Currently, when we have an instruction that requires legalizations for several types, and the legalization is the same modulo the types involved, we'll create one legalization for each type, and will bind the source instruction to the type.</p>\n<p>It's actually a shame, because the meta crate implements type inference and can do better than this: for instance, if the instruction you're legalizing accepts types in a set S, then it could be able to generate all the legalizations for types in S as one legalization, and not one per type.</p>\n<p>We could switch to use the type inference a bit more. One drawback I can think of is that it would make it harder to find which legalizations handle which types. It's still possible to look at the generated source files, though, so that's a minor problem.</p>\n<p>For what it's worth, I've already implemented it, since I thought I found a bug in the type inference code (it was just never triggered, and has existed as long as type inference existed in Cranelift). Branch is <a href=\"https://github.com/bnjbvr/cranelift/tree/fix-bug-constraints\" target=\"_blank\" title=\"https://github.com/bnjbvr/cranelift/tree/fix-bug-constraints\">there</a> and diff of generated code is <a href=\"https://github.com/bnjbvr/cranelift-compare-gencode/commit/cec74867e8683ca90c8d35d14bf2e03584598e26\" target=\"_blank\" title=\"https://github.com/bnjbvr/cranelift-compare-gencode/commit/cec74867e8683ca90c8d35d14bf2e03584598e26\">there</a>.</p>\n</blockquote>",
        "id": 189361611,
        "sender_full_name": "GitHub",
        "timestamp": 1582932430
    }
]