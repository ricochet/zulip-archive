[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/751\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/751\">Issue #751</a>:</p>\n<blockquote>\n<p>Just something I've noticed while analyzing a program: in this example, on x86 64, the register allocator chooses to use RBX (non-volatile) while e.g. R9 (volatile) is available, adding a spurious push/pop sequence to the function's body. I think it should prefer volatile registers, as long as we have some available.</p>\n<p>Cranelift line to run the program: <code>cargo run wasm -dDp --target x86_64 a.wat</code></p>\n<p>WebAssembly text (a.wat):<br>\n&lt;details&gt;</p>\n<div class=\"codehilite\"><pre><span></span>(module\n  (memory (export &quot;mem&quot;) 100)\n  (func $dummy)\n  (func $loop (export &quot;dot&quot;) (param $len i32) (result i32)\n    (local $k1 i32)\n    (local $k2 i32)\n    (local $k3 i32)\n    (local $k4 i32)\n    (local $k5 i32)\n    (local $k6 i32)\n    (loop $AGAIN\n      (if (local.get $len)\n          (block\n            (local.set $len (i32.sub (local.get $len) (i32.const 1)))\n            (local.set $k1 (i32.add (local.get $k1) (i32.const 1)))\n            (local.set $k2 (i32.add (local.get $k2) (i32.const 2)))\n            (local.set $k3 (i32.add (local.get $k3) (i32.const 3)))\n            (local.set $k4 (i32.add (local.get $k4) (i32.const 4)))\n            (local.set $k5 (i32.add (local.get $k5) (i32.const 5)))\n            (local.set $k6 (i32.add (local.get $k6) (i32.const 6)))\n            (br_if $AGAIN (local.get $len)))))\n      (i32.add (i32.add (i32.add (i32.add (i32.add (local.get $k1) (local.get $k2))\n                                          (local.get $k3))\n                                 (local.get $k4))\n                        (local.get $k5))\n               (local.get $k6))))\n</pre></div>\n\n\n<p>&lt;/details&gt;</p>\n<p>Generated code:<br>\n&lt;details&gt;</p>\n<div class=\"codehilite\"><pre><span></span>   0:   40 55                   push    rbp\n   2:   48 89 e5                mov     rbp, rsp\n   5:   40 53                   push    rbx\n   7:   48 83 ec 08             sub     rsp, 8\n   b:   40 b8 00 00 00 00       mov     eax, 0\n  11:   40 89 c1                mov     ecx, eax\n  14:   40 89 c2                mov     edx, eax\n  17:   40 89 c3                mov     ebx, eax\n  1a:   40 89 c6                mov     esi, eax\n  1d:   41 89 c0                mov     r8d, eax\n  20:   40 85 ff                test    edi, edi\n  23:   74 21                   je      0x46\n  25:   40 83 c7 ff             add     edi, -1\n  29:   41 83 c0 01             add     r8d, 1\n  2d:   40 83 c6 02             add     esi, 2\n  31:   40 83 c3 03             add     ebx, 3\n  35:   40 83 c2 04             add     edx, 4\n  39:   40 83 c1 05             add     ecx, 5\n  3d:   40 83 c0 06             add     eax, 6\n  41:   40 85 ff                test    edi, edi\n  44:   75 da                   jne     0x20\n  46:   41 01 f0                add     r8d, esi\n  49:   41 01 d8                add     r8d, ebx\n  4c:   41 01 d0                add     r8d, edx\n  4f:   41 01 c8                add     r8d, ecx\n  52:   41 01 c0                add     r8d, eax\n  55:   44 89 c0                mov     eax, r8d\n  58:   48 83 c4 08             add     rsp, 8\n  5c:   40 5b                   pop     rbx\n  5e:   40 5d                   pop     rbp\n  60:   c3                      ret\n</pre></div>\n\n\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 189361438,
        "sender_full_name": "GitHub",
        "timestamp": 1582932352
    }
]