[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585407662\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585407662\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>Ping?</p>\n</blockquote>",
        "id": 188051307,
        "sender_full_name": "GitHub",
        "timestamp": 1581540078
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585422418\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585422418\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>@bjorn3 I'm fine with this once the conflicts are resolved and tests are added but that is because I'm not familiar enough with other ways of implementing TLS to have much comment. There's a Cranelift meeting on Monday mornings and there might be someone there that has more insight into the future Cranelift's threading support; I mention that because the whole threading thing might require some back-and-forth discussion.</p>\n</blockquote>",
        "id": 188054154,
        "sender_full_name": "GitHub",
        "timestamp": 1581542314
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585943990\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-585943990\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm not familiar enough with other ways of implementing TLS to have much comment.</p>\n</blockquote>\n<p>While there are other ways to implement TLS support, this matches the native TLS handling of ELF cq Mach-O. This way, it is possible to import/export tls variables from/to native objects. While this is not really necessary for cg_clif, as Rust makes a getter for the TLS var anyway and doesn't export the raw TLS var, for rcc it will likely be needed to interoperate with native code.</p>\n</blockquote>",
        "id": 188144146,
        "sender_full_name": "GitHub",
        "timestamp": 1581623828
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-586309526\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-586309526\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>I rebased this and added tests for legalization of <code>global_value</code> and encoding of <code>x86_{elf,macho}_tls_get_addr</code>. Should I also add a test that <code>cranelift-object</code> correctly writes the tls section?</p>\n<blockquote>\n<p>I mention that because the whole threading thing might require some back-and-forth discussion.</p>\n</blockquote>\n<p>For cg_clif this is technically the only thing that prevents multithreading at the moment. I have made atomics atomic by using a global lock. While this is slow, at least it works. I would love to see atomic support in Cranelift, but for now TLS is more important for me.</p>\n</blockquote>",
        "id": 188209917,
        "sender_full_name": "GitHub",
        "timestamp": 1581690217
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587467774\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587467774\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>@abrown Has this been discussed?</p>\n</blockquote>",
        "id": 188451377,
        "sender_full_name": "GitHub",
        "timestamp": 1582033607
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587541865\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587541865\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>I think the cranelift meeting yesterday was cancelled due to a US holiday (at least I didn't attend) but I posted in a <a href=\"#narrow/stream/217117-cranelift/topic/threading\" title=\"#narrow/stream/217117-cranelift/topic/threading\">zulip chat thread</a> and I will bring it up next Monday.</p>\n</blockquote>",
        "id": 188464355,
        "sender_full_name": "GitHub",
        "timestamp": 1582042477
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587658657\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-587658657\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>Ok, thanks!</p>\n</blockquote>",
        "id": 188479982,
        "sender_full_name": "GitHub",
        "timestamp": 1582052184
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-590519915\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-590519915\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>I decided to look a bit more at the <code>__tls_get_addr</code> ABI and noticed that I made a wrong assumption. In one place, it is said that the full code sequence needs to be 16 bytes (used to for example relax GD to other TLS models, <a href=\"https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186\" target=\"_blank\" title=\"https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186\">https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186</a>), suggesting a custom ABI, but the glibc implementation seems to require the C abi: <a href=\"https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821\" target=\"_blank\" title=\"https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821\">https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821</a>. When looking at LLVM, this seems to indeed be the case: <a href=\"https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471\" target=\"_blank\" title=\"https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471\">https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471</a>. The current code works for cg_clif, but that may be caused by the fact that rust creates a very small function just to get the tls addr, so none of the clobbered registers are used after the <code>global_value</code> instruction.</p>\n<p>Clobbering all necessary registers will mean that I have to add even more clobber registers. Another option would be to use the existing infrastructure for the <code>call</code> and <code>call_indirect</code> instruction.</p>\n</blockquote>",
        "id": 188960064,
        "sender_full_name": "GitHub",
        "timestamp": 1582574217
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-590519915\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-590519915\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>I decided to look a bit more at the <code>__tls_get_addr</code> ABI and noticed that I made a wrong assumption. In one place, it is said that the full code sequence needs to be 16 bytes (used to for example relax GD to other TLS models, <a href=\"https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186\" target=\"_blank\" title=\"https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186\">https://github.com/llvm/llvm-project/blob/deb5819d6249cfe110da9377910f7e5c88e8ee09/lld/ELF/Arch/X86_64.cpp#L186</a>), suggesting a custom ABI, but the glibc implementation seems to require the C abi: <a href=\"https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821\" target=\"_blank\" title=\"https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821\">https://github.com/bminor/glibc/blob/5f72f9800b250410cad3abfeeb09469ef12b2438/elf/dl-tls.c#L821</a>. When looking at LLVM, this seems to indeed be the case: <a href=\"https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471\" target=\"_blank\" title=\"https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471\">https://github.com/llvm/llvm-project/blob/78be61871704a451a5d9462d7e96ed6c982746d4/llvm/lib/Target/X86/X86InstrCompiler.td#L453-L471</a>. The current code works for cg_clif, but that may be caused by the fact that rust creates a very small function just to get the tls addr, so none of the clobbered registers are used after the <code>global_value</code> instruction.</p>\n<p>Clobbering all necessary registers will mean that I have to add even more clobber registers. &lt;strike&gt;Another option would be to use the existing infrastructure for the <code>call</code> and <code>call_indirect</code> instruction.&lt;/strike&gt; (Edit: existing infrastructure only works for actual <code>call</code> and <code>call_indirect</code>.)</p>\n</blockquote>",
        "id": 188961277,
        "sender_full_name": "GitHub",
        "timestamp": 1582575038
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591030786\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591030786\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>I tried to add more output registers for the clobbering, but the maximum amount of outputs is 8, which is way less than the amount of registers than are clobbered.</p>\n<p>I also tried to use the same spill logic as used by normal calls, but I can't find where it is determined which registers are caller-saved and should spilled to the stack.</p>\n</blockquote>",
        "id": 189052790,
        "sender_full_name": "GitHub",
        "timestamp": 1582659469
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591035038\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591035038\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<blockquote>\n<p>I also tried to use the same spill logic as used by normal calls, but I can't find where it is determined which registers are caller-saved and should spilled to the stack.</p>\n</blockquote>\n<p>I think you might not have been able to find it because all register values that live through a call are spilled - callee-save/caller-save ABI guarantees are disregarded at the moment. <a href=\"https://github.com/bytecodealliance/cranelift/blob/master/cranelift-codegen/src/regalloc/spilling.rs#L267-L269\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/blob/master/cranelift-codegen/src/regalloc/spilling.rs#L267-L269\">There's a note in <code>spilling.rs</code> for this</a>. This <code>if</code> could be extended to spill around clobber-happy TLS operations.</p>\n</blockquote>",
        "id": 189053635,
        "sender_full_name": "GitHub",
        "timestamp": 1582660016
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591050120\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591050120\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>Thanks @iximeow! It now correctly spills all caller-saved registers.</p>\n</blockquote>",
        "id": 189057110,
        "sender_full_name": "GitHub",
        "timestamp": 1582662110
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591277189\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-591277189\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n</blockquote>",
        "id": 189091105,
        "sender_full_name": "GitHub",
        "timestamp": 1582701598
    },
    {
        "content": "<p>stefson <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595205081\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595205081\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>@bjorn3  </p>\n<p>I'm getting a compile error with building for aarch64-unknown-linux-gnu on current master, and found this pullrequest as the culprit when bisecting the issue. Here's the error: </p>\n<div class=\"codehilite\"><pre><span></span>   Compiling cranelift-codegen-meta v0.59.0 (/tmp/wasmtime/cranelift/codegen/meta)\n   Compiling cranelift-bforest v0.59.0 (/tmp/wasmtime/cranelift/bforest)\n   Compiling wasi-common v0.12.0 (/tmp/wasmtime/crates/wasi-common)\n   Compiling cranelift-codegen v0.59.0 (/tmp/wasmtime/cranelift/codegen)\nwarning: unused import: `self::call::expand_call`\n  --&gt; cranelift/codegen/src/legalizer/mod.rs:35:5\n   |\n35 | use self::call::expand_call;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::globalvalue::expand_global_value`\n  --&gt; cranelift/codegen/src/legalizer/mod.rs:36:5\n   |\n36 | use self::globalvalue::expand_global_value;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `self::heap::expand_heap_addr`\n  --&gt; cranelift/codegen/src/legalizer/mod.rs:37:5\n   |\n37 | use self::heap::expand_heap_addr;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `self::table::expand_table_addr`\n  --&gt; cranelift/codegen/src/legalizer/mod.rs:39:5\n   |\n39 | use self::table::expand_table_addr;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `X86ElfTlsGetAddr` found for type `ir::instructions::Opcode` in the current scope\n    --&gt; cranelift/codegen/src/regalloc/spilling.rs:272:45\n     |\n272  |             || opcode == crate::ir::Opcode::X86ElfTlsGetAddr\n     |                                             ^^^^^^^^^^^^^^^^ variant or associated item not found in `ir::instructions::Opcode`\n     |\n    ::: /tmp/wasmtime/target/aarch64-unknown-linux-gnu/debug/build/cranelift-codegen-dd375821e82eb469/out/opcodes.rs:1427:1\n     |\n1427 | pub enum Opcode {\n     | --------------- variant or associated item `X86ElfTlsGetAddr` not found here\n\nerror[E0599]: no variant or associated item named `X86MachoTlsGetAddr` found for type `ir::instructions::Opcode` in the current scope\n    --&gt; cranelift/codegen/src/regalloc/spilling.rs:273:45\n     |\n273  |             || opcode == crate::ir::Opcode::X86MachoTlsGetAddr\n     |                                             ^^^^^^^^^^^^^^^^^^ variant or associated item not found in `ir::instructions::Opcode`\n     |\n    ::: /tmp/wasmtime/target/aarch64-unknown-linux-gnu/debug/build/cranelift-codegen-dd375821e82eb469/out/opcodes.rs:1427:1\n     |\n1427 | pub enum Opcode {\n     | --------------- variant or associated item `X86MachoTlsGetAddr` not found here\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `cranelift-codegen`.\n</pre></div>\n\n\n<p>It's propably worth noting that this only happens when executing <code>cargo build</code> from the wasmtime dir, and it doesn't when <code>cd wasmtime/cranelift &amp; cargo build</code>. Still the error seems to be from cranelift. </p>\n<p>P.S: the regression is caused by <a href=\"https://github.com/bytecodealliance/wasmtime/commit/0a1bb3ba6ccadd4b716cd259a097bb31435c0c6d\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/commit/0a1bb3ba6ccadd4b716cd259a097bb31435c0c6d\">https://github.com/bytecodealliance/wasmtime/commit/0a1bb3ba6ccadd4b716cd259a097bb31435c0c6d</a> , I hope this thread is the correct one to note the author of that regression. </p>\n</blockquote>",
        "id": 189785401,
        "sender_full_name": "GitHub",
        "timestamp": 1583411421
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595217112\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595217112\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>The problem is probably that Cranelift got built without x86 support, but I added a special case to regalloc with an x86 only instruction without checking for x86 support. I think the solution is to add an instruction attribute, just like <code>is_call</code> and <code>is_branch</code>, for this special case instead.</p>\n</blockquote>",
        "id": 189788140,
        "sender_full_name": "GitHub",
        "timestamp": 1583413351
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595409105\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595409105\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>@bjorn3, can you create an issue in wasmtime so we can track this there?</p>\n</blockquote>",
        "id": 189828324,
        "sender_full_name": "GitHub",
        "timestamp": 1583437084
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595409105\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174#issuecomment-595409105\">comment</a> on <a href=\"https://github.com/bytecodealliance/cranelift/pull/1174\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1174\">Issue #1174</a>:</p>\n<blockquote>\n<p>@bjorn3 (or @stefson), can you create an issue in wasmtime so we can track this there?</p>\n</blockquote>",
        "id": 189828370,
        "sender_full_name": "GitHub",
        "timestamp": 1583437115
    }
]