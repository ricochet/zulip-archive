[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1246\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1246\">Issue #1246</a>:</p>\n<blockquote>\n<p>Cranelift's existing register allocator has proven to be a limiting factor for<br>\nachievable code quality.  Typically it limits the performance of compiled<br>\nWebAssembly inputs to around 80% of that achieved when compiling WebAssembly<br>\nvia SpiderMonkey's Ion pipeline instead.</p>\n<p>In particular, the allocator generates excessive spilling.  This is because it<br>\ndoesn't implement live range splitting.  Investigations have shown that while<br>\nit would be possible to implement splitting, this would make the allocator run<br>\nsignificantly more slowly.  But the allocator already dominates Cranelift's<br>\ncompilation time, and is already uncompetitively slow.  So this isn't a<br>\npromising route.</p>\n<p>The current plan is to implement two new allocators:</p>\n<p>(1) A traditional linear-scan register allocator, in the style of Poletto and<br>\n    Sarkar's paper [A], but not tune it much, at least at first.</p>\n<p>(2) At the same time, implement a backtracking, top-down allocator similar to<br>\n    that used by SpiderMonkey's Ion pipeline, and in LLVM 3.0's optimising<br>\n    mode, as summarised at [B].  Experience with Ion indicates that this<br>\n    allocator provides good quality allocation whilst being significantly<br>\n    faster than graph colouring schemes.  Hence it seems like a good choice.</p>\n<p>The purpose of doing (1) is threefold:</p>\n<ul>\n<li>\n<p>One area of uncertainty/schedule risk with implementing a new allocator is<br>\n  figuring out how to integrate it into CL's existing IR and<br>\n  machine-instruction infrastructure.  Starting off by implementing a simple<br>\n  core algorithm frees up time to explore the integration aspects, which are<br>\n  arguably the more difficult problem.</p>\n</li>\n<li>\n<p>It may be useful for some users of CL to have the choice of a faster<br>\n  allocator (hence, overall compilation) at the expense of poorer quality<br>\n  code.</p>\n</li>\n<li>\n<p>It gives a baseline for speed comparisons, both compilation speed and speed<br>\n  of generated code.</p>\n</li>\n</ul>\n<p>Whether, and to what extent, it is necessary to translate out of SSA prior to<br>\ndoing register allocation is currently under investigation.</p>\n<p>In order to avoid any interruption in service for existing CL users, the<br>\nexisting register allocator will be kept alive until such time as a new<br>\nimplementation can do better, both in code quality and compile time.</p>\n<p>[A] <a href=\"http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf\" target=\"_blank\" title=\"http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf\">http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf</a><br>\n[B] <a href=\"http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html\" target=\"_blank\" title=\"http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html\">http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html</a></p>\n</blockquote>",
        "id": 189361664,
        "sender_full_name": "GitHub",
        "timestamp": 1582932462
    }
]