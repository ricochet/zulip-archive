[
    {
        "content": "<p>abrown opened <a href=\"https://github.com/bytecodealliance/cranelift/issues/1401\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1401\">Issue #1401</a>:</p>\n<blockquote>\n<p>&lt;!-- Please try to describe precisely what you would like to do in Cranelift and/or<br>\nexpect from it. You can answer the questions below if they're relevant and<br>\ndelete this text before submitting. Thanks for opening an issue! --&gt;</p>\n<h4>Feature</h4>\n<p>&lt;!-- What is the feature or code improvement you would like to do in Cranelift? --&gt;</p>\n<p>The types <code>i16</code>, <code>i32</code>, and <code>i64</code> currently cannot be parsed from a hexadecimal integer; <code>i8</code> can by using the <code>match_uimm8</code> function in <code>parser.rs</code> but <code>match_imm16</code>, <code>match_imm32</code>, and <code>match_imm64</code> do not allow this.</p>\n<h4>Benefit</h4>\n<p>&lt;!-- What is the value of adding this in Cranelift? --&gt;</p>\n<p>At times we are forced to use strange negative numbers to represent values more naturally expressed with a hexadecimal number; e.g. when preparing a value for checking overflow semantics in a 16-bit vector lane, it is more convenient to use <code>0xffff</code> than <code>-32768</code>.</p>\n<h4>Implementation</h4>\n<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or algorithms to use? --&gt;</p>\n<ul>\n<li>Add hexadecimal parsing to  <code>match_imm16</code>, <code>match_imm32</code>, and <code>match_imm64</code> (see <code>match_uimm8</code>)</li>\n<li>Modify tests using strange negative numbers (e.g. like <a href=\"https://github.com/bytecodealliance/cranelift/pull/1371#discussion_r382664691\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1371#discussion_r382664691\">this comment</a>), replacing these with the more clear hexadecimal syntax</li>\n</ul>\n<h4>Alternatives</h4>\n<p>&lt;!-- Have you considered alternative implementations? If so, how are they better or worse than your proposal? --&gt;</p>\n<p>We could leave this as is; it makes sense that the <code>match_imm*</code> functions are concerned primarily with parsing signed integers. However, adding hexadecimal parsing would not break anything as long as we include checks that the number has no more bits than necessary (e.g. a hex number parsed to an <code>Imm64</code> should have no more than 64 bits).</p>\n</blockquote>",
        "id": 188761786,
        "sender_full_name": "GitHub",
        "timestamp": 1582310740
    },
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1401\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1401\">Issue #1401</a>:</p>\n<blockquote>\n<p>&lt;!-- Please try to describe precisely what you would like to do in Cranelift and/or<br>\nexpect from it. You can answer the questions below if they're relevant and<br>\ndelete this text before submitting. Thanks for opening an issue! --&gt;</p>\n<h4>Feature</h4>\n<p>&lt;!-- What is the feature or code improvement you would like to do in Cranelift? --&gt;</p>\n<p>The types <code>i16</code>, <code>i32</code>, and <code>i64</code> currently cannot be parsed from a hexadecimal integer; <code>i8</code> can by using the <code>match_uimm8</code> function in <code>parser.rs</code> but <code>match_imm16</code>, <code>match_imm32</code>, and <code>match_imm64</code> do not allow this.</p>\n<h4>Benefit</h4>\n<p>&lt;!-- What is the value of adding this in Cranelift? --&gt;</p>\n<p>At times we are forced to use strange negative numbers to represent values more naturally expressed with a hexadecimal number; e.g. when preparing a value for checking overflow semantics in a 16-bit vector lane, it is more convenient to use <code>0xffff</code> than <code>-32768</code>.</p>\n<h4>Implementation</h4>\n<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or algorithms to use? --&gt;</p>\n<ul>\n<li>Add hexadecimal parsing to  <code>match_imm16</code>, <code>match_imm32</code>, and <code>match_imm64</code> (see <code>match_uimm8</code>)</li>\n<li>Modify tests using strange negative numbers (e.g. like <a href=\"https://github.com/bytecodealliance/cranelift/pull/1371#discussion_r382664691\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/pull/1371#discussion_r382664691\">this comment</a>), replacing these with the more clear hexadecimal syntax</li>\n</ul>\n<h4>Alternatives</h4>\n<p>&lt;!-- Have you considered alternative implementations? If so, how are they better or worse than your proposal? --&gt;</p>\n<p>We could leave this as is; it makes sense that the <code>match_imm*</code> functions are concerned primarily with parsing signed integers. However, adding hexadecimal parsing would not break anything as long as we include checks that the number has no more bits than necessary (e.g. a hex number parsed to an <code>Imm64</code> should have no more than 64 bits).</p>\n</blockquote>",
        "id": 189361785,
        "sender_full_name": "GitHub",
        "timestamp": 1582932536
    }
]