[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/642\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/642\">Issue #642</a>:</p>\n<blockquote>\n<p>Cranelift uses arrays and indices extensively, rather than pointer-based data structures. This allows us to use 32-bit indices rather than 64-bit pointers on 64-bit platforms, and has some other nice properties, however these indices appear to Rust as random accesses, so they get bounds checked.</p>\n<p>The following patch to disable bounds checks in <code>PrimaryMap</code> speeds up Cranelift compile times by over 8%, which is considerable:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"gh\">diff --git a/lib/entity/src/primary.rs b/lib/entity/src/primary.rs</span>\n<span class=\"gh\">index 6d710c2e..911223bd 100644</span>\n<span class=\"gd\">--- a/lib/entity/src/primary.rs</span>\n<span class=\"gi\">+++ b/lib/entity/src/primary.rs</span>\n<span class=\"gu\">@@ -150,7 +150,7 @@ where</span>\n     type Output = V;\n\n     fn index(&amp;self, k: K) -&gt; &amp;V {\n\n<span class=\"gd\">-        &amp;self.elems[k.index()]</span>\n<span class=\"gi\">+        unsafe { self.elems.get_unchecked(k.index()) }</span>\n     }\n }\n\n<span class=\"gu\">@@ -160,7 +160,7 @@ where</span>\n     K: EntityRef,\n {\n     fn index_mut(&amp;mut self, k: K) -&gt; &amp;mut V {\n\n<span class=\"gd\">-        &amp;mut self.elems[k.index()]</span>\n<span class=\"gi\">+        unsafe { self.elems.get_unchecked_mut(k.index()) }</span>\n     }\n }\n</pre></div>\n\n\n<p>Of course, this is not completely safe.</p>\n<p>But, the common pattern of these indices in Cranelift is to use them relatively safely. We don't use this indices for iterating; we use custom index types that don't even permit arithmetic. Most <code>PrimaryMap</code> keys are produced by <code>PrimaryMap</code> itself when we push new entries:</p>\n<p>let key = my_primary_map.push(x); // returns the key of the newly pushed element</p>\n<p>These keys are in bounds from the start.</p>\n<p>Yet, there are some ways things could go wrong. Besides a few minor details which a relatively easy to fix, there are a few deep problems. Nothing outright prevents keys from living across calls to <code>clear()</code>. Similarly, nothing prevents indices from living while we exit a <code>PrimaryMap</code>'s scope and then re-enter it, creating a new <code>PrimaryMap</code>. And, while we use distinct index types to catch using an index in the wrong map, and don't tend to use more than one instance of <code>PrimaryMap</code> with the same type at a time, nothing enforces that.</p>\n<p>We don't tend to do the kinds of things which would lead to trouble. But all the same, disabling the bounds checks is not completely safe.</p>\n<p>So I don't yet know what the best thing to do here is. Should we add a cargo feature to allow users to decide whether they want the safe or unsafe version? Is there a way to do what we're doing in Rust safely without paying for bounds checks? Should we re-architect Cranelift's core data structures to some other form?</p>\n<p>cc @nnethercote </p>\n</blockquote>",
        "id": 189361400,
        "sender_full_name": "GitHub",
        "timestamp": 1582932328
    }
]