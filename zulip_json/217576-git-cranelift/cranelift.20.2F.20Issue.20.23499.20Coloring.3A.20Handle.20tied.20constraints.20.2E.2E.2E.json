[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/499\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/499\">Issue #499</a>:</p>\n<blockquote>\n<p>Tied constraints are when an input to an instruction has to be in the same register as an output, as is the case for most arithmetic instructions on x86.</p>\n<p>Currently, Cranelift's register allocator handles this constraint in the coloring pass. However, the coloring pass is very late, when a lot decisions have already been made, and a lot of other constraints have been saved up to be solved at once.</p>\n<p>One idea for doing this would be to extend the concept of CSSA form produced by the <a href=\"https://github.com/CraneStation/cranelift/blob/master/lib/codegen/src/regalloc/coalescing.rs\" target=\"_blank\" title=\"https://github.com/CraneStation/cranelift/blob/master/lib/codegen/src/regalloc/coalescing.rs\">coalescing pass</a>. CSSA is essentially about putting \"phi-related\" values into sets which can be allocated the same <a href=\"https://github.com/CraneStation/cranelift/blob/master/lib/codegen/src/regalloc/virtregs.rs\" target=\"_blank\" title=\"https://github.com/CraneStation/cranelift/blob/master/lib/codegen/src/regalloc/virtregs.rs\">virtual register</a>, because whenever the input to a phi and the output to a phi can occupy the same register, we avoid a copy. Tied constraints are very similar: we want the input to an instruction and the output to be in the same register, so coalescing them would also avoid requiring a copy.</p>\n<p>In cases where the input and output register conflict, we could insert an explicit copy.</p>\n<p>And since coalescing happens before spilling or coloring, this should mean that coloring wouldn't have to worry about these constraints.</p>\n</blockquote>",
        "id": 189361360,
        "sender_full_name": "GitHub",
        "timestamp": 1582932289
    }
]