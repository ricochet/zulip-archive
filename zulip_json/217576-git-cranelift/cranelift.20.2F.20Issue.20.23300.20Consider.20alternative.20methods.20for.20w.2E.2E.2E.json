[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/cranelift/issues/300#issuecomment-585312630\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/300#issuecomment-585312630\">commented</a> on <a href=\"https://github.com/bytecodealliance/cranelift/issues/300\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/300\">Issue #300</a>:</p>\n<blockquote>\n<p>FWIW, this bit me while prototyping ARM64 (see issue <a href=\"https://github.com/cfallin/cranelift/issues/8\" target=\"_blank\" title=\"https://github.com/cfallin/cranelift/issues/8\">cfallin/cranelift#8</a>) -- we should definitely look at safer API options. Perhaps just a ctor that takes a slice, and bounds-checks as it generates? Was the intent of the initial design to avoid the bounds-check overhead?</p>\n</blockquote>",
        "id": 188030997,
        "sender_full_name": "GitHub",
        "timestamp": 1581527462
    },
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/300\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/300\">Issue #300</a>:</p>\n<blockquote>\n<p>Currently, binemit has its own <a href=\"https://docs.rs/cretonne-codegen/0.5.0/cretonne_codegen/binemit/trait.CodeSink.html\" target=\"_blank\" title=\"https://docs.rs/cretonne-codegen/0.5.0/cretonne_codegen/binemit/trait.CodeSink.html\">CodeSink</a> trait for writing binary data. It isn't entirely satisfying, in part because it's an unsafe interface -- it doesn't perform bounds checking on the underlying data. While we can provide relatively safe interfaces to protect users from misusing the API, it's harder to be absolutely certain that the number of bytes <code>compile</code> says a function needs is the number of bytes <code>emit_to_memory</code> actually writes for that function.</p>\n<p>One option would be to provide a safe checked version of <code>MemoryCodeSink</code>. However, it's also worth considering evaluating available crates that provide low-level byte buffer writing functionality, including:</p>\n<ul>\n<li><a href=\"https://crates.io/crates/bytevec\" target=\"_blank\" title=\"https://crates.io/crates/bytevec\">https://crates.io/crates/bytevec</a></li>\n<li><a href=\"https://crates.io/crates/bytebuffer\" target=\"_blank\" title=\"https://crates.io/crates/bytebuffer\">https://crates.io/crates/bytebuffer</a></li>\n<li><a href=\"https://crates.io/crates/scroll\" target=\"_blank\" title=\"https://crates.io/crates/scroll\">https://crates.io/crates/scroll</a></li>\n</ul>\n</blockquote>",
        "id": 189361336,
        "sender_full_name": "GitHub",
        "timestamp": 1582932268
    }
]