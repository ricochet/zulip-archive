[
    {
        "content": "<p>alexcrichton transferred <a href=\"https://github.com/bytecodealliance/cranelift/issues/1192\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1192\">Issue #1192</a>:</p>\n<blockquote>\n<h3>What is the feature or code improvement you would like to do in Cranelift?</h3>\n<p>During translation from Wasm to CLIF, a combination of Wasm's <code>v128</code> type and Cranelift's current type system forces us to add many <code>raw_bitcast</code> instructions between operations. For example, this Wasm code:</p>\n<div class=\"codehilite\"><pre><span></span>  (func (export &quot;add-sub&quot;) (param v128 v128 v128) (result v128)\n    (i16x8.add (i16x8.sub (local.get 0) (local.get 1))(local.get 2)))\n</pre></div>\n\n\n<p>Translates to this CLIF code:</p>\n<div class=\"codehilite\"><pre><span></span>function u0:4(i64 vmctx [%rdi], i8x16 [%xmm0], i8x16 [%xmm1], i64 fp [%rbp]) -&gt; i8x16 [%xmm0], i64 fp [%rbp] system_v {\n    ss0 = incoming_arg 16, offset -16\n\n                                ebb0(v0: i64 [%rdi], v1: i8x16 [%xmm0], v2: i8x16 [%xmm1], v12: i64 [%rbp]):\n[RexOp1pushq#50]                    x86_push v12\n[RexOp1copysp#8089]                 copy_special %rsp -&gt; %rbp\n@00a6 [null_fpr#00,%xmm0]           v4 = raw_bitcast.i16x8 v1\n@00a6 [Mp2vconst_optimized#5ef,%xmm2] v11 = vconst.i16x8 0x00\n@00a6 [Mp2fa#5f9,%xmm2]             v5 = isub v11, v4\n@00a6 [null_fpr#00,%xmm2]           v6 = raw_bitcast.i8x16 v5\n@00aa [null_fpr#00,%xmm2]           v7 = raw_bitcast.i16x8 v6\n@00aa [null_fpr#00,%xmm1]           v8 = raw_bitcast.i16x8 v2\n@00aa [Mp2fa#5fd,%xmm2]             v9 = iadd v7, v8\n@00aa [null_fpr#00,%xmm2]           v10 = raw_bitcast.i8x16 v9\n@00ac [-]                           fallthrough ebb1(v10)\n\n                                ebb1(v3: i8x16 [%xmm2]):\n@00ac [Op2frmov#428]                regmove v3, %xmm2 -&gt; %xmm0\n[RexOp1popq#58,%rbp]                v13 = x86_pop.i64\n@00ac [Op1ret#c3]                   return v3, v13\n}\n</pre></div>\n\n\n<p>This issue is to discuss if and how to remove these extra bitcasts.</p>\n<h3>What is the value of adding this in Cranelift?</h3>\n<p>The extra <code>raw_bitcasts</code> emit no machine code but they are confusing when troubleshooting and add extra memory and processing overhead during compilation.</p>\n<h3>Do you have an implementation plan, and/or ideas for data structures or algorithms to use?</h3>\n<p>Some options:</p>\n<ol>\n<li>\n<p>add types to <code>load</code> and <code>const</code>: <a href=\"https://github.com/WebAssembly/simd/issues/125\" target=\"_blank\" title=\"https://github.com/WebAssembly/simd/issues/125\">https://github.com/WebAssembly/simd/issues/125</a> was discussed in the Wasm SIMD Sync meeting (<a href=\"https://github.com/WebAssembly/simd/issues/121\" target=\"_blank\" title=\"https://github.com/WebAssembly/simd/issues/121\">https://github.com/WebAssembly/simd/issues/121</a>) and someone brought up that making <code>load</code> and <code>const</code> typed (e.g. <code>f32x4.load</code>) would allow compilers to attach the correct types to values and retain them through the less-strong <code>v128</code> operations (e.g. <code>xor</code>). <a href=\"https://github.com/WebAssembly/simd/issues/125\" target=\"_blank\" title=\"https://github.com/WebAssembly/simd/issues/125\">https://github.com/WebAssembly/simd/issues/125</a> discusses this from a performance point of view but that addition would solve this issue.</p>\n</li>\n<li>\n<p>examine the DFG: another approach would be to look at the DFG to figure out the types of predecessors as mentioned in <a href=\"https://github.com/WebAssembly/simd/pull/1#issuecomment-295331508\" target=\"_blank\" title=\"https://github.com/WebAssembly/simd/pull/1#issuecomment-295331508\">https://github.com/WebAssembly/simd/pull/1#issuecomment-295331508</a>. This, however, would have to be extended for type signatures. Cranelift would have to look at the instructions in a function to figure out how the <code>v128</code> parameters are used. In the function <code>add-sub</code> above, with signature <code>(param v128 v128 v128)</code>, the addition and subtraction make this clear but some functions will make this analysis impossible.</p>\n</li>\n<li>\n<p>add a <code>V128</code> type to Cranelift: Cranelift's type system could be extended to include a <code>V128</code> type in Cranelift's type system that would include all <code>INxN</code>, <code>FNxN</code>, and <code>BNxN</code> types. The instruction types would stay the same (e.g. <code>iadd</code> should still only accept integers) but type-checking could be relaxed to allow the <code>V128</code> type to be used as one of its valid subtypes. This opens up a mechanism to get around the type-checking but arguably that already exists with <code>raw_bitcast</code>. Code that knows its types would remain as-is but Wasm-to-CLIF translated code could use the <code>V128</code> a bit more naturally than the <code>raw_bitcast</code>s.</p>\n</li>\n<li>\n<p>do nothing: I brought this up a long time ago when talking to @sunfishcode and that seemed the best thing to do then--I'm opening this issue to discuss whether that is still the case.</p>\n</li>\n</ol>\n<h3>Have you considered alternative implementations? If so, how are they better or worse than your proposal?</h3>\n<p>See above.</p>\n</blockquote>",
        "id": 189361641,
        "sender_full_name": "GitHub",
        "timestamp": 1582932450
    }
]