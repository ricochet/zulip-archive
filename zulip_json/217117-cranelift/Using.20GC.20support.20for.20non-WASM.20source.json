[
    {
        "content": "<p>Hi all - I'm working on a university project to make a JIT compiler for OCaml bytecode in Rust. I'd like to use cranelift for the backend generation[1] but I need to make it work with the OCaml runtime's garbage collector. The precise stack maps and reference type support looks promising but as an R64 is just an opaque value there's not much I can do with it. My initial research has led me to consider forking cranelift for the project[2]. I'd appreciate if any of you could have a quick glance at my idea for the change I'd make and tell me if it might work or would be incredibly difficult:</p>\n<p>It's my understanding from looking at the docs that an R32/R64 is just an opaque reference besides some WASM-specific primitives to make and check for null R64s (please correct me if I'm wrong!).</p>\n<p>Would I possibly have any success adding instructions to cast from a R64 to an I64 and back again? The way I'd hope it'd work is any live R64 values are spilled if they're in registers and put on the stackmap at safepoints but mutating the I64 derived from the R64 doesn't cause the mutated I64 to be spilled accidentally. However in cases where it's just doing a pointer lookup with an offset using the I64 we got from the R64 they'd ideally use the same register.</p>\n<p>In the input IR no I64 pointer derived from an R64 would ever be live[3] - but would I have to be worried about any optimisations reordering things to break this invariant?</p>\n<p>Would this possibly work? Is there anything I'd have to be careful about/modify to do this beyond the minimum to add a new type of instruction?</p>\n<p>[1] I've already got a JIT working using <a href=\"https://github.com/CensoredUsername/dynasm-rs\">https://github.com/CensoredUsername/dynasm-rs</a> but it keeps exactly to the same semantics as the existing bytecode interpreter (that is really inefficient stack machine). I'm now working on a slower compiler that I can replace closures with once I've noticed they're hot. I've written something which keeps track of the stack and basic blocks and converts it into SSA - I'd be looking to use cranelift to turn this SSA into x86_64 assembly but I'd need to integrate what I do with the GC.</p>\n<p>Despite not being designed for the type of GC OCaml uses (precise generational mark-and-sweep rather than delayed reference counting) I think besides not being able to access and create raw reference values the existing support in cranelift is a perfect fit - when the GC is called I'd just have to walk up the stack and lookup stackmaps from a hashtable keyed by the return address.</p>\n<p>[2] It's a write-once nobody-will-use contrived university project so taking the time to work on a more general solution to my problem that could be upstreamed is not worth it for me now - but I'd definitely be happy to share anything I found or consider working on something more general once I have more time this summer</p>\n<p>[3] The OCaml runtime is single-threaded and garbage collection will only ever be triggered in specific places (like allocations once the \"minor heap\" is full and it's no longer just a pointer bump). The way I'm going to do codegen means it's pretty easy to keep this invariant - any use of the actual values of the R64 will be local between statepoints to do pointer lookups.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/CensoredUsername/dynasm-rs\" style=\"background-image: url(https://avatars.githubusercontent.com/u/3411575?s=400&amp;v=4)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/CensoredUsername/dynasm-rs\" title=\"CensoredUsername/dynasm-rs\">CensoredUsername/dynasm-rs</a></div><div class=\"message_embed_description\">A dynasm-like tool for rust. Contribute to CensoredUsername/dynasm-rs development by creating an account on GitHub.</div></div></div>",
        "id": 230572675,
        "sender_full_name": "Will Robson",
        "timestamp": 1615921739
    },
    {
        "content": "<blockquote>\n<p>Would I possibly have any success adding instructions to cast from a R64 to an I64 and back again? The way I'd hope it'd work is any live R64 values are spilled if they're in registers and put on the stackmap at safepoints but mutating the I64 derived from the R64 doesn't cause the mutated I64 to be spilled accidentally. However in cases where it's just doing a pointer lookup with an offset using the I64 we got from the R64 they'd ideally use the same register.</p>\n</blockquote>\n<p>If the <code>r64</code>s aren't used again after casting to <code>i64</code>, then they won't be in the stack maps because the regalloc won't know that they are still \"live\" via the derived <code>i64</code>, meaning that the GC won't see these references, will mistakenly reclaim them as garbage, and you'll get use after frees. This is a pretty serious footgun with the approach.</p>\n<p>I think it would be better to add support for loading/storing through <code>r64</code>/<code>r32</code> with the existing load/store instructions (I looked into this once / started doing it once, but I don't remember if I ever actually finished it...)</p>",
        "id": 230578119,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1615923800
    },
    {
        "content": "<blockquote>\n<p>If the <code>r64</code>s aren't used again after casting to <code>i64</code>, then they won't be in the stack maps because the regalloc won't know that they are still \"live\" via the derived <code>i64</code>, meaning that the GC won't see these references, will mistakenly reclaim them as garbage, and you'll get use after frees. This is a pretty serious footgun with the approach.</p>\n</blockquote>\n<p>This is impossible the way I'd be using it - there wouldn't be any live <code>i64</code>s derived from the <code>r64</code> at places the GC could trigger (asuming this doesn't get reordered by an optimisation). It would be things sort of like this exmaple </p>\n<ol>\n<li>Cast <code>r64</code> to <code>i64</code></li>\n<li>Dereference the pointer to get another <code>i64</code></li>\n<li>Cast the derfenced value <code>i64</code> back to <code>r64</code></li>\n</ol>\n<p>where the value in 2 is only ever used in 3.</p>\n<p>If the original <code>r64</code> isn't ever used again and isn't referenced by any of the other roots then it is indeed garbage and would be collected - but that'd be fine because the <code>i64</code> wouldn't be used either. There's never going to be an reference-derived i64 which is alive between multiple GC calls.</p>\n<blockquote>\n<p>I think it would be better to add support for loading/storing through <code>r64</code>/<code>r32</code> with the existing load/store instructions (I looked into this once / started doing it once, but I don't remember if I ever actually finished it...)</p>\n</blockquote>\n<p>This is where OCaml makes things fun - it uses a uniform data representation[1] where everything is either a 63 bit integer with an LSB of 1 or it's a pointer (taking advantage of pointer alignment). So GC-managed values would still need to be cast to pointers in any case. For example, for sum types/Rust enums it uses an integer for the nullary constructors and effectively a tagged tuple for the constructors with data. Lots of functions I'd be compiling would branch based on seeing whether the bit 0 is 0 or 1.</p>\n<p>So if I'm going to use cranelift I'm forced to somehow interpret GC-managed values as raw integers - unless there's some other approach I'm not considering?</p>\n<p>I guess my question is, is there any subtle way this could break things (asuming the above invariant stops the problem of live <code>i64</code>s after the <code>r64</code> is dead)?</p>\n<p>[1] It's basically  the opposite approach to Rust/C++ templates - rather than generate lots of different versions of the code make everything look the same and generate one. The data representations you're forced to use are as slow as you'd expect - a 4 byte f32 takes up 16 bytes in total and requires boxing/unboxing every time you do everything with it.</p>",
        "id": 230582454,
        "sender_full_name": "Will Robson",
        "timestamp": 1615925360
    },
    {
        "content": "<p>Might using <code>raw_bitcast</code> work? It looks like the x64 backend (the only one I care about) lowers it to a move:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Opcode</span>::<span class=\"n\">RawBitcast</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// A raw_bitcast is just a mechanism for correcting the type of V128 values (see</span>\n<span class=\"w\">            </span><span class=\"c1\">// https://github.com/bytecodealliance/wasmtime/issues/1147). As such, this IR</span>\n<span class=\"w\">            </span><span class=\"c1\">// instruction should emit no machine code but a move is necessary to give the register</span>\n<span class=\"w\">            </span><span class=\"c1\">// allocator a definition for the output virtual register.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">put_input_in_reg</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inputs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_output_reg</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]).</span><span class=\"n\">only_reg</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">Inst</span>::<span class=\"n\">gen_move</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// then</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">gen_move</span><span class=\"p\">(</span><span class=\"n\">dst_reg</span>: <span class=\"nc\">Writable</span><span class=\"o\">&lt;</span><span class=\"n\">Reg</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">src_reg</span>: <span class=\"nc\">Reg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span>: <span class=\"nc\">Type</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Inst</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rc_dst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dst_reg</span><span class=\"p\">.</span><span class=\"n\">to_reg</span><span class=\"p\">().</span><span class=\"n\">get_class</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rc_src</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">src_reg</span><span class=\"p\">.</span><span class=\"n\">get_class</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// If this isn't true, we have gone way off the rails.</span>\n<span class=\"w\">        </span><span class=\"fm\">debug_assert!</span><span class=\"p\">(</span><span class=\"n\">rc_dst</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">rc_src</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">rc_dst</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">RegClass</span>::<span class=\"n\">I64</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Inst</span>::<span class=\"n\">mov_r_r</span><span class=\"p\">(</span><span class=\"n\">OperandSize</span>::<span class=\"n\">Size64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">src_reg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst_reg</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// ...</span>\n</code></pre></div>",
        "id": 230664532,
        "sender_full_name": "Will Robson",
        "timestamp": 1615975029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"398072\">@Will Robson</span> the one potential issue I see in this scheme is: there is a window of unrooted vulnerability between the cast-to-i64 and deref if this is the last use of the ref (so the cast back to r64 to \"keep it alive\" is actually dead). The combination of instruction lowering and regalloc live analysis is smart enough to see through that pattern -- the move for the i64-to-r64 cast won't be lowered (its result is unused) and the regalloc will see the live range of the r64 ends at the r64-to-i64</p>",
        "id": 230719559,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1615997663
    },
    {
        "content": "<p>This is fine if there are no safepoints between r64-to-i64 cast and load, of course</p>",
        "id": 230719629,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1615997678
    },
    {
        "content": "<blockquote>\n<p>This is fine if there are no safepoints between r64-to-i64 cast and load, of course</p>\n</blockquote>\n<p>Luckily I have this invariant with the format of the OCaml bytecode I'm translating from. It's what I was trying to get at when I said \"there wouldn't be any live i64s derived from the r64 at places the GC could trigger\".  It won't necessarily be true at every safepoint (because one gets created every function call) but it will be at every safepoint the GC could trigger.</p>\n<p>The way I'd be using the cast to i64 would be to inline the actual operations I'd need to do with GC values but these temporary i64s would always have a lifetime that fits in between any two GC operations (if that makes sense?). It's not so much there won't be any alive <code>i64</code>s without a corresponding live <code>r64</code> - but instead there will never be any alive <code>r64</code>-derived <code>i64</code>s at a meaningful safepoint.</p>\n<p>It's not something true in general without being careful about keeping the invariant in the CLIF and would likely break with aggressive LLVM-style optimizations but for this I think it would work.</p>\n<p>Thank you both for your help! I think I can make this work without having to fork cranelift.</p>",
        "id": 230733093,
        "sender_full_name": "Will Robson",
        "timestamp": 1616002220
    },
    {
        "content": "<p><em>I'm  posting this here rather than the <a class=\"stream\" data-stream-id=\"225524\" href=\"/#narrow/stream/225524-cranelift-new-backend\">#cranelift-new-backend</a> stream to keep the context</em></p>\n<p>This approach worked for a while but for one of my functions caused an assertion to fail deep inside<code>regalloc</code>. I've only spent a few hours trying to wrap my head around the regalloc but this is where I've traced it to. The assertion that fails is the second from this block at the start of <code>alloc_spill_slots</code>:</p>\n<p><a href=\"https://github.com/bytecodealliance/regalloc.rs/blob/109455ce4cea07a6e8d87e06d200c1318605c0ea/lib/src/bt_spillslot_allocator.rs#L295\">https://github.com/bytecodealliance/regalloc.rs/blob/109455ce4cea07a6e8d87e06d200c1318605c0ea/lib/src/bt_spillslot_allocator.rs#L295</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">is_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vlr_env</span><span class=\"p\">[</span><span class=\"n\">vlrix</span><span class=\"p\">].</span><span class=\"n\">is_ref</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">cand_vlrix</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">vlrEquivClasses</span><span class=\"p\">.</span><span class=\"n\">equiv_class_elems_iter</span><span class=\"p\">(</span><span class=\"n\">vlrix</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// \"None of the VLRs in this equivalence class have an allocated spill slot.\"</span>\n<span class=\"w\">            </span><span class=\"c1\">// This should be true because we allocate spill slots for all of the members of an</span>\n<span class=\"w\">            </span><span class=\"c1\">// eclass at once.</span>\n<span class=\"w\">            </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">vlr_slot_env</span><span class=\"p\">[</span><span class=\"n\">cand_vlrix</span><span class=\"p\">].</span><span class=\"n\">is_none</span><span class=\"p\">());</span><span class=\"w\"></span>\n\n<span class=\"w\">            </span><span class=\"c1\">// \"All of the VLRs in this eclass have the same ref-ness as this VLR.\"</span>\n<span class=\"w\">            </span><span class=\"c1\">// Why this is true is a bit subtle.  The equivalence classes are computed by</span>\n<span class=\"w\">            </span><span class=\"c1\">// `do_coalescing_analysis`, fundamentally by looking at all the move instructions</span>\n<span class=\"w\">            </span><span class=\"c1\">// and computing the transitive closure induced by them.  The ref-ness annotations</span>\n<span class=\"w\">            </span><span class=\"c1\">// on each VLR are computed in `do_reftypes_analysis`, and they are also computed</span>\n<span class=\"w\">            </span><span class=\"c1\">// as a transitive closure on the same move instructions.  Hence the results should</span>\n<span class=\"w\">            </span><span class=\"c1\">// be identical.</span>\n<span class=\"w\">            </span><span class=\"c1\">//</span>\n<span class=\"w\">            </span><span class=\"c1\">// With all that said, note that these equivalence classes are *not* guaranteed to</span>\n<span class=\"w\">            </span><span class=\"c1\">// be internally non-overlapping.  This is explained in the big block comment at the</span>\n<span class=\"w\">            </span><span class=\"c1\">// top of bt_coalescing_analysis.rs.</span>\n<span class=\"w\">            </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">vlr_env</span><span class=\"p\">[</span><span class=\"n\">cand_vlrix</span><span class=\"p\">].</span><span class=\"n\">is_ref</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">is_ref</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The vcode passed in to regalloc contains:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">       </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">5</span>: <span class=\"nc\">movl</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v56Jl</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">6</span>: <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v56J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v7J</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>%v56J</code> isn't used at all after this but <code>%v7J</code> is used later. The original IR had:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">v7</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">raw_bitcast</span><span class=\"p\">.</span><span class=\"n\">r64</span><span class=\"w\"> </span><span class=\"n\">v7</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So <code>%v7J</code> is marked as a reftyped vreg but <code>%v56J</code> (which for some reason v8 gets put in depsite the original) isn't. Their corresponding virtualranges also behave the same way.</p>\n<p><code>analysis_reftypes</code> doesn't mark $v56J as containing a reftyped value as it's doing a DFS starting at all reftyped regs. But <code>bt_coalescing_analysis</code> puts them in an equivalence class because it sees the move.</p>\n<p>So for this particular case the reasoning behind the assertion is wrong. The assumption is <code>a -mov-&gt; b &amp; b reffy ==&gt; a reffy</code> but that's not true in this case. I'd imagine it works completely fine for wasm where there's no casting between reftype values an dintegers. I've only just ran into it on this one example after thousands of compiled functions don't hit this assertion despite doing moves from cranelift <code>I64</code>s to <code>R64</code>s all the time so hitting a code path where this assertion fails is somewhat rare.</p>\n<p>Commenting out the assertion doesn't appear to break anything in the generated assembly for this case - but it might be an important invariant that just hasn't happened to trigger any problems?</p>\n<p>Should the coalescing analysis consider <code>reffy-ness</code> when deciding to put things in the same class? Does this invariant actually matter for the spillslot allocator?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/regalloc.rs/blob/109455ce4cea07a6e8d87e06d200c1318605c0ea/lib/src/bt_spillslot_allocator.rs#L295\" style=\"background-image: url(https://avatars.githubusercontent.com/u/54038801?s=400&amp;v=4)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/regalloc.rs/blob/109455ce4cea07a6e8d87e06d200c1318605c0ea/lib/src/bt_spillslot_allocator.rs#L295\" title=\"bytecodealliance/regalloc.rs\">bytecodealliance/regalloc.rs</a></div><div class=\"message_embed_description\">Modular register allocator algorithms. Contribute to bytecodealliance/regalloc.rs development by creating an account on GitHub.</div></div></div>",
        "id": 232793778,
        "sender_full_name": "Will Robson",
        "timestamp": 1617297905
    },
    {
        "content": "<p>Ah, so this is the check that a vreg is always used either as a \"reffy\" value or never</p>",
        "id": 232793869,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617297962
    },
    {
        "content": "<p>Are you reusing a vreg for a GC ref and then a non-GC value?</p>",
        "id": 232793946,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617297981
    },
    {
        "content": "<p>Err actually sorry I'm thinking in non-SSA</p>",
        "id": 232793970,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617297993
    },
    {
        "content": "<p>Hmm. A test-case would be useful to see; but also I should note I'm currently reworking the regalloc so if this is a real bug in <a href=\"http://regalloc.rs\">regalloc.rs</a> then it may or may not be worth looking into</p>",
        "id": 232794041,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617298033
    },
    {
        "content": "<p>This is the full logs including the IR that caused it &amp; VCode: <a href=\"https://gist.github.com/wrbs/d4fde11deae93dcb1f3f89cebe7c1670\">https://gist.github.com/wrbs/d4fde11deae93dcb1f3f89cebe7c1670</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/wrbs/d4fde11deae93dcb1f3f89cebe7c1670\" style=\"background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/wrbs/d4fde11deae93dcb1f3f89cebe7c1670\" title=\"gist:d4fde11deae93dcb1f3f89cebe7c1670\">gist:d4fde11deae93dcb1f3f89cebe7c1670</a></div><div class=\"message_embed_description\">GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 232794309,
        "sender_full_name": "Will Robson",
        "timestamp": 1617298165
    },
    {
        "content": "<p>I haven't had any luck reproducing it with anything smaller so far</p>",
        "id": 232794332,
        "sender_full_name": "Will Robson",
        "timestamp": 1617298178
    },
    {
        "content": "<p>but I also haven't tried very hard to do that</p>",
        "id": 232794355,
        "sender_full_name": "Will Robson",
        "timestamp": 1617298191
    },
    {
        "content": "<p>OK, if you can get a minimized example, let us know (or at least point out which reg is both a GC ref and not, according to the regalloc)</p>",
        "id": 232795466,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617298615
    },
    {
        "content": "<p>Thanks for your help! I'll try to get something reproducible as an easily executable test case tomorrow and see see how much of it I can remove and still hit the issue.</p>\n<blockquote>\n<p>(or at least point out which reg is both a GC ref and not, according to the regalloc)</p>\n</blockquote>\n<p>I'm not sure if this is it? It's more that two ranges one of which is of ref type get put in an equivalence class because they contain the same value. What I don't know is why this assertion only fails for this particular case not any of the other times. This is a smaller case showing the same pattern (see Inst pairs 3,4/5,6/7,8): </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">VCode_ShowWithRRU</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Entry</span><span class=\"w\"> </span><span class=\"n\">block</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Block</span><span class=\"w\"> </span><span class=\"mi\">0</span>:\n      <span class=\"p\">(</span><span class=\"n\">original</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">block</span>: <span class=\"nc\">block0</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">successor</span>: <span class=\"nc\">Block</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">0</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v0J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">1</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rsi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v1J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">2</span>:   <span class=\"nc\">load_ext_name</span><span class=\"w\"> </span><span class=\"n\">u1</span>:<span class=\"mi\">0</span><span class=\"o\">+</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v2J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">3</span>:   <span class=\"nc\">movl</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v17Jl</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">4</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v17J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v4J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">5</span>:   <span class=\"nc\">movl</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v16Jl</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">6</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v16J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v6J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">7</span>:   <span class=\"nc\">movl</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v15Jl</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">8</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v15J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v8J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">9</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"mi\">8</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">v0J</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v9J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">10</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v1J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v11J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">11</span>:   <span class=\"nc\">addq</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"o\">-</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v11J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">12</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v8J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">16</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">v1J</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">13</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v6J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">8</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">v1J</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">14</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v4J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">v1J</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">15</span>:   <span class=\"nc\">jmp</span><span class=\"w\">     </span><span class=\"n\">label1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Block</span><span class=\"w\"> </span><span class=\"mi\">1</span>:\n      <span class=\"p\">(</span><span class=\"n\">original</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">block</span>: <span class=\"nc\">block1</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"mi\">23</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">16</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v11J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">152</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">v2J</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">17</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v9J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v12J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">18</span>:   <span class=\"nc\">movl</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v14Jl</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">19</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v14J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">v13J</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">20</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v12J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">21</span>:   <span class=\"nc\">movq</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">v13J</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">rdx</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">Inst</span><span class=\"w\"> </span><span class=\"mi\">22</span>:   <span class=\"nc\">ret</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but it compiles fine</p>",
        "id": 232798803,
        "sender_full_name": "Will Robson",
        "timestamp": 1617300029
    },
    {
        "content": "<p>Ah! I just realized that perhaps this is a consequence of move coalescing. \"Reffyness\" propagates across moves (that's the fixpoint loop where the assert fired) so the bitcasts you're using to turn R64s into I64s are going to cause this</p>",
        "id": 232809575,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617304386
    },
    {
        "content": "<p>Somehow we need to mark those as not moves but opaque operators</p>",
        "id": 232809625,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617304407
    },
    {
        "content": "<p>(in other words I can imagine the fix but it's slightly nontrivial)</p>",
        "id": 232809742,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1617304459
    }
]