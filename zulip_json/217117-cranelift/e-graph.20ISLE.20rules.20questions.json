[
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> </p>\n<p>I'm trying to add some of the div/rem opts i talked about on github, i just had a few questions on things im a bit stuck on if you dont mind:</p>\n<p>would this be the overall correct way to implement the basic transform?</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">simplify</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">udiv</span><span class=\"w\"> </span><span class=\"nv\">ty</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">c</span><span class=\"w\"> </span><span class=\"nv\">@</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">iconst</span><span class=\"w\"> </span><span class=\"nv\">ty</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">power_of_two</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"p\">))))</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"nv\">ushr</span><span class=\"w\"> </span><span class=\"nv\">ty</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">c</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I am mostly just confused on how to handle the immediate RHS value. I wrote this small extractor here: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">power_of_two</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">imm</span>: <span class=\"nc\">Imm64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Imm64</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i64_is_power_of_two</span><span class=\"p\">(</span><span class=\"n\">imm</span><span class=\"p\">.</span><span class=\"n\">bits</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Imm64</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As part of <code>prelude_opt.isle</code> to extract the power of two imm. I then run <code>cargo run -- test ./filetests/filetests/egraph/algebraic.clif</code> for which i added another function below the existing one:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">div_rem_pow_2</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">udiv</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">check</span>: <span class=\"nc\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ushr</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to fail however. I presume i am doing something wrong or missing something. I am also unsure if i should insert an upper bound for <code>power_of_two</code>, since the existing preopts seem to do that too.</p>",
        "id": 292072035,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648385
    },
    {
        "content": "<p>in particular, im not sure how to match a const on the rhs with a specific extractor, and then <em>also</em> use the value in the rewrite</p>",
        "id": 292072592,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648683
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418736\">@Riccardo D'Ambrosio</span> the general shape here looks correct. I'm not sure why the if-let on <code>i64_is_power_of_two</code>'s result matches a <code>false</code> (what does the returned tuple mean? the function definition isn't here to check). Ah, and the rule as-written will use the original 2^x constant as the shift amount, rather than x</p>",
        "id": 292072610,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659648697
    },
    {
        "content": "<p>You'll probably want to write <code>(iconst ty (power_of_two c))</code> and then use <code>c</code> as the shift-amount</p>",
        "id": 292072636,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659648713
    },
    {
        "content": "<p>its the function from <code>simple_preopt.rs</code>, the false is to check if the power of two is not negative</p>",
        "id": 292072717,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648736
    },
    {
        "content": "<p>which it should not be because this is udiv, but im not sure</p>",
        "id": 292072729,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/e-graph.20ISLE.20rules.20questions/near/292072636\">said</a>:</p>\n<blockquote>\n<p>You'll probably want to write <code>(iconst ty (power_of_two c))</code> and then use <code>c</code> as the shift-amount</p>\n</blockquote>\n<p>iirc i tried that, but it complained that <code>Variable 'c' has type Imm64 but we need Id in context</code>. Which makes sense to me, but i wasn't quite sure how to put a new value into the graph and get back an ID</p>",
        "id": 292072897,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648851
    },
    {
        "content": "<p>ah! for that you probably want <code>(iconst ty c)</code> in the right-hand side</p>",
        "id": 292072940,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659648877
    },
    {
        "content": "<p>(<code>iconst</code> along with the other opcodes work as both extractors and constructors in the mid-end)</p>",
        "id": 292072969,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659648897
    },
    {
        "content": "<p>I see</p>",
        "id": 292072993,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648913
    },
    {
        "content": "<p>it compiles but it does not pass the test: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">FAIL</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">filetests</span><span class=\"o\">/</span><span class=\"n\">filetests</span><span class=\"o\">/</span><span class=\"n\">egraph</span><span class=\"o\">/</span><span class=\"n\">algebraic</span><span class=\"p\">.</span><span class=\"n\">clif</span>: <span class=\"nc\">optimize</span><span class=\"w\"></span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"nc\">filecheck</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"mi\">15</span>:\n    #<span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">check</span>: <span class=\"nc\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ushr</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">div_rem_pow_2</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"nc\">fast</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Missed</span><span class=\"w\"> </span>#<span class=\"mi\">0</span>: <span class=\"err\">\\</span><span class=\"n\">bv2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ushr</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"err\">\\</span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"w\">                                 </span><span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"o\">&gt;</span><span class=\"w\">                                     </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"w\">                                     </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">udiv</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"w\">                                     </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 292073015,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659648935
    },
    {
        "content": "<p>ok. I think I just need to look at this myself -- this stuff is literally a few days old and I'm still working out the kinks; debugging indirectly is an order of magnitude harder. But thank you for kicking the tires early :-)</p>",
        "id": 292073116,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659648997
    },
    {
        "content": "<p>no problem <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 292073127,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659649008
    },
    {
        "content": "<p>oh wait, i just noticed, that should not be an <code>iconst.i32 2</code>, i need to check for <code>v1 = iconst.i32 1</code>, tho i dont think thats the root issue</p>",
        "id": 292073679,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659649386
    },
    {
        "content": "<p>seems like <code>udiv</code> stuff overall doesn't match, even with the existing <code>x / 1 =&gt; x</code> transform, odd</p>",
        "id": 292075924,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659650762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> i figured it out, <code>imul</code> maps to a <code>Pure</code> node because it cannot trap, while <code>udiv</code>/<code>sdiv</code> map to <code>Instr</code> because it could trap.  So it is not matching the Instr node.</p>",
        "id": 292178812,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659717554
    },
    {
        "content": "<p>a possible solution i noticed is adding <code>Node::Instr</code> to the <code>ContextIter</code> handler, though i am unsure if that's what you planned to do to handle such node types</p>",
        "id": 292179075,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659717685
    },
    {
        "content": "<p>Ah! That would do it. I suspect we might want to actually make the extractor iterate over all nodes instead (or <code>Pure</code> and <code>Inst</code> at least) for this reason, and perhaps have a way of marking a non-pure node as \"deleted\" when we can prove that it's safe, e.g. if we statically know the trap will never occur (this case)</p>",
        "id": 292179442,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659717892
    },
    {
        "content": "<p>Yeah that would make sense</p>",
        "id": 292179502,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659717921
    },
    {
        "content": "<p>thanks for tracking this down; I've been working on integrating the alias analysis then I'll likely make this change</p>",
        "id": 292179534,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659717941
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 292179544,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659717946
    },
    {
        "content": "<p>kinda surprised you can integrate alias analysis without this change tho haha</p>",
        "id": 292179653,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659717994
    },
    {
        "content": "<p>then again im not quite sure how an e-graph alias analysis would look like, since alias analysis requires tracking information in multiple passes and things like that</p>",
        "id": 292179732,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718042
    },
    {
        "content": "<p>oh, I had been writing a special set of ctors/etors to make it work; and the analysis itself (last-store analysis) is separate</p>",
        "id": 292180308,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718329
    },
    {
        "content": "<p>interestingly Redundant Load Elimination can actually just fall out of the node dedup, if one defines the node identity (Hash/Eq) carefully: based on addr eclass and offset (and load type), but not specific load instruction. Store-to-load forwarding is a bit harder :-)</p>",
        "id": 292180361,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/e-graph.20ISLE.20rules.20questions/near/292180308\">said</a>:</p>\n<blockquote>\n<p>oh, I had been writing a special set of ctors/etors to make it work; and the analysis itself (last-store analysis) is separate</p>\n</blockquote>\n<p>I see, what does the analysis pass run on/when? my confusion is that, wouldn't you need to run the pass at every iteration of the graph?</p>",
        "id": 292180546,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718453
    },
    {
        "content": "<p>No, because stores are side-effecting so always exist and will not move; the analysis happens on the CLIF before egraph build and computes a property for each load</p>",
        "id": 292180669,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718526
    },
    {
        "content": "<p>Oh interesting</p>",
        "id": 292180698,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718539
    },
    {
        "content": "<p>i imagine that might get a bit more complex though once things like unrolling are added</p>",
        "id": 292180782,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718566
    },
    {
        "content": "<p>If/when we want dead-store elimination that gets more complex, but DSE is quite tricky for Wasm at least because we have to get the state at any given trap point right</p>",
        "id": 292180817,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718580
    },
    {
        "content": "<p>I see</p>",
        "id": 292180855,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718600
    },
    {
        "content": "<p>unrolling falls into \"control-flow opt\" which is outside the scope of the egraph-based work for now -- needs more thought!</p>",
        "id": 292180885,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718614
    },
    {
        "content": "<p>Yeah absolutely</p>",
        "id": 292180907,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718621
    },
    {
        "content": "<p>there is certainly a fixpoint between at least inlining and egraph value opts (specifically: constant prop can lead to constant func ptr can lead to inlining can lead to more constant prop; important for dynamic-dispatch cases) so I do want to think more about control flow in the context of the egraph work eventually</p>",
        "id": 292180997,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718672
    },
    {
        "content": "<p>Yeah</p>",
        "id": 292181270,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718786
    },
    {
        "content": "<p>i imagine inling in an e-graph may work fairly well if the whole program is a single e-graph, since it could select between inlining and not inlining much better because it knows that inlining allowed for better optimization that outweighed the cost</p>",
        "id": 292181432,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718856
    },
    {
        "content": "<p>yep! and that was suggested by mwillsey over in the rfc thread actually too</p>",
        "id": 292181473,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718886
    },
    {
        "content": "<p>one could in theory have a bridge from the callsite to the function body also in the egraph, and let elaboration go transparently across that bridge</p>",
        "id": 292181505,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718908
    },
    {
        "content": "<p>Right, i noticed some talk about whether everything should be a single e-graph or not, but i forget what the final decision was/if there was one</p>",
        "id": 292181635,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718950
    },
    {
        "content": "<p>it gets a bit trickier once one wants to optimize though: fundamentally the different inlined bodies want to diverge sometimes. so some sort of cloning is needed</p>",
        "id": 292181642,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718957
    },
    {
        "content": "<p>for now it's a big architectural change (everything in Cranelift assumes per-function compilation) so it's more of a \"future thoughts\" sort of thing</p>",
        "id": 292181669,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659718975
    },
    {
        "content": "<p>everything being one graph sounds awesome for memory usage since e-graphs are great at sharing</p>",
        "id": 292181696,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718986
    },
    {
        "content": "<p>but more complex as well</p>",
        "id": 292181704,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659718992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/e-graph.20ISLE.20rules.20questions/near/292181669\">said</a>:</p>\n<blockquote>\n<p>for now it's a big architectural change (everything in Cranelift assumes per-function compilation) so it's more of a \"future thoughts\" sort of thing</p>\n</blockquote>\n<p>Ah ok</p>",
        "id": 292181721,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719005
    },
    {
        "content": "<p>btw, does cranelift have a concept of NSW/NUW? i.e. ops which assume overflow does not happen. I know that condition is required for a significant amount of optimizations in llvm</p>",
        "id": 292182350,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719314
    },
    {
        "content": "<p>nope; that actually came up somewhere here a bit ago when I was looking at address-computation code</p>",
        "id": 292182473,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719379
    },
    {
        "content": "<p>the major issue with that is it introduces semantically undefined behavior, which is a notorious correctness footgun; it's better, all other things equal, to fully define the output for every set of inputs</p>",
        "id": 292182581,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719416
    },
    {
        "content": "<p>Yeah it's required for things like optimizing out bounds checks</p>",
        "id": 292182591,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719423
    },
    {
        "content": "<p>Yeah true</p>",
        "id": 292182603,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719432
    },
    {
        "content": "<p>I suspect that there may be cases where we can instead encode the knowledge in the types, or ... basically I want to find a way around adding it</p>",
        "id": 292182631,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719454
    },
    {
        "content": "<p>but this, too, needs more thought</p>",
        "id": 292182643,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418736\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/217117-cranelift/topic/e-graph.20ISLE.20rules.20questions/near/292182591\">said</a>:</p>\n<blockquote>\n<p>Yeah it's required for things like optimizing out bounds checks</p>\n</blockquote>\n<p>well, to some degree, llvm has to also prove the condition does not overflow before optimizing it out</p>",
        "id": 292182656,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719467
    },
    {
        "content": "<p>This presentation by the llvm devs on how they optimize out math-based conditions was very interesting <a href=\"https://www.youtube.com/watch?v=1hm5ZVmBEvo\">YouTube - 2021 LLVM Dev Mtg “A New Approach to Removing Redundant Conditions in LLVM”</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"1hm5ZVmBEvo\" href=\"https://www.youtube.com/watch?v=1hm5ZVmBEvo\"><img src=\"https://uploads.zulipusercontent.net/e12ab907d6c0a67322a2f4bf8c67868c7b6bdb02/68747470733a2f2f692e7974696d672e636f6d2f76692f31686d355a566d4245766f2f64656661756c742e6a7067\"></a></div>",
        "id": 292182787,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719538
    },
    {
        "content": "<p>right, so for example a range-analysis could drive a rule that widens adds or removes uextends or whatever when the wraparound behavior can't be hit</p>",
        "id": 292182802,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719549
    },
    {
        "content": "<p>cool, I'll add that to my queue, thanks!</p>",
        "id": 292182816,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719557
    },
    {
        "content": "<p>I was wondering at some point if its possible to do it using e-graphs by tracking invariants using <code>egg::Analysis</code>-like things, but i never explored it a lot</p>",
        "id": 292182837,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719570
    },
    {
        "content": "<p>range analysis should definitely be possible to build using such a framework</p>",
        "id": 292182891,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659719601
    },
    {
        "content": "<p>because it requires storing a variable amount of invariants for each node/eclass, which is difficult to manage, allocation-optimization-wise</p>",
        "id": 292182898,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719605
    },
    {
        "content": "<p>and it uses fourier-motzkin elimination to check the invariants, which is probably possible in a constructor, but it needs more thought</p>",
        "id": 292182938,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719636
    },
    {
        "content": "<p>if it doesn't explode the number of invariants kept, it's probably possible to store just an id into a bump-allocator or something</p>",
        "id": 292183183,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659719745
    },
    {
        "content": "<p>hmm, I guess I've envisioned range analysis as something much simpler: if the analysis domain allows just a single integer range (open-ended or closed on both sides) then it's constant space per value, no?</p>",
        "id": 292183712,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720017
    },
    {
        "content": "<p>my concern is mainly that it might widely increase memory usage as optimization proceeds, because data is associated with every eclass, so you may end up having to allocate a lot of invariants, especially if you support a variable amount of range invariants per class</p>",
        "id": 292183762,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720055
    },
    {
        "content": "<p>this seems sufficient for something like eliminating overflow cases: if we can carry the fact that x \\in [0, 4095) or whatever then we can use that, and we can propagate these through a number of binary operators too</p>",
        "id": 292183803,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720073
    },
    {
        "content": "<p>Yeah that's true, a simple single-range system might work fairly well as a starting experiment</p>",
        "id": 292183913,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720123
    },
    {
        "content": "<p>anything that involves solving more complex systems (variable number of constraints etc) I think would probably not be practical in our compilation-time envelope, though I would be curious to see what use-cases/applications of that you had in mind</p>",
        "id": 292183959,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720146
    },
    {
        "content": "<p>Yeah i think it's probably out of scope for cranelift</p>",
        "id": 292183978,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720159
    },
    {
        "content": "<p>Im writing a shader language, and naturally, the core of optimizing shaders is optimizing the math to hell and back, which is why im exploring e-graphs, since from simple experiments, they work unbelievably well for this task, i had this wild optimization my experiment did a while back:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mf\">3.0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">---</span>-&gt; <span class=\"nc\">fma</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">fma</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">recip</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"n\">Cost</span>: <span class=\"mf\">26.5</span><span class=\"w\"> </span>-&gt; <span class=\"mi\">12</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 292184101,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720230
    },
    {
        "content": "<p>However, one intricacy about shader optimization is that some transforms only work on normalized vectors/floats, so i must track that invariant somehow</p>",
        "id": 292184186,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720269
    },
    {
        "content": "<p>interesting, that's pretty cool</p>",
        "id": 292184211,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720284
    },
    {
        "content": "<p>this is definitely a case where more expensive analysis is warranted</p>",
        "id": 292184243,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720306
    },
    {
        "content": "<p>i think a single range associated with each eclass may work, i probably won't have indexing conditions that require disjoint ranges</p>",
        "id": 292184274,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/e-graph.20ISLE.20rules.20questions/near/292184243\">said</a>:</p>\n<blockquote>\n<p>this is definitely a case where more expensive analysis is warranted</p>\n</blockquote>\n<p>To some degree i actually think using e-graphs <em>vastly</em> simplifies my job, since the e-graph can propagate invariants for me really easily. I just have to store the invariants efficiently and write rules that check them</p>",
        "id": 292184387,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720384
    },
    {
        "content": "<p>though i have an RVSDG-based IR also, so im not solely working off the e-graph, which allows me to do some analyses much easier, to then propagate those results into the egraph</p>",
        "id": 292184585,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720507
    },
    {
        "content": "<p>another analysis which might work very well with egraphs is scalar evolution (thats what llvm calls it), which builds a \"chain of recurrences\" to describe how a loop calculates its next result, i.e. how it evolves. An e-graph that knows about such info might be able to make really good inferences about moving out or transforming things inside the loop</p>",
        "id": 292184869,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720663
    },
    {
        "content": "<p>yup, that's a really good point</p>",
        "id": 292184931,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720714
    },
    {
        "content": "<p>its probably also possible to piggyback off the CR for LICM, any recurrence not directly associated with an induction variable can be moved out</p>",
        "id": 292185084,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720798
    },
    {
        "content": "<p>not sure if you are familiar with chains of recurrences, but this article breaks it down fairly well <a href=\"https://kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html\">https://kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html</a></p>",
        "id": 292185214,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720872
    },
    {
        "content": "<p>i'm unsure of how expensive of an analysis it actually is however</p>",
        "id": 292185257,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720904
    },
    {
        "content": "<p>yep, I've looked at the general idea before. there's certainly a lot we could do here</p>",
        "id": 292185293,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720930
    },
    {
        "content": "<p>one thing I want to be a little careful of avoiding is actually introducing loops into the egraph; right now blockparams (hence part of the path for any recurrence) are terminals (nodes without children)</p>",
        "id": 292185396,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659720971
    },
    {
        "content": "<p>Yeah, i imagine they play a somewhat significant part in performance for some programs</p>",
        "id": 292185397,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720971
    },
    {
        "content": "<p>I see</p>",
        "id": 292185423,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659720988
    },
    {
        "content": "<p>but perhaps there's a way of giving rules access to preds/inputs without actually wiring up the dataflow (a separate extractor, etc)</p>",
        "id": 292185443,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721000
    },
    {
        "content": "<p>could loops perhaps be special <code>Loop</code> nodes?</p>",
        "id": 292185470,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721010
    },
    {
        "content": "<p>so, this, too, \"needs more thought\" (sorry that's becoming my frequent refrain :-) )</p>",
        "id": 292185479,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721015
    },
    {
        "content": "<p>that gets hairy really quickly. I looked at more structured forms of graph IR (RVSDGs etc) but the issue is going into and out of it from the CFG world on either end</p>",
        "id": 292185517,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721043
    },
    {
        "content": "<p>hehe, yeah, i feel like this is mostly uncharted waters</p>",
        "id": 292185531,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721051
    },
    {
        "content": "<p>hmm, yeah</p>",
        "id": 292185570,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721074
    },
    {
        "content": "<p>so for now I keep the CFG in the \"side-effect skeleton\" and avoid completely any questions of reasoning about CFG-related patterns, but perhaps there's something we could do</p>",
        "id": 292185584,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721081
    },
    {
        "content": "<p>at least an overlay (a node representing \"this is a loop and these are the recurrent inputs\") that doesn't feed into the lowering-back-out but can be used to match</p>",
        "id": 292185670,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721117
    },
    {
        "content": "<p>couldn't loop outputs be treated as opaque variables? like variables used in more than one place</p>",
        "id": 292185678,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721121
    },
    {
        "content": "<p>inputs you mean? or specifically outputs?</p>",
        "id": 292185774,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721181
    },
    {
        "content": "<p>uhhh, mostly outputs, but maybe it could apply to inputs too? idk haha</p>",
        "id": 292185833,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721203
    },
    {
        "content": "<p>kind of like how RVSDG has input and output edges for loop nodes</p>",
        "id": 292185894,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721217
    },
    {
        "content": "<p>in general, what are the issues with treating structured control flow as special nodes if you know they fit a particular control flow pattern like looping or switching/branching?</p>",
        "id": 292186005,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721279
    },
    {
        "content": "<p>I guess the main issue I was trying to avoid was fitting <em>all</em> control flow into that form; we have to be able to accept arbitrary CFGs as input and I don't want a Relooper-like algorithm</p>",
        "id": 292186072,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721319
    },
    {
        "content": "<p>Yeah absolutely</p>",
        "id": 292186126,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721330
    },
    {
        "content": "<p>so then there's a question of how to mix the two; an overlay node for informational purposes only seems totally reasonable, as long as the control flow <em>also</em> exists in the current blockparam nodes and side-effecting skeleton</p>",
        "id": 292186183,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721359
    },
    {
        "content": "<p>Yeah it needs some way of combining both unstructured control flow, and structured control flow known to fit some pattern</p>",
        "id": 292186239,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721389
    },
    {
        "content": "<p>ok, I am going to disappear from this conversation for a bit to get some hacking done :-) but thanks for all the ideas, I'll keep chewing on this</p>",
        "id": 292186521,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659721547
    },
    {
        "content": "<p>bye <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 292186542,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659721559
    },
    {
        "content": "<p>noticed PR seems to now support inst nodes, i'll try to add the div/rem transforms now</p>",
        "id": 292428002,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977399
    },
    {
        "content": "<p>most of the hard work seems to already be done from simple_preopt so i hope it won't be too bad</p>",
        "id": 292428180,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977466
    },
    {
        "content": "<p>also, has there been any thought on being able to mark certain ISLE rules as bidirectional? it's helpful for some rules</p>",
        "id": 292428220,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977489
    },
    {
        "content": "<p>for example, <code>x * 2</code> &lt;---&gt; <code>x &gt;&gt; 1</code> which could help in discovering other transforms based on the mul</p>",
        "id": 292428403,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977561
    },
    {
        "content": "<p>the bidirectional thing is interesting but I would want to be a bit careful with this as it would be easy to produce a lot of blowup</p>",
        "id": 292428467,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977588
    },
    {
        "content": "<p>Yes absolutely, from my experiments it seems that rules that allow the optimizer to create random terms are <em>really</em> bad, not sure what i expected tho...</p>",
        "id": 292428549,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977632
    },
    {
        "content": "<p>in general I think I need to nail down some \"rules for rules\" more precisely -- something like layering for forward-progress guarantees</p>",
        "id": 292428668,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977665
    },
    {
        "content": "<p>Yeah totally</p>",
        "id": 292428682,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977671
    },
    {
        "content": "<p>I've found it not too hard to accidentally create a generative loop, and because we don't do full eq-sat we end up creating an infinite chain of union nodes instead</p>",
        "id": 292428716,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977688
    },
    {
        "content": "<p>associativity/commutativity rules are an interesting case specifically</p>",
        "id": 292428734,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977695
    },
    {
        "content": "<p>but in limited cases (\"either of these two nodes creates the other automatically\") I agree some sort of syntax sugar for one rule to become two might be useful</p>",
        "id": 292428797,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977716
    },
    {
        "content": "<p>Yeah, and you dont do exponential backoff either, so it's a recipe for disaster haha</p>",
        "id": 292428824,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977730
    },
    {
        "content": "<p>associativity/commutativity scare me a bit because it's easy to get combinatorial blowup</p>",
        "id": 292428834,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977735
    },
    {
        "content": "<p>yeah i never really decided on an approach to standardize how they would work so they dont end up dominating rewrite time</p>",
        "id": 292428877,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659977759
    },
    {
        "content": "<p>so for now what I'm doing is having two forms of each rule (in cprop for example) for commutativity, and some rules that try to reassociate in certain cases for cprop and licm</p>",
        "id": 292428936,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659977772
    },
    {
        "content": "<p>makes sense, although i think such rewrite rules are very helpful once u have simplifications that can take multiple terms, such as FMA (<code>a * b + c</code> -&gt; <code>fma(a, b, c)</code>). Though this might not be a problem for cranelift</p>",
        "id": 292464447,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659978002
    },
    {
        "content": "<p>maybe doing some sort of marking to avoid one associative rewrite from happening infinitely many times, idk</p>",
        "id": 292464588,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659978049
    },
    {
        "content": "<p>This is another problem with bidirectional rules, something like an FMA rewrite can result in infinite loops. And im not quite sure that its possible to avoid such a problem without having a way to make the rewriter realize that it already went through such a rewrite</p>",
        "id": 292465167,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659978331
    },
    {
        "content": "<p>right, the interning/dedup is important there. over the weekend I did some hacking on the aegraph implementation to do hash/eq on nodes based on a \"canonical id\" which is different from the \"latest id\" (pointing to the whole tree of union nodes) that should help in that regard...</p>",
        "id": 292465423,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659978462
    },
    {
        "content": "<p>one still has to be careful about truly generative rules of course</p>",
        "id": 292465500,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659978490
    },
    {
        "content": "<p>Yeah</p>",
        "id": 292465510,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659978495
    },
    {
        "content": "<p>it might also be possible to order the rules in a way where actually \"meaningful\" rewrites are tried first, but doing that automatically seems challenging</p>",
        "id": 292465612,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659978549
    },
    {
        "content": "<p>yeah, what I'm finding is that there's a good amount of tweaking/engineering that goes into this if one wants to make it performant on par with a handwritten pass</p>",
        "id": 292466122,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659978787
    },
    {
        "content": "<p>it's still better than actually writing a pass by hand! but I'm thinking we'll want to invest in tooling to show what's going on maybe, or at least write down some guidelines</p>",
        "id": 292466165,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659978809
    },
    {
        "content": "<p>yeah, especially with no full eq-sat it might be easy for a contributor to accidentally create hard to debug infinite loops</p>",
        "id": 292466722,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659979107
    },
    {
        "content": "<p>Another random thought i had, e-graphs might make it really easy to implement at least basic SLP vectorization, assuming the optimizer can figure out how to potentially reorder statements to allow this to happen</p>",
        "id": 292489261,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659989015
    },
    {
        "content": "<p>Hmm seems like inst nodes still don't match, i think the issue now is that there is only a single constructor, and that is for pure enodes. Though im unsure of how to solve this since constructing an inst node requires a sourceloc as well, so the sourceloc value has to be either passed transparently through the rewrite somehow, or matched in the rule</p>",
        "id": 292491254,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659990034
    },
    {
        "content": "<p>Yeah, you're hitting a very \"under construction\" bit of code again</p>",
        "id": 292491844,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659990333
    },
    {
        "content": "<p>right now my focus has been on pure nodes as reasoning about merging and code motion with side-effects is quite a bit more complex</p>",
        "id": 292491937,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1659990379
    },
    {
        "content": "<p>makes sense</p>",
        "id": 292499012,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659994106
    },
    {
        "content": "<p>i kind of wonder if it might be possible to do something similar to what RVSDG does for solving the side effect problem with graphs</p>",
        "id": 292499054,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659994140
    },
    {
        "content": "<p>where you have edges for every side-effectful op and they connect together to form an ordering constraint for what ops must run before/after</p>",
        "id": 292499096,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1659994168
    },
    {
        "content": "<p>I'm late to the conversation but Riccardo, your project sounds cool! I did experiments a few months ago on manipulating RVSDGs in e-graphs (<a href=\"https://github.com/jameysharp/optir\">https://github.com/jameysharp/optir</a>), if you want to see a way you can do full control-flow inside your e-graph. Cranelift isn't going that direction because the trade-offs are different but I bet it'd expose more opportunities in a shader compiler. regarding the earlier conversation about inlining: I found it's especially neat in e-graphs because you can optimize call sites based on information you learn from inlining, but then still decide not to inline; that doesn't change the fact that Cranelift isn't designed for that, but I think it makes the potential future gains from this work bigger.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/jameysharp/optir\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/61387605f7a7db4b28e1cbd8ffb33b8b073ce0ec\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623436613638323539396630623966666134643861663566613331303637636639366434633037663566613663303832336464393239363661636630323366392f6a616d657973686172702f6f70746972)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/jameysharp/optir\" title=\"GitHub - jameysharp/optir: Compiler optimizer for arbitrary control flow based on equality saturation\">GitHub - jameysharp/optir: Compiler optimizer for arbitrary control flow based on equality saturation</a></div><div class=\"message_embed_description\">Compiler optimizer for arbitrary control flow based on equality saturation - GitHub - jameysharp/optir: Compiler optimizer for arbitrary control flow based on equality saturation</div></div></div>",
        "id": 292682476,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1660095156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"504918\">@Jamey Sharp</span> oh hey i read optir a lot to check out ideas! awesome. I was a little confused in some areas but i got the general gist and it inspired me to try RVSDG + egraphs even more. Im interested in e-graphs mostly for superoptimizing math, since shaders are just blobs of math, and float math is criminally underoptimized, especially trigonometry. Inlining is something i'd like to explore a bit more fine-grained, my current (and potentially final) approach is to just recursively inline <em>everything</em> and optimize a single graph for each shader entry point. Reason being that shaders don't exactly have true function calls, and literally every single gpu compiler on the planet inlines everything it can get away with, even CUDA compilers. Especially when it comes to math and optimizing math across functions. But maybe it would be cool to let e-graphs drive cross-function discovery to choose whether to inline or decide to treat it as \"opaque\" for optimization purposes</p>",
        "id": 292687683,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660101137
    },
    {
        "content": "<p>the timing of cranelift's e-graphs RFC could not have been more perfect <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 292687846,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660101337
    },
    {
        "content": "<p>in particular i think RVSDG + e-graphs could help tremendously for cases where the ordering of actual operations doesnt matter, only how they are connected together</p>",
        "id": 292687938,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660101459
    },
    {
        "content": "<p>and once u think about it, this fits <em>so many</em> optimizations, even something pretty complex like superword level parallelism</p>",
        "id": 292687989,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660101501
    },
    {
        "content": "<p>so i think it's the perfect combination once it can be explored more in depth, RVSDG excels at the \"large bits\", analyzing how things connect, things like that. And e-graphs excel at discovering the smaller bits and how they can be potentially rewritten to be better</p>",
        "id": 292688051,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660101599
    },
    {
        "content": "<p>I think there are also interesting opportunities with noticing that different expressions of control-flow are equivalent. I didn't previously have any intraprocedural examples where e-graphs help with that, but the link you shared last week about \"How LLVM optimizes power sums\" is a good one: for small loop counts, the closed-form loop-free version may take longer than the simpler loop. doing that transformation on an e-graph means you can defer the decision about whether it's profitable until you've reached saturation, at which point your cost function may have more information to work with. like with inlining, it also allows surrounding code to be improved based on information learned from the power-sum analysis, even if the later decision is to emit a loop after all.<br>\nand yeah, I agree that there are a ton of interesting directions to go, various kinds of parallelism definitely included! I think the general criterion for \"would an e-graph help here\" is: are you sure this transformation is an improvement in all cases? if not, an e-graph is great, and I think most optimizations have this kind of uncertainty. (although I think it'd be nice if egg provided some better support for pruning alternatives if you do know they're always worse; the way egg's examples do constant-folding seems like it's a foot-gun without some more restricted API.)<br>\non the other hand I think you're right that for shaders you should just always inline everything.</p>",
        "id": 292820606,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1660160434
    },
    {
        "content": "<p>Yeah, shaders in particular make it easier to do certain things, for example, its rarely not profitable to unroll a loop unless its a really big loop.</p>",
        "id": 292832775,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1660165388
    }
]