[
    {
        "content": "<p>I'm trying to generate Rust-like backtraces (a list of function symbols is enough for now, no line number) with libunwind. However; whenever I try to fetch symbol names with <code>unw_get_proc_name</code> i get  the <code>general unspecified error</code> error code. I suspect this is because I'm not generating unwind information correctly from cranelift. However; I cannot figure out where the problem sits. </p>\n<p>For now I copied Rustc's cranelift backends implementation for adding <a href=\"https://github.com/luminalang/lumina/blob/libunwind/lumina-compiler/src/backend/cranelift/debuginfo/unwind.rs\">unwind information</a> and then <a href=\"https://github.com/luminalang/lumina/blob/6f1828ade5bc31b817a4e4710267ca037a333f04/lumina-compiler/src/backend/cranelift/mod.rs#L143\">add it after defining each function</a> . Then in my language's standard library I invoke the <a href=\"https://github.com/luminalang/lumina/blob/libunwind/luminapath/std/unwind/lib.lm\">libunwind functions</a> which I think are meant to retrieve that information. After copying Rustc's libunwind code I no longer get the <code>missing unwind information</code> error code but now instead just always get <code>EUNSPEC</code> (unspecified error). </p>\n<p>Strangely, when I try calling the <code>unw_get_proc_name</code> function the same way in Rust (on the musl target which has the <code>unw_*</code> symbols) I get exactly the same EUNSPEC error. <a href=\"https://github.com/luminalang/lumina/blob/libunwind/rust-replication/src/main.rs\">https://github.com/luminalang/lumina/blob/libunwind/rust-replication/src/main.rs</a> so this problem might not even be related to how I use cranelift. Or; Rust doesn't generate this unwind information either and does something completely different to create its backtraces? </p>\n<p>Regardless; I'm very lost in what I'm supposed to do to achieve this goal and what I'm doing wrong in my attempts to do so.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/luminalang/lumina/blob/libunwind/lumina-compiler/src/backend/cranelift/debuginfo/unwind.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f7986d82c0cc1034d8fe3e8ec87d899613f0a07d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643733333462396234636439343938653161336439303664653435613465376533633664336636643962646439623230366463393662653863333636316465372f6c756d696e616c616e672f6c756d696e61&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/luminalang/lumina/blob/libunwind/lumina-compiler/src/backend/cranelift/debuginfo/unwind.rs\" title=\"lumina/lumina-compiler/src/backend/cranelift/debuginfo/unwind.rs at libunwind · luminalang/lumina\">lumina/lumina-compiler/src/backend/cranelift/debuginfo/unwind.rs at libunwind · luminalang/lumina</a></div><div class=\"message_embed_description\">Lumina is an eager-by-default natively compiled functional programming language with the core goals of readibility, practicality, compiler-driven development and simplicity. - luminalang/lumina</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/luminalang/lumina/blob/6f1828ade5bc31b817a4e4710267ca037a333f04/lumina-compiler/src/backend/cranelift/mod.rs#L143\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f7986d82c0cc1034d8fe3e8ec87d899613f0a07d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643733333462396234636439343938653161336439303664653435613465376533633664336636643962646439623230366463393662653863333636316465372f6c756d696e616c616e672f6c756d696e61&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/luminalang/lumina/blob/6f1828ade5bc31b817a4e4710267ca037a333f04/lumina-compiler/src/backend/cranelift/mod.rs#L143\" title=\"lumina/lumina-compiler/src/backend/cranelift/mod.rs at 6f1828ade5bc31b817a4e4710267ca037a333f04 · luminalang/lumina\">lumina/lumina-compiler/src/backend/cranelift/mod.rs at 6f1828ade5bc31b817a4e4710267ca037a333f04 · luminalang/lumina</a></div><div class=\"message_embed_description\">Lumina is an eager-by-default natively compiled functional programming language with the core goals of readibility, practicality, compiler-driven development and simplicity. - luminalang/lumina</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/luminalang/lumina/blob/libunwind/luminapath/std/unwind/lib.lm\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f7986d82c0cc1034d8fe3e8ec87d899613f0a07d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643733333462396234636439343938653161336439303664653435613465376533633664336636643962646439623230366463393662653863333636316465372f6c756d696e616c616e672f6c756d696e61&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/luminalang/lumina/blob/libunwind/luminapath/std/unwind/lib.lm\" title=\"lumina/luminapath/std/unwind/lib.lm at libunwind · luminalang/lumina\">lumina/luminapath/std/unwind/lib.lm at libunwind · luminalang/lumina</a></div><div class=\"message_embed_description\">Lumina is an eager-by-default natively compiled functional programming language with the core goals of readibility, practicality, compiler-driven development and simplicity. - luminalang/lumina</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/luminalang/lumina/blob/libunwind/rust-replication/src/main.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f7986d82c0cc1034d8fe3e8ec87d899613f0a07d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643733333462396234636439343938653161336439303664653435613465376533633664336636643962646439623230366463393662653863333636316465372f6c756d696e616c616e672f6c756d696e61&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/luminalang/lumina/blob/libunwind/rust-replication/src/main.rs\" title=\"lumina/rust-replication/src/main.rs at libunwind · luminalang/lumina\">lumina/rust-replication/src/main.rs at libunwind · luminalang/lumina</a></div><div class=\"message_embed_description\">Lumina is an eager-by-default natively compiled functional programming language with the core goals of readibility, practicality, compiler-driven development and simplicity. - luminalang/lumina</div></div></div>",
        "id": 478016234,
        "sender_full_name": "Floppy",
        "timestamp": 1729506218
    },
    {
        "content": "<p>Rust uses the _Unwind_* family of functions to generate backtraces. llvm-libunwind supports this too. I have no idea how the unw_* family of functions is supposed to be used.</p>",
        "id": 478025863,
        "sender_full_name": "bjorn3",
        "timestamp": 1729509211
    },
    {
        "content": "<p>Also for translating function addresses to human readable function names rust uses it's own debuginfo parsing code through the addr2line crate.</p>",
        "id": 478026112,
        "sender_full_name": "bjorn3",
        "timestamp": 1729509279
    },
    {
        "content": "<p>hm ok. llvm-libunwind seems to use <code>dladdr</code> to get the symbol names which is probably very limited. Seems like parsing the dwarf debuginfo manually after unwinding, using the addresses given by libunwind would be the way to go. I'll look whether writing the minimal dwarf parsing code I'd need would be simple enough, if not I could just depend on <code>addr2line</code> as a hack for now.</p>",
        "id": 478033822,
        "sender_full_name": "Floppy",
        "timestamp": 1729511504
    }
]