[
    {
        "content": "<p>Hello! I'm trying to use Cranelift infrastructure to compile WASM modules (generated from Rust) to run on a home-grown virtual machine (specialized for Zero-knowledge proving).</p>\n<p>I'm still in an exploratory phase and I would really appreciate some feedback on the feasibility of my approach before I invest multiple months of work into it.</p>\n<h2>Motivation</h2>\n<p>This work is a continuation of <a href=\"#narrow/channel/217117-cranelift/topic/zkASM.20backend/near/391643702\">zkAsm project</a> that aims to generate Zero-Knowledge proofs for execution of WASM functions. There is an extended <a href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w\">motivation document</a> that goes into why this is useful if you are interested.</p>\n<p>For the purpose of this discussion thread, I have a RISC-V like ISA called <a href=\"https://github.com/0xPolygonHermez/zisk/blob/cd11b3dffc972d7b61968d4233f8362e957f60a8/core/src/zisk_ops.rs#L224\">ZisK</a> and I want to compile WASM modules to bare-metal binaries for this platform. I understand that WASM code expects to be executed in a VM, but solutions like <code>wasm2c</code> and <a href=\"https://github.com/0xPolygonHermez/zisk/blob/cd11b3dffc972d7b61968d4233f8362e957f60a8/core/src/zisk_ops.rs#L224\"><code>w2c2</code></a> give me hope that generating a standalone executable is possible.</p>\n<h2>Plan</h2>\n<p>I know that writing a new Cranelift backend is a big undertaking, so right now I'm trying to guess-timate feasibility, complexity and performance characterisics of the resulting solution before diving into implementation.</p>\n<p>Luckily, I already have a RISC-V -&gt; ZisK translator, so I thought I can assemble the end-to-end prototype that goes like this:</p>\n<ol>\n<li>Compile Rust code to WASM module with <code>rustc</code></li>\n<li>Compile WASM module to RISC-V ELF with <code>wasmtime compile</code></li>\n<li>Translate ELF to ZisK bytecode</li>\n<li>Run the resulting code on ZisK emulator</li>\n</ol>\n<h2>Problems and ideas for solutions</h2>\n<p>I ran into a few problems:</p>\n<ol>\n<li>The bytecode generated in step (2) is relying on WASM VM, e.g. through passing and using <code>vmctx</code> in all functions</li>\n<li>The ELF file generated by <code>wasmtime compile</code> is not really a standalone executable, but more of a container for data necessary for the execution, so I need to re-assemble a ZisK binary out of it</li>\n</ol>\n<p>For 1, I imagine I have two options:<br>\nA. Implement the support for <code>vmctx</code> in ZisK VM - this seems quite fragile, as I need to replicate an implementation of <code>Vmctx</code> struct and calls from wasmtime in ZisK<br>\nB. Get rid of/change vmctx usage by rewriting <code>wasmtime_environ::Compiler</code> and related structs/traits (<code>FuncEnvironment</code>, <code>Call</code>) - this seems like the right way to go and might even be less work</p>\n<p>For 2, my naive idea was just to take <code>.text</code> section from the ELF, put it at address 0, strip out other executable sections. Then lay out data sections, heap and stack at the expected addresses.</p>\n<h2>Questions</h2>\n<ul>\n<li>Is this path of compiling a WASM module into a standalone executable for custom ISA feasible? reasonable? Are there any alternatives I should consider?</li>\n<li>For the two problems that I've encountered above, do solutions seem plausible? Are there any other problems that I'm missing but will likely run into?</li>\n</ul>\n<p>If this is not the best format for this discussion, please let me know and I'm happy to create a Google Doc/Hackmd/GitHub Issue for this.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/b37ce5483ca5f88093e39486a76c6a2b768cd6a5/68747470733a2f2f6861636b6d642e696f2f696d616765732f6d656469612f4861636b4d442d6f672e6a7067&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w\" title=\"Cranelift for ZK WASM - HackMD\">Cranelift for ZK WASM - HackMD</a></div><div class=\"message_embed_description\">or</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/0xPolygonHermez/zisk/blob/cd11b3dffc972d7b61968d4233f8362e957f60a8/core/src/zisk_ops.rs#L224\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/6f4b14962b8f2a2351b7ca77335d406db189a71c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613131666661663634393661623734316262366665386334323238353334623062313938623032393535386131376437353939626463343363633336613930652f3078506f6c79676f6e4865726d657a2f7a69736b&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/0xPolygonHermez/zisk/blob/cd11b3dffc972d7b61968d4233f8362e957f60a8/core/src/zisk_ops.rs#L224\" title=\"zisk/core/src/zisk_ops.rs at cd11b3dffc972d7b61968d4233f8362e957f60a8 · 0xPolygonHermez/zisk\">zisk/core/src/zisk_ops.rs at cd11b3dffc972d7b61968d4233f8362e957f60a8 · 0xPolygonHermez/zisk</a></div><div class=\"message_embed_description\">Contribute to 0xPolygonHermez/zisk development by creating an account on GitHub.</div></div></div>",
        "id": 484976140,
        "sender_full_name": "Andrew Borg (aborg-dev)",
        "timestamp": 1732821565
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"760890\">@Andrew Borg (aborg-dev)</span> -- very interesting project, and it's clear you've done some homework already. Unfortunately I don't think trying to repurpose the Wasmtime compilation pipeline to create artifacts usable in your own VM is a good long-term strategy.</p>\n<p>As you've noted the generated code is intertwined with our VM data structures, accessing them directly. Not only would you have to write \"another wasmtime\" with exactly compatible data structures, but you'd have to keep it up to date as we evolve our engine -- and we do, without any concerns about backward compatibility, because these are internal implementation details. The code generator and runtime are meant to go together and aren't meant to be consumed separately.</p>\n<p>At some point one might ask: why not adapt Wasmtime itself to suit your needs? (Port it to your custom ISA, or pull out the relevant pieces and adapt them, or ...)</p>\n<p>Regarding your second question about the ELF sections -- honestly I sometimes wish we had used another container format because it's a constant temptation created by the \"just close enough to native\" images we generate to try to consume them like normal ELFs. It is convenient to be able to use <code>objdump</code>, and for <code>gdb</code> to understand them when loaded in-process, but otherwise as above they aren't meant to be consumed by anything but Wasmtime. The other sections you want to strip out are sometimes necessary for actual execution correctness: for example, when using Wasm GC, the metadata includes stackmaps that are needed by the runtime to trace GC refs on the stack; and when a Wasm trap occurs, metadata to indicate what it is; and metadata to describe what memories, tables and other data structures to create at startup (feeding into your first question). For the last one in particular: there is no one <code>vmctx</code> format, it depends on the particular module with a dynamically computed layout based on this metadata.</p>\n<p>Overall I suspect there's a bit of an X-Y problem here: I can't help but wonder why your own VM is needed vs Wasmtime. (Or if it is, the right path is to avoid the shortcut and develop your own code generator for your own VM.) Maybe you could say more there?</p>",
        "id": 484977855,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1732822594
    },
    {
        "content": "<p>Thank you for a detailed answer, <span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> .<br>\nIt overall confirms my feeling that my current approach is straying quite far from the well-supported path and I would very much like to avoid this.</p>\n<p>I agree, there is a X-Y problem here, so let me step back and state my high level goals.</p>\n<p>My primary goal is to efficiently generate Zero-Knowledge proofs for Rust programs. Specifically, Rust programs with a really narrow interface to the outside system: ability read and write bytes from stdin/stdout and a few other simple interactions like access to a source of randomness.<br>\nFor the purpose of this discussion, you can think of ZK proof as a succinct cryptographic commitment (a few hundreds of bytes) that claims that running a given Rust program on a given input results in a given output. The important property is that this commitment can't be falsified - if it can be created, then with a very high probability the Rust program indeed behaved as stated.</p>\n<p>We know how to create these proofs for facts about mathematical objects like high-degree polynomials. But the gap between polynomials and Rust programs is quite large, so we introduce an intermediate step - custom CPU architectures (usually called ZKVMs) like ZisK or <a href=\"https://delendum.xyz/writings/2023-05-10-zkvm-design.html#architecture\">Valida</a> that still can be efficiently \"lowered\" to the polynomial representation but are a better target for compilation of Rust program.</p>\n<p>One notable approach is to use an existing ISA like <a href=\"https://dev.risczero.com/api/zkvm\">RISC-V</a>, which is still simple enough to convert to polynomials but is already a common compilation target. This approach has a lot of nice properties, but we think it leaves a lot of performance (1.5x-5x) on the table because of the <a href=\"https://dev.risczero.com/api/zkvm/optimization#key-differences\">mismatch between cost models</a> in real RISC-V CPUs and the one implemented as ZKVM.<br>\nSo we think we'll be able to get a better performance with a custom ISA called ZisK (although I'm open to revise this thesis).</p>\n<p>To be precise, we ultimately care about performance of proof generation. But it is proportional to <code>c * steps(P)</code>, where <code>steps(P)</code> is a number of instructions executed to run the program <code>P</code>, and the constant <code>c</code> depends on the complexity of ZKVM instruction set (overhead of conversion to polynomials). For simple ISAs like RISC-V the constant will be close to 1.</p>\n<p>Now the question effectively becomes: <strong>How do you build a compiler from Rust to ZisK that optimizes for performance of ZisK programs?</strong></p>\n<p>My thinking process from this point that leads to Cranelift/Wasmtime is:</p>\n<ul>\n<li>Rustc uses LLVM, let's build a ZisK backend for LLVM</li>\n<li>Oh no, LLVM seems like way too much work. Huge C++ codebase, a lot of ceremony</li>\n<li>Cranelift could work for this, very flexible, we are familiar with Rust</li>\n<li>It even has a direct <a href=\"https://github.com/rust-lang/rustc_codegen_cranelift\">Rust compiler</a>!</li>\n<li>Oops, that compiler not optimized for performance as LLVM is. This is a deal breaker</li>\n<li>But maybe we can use LLVM to compile Rust to WASM, retain all <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4712\">performance optimizations</a> and feed that to Cranelift</li>\n<li>Now we just need to compile the resulting WASM module to ZisK...</li>\n</ul>\n<p>I hope this provides the necessary context. I'm not tied to any of technical choices made so far and ready to make as many steps back as necessary in that thinking process and try other avenues.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://delendum.xyz/writings/2023-05-10-zkvm-design.html#architecture\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c359fbd7cd16c9839324b69dbf0cda9f3789d421/68747470733a2f2f64656c656e64756d2e78797a2f&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://delendum.xyz/writings/2023-05-10-zkvm-design.html#architecture\" title=\"Valida zkVM Design\">Valida zkVM Design</a></div><div class=\"message_embed_description\">Valida: a STARK-based VM focused on code reuse, performance, and modularity</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://dev.risczero.com/api/zkvm\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f6aa08f1aa43cf967a7f24bc1c1543eb383f020c/68747470733a2f2f6465762e726973637a65726f2e636f6d2f707265766965772d696d616765732f363934363464633732656634623536613335646463353864343638353634663331333166303430642e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://dev.risczero.com/api/zkvm\" title=\"zkVM Overview | RISC Zero Developer Docs\">zkVM Overview | RISC Zero Developer Docs</a></div><div class=\"message_embed_description\">The RISC Zero zero-knowledge virtual machine [zkVM] (zkVM) lets you [prove]</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://dev.risczero.com/api/zkvm/optimization#key-differences\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/d962c9182d22fc61353608b49297f0cd88c7359e/68747470733a2f2f6465762e726973637a65726f2e636f6d2f707265766965772d696d616765732f626565383538306335616563323231623431356362373135313237333333613138666365356363302e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://dev.risczero.com/api/zkvm/optimization#key-differences\" title=\"Guest Optimization Guide | RISC Zero Developer Docs\">Guest Optimization Guide | RISC Zero Developer Docs</a></div><div class=\"message_embed_description\">RISC Zero's zkVM is designed and built to act like a physical CPU. We did this</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/rust-lang/rustc_codegen_cranelift\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/9f1a263d49b93b90836f0248307049f38a5da561/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633862653534353462363765633466666261666339633335336130356166336631356633613732333535306461353035343163333130363334333533393839342f727573742d6c616e672f72757374635f636f646567656e5f6372616e656c696674&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/rust-lang/rustc_codegen_cranelift\" title=\"GitHub - rust-lang/rustc_codegen_cranelift: Cranelift based backend for rustc\">GitHub - rust-lang/rustc_codegen_cranelift: Cranelift based backend for rustc</a></div><div class=\"message_embed_description\">Cranelift based backend for rustc. Contribute to rust-lang/rustc_codegen_cranelift development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/4712\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/bf7024f0cda75de0412bb45fc57b2fb498f0180a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333937626438623363666532346234626637386566343535383363376630346463636533623265306265323666643038396133393133366536613331356132652f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f34373132&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/4712\" title=\"Census of binaryen/`wasm-opt` passes that might be relevant to Cranelift · Issue #4712 · bytecodealliance/wasmtime\">Census of binaryen/`wasm-opt` passes that might be relevant to Cranelift · Issue #4712 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">What is Cranelift's job (in the context of Wasmtime)? To take Wasm that is produced by LLVM and already optimized 99% of the time and do the architecture-specific code generation that LLVM cannot d...</div></div></div>",
        "id": 485101571,
        "sender_full_name": "Andrew Borg (aborg-dev)",
        "timestamp": 1732887692
    },
    {
        "content": "<p>Very interesting, thanks for the additional detail!</p>\n<p>I suspect that trying to repurpose LLVM+Wasm+Wasmtime's compiler frontend without Wasmtime runtime+Cranelift as an \"easier\" compiler pipeline than plain LLVM might be a bit of a false promise here: what you're finding is that there are impedance mismatches due to taking the program through Wasm form. In particular, all the details that the Wasmtime-compiled code requires of the runtime will basically require you to write a new Wasm runtime, and make that runtime work with respect to your new VM. You didn't set out to build all the Wasm abstractions, you set out to run user Rust code; Wasmtime is engineer-years of work and even mocking a fraction of it will be a significant effort, nevermind the issues with keeping your \"fake Wasmtime\" up to date as mentioned above. Alternately, actually port Wasmtime to run within your zkVM, but that seems like a huge effort as well.</p>\n<p>In summary I'd recommend pursuing a straight port of LLVM -- it's superficially scary yes, but conceptually that approach is way way way simpler than what you're trying to do here. All the best!</p>",
        "id": 485151346,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1732908513
    },
    {
        "content": "<p>Alright, you convinced me to seriously investigate the LLVM direction :)</p>\n<p>To close this off, let me make sure that I understand the main costs of Cranelift-based solution so that I can communicate it properly to my team.</p>\n<p>The main intention of existing Wasmtime/Cranelift compilation pipeline is to generate bytecode that will run inside <code>wasmtime</code> VM.<br>\nFor ZisK project we will need to break that core assumption, as we agree that maintaining compatibility with a moving <code>wasmtime</code> target is a non-starter. </p>\n<p>The three main components that we will need to (re)write and maintain are:</p>\n<ol>\n<li>WASM frontend that generates ZisK-compatible CLIF - ~5k lines of Rust code</li>\n<li>ZisK backend/codegen - ~5k-20k lines of code (Rust + ISLE)</li>\n<li>ZisK assembler/linker - outputs a ZisK binary from a WASM module and ZisK bytecode. Not sure about the size here.</li>\n</ol>\n<p>These components are very unlikely to make it back to upstream due to specialized nature, so we will need to maintain a <code>wasmtime</code> fork and periodically sync it with the upstream.</p>\n<p>Would you say this sums it up? I see that you mentioned building a new WASM runtime, but in my mind it is implicitly generated in steps 1-3?</p>",
        "id": 485906976,
        "sender_full_name": "Andrew Borg (aborg-dev)",
        "timestamp": 1733245807
    },
    {
        "content": "<p>Yes, that's a lower bound on the work I think. My \"new Wasm runtime\" phrase was referring to the missing piece implied by your point 1: when the Wasm module contains a Wasm memory access, or an indirect call through a table, or a funcref, what do you do? These are handled by exactly the parts of the current Wasm-to-CLIF translator that refer to Wasmtime data structures (<code>vmctx</code> and everything reachable from it) that we've talked about above.</p>",
        "id": 485907744,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1733246026
    }
]