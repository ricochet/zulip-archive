[
    {
        "content": "<p>Hi all -- just wanted to leave a note here that (as of yesterday) I made a Motion to Finalize the RFC regarding our instruction-selector DSL. Here is the link: <a href=\"https://github.com/bytecodealliance/rfcs/pull/15\">https://github.com/bytecodealliance/rfcs/pull/15</a>.   <span class=\"user-mention\" data-user-id=\"253990\">@fitzgen (he/him)</span> gave an excellent presentation on the latest progress yesterday as well (<a href=\"https://docs.google.com/presentation/d/1b6psjaIKkVTZGaGzMcw9h_Ahgih-ctUcnz0Dbjn11GI/edit\">link</a>).</p>\n<p>Merging this RFC would mean that we've decided to move forward with defining our instruction-selection backends in Cranelift with the DSL we've been prototyping. The details of the bindings and definitions can of course be tweaked over time, just as for any other part of the codebase.</p>\n<p>So far it has a few approvals but I wanted to make sure folks saw this -- especially if you've participated in conversations so far, and are ok with this direction, please do head over to the RFC and let us know if you give final approval!  Or, if not, let us know if any issues still remain.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"254393\">@Benjamin Bouvier</span> <span class=\"user-mention\" data-user-id=\"300050\">@Anton Kirilov</span> <span class=\"user-mention\" data-user-id=\"421408\">@Sam Parker</span> <span class=\"user-mention\" data-user-id=\"257554\">@Johnnie Birch</span> <span class=\"user-mention\" data-user-id=\"268749\">@Ulrich Weigand</span> especially, who have participated actively in the last several discussions in our meetings -- thanks for the time and patience on this :-)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/rfcs/pull/15\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/dd57cf9c82fa19ccfaecc1c0b39fe1d648ea569a\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623161353437636433646330616539333235613038396561393534643338363430386536643936643031626461346564633038346162333462343530343531352f62797465636f6465616c6c69616e63652f726663732f70756c6c2f3135)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/rfcs/pull/15\" title=\"RFC: design of ISLE instruction-selector DSL. by cfallin · Pull Request #15 · bytecodealliance/rfcs\">RFC: design of ISLE instruction-selector DSL. by cfallin · Pull Request #15 · bytecodealliance/rfcs</a></div><div class=\"message_embed_description\">Rendered\nThis RFC proposes a new DSL for the instruction selectors in Cranelift,\nautomating the generation of the backends based on a list of term-rewriting\nrules provided by the backend author.\nTh...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://docs.google.com/presentation/d/1b6psjaIKkVTZGaGzMcw9h_Ahgih-ctUcnz0Dbjn11GI/edit\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/439d34673d8fb9bc590a5c9a0362644991453b80\\/68747470733a2f2f6c68332e676f6f676c6575736572636f6e74656e742e636f6d2f4f63725a796f4f70454d2d382d4f7779626b45446c3453656e726d6c544e7443454c56394e743449486b534f427570307175725f39546257495a46796561497078775f6e76436b466447694274673d77313230302d683633302d70)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://docs.google.com/presentation/d/1b6psjaIKkVTZGaGzMcw9h_Ahgih-ctUcnz0Dbjn11GI/edit\" title=\"ISLE Update\">ISLE Update</a></div><div class=\"message_embed_description\">ISLE Instruction Selection DSL Update Nick Fitzgerald Cranelift Bi-Weekly 2021-11-01</div></div></div>",
        "id": 260077313,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1635900075
    },
    {
        "content": "<p>Hi! I was absent from the meeting because of a public holiday here. I was a bit curious about the next steps, especially around the approach: does it mean we're going to have the new system checked in in code in wasmtime soon? And then starting to rewrite incrementally lowering so as to use the new system (as opposed as having the new system be developed on the side, and have a one-time switch of the backends to the new systems entirely)? In the latter cases, do we have benchmarks running on a very frequent basis, to make sure that the compile times don't get bad?</p>",
        "id": 260116777,
        "sender_full_name": "Benjamin Bouvier",
        "timestamp": 1635937050
    },
    {
        "content": "<p>Hey Ben -- sorry, didn't realize the date was a conflict for .fr! (FWIW this seems like a totally valid reason to ask for agenda items to move in the future, if important folks can't make it :-) )</p>\n<p>The tl;dr of my answer is (i) gradual, not all-at-once switch, and (ii) yes, we'll benchmark, and avoid any perf regressions. In more detail:</p>\n<ul>\n<li>\n<p>The way that the integration branch works now is that the generated code from the patterns is invoked first, and if it returns <code>None</code>, then the original code is invoked. The idea is that this will allow us to have a lot of little PRs to move over a few instruction lowerings at a time, all the while keeping the thing working; this is less risky than trying to match behavior exactly and switch all at once, especially if the backend is a moving target.</p>\n</li>\n<li>\n<p>Performance <em>should</em> be faster or at parity, by construction (by generating code that is the same as what we write by hand initially, then improving). Actually in the current code we're already doing a few tricks that the handwritten backends do not, like matching directly on the <code>InstructionData</code> rather than opcode first then extracting data separately. In the future we can algorithmically optimize the order of matching and combining of matching effort; @fitzgen had a great idea yesterday for example to do a pass to reorder matches to increase the amount of work shared between rules (<a href=\"https://github.com/cfallin/isle/issues/11\">isle#11</a>). The cool thing about ideas like that is that it's now practical to make such changes across all backend code; it would've been very hard or impossible to \"transpose\" the whole backend or turn it inside out for performance with the handwritten methodology.</p>\n</li>\n<li>\n<p>To be sure of this, we will benchmark compile time when we do the initial PR to bring in the framework and the first few lowering rules, and we will not merge if there is any slowdown until we can fix it. As we move code over, we expect compile time to remain the same or faster, but it would be nice to have benchmarks for this too. I don't know if we want to go to the length of requiring contributors to benchmark manually in every PR -- this seems extreme, when we don't have such a requirement for other changes, and hopefully an initial benchmark plus the argument that the generated code is the same or better is enough -- but I'm curious what you and others say to that.</p>\n</li>\n<li>\n<p>To some degree, \"continuous benchmarking\" is the domain of RFCs #3 and #4, in which we agreed we wanted infrastructure like this; I haven't kept up with the progress on implementing these but I know we at least allocated a CI machine for it earlier in the year. <span class=\"user-mention\" data-user-id=\"257554\">@Johnnie Birch</span> do you have any updates on the continuous benchmarking infrastructure?</p>\n</li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/cfallin/isle/issues/11\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/01b07ffb842e713e7523de0c17e45d0ede778785\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313163613138376432636161363964393766373032306436363462373131323561323236393735373837373931633233346136363731623766633433313035392f6366616c6c696e2f69736c652f6973737565732f3131)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/cfallin/isle/issues/11\" title=\"Sort linearized match ops to maximize trie prefix sharing · Issue #11 · cfallin/isle\">Sort linearized match ops to maximize trie prefix sharing · Issue #11 · cfallin/isle</a></div><div class=\"message_embed_description\">After linearizing rule patterns for a given term, but before we insert those linear match ops into the trie, we should do a custom topological sort of the linear match ops&#39;s data-flow graph tha...</div></div></div>",
        "id": 260155550,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1635955169
    }
]