[
    {
        "content": "<p>Hey all,</p>\n<p>If you've been keeping a close eye on the pull request list, you may have noticed <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6898\">https://github.com/bytecodealliance/wasmtime/pull/6898</a>. This PR was an accident of sorts, but the experiments with the <a href=\"https://wiki.polygon.technology/docs/zkevm/zkASM/introduction/\">zkASM</a> backend did continue making progress since. We've made enough progress that the backend is now able to produce valid code for very basic wasm programs (although the code is pretty MVP quality.)  </p>\n<p>As we're getting closer to dedicating more time to this, I wanted to do a temperature check of sorts. How comfortable you all would be with a backend like this being developed in the upstream repository? Or maybe perhaps there is another, better to develop a target, other than maintaining a fork, that we haven't thought of?</p>\n<p>This target would be unique first and foremost because it is not targeting, and is unlikely to ever target, any particular piece of hardware. Instead, the machine executing the produced code is implemented in software. It is also a pretty unique machine in that unlike regular architectures it does not actually execute machine instructions in the traditional sense; it also does not only produce effects of executing a program, but also generates additional piece of data that allows to prove (more quickly than by executing the program itself) that the effects produced are indeed a result of executing a that program. Hence zero-knowledge in zkASM.</p>\n<p>From top of my head the caveats are that our current prototype:</p>\n<ul>\n<li>Unlike the other targets, outputs is a textual assembly, which is later converted by non-trivial logic to “operations” for the underlying machine.<ul>\n<li>Though I don't see why we couldn't introduce a binary object file representation of the same, if necessary.</li>\n</ul>\n</li>\n<li>The machine isn't completely nailed down quite yet and changes to it are being made quite liberally<ul>\n<li>For instance, the team that's working on zkASM may change the implementation away from using 256 bit registers towards the more usual 64 bit ones;</li>\n<li>On the other hand there's no need to maintain compatibility with previous versions of the “architecture”.</li>\n</ul>\n</li>\n</ul>\n<p>Why do we want to work upstream so relatively soon? Well, there are a couple of things we hope to achieve by doing this: first most of us working on the backend don't really have any working experience with the cranelift internals, so it would be great to have some guidance, and we felt that having the changes to show up as PRs on the upstream repository would hopefully give us an opportunity to ask for insights more easily (although we don't necessarily expect anybody to dedicate their precious time actually responding;) and more importantly because it would make it easier for <em>us</em> to keep up with the relevant changes in cranelift as they occur upstream.</p>\n<p>Any questions? Glad to try to answer or, failing that, get people who know the answers chime in <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/6898\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/d39a96a4259025e6878fc4cc9d1790edfc3de53c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653861633138366538393533396464303934383738636663356166636233393031636538643039343330336133656565646132656134373239373563363336322f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f36383938)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6898\" title=\"zkasm hackaton by nagisa · Pull Request #6898 · bytecodealliance/wasmtime\">zkasm hackaton by nagisa · Pull Request #6898 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">does not build yet</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://wiki.polygon.technology/docs/zkevm/zkASM/introduction/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/f371b31477848a146acc7592023f6d0628cf72bf\\/68747470733a2f2f77696b692e706f6c79676f6e2e746563686e6f6c6f67792f706f6c79676f6e2d6c6f676f2e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://wiki.polygon.technology/docs/zkevm/zkASM/introduction/\" title=\"Introduction to zkASM | Polygon Wiki\">Introduction to zkASM | Polygon Wiki</a></div><div class=\"message_embed_description\">The ideas behind zkASM</div></div></div>",
        "id": 391643702,
        "sender_full_name": "nagisa",
        "timestamp": 1695025846
    },
    {
        "content": "<p>From a project perspective two things that may interest you are:</p>\n<ul>\n<li><a href=\"https://docs.wasmtime.dev/stability-tiers.html#tier-3---not-production-ready\">Documentation on tier 3 requirements in Wasmtime</a> (and by extension Cranelift) - basically the minimum requirements for landing something in-tree</li>\n</ul>",
        "id": 391715195,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1695048051
    },
    {
        "content": "<ul>\n<li>There's weekly Cranelift meetings which might be a good venue to discuss this with other Cranelift maintainers (if necessary beyond Zulip, which of course also works)</li>\n</ul>",
        "id": 391715311,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1695048085
    },
    {
        "content": "<p>ah, and <a href=\"https://github.com/bytecodealliance/meetings/tree/main/cranelift\">meetings link</a></p>",
        "id": 391715374,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1695048104
    },
    {
        "content": "<p>One other thing that would be good to understand (it's a little unclear from the zkASM link you gave): what's the expected use-case?</p>\n<p>For \"exists as silicon in the physical world\" ISAs, this is fairly self-evident, as long as the architecture is still in use: e.g. I don't think there's any question that we'd accept an arm32 backend, or even something a little rarer now like mips32, as long as all the other tier 3 reqs (maintainers, ...) are met. But for more niche virtual ISAs, we'd want to consider the use-cases against the maintenance cost: e.g. are we enabling one very specific user or is this something that could enable a bunch of folks to experiment and make use of Cranelift in new ways.</p>\n<p>Another thing to consider with less-common ISAs is what tooling and documentation exists: for all our ports currently, we can use qemu to test, we can build ELF binaries of Wasmtime for linux/&lt;CPU&gt; and test them, we can debug, there are ISA manuals. It'd be good to understand where all of that stands with zkASM as well</p>",
        "id": 391723540,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1695050441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391723540\">said</a>:</p>\n<blockquote>\n<p>One other thing that would be good to understand (it's a little unclear from the zkASM link you gave): what's the expected use-case?</p>\n</blockquote>\n<p>Great question :)</p>\n<p>At a really high-level, WASM -&gt; zkASM compiler paired with <a href=\"https://wiki.polygon.technology/docs/zkevm/zkProver/zkprover-design/#the-basic-design-approach\">zkASM prover</a> (already exists) would allow generating short proofs that a given WASM program produced a given result and the proof could be cheaply verified by anyone.</p>\n<p>The main use-case is verifiably outsourcing computation - you can ask someone to run an expensive program for you and give you the result together with a proof of a computation. This way you can be sure that they indeed ran your program and not just gave you some random output. This turns out to be useful in many different contexts, to name a few:</p>\n<ul>\n<li>Scaling blockchains (this is the angle that we come from) - blockchain is basically a group of nodes that try to agree the result of same deterministic computation. And currently all the nodes need to re-run the same computation and compare it with results from other nodes. In the model with ZK proofs, it would be enough for a single node to produce a proof and the rest of nodes just need to verify it.</li>\n<li>Verifiable compilation provenance - proving that the result of compiling VIM source code with a given GCC compiler produces a given binary. The user will be able to validate the proof by only having VIM git commit hash and md5 sums of GCC and resulting VIM binary and won't need to repeat the compilation.</li>\n</ul>\n<p>I wrote a more concrete explanation in: <a href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w?view#Background\">https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w?view#Background</a>, let me know if it makes sense!</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://wiki.polygon.technology/docs/zkevm/zkProver/zkprover-design/#the-basic-design-approach\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/f371b31477848a146acc7592023f6d0628cf72bf\\/68747470733a2f2f77696b692e706f6c79676f6e2e746563686e6f6c6f67792f706f6c79676f6e2d6c6f676f2e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://wiki.polygon.technology/docs/zkevm/zkProver/zkprover-design/#the-basic-design-approach\" title=\"zkProver Design Approach | Polygon Wiki\">zkProver Design Approach | Polygon Wiki</a></div><div class=\"message_embed_description\">A brief introduction to the zkProver's State Machine design approach</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w?view#Background\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b37ce5483ca5f88093e39486a76c6a2b768cd6a5\\/68747470733a2f2f6861636b6d642e696f2f696d616765732f6d656469612f4861636b4d442d6f672e6a7067)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://hackmd.io/DK6S9vsbQ9GAmBJEOIwh4w?view#Background\" title=\"Cranelift for ZK WASM - HackMD\">Cranelift for ZK WASM - HackMD</a></div><div class=\"message_embed_description\">or</div></div></div>",
        "id": 391753075,
        "sender_full_name": "Andrei Kashin (akashin)",
        "timestamp": 1695061001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391723540\">said</a>:</p>\n<blockquote>\n<p>Another thing to consider with less-common ISAs is what tooling and documentation exists: for all our ports currently, we can use qemu to test, we can build ELF binaries of Wasmtime for linux/&lt;CPU&gt; and test them, we can debug, there are ISA manuals. It'd be good to understand where all of that stands with zkASM as well</p>\n</blockquote>\n<p>There is already a decent amount of tooling around ZK ASM:</p>\n<ul>\n<li><a href=\"https://github.com/0xPolygonHermez/zkasmcom\">Text Assembly Parser</a></li>\n<li>Simulators and profilers in <a href=\"https://github.com/0xPolygonHermez/zkevm-proverjs\">JS</a> and <a href=\"https://github.com/0xPolygonHermez/zkevm-prover\">C++</a></li>\n<li><a href=\"https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/zkevm-architecture/v.1.1/zkevm-architecture.pdf\">ISA Spec document</a></li>\n</ul>\n<p>We will most likely extend this tooling with Rust implementation/bindings to make testing in Rust-based projects simpler.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/0xPolygonHermez/zkasmcom\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/639e30fac80e12b67e11c7ec3728c5ed665d4201\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356666333238353031366463653862343031376337323037336162626136336637333365393837613365613738666634656362656265333036336638303463362f3078506f6c79676f6e4865726d657a2f7a6b61736d636f6d)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/0xPolygonHermez/zkasmcom\" title=\"GitHub - 0xPolygonHermez/zkasmcom: This repo compiles .zkasm to a json ready for the zkExecutor\">GitHub - 0xPolygonHermez/zkasmcom: This repo compiles .zkasm to a json ready for the zkExecutor</a></div><div class=\"message_embed_description\">This repo compiles .zkasm to a json ready for the zkExecutor - GitHub - 0xPolygonHermez/zkasmcom: This repo compiles .zkasm to a json ready for the zkExecutor</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/0xPolygonHermez/zkevm-proverjs\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/927f42c7e931162394fed332402b7ffbf98b150f\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373630396463643363663835323037386231396462373232663633343564396562663139303966363035653438393462623465343639393563313332366561372f3078506f6c79676f6e4865726d657a2f7a6b65766d2d70726f7665726a73)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/0xPolygonHermez/zkevm-proverjs\" title=\"GitHub - 0xPolygonHermez/zkevm-proverjs: zkEVM proof generator reference written in Javascript\">GitHub - 0xPolygonHermez/zkevm-proverjs: zkEVM proof generator reference written in Javascript</a></div><div class=\"message_embed_description\">zkEVM proof generator reference written in Javascript - GitHub - 0xPolygonHermez/zkevm-proverjs: zkEVM proof generator reference written in Javascript</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/0xPolygonHermez/zkevm-prover\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/31b6b05ffa417d03c58f9443cbba51c79eb1286f\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653030613139666231386637636266646463643334376330353933313431336233643463383834616565613539623063313032306538663333663963616138662f3078506f6c79676f6e4865726d657a2f7a6b65766d2d70726f766572)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/0xPolygonHermez/zkevm-prover\" title=\"GitHub - 0xPolygonHermez/zkevm-prover: zkEVM prover in C++\">GitHub - 0xPolygonHermez/zkevm-prover: zkEVM prover in C++</a></div><div class=\"message_embed_description\">zkEVM prover in C++. Contribute to 0xPolygonHermez/zkevm-prover development by creating an account on GitHub.</div></div></div>",
        "id": 391859055,
        "sender_full_name": "Andrei Kashin (akashin)",
        "timestamp": 1695112446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391715311\">said</a>:</p>\n<blockquote>\n<ul>\n<li>There's weekly Cranelift meetings which might be a good venue to discuss this with other Cranelift maintainers (if necessary beyond Zulip, which of course also works)</li>\n</ul>\n</blockquote>\n<p>Will you be open for us to give a quick (10-15 min) presentation to provide more context on one these meetings (e.g. September 27th) ?</p>",
        "id": 391859778,
        "sender_full_name": "Andrei Kashin (akashin)",
        "timestamp": 1695112655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"651183\">Andrei Kashin (akashin)</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391859778\">said</a>:</p>\n<blockquote>\n<p>Will you be open for us to give a quick (10-15 min) presentation to provide more context on one these meetings (e.g. September 27th) ?</p>\n</blockquote>\n<p>You're always welcome to add agenda items -- please feel free to submit a PR to the <code>bytecodealliance/meetings</code> repo to add an item under <code>cranelift/2023/</code> in the file for whichever date you prefer.</p>",
        "id": 391953704,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1695141734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391953704\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"651183\">Andrei Kashin (akashin)</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391859778\">said</a>:</p>\n<blockquote>\n<p>Will you be open for us to give a quick (10-15 min) presentation to provide more context on one these meetings (e.g. September 27th) ?</p>\n</blockquote>\n<p>You're always welcome to add agenda items -- please feel free to submit a PR to the <code>bytecodealliance/meetings</code> repo to add an item under <code>cranelift/2023/</code> in the file for whichever date you prefer.</p>\n</blockquote>\n<p>I see! Sent <a href=\"https://github.com/bytecodealliance/meetings/pull/161\">https://github.com/bytecodealliance/meetings/pull/161</a>, let me know if you need any more details there.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/meetings/pull/161\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/9d846fdd6e43c3bbb67b00dc0591353455542507\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616432313737343866376239346665326562386536303131356263646432326561616363643532623163336531626666613330613866643032353062323437362f62797465636f6465616c6c69616e63652f6d656574696e67732f70756c6c2f313631)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/meetings/pull/161\" title=\"Add zkASM to agenda for September 27 by akashin · Pull Request #161 · bytecodealliance/meetings\">Add zkASM to agenda for September 27 by akashin · Pull Request #161 · bytecodealliance/meetings</a></div><div class=\"message_embed_description\">Let me know if I need to provide a more detailed agenda!</div></div></div>",
        "id": 392075457,
        "sender_full_name": "Andrei Kashin (akashin)",
        "timestamp": 1695201525
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"651183\">@Andrei Kashin (akashin)</span> , excuse me if my question is off topic but what prover are you using? </p>\n<p>Really nice initiative btw.</p>",
        "id": 392093653,
        "sender_full_name": "Juan Bono",
        "timestamp": 1695207995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"651183\">Andrei Kashin (akashin)</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/391753075\">said</a>:</p>\n<blockquote>\n<p>At a really high-level, WASM -&gt; zkASM compiler paired with <a href=\"https://wiki.polygon.technology/docs/zkevm/zkProver/zkprover-design/#the-basic-design-approach\">zkASM prover</a> (already exists) would allow generating short proofs that a given WASM program produced a given result and the proof could be cheaply verified by anyone.</p>\n</blockquote>\n<p>I think there might be some hidden assumptions here that are going to affect how well you can prove that a compiled Wasm program is computing anything. I want to help uncover them and make a bunch of stuff explicit so that we are all on the same page and you understand what you're asking and what you're getting into.</p>\n<p>The biggest thing to note is that cranelift doesn't compile Wasm in isolation:</p>\n<ul>\n<li>you can't just take cranelift off the shelf to compile Wasm and get a runnable wasm binary.</li>\n<li>cranelift doesn't even know anything about Wasm, it just compiles its own intermediate representation called CLIF.</li>\n<li>you can use the <code>cranelift-wasm</code> crate to translate Wasm to CLIF. but CLIF by itself can't implement Wasm's semantics. Wasm translated to CLIF needs access to the external world to, for example, load and store to the native memory regions that implement the Wasm linear memories. How to get those regions and where they are placed in the native address space is something you have to configure in <code>cranelift-wasm</code> and is <em>very</em> specific to the runtime you're using.</li>\n<li>that's because <strong>you need to pair a Wasm runtime with Cranelift to actually compile and run Wasm</strong>, for us that runtime is Wasmtime</li>\n<li>Wasmtime doesn't even implement all of these interface-with-the-outside-world bits in inline CLIF itself, a lot of that stuff is in libcalls. for example the <code>memory.grow</code> instruction is implemented in Rust code as a libcall that the compiled Wasm calls out to</li>\n<li>so the compiled code is going to have <strong>a bunch of stuff that you'd need to just accept as axioms in your proofs</strong>, like function calls out to the runtime/host. the compiled wasm binary is not \"pure\" or standalone. I don't know if that is a deal breaker or not, or if it is even possible to have host calls in zkasm</li>\n<li>but this also implies that <strong>all of Wasmtime needs to be available in zkasm</strong> since the compiled code relies on calling directly to Wasmtime's runtime functionality. getting all of Wasmtime compiled to zkasm on top of the new cranelift backend is going to be a very large amount of work. and I suspect that zkasm will be missing things that Wasmtime assumes and requires, like the ability to map new pages executable. and we would need to analyze the effect that being able to compile all of Wasmtime to zkasm, if it is even possible, would have on Wasmtime's maintainability and look at the balance of the costs and benefits.</li>\n<li>in theory you could create a runtime that can run Wasm inside some virtual cpu while leaving the runtime in native. that isn't Wasmtime; Wasmtime is not architected to do that.</li>\n</ul>\n<p>I know I am coming across somewhat pessimistic, but I really want folks to understand that this isn't a thing where one could \"just\" add a new zkasm Cranelift backend to get provable Wasm computations. There is a lot more involved here.</p>",
        "id": 392154720,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1695227533
    },
    {
        "content": "<p>Thank you for taking the time to bring these concerns to our attention!</p>\n<blockquote>\n<p>this also implies that all of Wasmtime needs to be available in zkasm since the compiled code relies on calling directly to Wasmtime's runtime functionality.</p>\n</blockquote>\n<p>As a background, we both come from a team that's been working on a (fork of a) WASM runtime, so we do have the potential complications in the areas you've raised on our mind as well. </p>\n<p>zkasm, specifically, does have ways to call out to external code for complicated behaviours and mechanisms to write down proofs for those call outs. As far as I am aware, even more complicated operations that are traditionally regular instructions, such as multiplication and division, are expected to be implemented using this mechanism at this moment in time (although this might change in the future, thus basically shifting the burden of proof to a different place.)</p>",
        "id": 392263776,
        "sender_full_name": "nagisa",
        "timestamp": 1695281474
    },
    {
        "content": "<p>I guess the major thing that remains to be seen is how to best approach providing/linking in proofs for not only the libcalls but also the user provided imports/exports. For our immediate use-case that wasn't a big deal since our interface is locked-in, while for something general purpose like wasmtime proper there would need to be a generic solution that anybody can use. And I have no idea how to best approach this at this moment in time!</p>",
        "id": 392269906,
        "sender_full_name": "nagisa",
        "timestamp": 1695283898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577281\">Juan Bono</span> <a href=\"#narrow/stream/217117-cranelift/topic/zkASM.20backend/near/392093653\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"651183\">Andrei Kashin (akashin)</span> , excuse me if my question is off topic but what prover are you using? </p>\n<p>Really nice initiative btw.</p>\n</blockquote>\n<p>Thank you :)<br>\nWe will be using <a href=\"https://wiki.polygon.technology/docs/zkevm/PIL/introduction/\">PIL (Polynomial Identity Langugage)</a> to describe constraints and generate STARKs and <a href=\"https://github.com/mir-protocol/plonky2\">Plonky2</a> as a proving system (based on FRI).<br>\nI think we'll try to stay reasonably flexible on this front as new proving systems appear at a fast pace, but for the first version, we'll focus on this proving stack.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://wiki.polygon.technology/docs/zkevm/PIL/introduction/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/f371b31477848a146acc7592023f6d0628cf72bf\\/68747470733a2f2f77696b692e706f6c79676f6e2e746563686e6f6c6f67792f706f6c79676f6e2d6c6f676f2e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://wiki.polygon.technology/docs/zkevm/PIL/introduction/\" title=\"Polynomial Identity Language | Polygon Wiki\">Polynomial Identity Language | Polygon Wiki</a></div><div class=\"message_embed_description\">Polynomial Identity Language (PIL) is a domain-specific language (DSL) created to provide developers with a holistic framework for constructing programs through an easy-to-use interface, and abstracting the complexity of proof/verification mechanisms.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/mir-protocol/plonky2\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/49a5e28bc3865731ec42cf4ab6afecad01a9e6a8\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616136643136333332626462323236383331353363643433666338336138323439666135386530306636626162376334366536636231356533306461353132322f6d69722d70726f746f636f6c2f706c6f6e6b7932)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/mir-protocol/plonky2\" title=\"GitHub - mir-protocol/plonky2\">GitHub - mir-protocol/plonky2</a></div><div class=\"message_embed_description\">Contribute to mir-protocol/plonky2 development by creating an account on GitHub.</div></div></div>",
        "id": 392351549,
        "sender_full_name": "Andrei Kashin (akashin)",
        "timestamp": 1695311922
    },
    {
        "content": "<p>So my summary takeaway is:</p>\n<ol>\n<li>We will probably continue working in a fork for the time being, but will seriously explore having this backend as a separate crate as it matures;</li>\n<li>It is in clift’s interest to have the infrastructure (and, I guess, documentation) necessary for first-class backends of such sort (and we should start by creating an issue for this – I'll make a note to start one tomorrow;)</li>\n<li>If we were to come in with a PR upstream, we would still need a good plan on how to handle things like imported wasm memory and functions like <code>memory.grow</code> and make sure it works well and is generally applicable.</li>\n</ol>",
        "id": 393565401,
        "sender_full_name": "nagisa",
        "timestamp": 1695846251
    },
    {
        "content": "<p>Filed the issue at <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7124\">https://github.com/bytecodealliance/wasmtime/issues/7124</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/7124\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/2b84ceda7f1fd8901ca6bf707355de60f430d163\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373536313162613238366635356265313361323862623666303338636430613061323335376339316139636361646337633133386537393466646637373265332f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f37313234)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/7124\" title=\"Externally maintained cranelift backends · Issue #7124 · bytecodealliance/wasmtime\">Externally maintained cranelift backends · Issue #7124 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Feature Today cranelift has a number of backends for traditional computer architectures: x86, aarch64, riscv64 and some others as well. It would be great if we could have many more, however adding ...</div></div></div>",
        "id": 394370699,
        "sender_full_name": "nagisa",
        "timestamp": 1696238047
    },
    {
        "content": "<p>If this is possible to verify an expected computation, why does it need to be a different isa?</p>\n<p>The more I think about the whole purpose of the project, the more I think it just isn't possible. In order to verify a cryptic hash function its input and output, you must run the hash function. Otherwise, it wasn't a very good hash function. If its just using the public key to verify the digest, that operation is cheap.</p>\n<p>Moreover, the zkasm is specific to things related to cryptography, not a real isa.</p>",
        "id": 395569984,
        "sender_full_name": "Chris Clark",
        "timestamp": 1696793033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"619350\">@Chris Clark</span> the \"not a real [I might say 'physical'] ISA\" bit is the main reason we prefer not to upstream it at the moment, since it's so different from other ISAs with a full OS stack, ABI, linkers and debuggers, and the like. In that sense I'd agree.</p>\n<p>However I would also note and defend the idea a bit that zero-knowledge proofs are a pretty deep research area, and there's something novel and useful there. (It's pretty counterintuitive -- it really is \"zero knowledge\", i.e. you don't know the input, but it's probabilistic.) Not to pass any judgment on whether or how it fits into Cranelift but I want to make sure we are fair to the idea and those who work hard on it :-)</p>",
        "id": 395570338,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1696793354
    },
    {
        "content": "<p>My apologies. Countering my statement of it \"just isn't possible\", is probably that entire area of research. I will leave that up to the experts, and meant no ill-will.</p>",
        "id": 395573488,
        "sender_full_name": "Chris Clark",
        "timestamp": 1696796389
    },
    {
        "content": "<p>To answer \"why does it need to be a different ISA\" is probably quite multifaceted. To motivate \"why ISA at all\" first: Zero Knowledge proofs use some pretty complicated math behind the scenes I am not really able to fully grok despite my involvement in a relevant project. The way I view zkASM is that should be considered largely as a mechanism to simplify expressing the computations to prove in a way that’s more familiar to the broader groups (such as that of Software Engineers). One major benefit, just like with many simplifying abstractions, is that it is now possible to verify that the conversion is correct once and that makes it scalable for the experts in the field to pool their attention to verifying just those few equations. “Why a different ISA” then? I don’t see why we couldn’t be converting x64 or  RISC-V down to those complicated math expressions. It is just that making a new one doesn’t cost very much and gives the ones working on the machine some additional flexibility to adapt it to what the underlying maths can express.</p>\n<p>Overall I think zkASM is quite similar to all of the traditional [hardware/physical] ISAs, from the perspective of motivation, benefits and tradeoffs.</p>\n<p>On the point of it being specific to cryptography – zkASM is still a project in heavy development and it’s direction up to this point was indeed driven largely by crypto field needs. We don’t think there’s a huge reason it wouldn’t be possible to make it more generally applicable than it currently is, and is one of the things that is being worked on right now. In principle the machine is already a linear bounded automaton complete, although lack of some operations can make it quite painful to use in certain contexts.</p>\n<p>On the point of hash function computations: I unfortunately am enabled to be ignorant enough of the underlying research to be able to counter this observation. I do know that (some?) hash functions are quite compatible and comparatively easy to integrate into broader zk-proved computations, and that it isn’t necessary to recompute the hash to prove it. I do _suspect_ that it may weaken some probablistic guarantees of the hash functions, but I never thought about this hard enough to actually ask the people in-the-know to verify this. That’s pretty much all I can say about it <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> </p>\n<p>Maybe Andrei will be able to add more to my response when they’re back in ~month.</p>",
        "id": 395702312,
        "sender_full_name": "nagisa",
        "timestamp": 1696858930
    },
    {
        "content": "<p>This sounds quite interesting, personally. Although I do not possess the skills to do this by myself</p>",
        "id": 406526899,
        "sender_full_name": "ghostway",
        "timestamp": 1701950113
    },
    {
        "content": "<p>I'm working on zkasm backend and have a question about cranelift filetests.  Prerequisite: we don't change many parts of cranelift, we only add new isa and write code to lower clif -&gt; zkasm.</p>\n<p>Currently, for testing, in general we use next approach -- we generate some runnable wasm files from wasm spectest, and have rust <code>#[test]</code> function which compiles them. Than, we run generated zkasm by separate script. It was an idea to move our wasm files from separate folder to cranelift filetests. Any thoughts about it, is it worth to do?</p>",
        "id": 416003011,
        "sender_full_name": "Viktar Makouski",
        "timestamp": 1705489411
    }
]