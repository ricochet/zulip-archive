[
    {
        "content": "<p>Hi,</p>\n<p>I'm wondering if there are any updates on this - <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2023.md#cranelift-porting-how-to-write-a-backend\">https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2023.md#cranelift-porting-how-to-write-a-backend</a>.</p>\n<p><strong>Context:</strong> I am new to compiler engineering (i.e., I've never worked on compiler development before but have some experience with Rust). I looked at the Cranelift repository and feel a bit lost. I'm trying to understand how we go from a given <code>.clif</code> file (assuming it's a single function) to actual machine code. So far, my understanding is as follows:</p>\n<ul>\n<li>Given a CLIF file, we go through the following phases:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>CLIF --&gt; ISLE-based Lowering to arch-specific VCode --&gt; Legalization --&gt; Some e-graph-based mid-end optimizations --&gt; Register allocation via regalloc2 --&gt; Final lowering to VCode --&gt; Emitting machine instructions\n</code></pre></div>\n<p><strong>Additional questions:</strong></p>\n<ul>\n<li>Is my understanding correct?</li>\n<li>Are there any gotchas to note if I want to breakpoint-debug a simple Cranelift run with a simple <code>.clif</code> file as its input and work through its program execution?</li>\n<li>Is it possible to add support for backends other than the usual microprocessor ISAs, such as ARM's Thumb-2 ISA (used in various MCU families), or is this not a target for <code>wasmtime</code>?</li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2023.md#cranelift-porting-how-to-write-a-backend\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/fa8d53fe568e48d7edab236623fcaa559e6f6ad4/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333139326561383535613037636435646536376339353566303461333961306630343837623136393636336663663165666531623335313064623532616166342f62797465636f6465616c6c69616e63652f72666373&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/cranelift-roadmap-2023.md#cranelift-porting-how-to-write-a-backend\" title=\"rfcs/accepted/cranelift-roadmap-2023.md at main · bytecodealliance/rfcs\">rfcs/accepted/cranelift-roadmap-2023.md at main · bytecodealliance/rfcs</a></div><div class=\"message_embed_description\">RFC process for Bytecode Alliance projects. Contribute to bytecodealliance/rfcs development by creating an account on GitHub.</div></div></div>",
        "id": 443726291,
        "sender_full_name": "Nihal Pasham",
        "timestamp": 1718012490
    },
    {
        "content": "<p>There is first optimizations on clif ir which includes the e-graph based optimizations and somewhere in the middle of the optimization pipeline legalizations are performed. Then lowering to arch-specific VCode which does some peep-hole optimizations at the same time, then regalloc and finally emitting machine code.</p>",
        "id": 443784664,
        "sender_full_name": "bjorn3",
        "timestamp": 1718029906
    },
    {
        "content": "<p>hi <span class=\"user-mention\" data-user-id=\"726787\">@Nihal Pasham</span> -- the pipeline you wrote out is a bit out of order; it goes something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">CLIF</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">legalization</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">mid</span><span class=\"o\">-</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">egraph</span><span class=\"w\"> </span><span class=\"n\">rewrites</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">enabled</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">rules</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">ISLE</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">lowering</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">backend</span><span class=\"o\">-</span><span class=\"n\">specific</span><span class=\"w\"> </span><span class=\"n\">VCode</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">rules</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">ISLE</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">regalloc</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">binary</span><span class=\"w\"> </span><span class=\"n\">emission</span>\n</code></pre></div>\n<p>in general we should have better docs, though the module-level doc comments for certain pieces try to be fairly helpful at the low-to-mid level; I'd encourage reading through the code in <code>machinst/</code> (and <code>context.rs</code> in the cranelift-codegen toplevel is where the compiler driver is, so you can trace from there too).</p>\n<p>The specific \"how to write a backend\" tutorial idea you link to unfortunately never happened because, well, there's always too much to do; your best bet at this point would be reading through the other backends probably (I'm partial to aarch64 as maybe the cleanest at the moment?).</p>\n<p>Finally, there's no reason Cranelift couldn't target Thumb-2 or any other ISA like that as long as it's not too \"unusual\": machine code with registers and jumps between instructions, etc. (For an example of a little too unusual, we've talked about targeting GPUs before, and there the differences in regalloc and the control flow handling will take some thought; but Thumb-2 is \"just\" another CPU ISA in comparison)</p>",
        "id": 443802550,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1718034428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"264278\">@bjorn3</span> and <span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span>  - thank you. </p>\n<ul>\n<li>Could you elaborate on the kinds of optimizations or rewrites that the <code>mid-end egraph rewrites</code> cover when enabled (using rules in ISLE)? Specifically, does it include common optimizations such as Global Value Numbering (GVN), Loop Invariant Code Motion (LICM), and Dead Code Elimination (DCE), or does it encompass a more exhaustive list of optimizations?</li>\n</ul>\n<blockquote>\n<p>For an example of a little too unusual, we've talked about targeting GPUs before, and there the differences in regalloc and the control flow handling will take some thought</p>\n</blockquote>\n<ul>\n<li>Got it. Does the same apply to more specialized hardware such as TPUs, NPUs, and DSPs, which come with specialized instruction sets designed specifically for neural network (tensor) operations or signal processing? Would these architectures be more or less amenable to Cranelift's current design?</li>\n</ul>",
        "id": 443952197,
        "sender_full_name": "Nihal Pasham",
        "timestamp": 1718096764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726787\">Nihal Pasham</span> <a href=\"#narrow/stream/217117-cranelift/topic/Cranelift.20architecture.20overview.20-.20documentation/near/443952197\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Could you elaborate on the kinds of optimizations or rewrites that the <code>mid-end egraph rewrites</code> cover when enabled (using rules in ISLE)? Specifically, does it include common optimizations such as Global Value Numbering (GVN), Loop Invariant Code Motion (LICM), and Dead Code Elimination (DCE), or does it encompass a more exhaustive list of optimizations?</li>\n</ul>\n</blockquote>\n<p>Yes, it implements LICM, DCE, GVN, as well as an alias analysis that feeds into redundant-load elimination, and finally (probably most importantly) it runs a bunch of rewrite rules in cranelift/codegen/src/opts/, including constant propagation/constant folding as well as a lot of algebraic identities.</p>\n<p>You can find more detail on how the mid-end works in a talk I gave last year (<a href=\"https://vimeo.com/843540328\">video</a>, <a href=\"https://cfallin.org/pubs/egraphs2023_aegraphs_slides.pdf\">slides</a>), though we should probably write a paper or something eventually to describe all the inner workings. And again we try to leave reasonable comments that you can read (in this case in <code>egraph.rs</code> and <code>egraph/elaborate.rs</code>).</p>\n<blockquote>\n<p>Got it. Does the same apply to more specialized hardware such as TPUs, NPUs, and DSPs, which come with specialized instruction sets designed specifically for neural network (tensor) operations or signal processing? Would these architectures be more or less amenable to Cranelift's current design?</p>\n</blockquote>\n<p>DSPs are probably not too bad -- they're \"normal\" except for the VLIW instruction scheduling that most require, which we could handle in a single pass during instruction emission in the worst case -- but TPUs/NPUs are not really general-purpose processors (more like matrix-multiplication accelerators) and so are not suitable for running the general-purpose code that Cranelift compiles.</p>\n<div class=\"embed-video message_inline_image\"><a data-id=\"&lt;iframe src=&quot;https://player.vimeo.com/video/843540328?app_id=122963&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; fullscreen; picture-in-picture; clipboard-write&quot; title=&quot;ægraphs: Acyclic E-graphs for Efficient Optimization in a Production Compiler&quot;&gt;&lt;/iframe&gt;\" href=\"https://vimeo.com/843540328\" title=\"ægraphs: Acyclic E-graphs for Efficient Optimization in a Production Compiler\"><img src=\"https://uploads.zulipusercontent.net/c41bda9d961fc489576190a868fd535ae9cb2884/68747470733a2f2f692e76696d656f63646e2e636f6d2f766964656f2f313639353233393433382d353434653235313863303639373336623264343834636237363262643931653535313733653961313663646437656531643165663637366430343133656165302d645f363430\"></a></div>",
        "id": 444032757,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1718119925
    },
    {
        "content": "<p>AMD's AIE NPU looks much more like a CPU with SIMD to me, it is VLIW with scalar and vector units, afaict it is turing complete (within the memory limits of course): <a href=\"https://docs.amd.com/r/en-US/am020-versal-aie-ml/AIE-ML-Architecture\">https://docs.amd.com/r/en-US/am020-versal-aie-ml/AIE-ML-Architecture</a></p>",
        "id": 444144552,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1718166262
    },
    {
        "content": "<p>so cranelift could probably target it, but you'd want to vectorize most of your code before feeding it in, or you'd end up with a small fraction of the performance due to just using scalar instructions.</p>",
        "id": 444144650,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1718166311
    },
    {
        "content": "<p>VLIW means that the compiler has to do instruction scheduling, which Cranelift doesn't currently do.</p>",
        "id": 444163639,
        "sender_full_name": "bjorn3",
        "timestamp": 1718176451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/Cranelift.20architecture.20overview.20-.20documentation/near/444032757\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"726787\">Nihal Pasham</span> <a href=\"#narrow/stream/217117-cranelift/topic/Cranelift.20architecture.20overview.20-.20documentation/near/443952197\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Could you elaborate on the kinds of optimizations or rewrites that the <code>mid-end egraph rewrites</code> cover when enabled (using rules in ISLE)? Specifically, does it include common optimizations such as Global Value Numbering (GVN), Loop Invariant Code Motion (LICM), and Dead Code Elimination (DCE), or does it encompass a more exhaustive list of optimizations?</li>\n</ul>\n</blockquote>\n<p>Yes, it implements LICM, DCE, GVN, as well as an alias analysis that feeds into redundant-load elimination, and finally (probably most importantly) it runs a bunch of rewrite rules in cranelift/codegen/src/opts/, including constant propagation/constant folding as well as a lot of algebraic identities.<br>\n</p>\n</blockquote>\n<p>I’m probably wrong but don’t DCE and GVN (or equivalents) actually come ‘free’ with the transform to aegraph?</p>",
        "id": 444327359,
        "sender_full_name": "Kirp",
        "timestamp": 1718224511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/Cranelift.20architecture.20overview.20-.20documentation/near/444032757\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"726787\">Nihal Pasham</span> <a href=\"#narrow/stream/217117-cranelift/topic/Cranelift.20architecture.20overview.20-.20documentation/near/443952197\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Could you elaborate on the kinds of optimizations or rewrites that the <code>mid-end egraph rewrites</code> cover when enabled (using rules in ISLE)? Specifically, does it include common optimizations such as Global Value Numbering (GVN), Loop Invariant Code Motion (LICM), and Dead Code Elimination (DCE), or does it encompass a more exhaustive list of optimizations?</li>\n</ul>\n</blockquote>\n<p>Yes, it implements LICM, DCE, GVN, as well as an alias analysis that feeds into redundant-load elimination, and finally (probably most importantly) it runs a bunch of rewrite rules in cranelift/codegen/src/opts/, including constant propagation/constant folding as well as a lot of algebraic identities.<br>\n</p>\n</blockquote>\n<p>I’m probably wrong but don’t DCE and GVN (or equivalents) actually come ‘free’ with the transform to aegraph?</p>",
        "id": 444327365,
        "sender_full_name": "Kirp",
        "timestamp": 1718224514
    },
    {
        "content": "<p>Yes, exactly, hence the mid-end implements them :-)</p>",
        "id": 444335230,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1718227670
    },
    {
        "content": "<p>(LICM falls out of the way we do code placement during aegraph-&gt;CFG elaboration too, it requires intentional choices but it is also not a separate pass)</p>",
        "id": 444335338,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1718227710
    }
]