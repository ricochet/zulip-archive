[
    {
        "content": "<p>Was reading this re rustc stackoverflow and the culprit was the size of <a href=\"http://isle_opts.rs\">isle_opts.rs</a> <a href=\"https://sunshowers.io/posts/rustc-segfault-illumos/\">https://sunshowers.io/posts/rustc-segfault-illumos/</a> - coincidentally was also talking earlier about the size of the rust code being generated by islec resulting in slow compiles - wonder if there is any feasible solution to split or shrink the code?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://sunshowers.io/posts/rustc-segfault-illumos/\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/975796475157e910c814458abce9362a54820ae4/68747470733a2f2f73756e73686f776572732e696f2f696d616765732f66617669636f6e2e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://sunshowers.io/posts/rustc-segfault-illumos/\" title=\"Debugging a rustc segfault on illumos :: sunshowers\">Debugging a rustc segfault on illumos :: sunshowers</a></div><div class=\"message_embed_description\">Using `mdb` and `pmap` to find the cause of a crash.</div></div></div>",
        "id": 456724196,
        "sender_full_name": "Kirp",
        "timestamp": 1722899054
    },
    {
        "content": "<p>Well, the ultimate culprit is the uncontrolled recursion in rustc's parser -- we are generating valid Rust, albeit one large function but the language does not specify limits on function size in the semantics so I believe the proper fix is where that post landed, i.e. fixing rustc</p>",
        "id": 456727932,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1722901087
    },
    {
        "content": "<p>even moreso given that rustc's parser <em>is</em> making efforts to not overflow the stack, but failed on illumos due to some missing plumbing; that shows the implementation intent</p>",
        "id": 456728063,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1722901156
    },
    {
        "content": "<p>The code is generated from our set of rewrite rules; fundamentally it all has to be there as long as we have those rules; it's always possible that there are constant-factor improvements in the code we generate, but it's pretty lean already (there are just a lot of cases). \"Slow builds\" is a little relative IMHO -- we're embodying a large collection of domain-specific logic. For comparison, how long does an LLVM backend take to build, etc... (the problem would be more urgent if we were seeing slowdowns <em>relative to another compiler of the same complexity</em> IMHO)</p>",
        "id": 456728339,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1722901273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/isle_opt.2Ers.20size/near/456728063\">said</a>:</p>\n<blockquote>\n<p>even moreso given that rustc's parser <em>is</em> making efforts to not overflow the stack, but failed on illumos due to some missing plumbing; that shows the implementation intent</p>\n</blockquote>\n<p>It is actually missing a place where stacker is used to extend the stack. The reason it crashed on Illumos is not because it didn't extend the stack, but because stacker extended the stack with a small segment when not strictly needed. Rustc runs on a 4MiB(?) stack by default, which masked the missing stacker call, but then on Illumos the first stacker call that would consider enough stack remaining on other OSes would switch to a new stack segment which is much smaller. (128KiB?) If enough stacker calls existed, this would be fine, but as a stacker call somewhere in the parser was missed, it would run out of this 128KiB stack segment and crash.</p>",
        "id": 456790149,
        "sender_full_name": "bjorn3",
        "timestamp": 1722930478
    },
    {
        "content": "<p>Is it possible for ISLE to subdivide large functions into multiple functions. LLVM is much slower at compiling a single huge function than many smaller ones anyway, so it should help with making Cranelift itself be built faster too.</p>",
        "id": 456790412,
        "sender_full_name": "bjorn3",
        "timestamp": 1722930569
    },
    {
        "content": "<blockquote>\n<p>Is it possible for ISLE to subdivide large functions into multiple functions</p>\n</blockquote>\n<p>WIth more analysis, yeah, that's theoretically possible; we'd need to analyze for captures to create the arguments. The trickier part is that we'd need to ensure the control flow remained identical: we generate tree-shaped matching code but with fallthroughs so we'd need to get the backtracking right</p>",
        "id": 456887168,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1722958403
    }
]