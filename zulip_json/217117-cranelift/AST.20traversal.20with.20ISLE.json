[
    {
        "content": "<p>I'm currently playing around with ISLE to check whether (and how) to use it for an AST-&gt;VmInstruction lowering, but all the examples I can find operate on an IR that does not seem to be deeply nested.</p>\n<p>From my limited examples, ISLE only transforms the root node / value, e.g. given</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nc\">Ast</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">enum</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">src1</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">src2</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"p\">))</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">Reg</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"n\">Reg</span><span class=\"p\">))</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span>\n<span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"n\">get_node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"n\">extractor</span><span class=\"w\"> </span><span class=\"n\">get_node</span><span class=\"w\"> </span><span class=\"n\">get_node</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">Ast</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"w\"> </span><span class=\"n\">get_node</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">Ast</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">.</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">.</span><span class=\"n\">Reg</span><span class=\"w\"> </span><span class=\"n\">src1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">.</span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)))</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">Ast</span><span class=\"p\">.</span><span class=\"n\">Reg</span><span class=\"w\"> </span><span class=\"n\">src1</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<p>A tree of form <code>Add(Add(reg1, 1), Add(reg2, 0))</code> will not be reduced/simplified. I'm not sure whether this is due to the flattened nature of the AST (replacing recursive children with indices, and an extractor to turn Index-&gt;Ast), or maybe I'm misunderstanding the the usage of ISLE in general. Do I need to provide an external driver/traversal function, or is ISLE able to do a recursive traversal by itself with the correct definitions?</p>",
        "id": 483062914,
        "sender_full_name": "Leon von Mulert",
        "timestamp": 1731946197
    },
    {
        "content": "<p>In general the ISLE user provides the traversal logic. The key to understanding ISLE is seeing that it isn't really a tree-rewriting system at all -- it's a DSL for generating matchers. If you define extractors for your AST nodes and use them on the left-hand side, you can match arbitrarily deep; but one top-level invocation of ISLE will only match one top-level rule and execute its right-hand side (whatever that does -- perhaps build more nodes).</p>\n<p>For two examples of ISLE \"embeddings\" (envrionments in which it is invoked), take a look at Cranelift's mid-end and backend -- the mid-end <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/egraph.rs\">egraph infra</a> and the backend (with helpers <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/machinst/isle.rs\">here</a>)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/egraph.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/ef318078f10506717025473f6f82ece856716a9c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616438613130346362393136326136653434616666633465623664636435343562633563366536336335326133313335396235376134636664316238316636382f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/egraph.rs\" title=\"wasmtime/cranelift/codegen/src/egraph.rs at main 路 bytecodealliance/wasmtime\">wasmtime/cranelift/codegen/src/egraph.rs at main 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A fast and secure runtime for WebAssembly. Contribute to bytecodealliance/wasmtime development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/machinst/isle.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/ef318078f10506717025473f6f82ece856716a9c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616438613130346362393136326136653434616666633465623664636435343562633563366536336335326133313335396235376134636664316238316636382f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/machinst/isle.rs\" title=\"wasmtime/cranelift/codegen/src/machinst/isle.rs at main 路 bytecodealliance/wasmtime\">wasmtime/cranelift/codegen/src/machinst/isle.rs at main 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A fast and secure runtime for WebAssembly. Contribute to bytecodealliance/wasmtime development by creating an account on GitHub.</div></div></div>",
        "id": 483111280,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1731959806
    },
    {
        "content": "<p>to add on to what Chris said: in both Cranelift embeddings of ISLE (mid end and backends) the actual traversal over the IR is driven by host Rust code rather than ISLE code, and that traversal invokes an ISLE constructor on each IR node as it goes. the ISLE constructor then does complex pattern matching, matching arbitrarily (but ~O(1)) deep, and all that to transform/rewrite in a peephole style. but the ISLE does not itself recurse over the IR or drive the traversal.</p>",
        "id": 486149112,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1733334904
    }
]