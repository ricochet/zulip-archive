[
    {
        "content": "<p>Has anyone had a chance to explore calling async functions from cranelift? Also, are there plans for creating async functions from cranelift?</p>\n<p>I've been poking around a bit, and was wondering just how much of Rust we might be able to call into. Async is definitely a big one that I wasn't sure if cranelift supported.</p>",
        "id": 361196733,
        "sender_full_name": "JT",
        "timestamp": 1685064005
    },
    {
        "content": "<p>The concept of \"async functions\" doesn't really exist at the Cranelift level. An async function in Rust, for example, is transformed by the Rust compiler into a function that looks kind of like a state machine and keeps its state in an anonymous type that implements the <code>Future</code> trait. Other languages may implement async differently. Cranelift has no knowledge of the Rust async semantics or stdlib, nor any other language's async, and so it wouldn't make sense to talk about \"async functions\" at the Cranelift level.</p>\n<p>As a parallel example, while Rust supports async functions, the IR presented to LLVM when you compile the Rust program has no \"async\" functions either. Think of Cranelift as similar to LLVM: you need to translate whatever higher-level notions you have into standard functions that take primitive args (floats/ints/pointers) and return primitive results. Does that make sense?</p>",
        "id": 361197735,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1685064469
    },
    {
        "content": "<p>On the topic of calling into Rust specifically: there are a bunch of Rust-level notions, like aggregate types (structs) for example, that Cranelift doesn't support. You can look at <code>cg_clif</code> (the rustc backend that uses Cranelift) to see how it implements all of this one abstraction layer up from Cranelift. (cc <span class=\"user-mention\" data-user-id=\"264278\">@bjorn3</span> for more on this!)</p>",
        "id": 361197865,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1685064576
    },
    {
        "content": "<p>I haven't tried it, but it boils down to calling <a href=\"https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll\">poll</a> on whatever implementation of the <code>Future</code> trait your async function returns, where the actual type is auto-generated by the Rust compiler. So if you know how to call trait methods, and can figure out the size of the generated type so you can allocate enough space to store it, then you're set. Except that is so many levels of unstable Rust ABIs that I hate to imagine trying to generate correct Cranelift calls for it without hooking deep into the Rust compiler.</p>\n<p>The usual trick for hiding away all those ABIs works here too though: construct a <code>Box&lt;dyn Future&gt;</code> in Rust code, then pass it to Cranelift-generated code through an <code>extern \"C\"</code> interface, and pass the box back into another Rust function when you want to call <code>poll</code>.</p>",
        "id": 361197867,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1685064577
    },
    {
        "content": "<p>(Actually you probably want <code>Box&lt;Box&lt;dyn Future&gt;&gt;</code> so that you have a thin pointer to pass around instead of a fat pointer.)</p>",
        "id": 361198017,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1685064669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/stream/217117-cranelift/topic/working.20with.20async/near/361197735\">said</a>:</p>\n<blockquote>\n<p>The concept of \"async functions\" doesn't really exist at the Cranelift level. An async function in Rust, for example, is transformed by the Rust compiler into a function that looks kind of like a state machine and keeps its state in an anonymous type that implements the <code>Future</code> trait. Other languages may implement async differently. Cranelift has no knowledge of the Rust async semantics or stdlib, nor any other language's async, and so it wouldn't make sense to talk about \"async functions\" at the Cranelift level.</p>\n<p>As a parallel example, while Rust supports async functions, the IR presented to LLVM when you compile the Rust program has no \"async\" functions either. Think of Cranelift as similar to LLVM: you need to translate whatever higher-level notions you have into standard functions that take primitive args (floats/ints/pointers) and return primitive results. Does that make sense?</p>\n</blockquote>\n<p>yeah, this was also my assumption but I wanted to confirm with y'all to be sure. Thanks, that's helpful.</p>",
        "id": 361216005,
        "sender_full_name": "JT",
        "timestamp": 1685077229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"504918\">Jamey Sharp</span> <a href=\"#narrow/stream/217117-cranelift/topic/working.20with.20async/near/361197867\">said</a>:</p>\n<blockquote>\n<p>I haven't tried it, but it boils down to calling <a href=\"https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll\">poll</a> on whatever implementation of the <code>Future</code> trait your async function returns, where the actual type is auto-generated by the Rust compiler. So if you know how to call trait methods, and can figure out the size of the generated type so you can allocate enough space to store it, then you're set. Except that is so many levels of unstable Rust ABIs that I hate to imagine trying to generate correct Cranelift calls for it without hooking deep into the Rust compiler.</p>\n<p>The usual trick for hiding away all those ABIs works here too though: construct a <code>Box&lt;dyn Future&gt;</code> in Rust code, then pass it to Cranelift-generated code through an <code>extern \"C\"</code> interface, and pass the box back into another Rust function when you want to call <code>poll</code>.</p>\n</blockquote>\n<p>this makes me a'feard <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  I think I'll stick to simpler paths.</p>",
        "id": 361216121,
        "sender_full_name": "JT",
        "timestamp": 1685077280
    }
]