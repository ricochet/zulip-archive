[
    {
        "content": "<p>l0yu opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p><a href=\"https://bytecodealliance.github.io/wasmtime/wasm-rust.html#writing-libraries\">https://bytecodealliance.github.io/wasmtime/wasm-rust.html#writing-libraries</a></p>\n<p>^^ I am following example to build a library with one function <code>print_hello</code></p>\n<p>when run <code>wasmtime --invoke print_hello target/wasm32-wasi/debug/hello_world.wasm</code><br>\nI get</p>\n<div class=\"codehilite\"><pre><span></span><code>Error: failed to run main module `target/wasm32-wasi/debug/hello_world.wasm`\n\nCaused by:\n    multiple tables: tables count must be at most 1 (at offset 557)\n</code></pre></div>\n\n\n<p>wasmtime version 0.17.0</p>\n</blockquote>",
        "id": 201086016,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592349680
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645424091\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>Thanks for the report! This is a known issue if you're using wasm-bindgen where wasmtime doesn't have full support for interface types just yet. The sample code that doesn't use wasm-bindgen should work alright though!</p>\n</blockquote>",
        "id": 201152271,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592405562
    },
    {
        "content": "<p>l0yu <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645481445\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>you are right, I cleaned local wasm bits with <code>wasm-bindgen</code> and build new one with <code>#[no_mangle]</code> only<br>\n<code>wasttime</code> command line is working.</p>\n<p>I further try call <code>print_hello</code> in my rust program <a href=\"https://bytecodealliance.github.io/wasmtime/lang-rust.html#hello-world\">reference sample in doc</a>. but get</p>\n<div class=\"codehilite\"><pre><span></span><code>Error: wrong number of imports provided, 0 != 4\n</code></pre></div>\n\n\n<p>the difference between sample is I am using <code>.wasm</code> in previous instead of <code>.wat</code> - wasm text<br>\nas library.</p>\n<p>hello_world lib</p>\n<div class=\"codehilite\"><pre><span></span><code>#[no_mangle]\npub extern &quot;C&quot; fn print_hello() {\n    println!(&quot;Hello, world!&quot;);\n}\n</code></pre></div>\n\n\n<p>rust program calling the lib</p>\n<div class=\"codehilite\"><pre><span></span><code>fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let engine = Engine::default();\n    // A `Store` is a sort of &quot;global object&quot; in a sense, but for now it suffices\n    // to say that it&#39;s generally passed to most constructors.\n    let store = Store::new(&amp;engine);\n\n    // We start off by creating a `Module` which represents a compiled form\n    // of our input wasm module. In this case it&#39;ll be JIT-compiled after\n    // we parse the text format.\n    let module = Module::from_file(&amp;engine, &quot;./lib/print_hello.wasm&quot;)?;\n\n    // After we have a compiled `Module` we can then instantiate it, creating\n    // an `Instance` which we can actually poke at functions on.\n    // &amp;[] -  import none of host function\n    let instance = Instance::new(&amp;store, &amp;module, &amp;[])?;\n\n    // The `Instance` gives us access to various exported functions and items,\n    // which we access here to pull out our `print_hello` exported function and\n    // run it.\n    let print_hello = instance.get_func(&quot;print_hello&quot;)\n        .expect(&quot;`print_hello` was not an exported function&quot;);\n\n    let print_hello = print_hello.get0::&lt;()&gt;()?;\n    print_hello()?;\n    Ok(())\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>cargo run\nError: wrong number of imports provided, 0 != 4\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201166408,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592411511
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645486088\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>You're compiling for the wasm32-wasi target which means you might import wasi functionality from the host (which <code>println!</code> does, for example). You'll want to follow the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/examples/linking.rs\">linking example</a> to link in wasi support.</p>\n</blockquote>",
        "id": 201167496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592412020
    },
    {
        "content": "<p>l0yu <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645500019\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>you are right, referencing example ^^ , I added WASI sdk and it <code>print_hello</code> wasm lib works !<br>\nis <code>println!</code> a system level function so that host app should provide WASI sdk ?</p>\n<p>working code</p>\n<div class=\"codehilite\"><pre><span></span><code>use std::error::Error;\nuse wasmtime::*;\nuse wasmtime_wasi::{Wasi, WasiCtx};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let engine = Engine::default();\n    // A `Store` is a sort of &quot;global object&quot; in a sense, but for now it suffices\n    // to say that it&#39;s generally passed to most constructors.\n    let store = Store::new(&amp;engine);\n\n    // Create an instance of `Wasi` which contains a `WasiCtx`. Note that\n    // `WasiCtx` provides a number of ways to configure what the target program\n    // will have access to.\n    let mut linker = Linker::new(&amp;store);\n    let wasi = Wasi::new(&amp;store, WasiCtx::new(std::env::args())?);\n    wasi.add_to_linker(&amp;mut linker)?;\n\n    // We start off by creating a `Module` which represents a compiled form\n    // of our input wasm module. In this case it&#39;ll be JIT-compiled after\n    // we parse the text format.\n    let module = Module::from_file(&amp;engine, &quot;./lib/print_hello.wasm&quot;)?;\n\n    // Instantiate module use WASI\n    let instance = linker.instantiate(&amp;module)?;\n\n    // The `Instance` gives us access to various exported functions and items,\n    // which we access here to pull out our `print_hello` exported function and\n    // run it.\n    let print_hello = instance.get_func(&quot;print_hello&quot;)\n        .expect(&quot;`print_hello` was not an exported function&quot;);\n\n    let print_hello = print_hello.get0::&lt;()&gt;()?;\n    print_hello()?;\n    Ok(())\n}\n</code></pre></div>\n\n\n<p>with dependency</p>\n<div class=\"codehilite\"><pre><span></span><code>[dependencies]\nwasmtime = &quot;0.18.0&quot;\nwasmtime-wasi = &quot;0.18.0&quot;\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>cargo run\nHello, world!\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201170587,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592413429
    },
    {
        "content": "<p>l0yu edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645500019\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>you are right, referencing example ^^ , I added WASI sdk and <code>print_hello</code> wasm lib works in host rust app!<br>\nis <code>println!</code> a system level function so that host app should provide WASI sdk ?</p>\n<p>working code</p>\n<div class=\"codehilite\"><pre><span></span><code>use std::error::Error;\nuse wasmtime::*;\nuse wasmtime_wasi::{Wasi, WasiCtx};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let engine = Engine::default();\n    // A `Store` is a sort of &quot;global object&quot; in a sense, but for now it suffices\n    // to say that it&#39;s generally passed to most constructors.\n    let store = Store::new(&amp;engine);\n\n    // Create an instance of `Wasi` which contains a `WasiCtx`. Note that\n    // `WasiCtx` provides a number of ways to configure what the target program\n    // will have access to.\n    let mut linker = Linker::new(&amp;store);\n    let wasi = Wasi::new(&amp;store, WasiCtx::new(std::env::args())?);\n    wasi.add_to_linker(&amp;mut linker)?;\n\n    // We start off by creating a `Module` which represents a compiled form\n    // of our input wasm module. In this case it&#39;ll be JIT-compiled after\n    // we parse the text format.\n    let module = Module::from_file(&amp;engine, &quot;./lib/print_hello.wasm&quot;)?;\n\n    // Instantiate module use WASI\n    let instance = linker.instantiate(&amp;module)?;\n\n    // The `Instance` gives us access to various exported functions and items,\n    // which we access here to pull out our `print_hello` exported function and\n    // run it.\n    let print_hello = instance.get_func(&quot;print_hello&quot;)\n        .expect(&quot;`print_hello` was not an exported function&quot;);\n\n    let print_hello = print_hello.get0::&lt;()&gt;()?;\n    print_hello()?;\n    Ok(())\n}\n</code></pre></div>\n\n\n<p>with dependency</p>\n<div class=\"codehilite\"><pre><span></span><code>[dependencies]\nwasmtime = &quot;0.18.0&quot;\nwasmtime-wasi = &quot;0.18.0&quot;\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>cargo run\nHello, world!\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201170668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592413457
    },
    {
        "content": "<p>l0yu edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889#issuecomment-645500019\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p>you are right, referencing example ^^ , I added WASI sdk and <code>print_hello</code> wasm lib works in host rust app!<br>\nis <code>println!</code> a system level function so that host app should provide WASI sdk for wasm lib ?</p>\n<p>working code</p>\n<div class=\"codehilite\"><pre><span></span><code>use std::error::Error;\nuse wasmtime::*;\nuse wasmtime_wasi::{Wasi, WasiCtx};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let engine = Engine::default();\n    // A `Store` is a sort of &quot;global object&quot; in a sense, but for now it suffices\n    // to say that it&#39;s generally passed to most constructors.\n    let store = Store::new(&amp;engine);\n\n    // Create an instance of `Wasi` which contains a `WasiCtx`. Note that\n    // `WasiCtx` provides a number of ways to configure what the target program\n    // will have access to.\n    let mut linker = Linker::new(&amp;store);\n    let wasi = Wasi::new(&amp;store, WasiCtx::new(std::env::args())?);\n    wasi.add_to_linker(&amp;mut linker)?;\n\n    // We start off by creating a `Module` which represents a compiled form\n    // of our input wasm module. In this case it&#39;ll be JIT-compiled after\n    // we parse the text format.\n    let module = Module::from_file(&amp;engine, &quot;./lib/print_hello.wasm&quot;)?;\n\n    // Instantiate module use WASI\n    let instance = linker.instantiate(&amp;module)?;\n\n    // The `Instance` gives us access to various exported functions and items,\n    // which we access here to pull out our `print_hello` exported function and\n    // run it.\n    let print_hello = instance.get_func(&quot;print_hello&quot;)\n        .expect(&quot;`print_hello` was not an exported function&quot;);\n\n    let print_hello = print_hello.get0::&lt;()&gt;()?;\n    print_hello()?;\n    Ok(())\n}\n</code></pre></div>\n\n\n<p>with dependency</p>\n<div class=\"codehilite\"><pre><span></span><code>[dependencies]\nwasmtime = &quot;0.18.0&quot;\nwasmtime-wasi = &quot;0.18.0&quot;\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>cargo run\nHello, world!\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201170849,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592413548
    },
    {
        "content": "<p>l0yu closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1889\">Issue #1889</a>:</p>\n<blockquote>\n<p><a href=\"https://bytecodealliance.github.io/wasmtime/wasm-rust.html#writing-libraries\">https://bytecodealliance.github.io/wasmtime/wasm-rust.html#writing-libraries</a></p>\n<p>^^ I am following example to build a library with one function <code>print_hello</code></p>\n<p>when run <code>wasmtime --invoke print_hello target/wasm32-wasi/debug/hello_world.wasm</code><br>\nI get</p>\n<div class=\"codehilite\"><pre><span></span><code>Error: failed to run main module `target/wasm32-wasi/debug/hello_world.wasm`\n\nCaused by:\n    multiple tables: tables count must be at most 1 (at offset 557)\n</code></pre></div>\n\n\n<p>wasmtime version 0.17.0</p>\n</blockquote>",
        "id": 201170877,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592413562
    }
]