[
    {
        "content": "<p>wmstack opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475\">issue #4475</a>:</p>\n<blockquote>\n<p>Relevant Question: <a href=\"https://cstheory.stackexchange.com/questions/6256/whats-the-difference-between-term-rewriting-and-pattern-matching?rq=1&amp;newreg=4ad61442dc214a2d8e999c01f8651e0c\">https://cstheory.stackexchange.com/questions/6256/whats-the-difference-between-term-rewriting-and-pattern-matching?rq=1&amp;newreg=4ad61442dc214a2d8e999c01f8651e0c</a></p>\n<p>It seems to me that as the answer says, that pattern matching can only rewrite the top-level structure that is pattern matched, while rewriting rules can rewrite any sub-expression (or sub-computation) that is anywhere in the tree or directed-acyclic graph of computations.</p>\n<p>Does ISLE rewrite subexpressions in the cranelift IR CFG?</p>\n</blockquote>",
        "id": 290223446,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658317307
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475#issuecomment-1190484227\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475\">issue #4475</a>:</p>\n<blockquote>\n<p>ISLE works on one instruction at a time (walking backwards for DCE without requiring a separate DCE pass), potentially matching the instructions that produce values used by this instruction. Instructions don't can't have sub-expressions. They are atomic units. For example for</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"></span>\n<span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n</code></pre></div>\n<p>it would first visit <code>v3 = iadd.i32 v1, v2</code> and try the rule at <a href=\"https://github.com/bytecodealliance/wasmtime/blob/b28abb620e3d41a3457f58b5dfb8f74b8321c398/cranelift/codegen/src/isa/x64/lower.isle#L80-L84\">https://github.com/bytecodealliance/wasmtime/blob/b28abb620e3d41a3457f58b5dfb8f74b8321c398/cranelift/codegen/src/isa/x64/lower.isle#L80-L84</a> This rule will match <code>v3 = iadd.i32 v1, v2</code> and <code>v2 = load.i32 v0</code> and turn it into an <code>add</code> instruction with a direct memory reference as operand. After this the <code>v2 = load.i32 v0</code> is skipped as it is already lowered and isn't used anywhere else (<code>sinkable_load</code> won't match when there is more than 1 use of a loaded value I believe) and then <code>v1 = iconst.i32 42</code> is lowered to a <code>mov</code> of a constant value.</p>\n</blockquote>",
        "id": 290258592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658333789
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475#issuecomment-1190485632\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475\">issue #4475</a>:</p>\n<blockquote>\n<p>Hi @wmstack -- I think the most accurate answer to your question is \"both\", but with significant subtleties. To start with:</p>\n<blockquote>\n<p>Does ISLE rewrite subexpressions in the cranelift IR CFG?</p>\n</blockquote>\n<p>can be answered either with \"not applicable\", because ISLE-the-DSL doesn't do anything except invoke extractors and constructors, and the behavior of these is up to the embedder of the DSL's generated code (in our case, Cranelift); or \"no\", because our current use of ISLE is to generate code for lowering, so there is no rewriting of the CLIF at all, only matching on the CLIF and then generating machine instructions (<code>MachInst</code>s).</p>\n<p>But if you widen the scope of the question to \"can ISLE be used to rewrite arbitrary subterms\", the answer is absolutely yes; all the DSL concerns itself with is pattern-matching on the left-hand side, and then building a new expression with those parts on the right-hand side. Given those building-blocks one could construct a system with ISLE that arbitrarily rewrites subexpressions.</p>\n<p>For what it's worth I think the StackExchange answer linked has a bit more nuance than \"top-level vs sub-expression\"; the first answer has good points with respect to term-rewriting generally being a model for computation and pattern-matching as an area of study focused more on efficient destructuring. Those two are orthogonal: one can build a term-rewriting system that steps through computation <em>with</em> pattern-matching.</p>\n</blockquote>",
        "id": 290258753,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658333864
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4475\">issue #4475</a>:</p>\n<blockquote>\n<p>Relevant Question: <a href=\"https://cstheory.stackexchange.com/questions/6256/whats-the-difference-between-term-rewriting-and-pattern-matching?rq=1&amp;newreg=4ad61442dc214a2d8e999c01f8651e0c\">https://cstheory.stackexchange.com/questions/6256/whats-the-difference-between-term-rewriting-and-pattern-matching?rq=1&amp;newreg=4ad61442dc214a2d8e999c01f8651e0c</a></p>\n<p>It seems to me that as the answer says, that pattern matching can only rewrite the top-level structure that is pattern matched, while rewriting rules can rewrite any sub-expression (or sub-computation) that is anywhere in the tree or directed-acyclic graph of computations.</p>\n<p>Does ISLE rewrite subexpressions in the cranelift IR CFG?</p>\n</blockquote>",
        "id": 290258868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658333911
    }
]