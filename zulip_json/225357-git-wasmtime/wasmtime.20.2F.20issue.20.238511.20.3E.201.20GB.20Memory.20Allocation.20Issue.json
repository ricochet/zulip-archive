[
    {
        "content": "<p>chanattan opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have looked through the documentation and some previous issues of Wasmtime<br>\nso sorry in advance if this has already been answered. I can't get a Wasm module<br>\nto be able to allocate more memory than 1GB before reaching a memory error,<br>\nin this case <code>thread '&lt;unnamed&gt;' panicked at library/alloc/src/raw_vec.rs:534:5:\ncapacity overflow</code>. I am trying to instantiate a Wasm module through a native program<br>\nwith Wasmtime 18.0.0 with the following code:</p>\n<p>`let engine = Engine::default();<br>\n    let mut linker = Linker::new(&amp;engine);</p>\n<div class=\"codehilite\"><pre><span></span><code>wasmtime_wasi::add_to_linker(&amp;mut linker, |s| s)?;\nlet module = Module::from_file(&amp;engine, wasm_prg)?;\n\nlet wasi = WasiCtxBuilder::new()\n    .inherit_stdio()\n    .inherit_args()?.preopened_dir(Dir::from_std_file(std::fs::File::open(path)?), path)?\n    .build();\n\nlet mut store = Store::new(&amp;engine, wasi);\nlet memory_type = MemoryType::new(1, Some(16384*4));\nMemory::new(&amp;mut store, memory_type).unwrap();`\n\nlet instance = linker\n        .instantiate(&amp;mut store, &amp;module).unwrap();\n match instance.get_export(&amp;mut store, &quot;function&quot;)\n        .and_then(|e| e.into_func())\n        .ok_or(0) {\n          Ok(func) =&gt; ...\n }`\n</code></pre></div>\n\n<p>Which instantiates a Wasm module and call a function that allocates a Vec of certain size &gt; 1 GB this way:</p>\n<p><code>let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(2217296726 as usize);</code></p>\n<p>Here is the full error upon execution:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">raw_vec</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">534</span>:<span class=\"mi\">5</span>:\n<span class=\"nc\">capacity</span><span class=\"w\"> </span><span class=\"n\">overflow</span>\n<span class=\"n\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Error</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n    <span class=\"mi\">0</span>: <span class=\"mh\">0x121cc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">__rust_start_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"mh\">0x11f54</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"mh\">0x11e87</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">rust_panic_with_hook</span>::<span class=\"n\">h01fa6d9286535f9c</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span>: <span class=\"mh\">0x1125c</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">begin_panic_handler</span>::<span class=\"p\">{{</span><span class=\"n\">closure</span><span class=\"p\">}}</span>::<span class=\"n\">h322b08995dd5f5cc</span>\n<span class=\"w\">    </span><span class=\"mi\">4</span>: <span class=\"mh\">0x111bc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">sys_common</span>::<span class=\"n\">backtrace</span>::<span class=\"n\">__rust_end_short_backtrace</span>::<span class=\"n\">hd7b53dba62f7f0aa</span>\n<span class=\"w\">    </span><span class=\"mi\">5</span>: <span class=\"mh\">0x1183e</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_begin_unwind</span>\n<span class=\"w\">    </span><span class=\"mi\">6</span>: <span class=\"mh\">0x16cf6</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">core</span>::<span class=\"n\">panicking</span>::<span class=\"n\">panic_fmt</span>::<span class=\"n\">h2a1cf3beec13dfc3</span>\n<span class=\"w\">    </span><span class=\"mi\">7</span>: <span class=\"mh\">0x16697</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">alloc</span>::<span class=\"n\">raw_vec</span>::<span class=\"n\">capacity_overflow</span>::<span class=\"n\">h71c1886b236d8c9d</span>\n<span class=\"w\">    </span><span class=\"mi\">8</span>: <span class=\"mh\">0x1505</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">benchmark_wasm_joins</span>\n<span class=\"n\">note</span>: <span class=\"nc\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">may</span><span class=\"w\"> </span><span class=\"n\">show</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">debugging</span><span class=\"w\"> </span><span class=\"n\">information</span>\n</code></pre></div>\n<p>Since Wasm should support 4GB of memory I thought it was only a question of option toggling but I don't see how to do it in the first code section. Hope it was clear enough.</p>\n</blockquote>",
        "id": 436364727,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714516571
    },
    {
        "content": "<p>chanattan edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have looked through the documentation and some previous issues of Wasmtime<br>\nso sorry in advance if this has already been answered. I can't get a Wasm module<br>\nto be able to allocate more memory than 1GB before reaching a memory error,<br>\nin this case <code>thread '&lt;unnamed&gt;' panicked at library/alloc/src/raw_vec.rs:534:5:\ncapacity overflow</code>. I am trying to instantiate a Wasm module through a native program<br>\nwith Wasmtime 18.0.0 with the following code:</p>\n<p>`let engine = Engine::default();<br>\n    let mut linker = Linker::new(&amp;engine);</p>\n<div class=\"codehilite\"><pre><span></span><code>wasmtime_wasi::add_to_linker(&amp;mut linker, |s| s)?;\nlet module = Module::from_file(&amp;engine, wasm_prg)?;\n\nlet wasi = WasiCtxBuilder::new()\n    .inherit_stdio()\n    .inherit_args()?.preopened_dir(Dir::from_std_file(std::fs::File::open(path)?), path)?\n    .build();\n\nlet mut store = Store::new(&amp;engine, wasi);\nlet memory_type = MemoryType::new(1, Some(16384*4));\nMemory::new(&amp;mut store, memory_type).unwrap();`\n\nlet instance = linker\n        .instantiate(&amp;mut store, &amp;module).unwrap();\n match instance.get_export(&amp;mut store, &quot;function&quot;)\n        .and_then(|e| e.into_func())\n        .ok_or(0) {\n          Ok(func) =&gt; ...\n }\n</code></pre></div>\n\n<p>Which instantiates a Wasm module and call a function that allocates a Vec of certain size &gt; 1 GB this way:</p>\n<p><code>let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(2217296726 as usize);</code></p>\n<p>Here is the full error upon execution:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">raw_vec</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">534</span>:<span class=\"mi\">5</span>:\n<span class=\"nc\">capacity</span><span class=\"w\"> </span><span class=\"n\">overflow</span>\n<span class=\"n\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Error</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n    <span class=\"mi\">0</span>: <span class=\"mh\">0x121cc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">__rust_start_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"mh\">0x11f54</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"mh\">0x11e87</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">rust_panic_with_hook</span>::<span class=\"n\">h01fa6d9286535f9c</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span>: <span class=\"mh\">0x1125c</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">begin_panic_handler</span>::<span class=\"p\">{{</span><span class=\"n\">closure</span><span class=\"p\">}}</span>::<span class=\"n\">h322b08995dd5f5cc</span>\n<span class=\"w\">    </span><span class=\"mi\">4</span>: <span class=\"mh\">0x111bc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">sys_common</span>::<span class=\"n\">backtrace</span>::<span class=\"n\">__rust_end_short_backtrace</span>::<span class=\"n\">hd7b53dba62f7f0aa</span>\n<span class=\"w\">    </span><span class=\"mi\">5</span>: <span class=\"mh\">0x1183e</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_begin_unwind</span>\n<span class=\"w\">    </span><span class=\"mi\">6</span>: <span class=\"mh\">0x16cf6</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">core</span>::<span class=\"n\">panicking</span>::<span class=\"n\">panic_fmt</span>::<span class=\"n\">h2a1cf3beec13dfc3</span>\n<span class=\"w\">    </span><span class=\"mi\">7</span>: <span class=\"mh\">0x16697</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">alloc</span>::<span class=\"n\">raw_vec</span>::<span class=\"n\">capacity_overflow</span>::<span class=\"n\">h71c1886b236d8c9d</span>\n<span class=\"w\">    </span><span class=\"mi\">8</span>: <span class=\"mh\">0x1505</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">benchmark_wasm_joins</span>\n<span class=\"n\">note</span>: <span class=\"nc\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">may</span><span class=\"w\"> </span><span class=\"n\">show</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">debugging</span><span class=\"w\"> </span><span class=\"n\">information</span>\n</code></pre></div>\n<p>Since Wasm should support 4GB of memory I thought it was only a question of option toggling but I don't see how to do it in the first code section. Hope it was clear enough.</p>\n</blockquote>",
        "id": 436364775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714516604
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have looked through the documentation and some previous issues of Wasmtime<br>\nso sorry in advance if this has already been answered. I can't get a Wasm module<br>\nto be able to allocate more memory than 1GB before reaching a memory error,<br>\nin this case <code>thread '&lt;unnamed&gt;' panicked at library/alloc/src/raw_vec.rs:534:5:\ncapacity overflow</code>. I am trying to instantiate a Wasm module through a native program<br>\nwith Wasmtime 18.0.0 with the following code:</p>\n<p>`let engine = Engine::default();<br>\n    let mut linker = Linker::new(&amp;engine);</p>\n<div class=\"codehilite\"><pre><span></span><code>wasmtime_wasi::add_to_linker(&amp;mut linker, |s| s)?;\nlet module = Module::from_file(&amp;engine, wasm_prg)?;\n\nlet wasi = WasiCtxBuilder::new()\n    .inherit_stdio()\n    .inherit_args()?.preopened_dir(Dir::from_std_file(std::fs::File::open(path)?), path)?\n    .build();\n\nlet mut store = Store::new(&amp;engine, wasi);\nlet memory_type = MemoryType::new(1, Some(16384*4));\nMemory::new(&amp;mut store, memory_type).unwrap();`\n\nlet instance = linker\n        .instantiate(&amp;mut store, &amp;module).unwrap();\n match instance.get_export(&amp;mut store, &quot;function&quot;)\n        .and_then(|e| e.into_func())\n        .ok_or(0) {\n          Ok(func) =&gt; ...\n }\n</code></pre></div>\n\n<p>Which instantiates a Wasm module and call a function that allocates a Vec of certain size &gt; 1 GB this way:</p>\n<p><code>let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(2217296726 as usize);</code></p>\n<p>Here is the full error upon execution:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">raw_vec</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">534</span>:<span class=\"mi\">5</span>:\n<span class=\"nc\">capacity</span><span class=\"w\"> </span><span class=\"n\">overflow</span>\n<span class=\"n\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Error</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n    <span class=\"mi\">0</span>: <span class=\"mh\">0x121cc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">__rust_start_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"mh\">0x11f54</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_panic</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"mh\">0x11e87</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">rust_panic_with_hook</span>::<span class=\"n\">h01fa6d9286535f9c</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span>: <span class=\"mh\">0x1125c</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">panicking</span>::<span class=\"n\">begin_panic_handler</span>::<span class=\"p\">{{</span><span class=\"n\">closure</span><span class=\"p\">}}</span>::<span class=\"n\">h322b08995dd5f5cc</span>\n<span class=\"w\">    </span><span class=\"mi\">4</span>: <span class=\"mh\">0x111bc</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">std</span>::<span class=\"n\">sys_common</span>::<span class=\"n\">backtrace</span>::<span class=\"n\">__rust_end_short_backtrace</span>::<span class=\"n\">hd7b53dba62f7f0aa</span>\n<span class=\"w\">    </span><span class=\"mi\">5</span>: <span class=\"mh\">0x1183e</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">rust_begin_unwind</span>\n<span class=\"w\">    </span><span class=\"mi\">6</span>: <span class=\"mh\">0x16cf6</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">core</span>::<span class=\"n\">panicking</span>::<span class=\"n\">panic_fmt</span>::<span class=\"n\">h2a1cf3beec13dfc3</span>\n<span class=\"w\">    </span><span class=\"mi\">7</span>: <span class=\"mh\">0x16697</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">alloc</span>::<span class=\"n\">raw_vec</span>::<span class=\"n\">capacity_overflow</span>::<span class=\"n\">h71c1886b236d8c9d</span>\n<span class=\"w\">    </span><span class=\"mi\">8</span>: <span class=\"mh\">0x1505</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">benchmark_wasm_joins</span>\n<span class=\"n\">note</span>: <span class=\"nc\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">may</span><span class=\"w\"> </span><span class=\"n\">show</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">debugging</span><span class=\"w\"> </span><span class=\"n\">information</span>\n</code></pre></div>\n<p>Since Wasm should support 4GB of memory I thought it was only a question of option toggling but I don't see how to do it in the first code section. Hope it was clear enough.</p>\n</blockquote>",
        "id": 436367390,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714518129
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2087678079\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>It appears that this is a Rust standard library issue on the guest side (i.e., your Wasm module, not Wasmtime itself): <a href=\"https://doc.rust-lang.org/beta/src/alloc/raw_vec.rs.html#609\">this line of code</a> in the <code>Vec</code> implementation checks that the allocation size is less than <code>isize::MAX</code>, and on a 32-bit platform such as Wasm, <code>isize</code> (signed pointer-sized integer) ranges up to +2GiB, not +4GiB. Your allocation request is just over 2GiB in length, hence the error.</p>\n<p>I'm not sure <em>why</em> <code>Vec</code> is this way; you'd have to read the library source to find out more, probably; but as this is not a Wasmtime issue (we're executing the module correctly) I'll go ahead and close this issue.</p>\n</blockquote>",
        "id": 436367391,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714518130
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088058412\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>LLVM considers it UB for allocations larger than isize::MAX to exist. Libstd panics here to avoid this UB.</p>\n</blockquote>",
        "id": 436459120,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714546207
    },
    {
        "content": "<p>chanattan <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088641233\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>Thank you for your answers.<br>\nI am still looking for an alternative to fix this issue.<br>\nThe initial goal remains simple, allocate the maximum memory in a Wasm module in Rust, i.e., 4GB currently.<br>\nDo you know what is being used to achieve that?</p>\n</blockquote>",
        "id": 436522757,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714577587
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088654360\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>You have to make multiple separate allocations to allocate more than 2GB total. There is no way to make a single contiguous allocation.</p>\n</blockquote>",
        "id": 436524347,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714578140
    },
    {
        "content": "<p>chanattan <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088658751\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>I was afraid this was the only solution.<br>\nThank you nonetheless. </p>\n</blockquote>",
        "id": 436524832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714578338
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088668516\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>To add a bit of nuance: not possible with LLVM, apparently. However, @bjorn3, do you know if the UB applies to a slice constructed manually (<code>std::slice::from_raw_parts</code>)? If that's allowed to range up to <code>usize::MAX</code>, then potentially you could write your own manual allocator function that uses <code>memory.grow</code> to grab a large (4GiB - epsilon) chunk. dlmalloc on the guest side is specifically compatible with \"discontiguous grow\" (some other client also using <code>memory.grow</code>).</p>\n</blockquote>",
        "id": 436525971,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714578741
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088668516\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>To add a bit of nuance: not possible with LLVM wrt Rust's allocator, apparently. However, @bjorn3, do you know if the UB applies to a slice constructed manually (<code>std::slice::from_raw_parts</code>)? If that's allowed to range up to <code>usize::MAX</code>, then potentially you could write your own manual allocator function that uses <code>memory.grow</code> to grab a large (4GiB - epsilon) chunk. dlmalloc on the guest side is specifically compatible with \"discontiguous grow\" (some other client also using <code>memory.grow</code>).</p>\n</blockquote>",
        "id": 436526124,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714578792
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088839630\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<blockquote>\n<p>However, @bjorn3, do you know if the UB applies to a slice constructed manually (std::slice::from_raw_parts)?</p>\n</blockquote>\n<p>Yes that is still UB if you actually try to use it. LLVM assumes that any allocation is less than <code>isize::MAX</code> bytes. From the LLVM LangRef:</p>\n<p><a href=\"https://llvm.org/docs/LangRef.html#getelementptr-instruction\">https://llvm.org/docs/LangRef.html#getelementptr-instruction</a></p>\n<blockquote>\n<p>These rules are based on the assumption that no allocated object may cross the unsigned address space boundary, and no allocated object may be larger than half the pointer index type space.</p>\n</blockquote>\n<p>and also the couple of rules above it for <code>getelementptr inbounds</code> (which is the instruction rustc uses for all slice indexing, pointer offsetting for field accesses and <code>ptr::offset</code> and so on (but not <code>ptr::wrapping_offset</code>)</p>\n</blockquote>",
        "id": 436545760,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714585954
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2088851440\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>That's too bad. @chanattan it appears this means that you'll be unable to use any LLVM-based toolchain for wasm32 (e.g. wasi-sdk, or emscripten, or Rust, or tinygo, or ...) to allocate a single object &gt;2GiB. You could still write your own (i) allocator, as above, and (ii) load/store primitives, in raw WAT, and link that into your wasm module; raw Wasm should have no issues with a single e.g. 3.75GiB array in memory. But you'd need LTO-time inlining to make that fast (maybe wasm-opt with the right options, I'm not sure).</p>\n</blockquote>",
        "id": 436547187,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714586485
    },
    {
        "content": "<p>chanattan <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511#issuecomment-2089004635\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8511\">issue #8511</a>:</p>\n<blockquote>\n<p>I will probably go for a custom allocation. I will eventually look at the rest later.<br>\nThank you again for your precious pieces of information.</p>\n</blockquote>",
        "id": 436562149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714592857
    }
]