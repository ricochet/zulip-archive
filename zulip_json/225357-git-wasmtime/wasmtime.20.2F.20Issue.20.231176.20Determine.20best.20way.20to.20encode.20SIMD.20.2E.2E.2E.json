[
    {
        "content": "<p>abrown closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1176\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1176\">Issue #1176</a>:</p>\n<blockquote>\n<h4>What is the feature or code improvement you would like to do in Cranelift?</h4>\n<p>I would like to implement the <a href=\"https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md#load-and-extend\" title=\"https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md#load-and-extend\">SIMD  <code>load_extend</code> instructions</a>. </p>\n<h4>What is the value of adding this in Cranelift?</h4>\n<p>This is necessary for Wasm SIMD spec compliance.</p>\n<h4>Do you have an implementation plan, and/or ideas for data structures or algorithms to use?</h4>\n<p>I see that currently <code>shared/instructions.rs</code> includes instructions such as <code>uload32</code> and <code>sload32</code>; one option is to add the additional instructions <code>[u/s]load8x8</code>, <code>[u/s]load16x4</code>, and <code>[u/s]load32x4</code>. Alternately, @bnjbvr and I had discussed using the IR-&gt;IR infrastructure of legalization to implement peephole optimizations; if this was in place and at the right level, I could translate the Wasm <code>load8x8_s</code>, e.g., to Cranelift's <code>load.i8x8</code> and <code>uextend</code> and then write a peephole optimization to generate the appropriate x86 <code>PMOVSXBW</code> to encode both of these instructions (perhaps with a new Cranelift <code>x86_pmovsxb</code> instruction). Which approach is better.</p>\n</blockquote>",
        "id": 192431343,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585679728
    }
]