[
    {
        "content": "<p>julian-seward1 opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205333563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014259
    },
    {
        "content": "<p><strong>julian-seward1</strong> requested <a href=\"https://github.com/bnjbvr\">bnjbvr</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a>.</p>",
        "id": 205334312,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014825
    },
    {
        "content": "<p><strong>julian-seward1</strong> requested <a href=\"https://github.com/cfallin\">cfallin</a> and <a href=\"https://github.com/bnjbvr\">bnjbvr</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a>.</p>",
        "id": 205334323,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014845
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-457345676\">PR Review</a>.</p>",
        "id": 205334341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014864
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-457345676\">PR Review</a>.</p>",
        "id": 205334343,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014864
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462161536\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>Mem</code> is defined at <a href=\"https://github.com/julian-seward1/wasmtime/blob/23b8640f2a016b7077f44f41501750a5d018a658/cranelift/codegen/meta/src/shared/instructions.rs#L791\">https://github.com/julian-seward1/wasmtime/blob/23b8640f2a016b7077f44f41501750a5d018a658/cranelift/codegen/meta/src/shared/instructions.rs#L791</a>. You could create a new typevar to only allow i8..i64.</p>\n</blockquote>",
        "id": 205334344,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014864
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462163432\">PR Review Comment</a>:</p>\n<blockquote>\n<p>cg_clif also requires nand, max, min, umax, umin.</p>\n</blockquote>",
        "id": 205334345,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596014864
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-457715365\">PR Review</a>.</p>",
        "id": 205412355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056064
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-457715365\">PR Review</a>.</p>",
        "id": 205412356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056064
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462448799\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Slightly pedantic (sorry!) but let's write out \"read-modify-write\" here for clarity.</p>\n</blockquote>",
        "id": 205412357,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056064
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462449315\">PR Review Comment</a>:</p>\n<blockquote>\n<p>+1, let's limit to just the types that make sense.</p>\n</blockquote>",
        "id": 205412358,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056064
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462450220\">PR Review Comment</a>:</p>\n<blockquote>\n<p>nit: single backticks here for consistency with other descriptions.</p>\n</blockquote>",
        "id": 205412359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056064
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462451452\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For clarity: the old value is returned whether or not the CAS succeeds, I assume? (There's no bool success flag so this must be the case?)</p>\n</blockquote>",
        "id": 205412360,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462531056\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Let's embed a <code>Type</code> instead.</p>\n</blockquote>",
        "id": 205412361,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462506017\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yes, I think that's reasonable; we try not to rely on the actual CLIF in the vcode, but there's no reason not to reuse its enum here.</p>\n</blockquote>",
        "id": 205412362,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462530450\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Actually (after looking further down) I think it might be better to simply reuse <code>ALUOp</code>: in principle, any <code>AluRRR</code> instruction could be emitted as the op inside the r-m-w sequence, no?</p>\n</blockquote>",
        "id": 205412363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462452658\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We might want to say something about the memory ordering model here. In particular, do atomics follow sequential consistency, and do they create happens-before edges that order normal (non-atomic) loads/stores? I think this is the case based on the fences that are emitted (but we should double-check!).</p>\n</blockquote>",
        "id": 205412364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462536112\">PR Review Comment</a>:</p>\n<blockquote>\n<p>No need for braces here</p>\n</blockquote>",
        "id": 205412365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462528890\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For consistency, I think it might be better to write an <code>enc_...() -&gt; u32</code> helper that takes the size as a parameter.</p>\n</blockquote>",
        "id": 205412366,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462539798\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think the no-extend is safe here for the ops this patch supports, but if we add e.g. min/max later, we need to reconsider...</p>\n</blockquote>",
        "id": 205412367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462537458\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>writable_xreg()</code> here as well</p>\n</blockquote>",
        "id": 205412368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462535659\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Use a <code>Type</code> here; or if not that, let's use or define an enum for this.</p>\n</blockquote>",
        "id": 205412369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462541165\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>emit_safepoint</code> if this is a resumable trap; if it kills the Wasm program, then no need (everything becomes dead on termination). I think a misalignment trap is the latter case?</p>\n</blockquote>",
        "id": 205412370,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462542273\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I like this API -- an elegant solution to the problem!</p>\n<p>We might want to add a note in the doc comment about when it might be necessary: e.g., a warning about parallel moves and overlapping registers when insts that emit sequences with fixed real regs are given real-reg arguments.</p>\n</blockquote>",
        "id": 205412371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462531800\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'd prefer to encapsulate <code>ldxr</code> (and the store-conditional below too) in <code>enc_...</code> helpers as with most of the other cases; we haven't been perfect with this (and I should clean it up later) but I want to try to maintain the separation.</p>\n</blockquote>",
        "id": 205412372,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462536489\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Use <code>writable_xreg()</code>?</p>\n</blockquote>",
        "id": 205412373,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462540220\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Maybe add a comment here that the CAS sequence does its own masking, so we don't need to worry about zero-extending narrow (<code>I8</code>/<code>I16</code>) values.</p>\n</blockquote>",
        "id": 205412374,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462546915\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Do we want to <code>return Err(wasm_unsupported!(\"Unsupported atomic access type {:?}\", access_ty))</code> instead? It seems we only call this with hardcoded types in the big match above (so any failure is our error, not a bad input) but it at least hooks into the existing error-reporting path.</p>\n</blockquote>",
        "id": 205412375,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462532724\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'd prefer not to have the redundant information here regarding ALU-op encodings; I'd prefer to construct an <code>AluRRR</code> (with the hardcoded registers and an <code>ALUOp</code> from this inst's fields) and emit it here. Or, if not that, at least invoke the <code>enc_...</code> helper directly with the appropriate regs and op.</p>\n<p>Aside from avoiding the redundancy, this change also makes it much easier to modify later; the hex constants are difficult to maintain if, e.g., we ever want to change which registers are used.</p>\n</blockquote>",
        "id": 205412376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462533652\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Similar comments here as above regarding hardcoded constants vs. encoding functions and labels.</p>\n</blockquote>",
        "id": 205412377,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462538930\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Potential optimization (not needed for correctness): there's no need to mask to 32 bits if we use a <code>cmp w27, w24</code> instead (and <code>cbnz w24, ...</code>).</p>\n</blockquote>",
        "id": 205412378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462533293\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Let's use a label and fixup for the branch target; not doing so is potentially very error-prone in hard-to-debug ways if we ever change the length of the sequence above.</p>\n</blockquote>",
        "id": 205412379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462535360\">PR Review Comment</a>:</p>\n<blockquote>\n<p>As hinted earlier -- I think the best way to go about this is to actually just reuse the <code>ALUOp</code> enum. I'm not sure of any reason to limit the allowed set of r-m-w opcodes; in principle, any two-source, one-dest operation might be desirable to perform in an atomic way.</p>\n</blockquote>",
        "id": 205412380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462581193\">PR Review Comment</a>:</p>\n<blockquote>\n<p>close-paren after <code>i32</code> (and likewise below)?</p>\n</blockquote>",
        "id": 205412381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596056065
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462752236\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The Wasm atomics spec requires sequential consistency, so for each of the 5 new CLIF insns, I have added <code>This operation is sequentially consistent.</code>.  For the happens-before relation to normal loads/stores, this exceeds my knowledge of such things.  I'll make enquiries.</p>\n</blockquote>",
        "id": 205444394,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596088607
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458090266\">PR Review</a>.</p>",
        "id": 205444395,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596088607
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458094094\">PR Review</a>.</p>",
        "id": 205444855,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596089215
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462755335\">PR Review Comment</a>:</p>\n<blockquote>\n<p>On investigation, I am inclined to leave this as-is (although rename it to <code>AtomicRMWOp</code>) for two reasons:</p>\n<ul>\n<li><code>ALUOp</code> has 32- and 64-bit variants of each operation.  But <code>Inst::AtomicRMW</code> also has a <code>type</code> field, and so that gives the possibility of creating nonsensical combinations (it violates the no-junk no-confusion rule).  Eg, <code>type</code> indicating 64-bit, but with <code>op</code> being <code>ALUOp::Orr32</code>.</li>\n<li>per @bjorn3's comment above (\"cg_clif also requires nand, max, min, umax, umin.\"), <code>ALUOp</code> doesn't have max/min/umax/umin.</li>\n</ul>\n</blockquote>",
        "id": 205444856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596089215
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458099656\">PR Review</a>.</p>",
        "id": 205445355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596090026
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462760095\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can write this as an <code>enc_*</code> function, no problem, but I didn't understand the comment about the size.  This is a fence; there is no size field.  Did you perhaps mean to parameterise it on the sharability domain (the <code>ISH</code> == \"inner sharable\") part?</p>\n</blockquote>",
        "id": 205445356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596090026
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458129807\">PR Review</a>.</p>",
        "id": 205446761,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596092134
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462779971\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Per comment above, it might in hindsight be cleaner to retain <code>LLSCOp</code> but rename it to <code>AtomicRMWOp</code>.</p>\n</blockquote>",
        "id": 205446762,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596092134
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462801416\">PR Review Comment</a>:</p>\n<blockquote>\n<p>When you say \"doc comment\", do you mean this comment here (on <code>ensure_in_vreg</code>), or somewhere else?  (unclear)</p>\n</blockquote>",
        "id": 205448557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596093974
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458147467\">PR Review</a>.</p>",
        "id": 205448558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596093974
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458179869\">PR Review</a>.</p>",
        "id": 205452020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596096784
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462826467\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yes, it returns the old value regardless of whether the CAS succeeds or fails.  I updated the comment accordingly.</p>\n</blockquote>",
        "id": 205452021,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596096784
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458187717\">PR Review</a>.</p>",
        "id": 205452868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097432
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462832585\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Regarding the happens-before edges, Lars writes: \"Yes [they create h-b edges] ... normal loads and stores may be reordered among themselves but not across atomics, and atomics may not be reordered wrt each other\".</p>\n<p>So I think we're good (right?)  The implementation fences everything with <code>dmb ish</code>, which IIUC prevents movement of both loads and stores either forwards or backwards across the fence.  And FWIW, this is the same fencyness as SM/wasm/baseline; I just cloned the scheme that uses.</p>\n</blockquote>",
        "id": 205452869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097432
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458192948\">PR Review</a>.</p>",
        "id": 205453473,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097842
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462836677\">PR Review Comment</a>:</p>\n<blockquote>\n<p>They are non-resumable; no stackmap needed.  Choosing plain <code>emit</code> therefore.</p>\n</blockquote>",
        "id": 205453474,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097842
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458193897\">PR Review</a>.</p>",
        "id": 205453555,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097915
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462837411\">PR Review Comment</a>:</p>\n<blockquote>\n<p>.. but then, why does <code>Opcode::Trap</code> use <code>emit_safepoint</code> ?</p>\n</blockquote>",
        "id": 205453556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596097915
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458196973\">PR Review</a>.</p>",
        "id": 205453883,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596098152
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462839730\">PR Review Comment</a>:</p>\n<blockquote>\n<p>One thing that concerns me here is that it seems like we're conflating the semantics of wasm with the semantics of CLIF.  Whether or not <code>Opcode::Trapif | Opcode::Trapff</code> produces a safepoint should surely be specified as part of CLIF's semantics, and not be dependent of the semantics of whatever that CLIF was translated from.</p>\n</blockquote>",
        "id": 205453884,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596098152
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r462853739\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 205455735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596099549
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458215363\">PR Review</a>.</p>",
        "id": 205455736,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596099549
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458523813\">PR Review</a>.</p>",
        "id": 205494634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596123566
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463088890\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Cool, that's what I suspected (and that's what the fences enforce, as far as I can tell), so as long as we document that in the descriptions, we're good!</p>\n</blockquote>",
        "id": 205494635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596123566
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458525210\">PR Review</a>.</p>",
        "id": 205494836,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596123655
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463090010\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yes, exactly, this comment here on the function declaration. Thanks!</p>\n</blockquote>",
        "id": 205494838,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596123655
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458532704\">PR Review</a>.</p>",
        "id": 205495859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596124150
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463095686\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hmm, I think I missed some context previously -- I thought for some reason that your additions here only had to do with atomics-related misalignments, but of course if I scroll up just a bit I see this is for any <code>Opcode::Trap{if,ff}</code>. D'oh. Yes, it should always have a safepoint if it is a trap at the CLIF level; the only non-safepoint-adorned traps are the ones that are internal to e.g. divides. I suppose we should specify in the CLIF descriptions that any traps generated by instruction error conditions (rather than explicit trap instructions) will not have safepoints.</p>\n<p>Just to be sure -- @bnjbvr, could you confirm that we don't expect (or can get away with specifying) that there is no safepoint data for e.g. divide traps?</p>\n</blockquote>",
        "id": 205495861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596124150
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458934914\">PR Review</a>.</p>",
        "id": 205560745,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596175420
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463421185\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Changing to <code>emit_safepoint</code>.</p>\n</blockquote>",
        "id": 205560746,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596175420
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-458935346\">PR Review</a>.</p>",
        "id": 205560818,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596175500
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463421537\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The emit code is complicated enough as it is; would you be greatly offended if I punted on this, at least for now?</p>\n</blockquote>",
        "id": 205560819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596175500
    },
    {
        "content": "<p>julian-seward1 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205561014,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596175851
    },
    {
        "content": "<p>julian-seward1 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205563805,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596179320
    },
    {
        "content": "<p>bnjbvr submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-459146496\">PR Review</a>.</p>",
        "id": 205586202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596199701
    },
    {
        "content": "<p>bnjbvr created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463590167\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Just to be sure -- @bnjbvr, could you confirm that we don't expect (or can get away with specifying) that there is no safepoint data for e.g. divide traps?</p>\n</blockquote>\n<p>Agreed, and i think that indeed it should be specified that no GC must happen during stack unwinding (that sounds very scary and unsafe anyways)(now I wonder if wasm exception handling + wasm GC types could make this case actually possible).</p>\n</blockquote>",
        "id": 205586203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596199701
    },
    {
        "content": "<p>bnjbvr submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-459159926\">PR Review</a>.</p>",
        "id": 205589102,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201612
    },
    {
        "content": "<p>bnjbvr submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-459159926\">PR Review</a>.</p>",
        "id": 205589103,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201612
    },
    {
        "content": "<p>bnjbvr created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463603064\">PR Review Comment</a>:</p>\n<blockquote>\n<p>If this is implemented as a callout in general: yes. All the callouts in the \"dummy\" wasm to clif environment are implemented this way; this is only used when testing internally wasm compilation with clif-util, that is, when no proper environment can be used.</p>\n</blockquote>",
        "id": 205589104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201612
    },
    {
        "content": "<p>bnjbvr created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463600613\">PR Review Comment</a>:</p>\n<blockquote>\n<p>nit: here and below, please remove the code commented out.</p>\n</blockquote>",
        "id": 205589105,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201612
    },
    {
        "content": "<p>bnjbvr created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r463603782\">PR Review Comment</a>:</p>\n<blockquote>\n<p>In terms of API cleanliness, would it make sense to have a single function <code>translate_atomic_wait</code> that takes an extra Type parameter, that can be either I32 or I64? Going one step further, would it make sense to have a single <code>translate_atomic</code> method that would be passed an enum with variants <code>WaitI32/I64/Notify</code>?</p>\n</blockquote>",
        "id": 205589106,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201612
    },
    {
        "content": "<p>bnjbvr submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-459159926\">PR Review</a>.</p>",
        "id": 205589119,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596201624
    },
    {
        "content": "<p>julian-seward1 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205598088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596206417
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-459978790\">PR Review</a>.</p>",
        "id": 205786825,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596457126
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r464376548\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Merging the <code>wait</code> and <code>notify</code> cases is messy because they have different params.  However, the two <code>wait</code> cases can be merged without even needing an extra <code>Type</code> parameter, since the 32-vs-64 bit difference can be determined by inspecting the type of the <code>expected</code> parameter.  So that's what I did.</p>\n</blockquote>",
        "id": 205786826,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596457126
    },
    {
        "content": "<p>julian-seward1 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205790197,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596459533
    },
    {
        "content": "<p><strong>julian-seward1</strong> requested <a href=\"https://github.com/cfallin\">cfallin</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a>.</p>",
        "id": 205796290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596462823
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-460190824\">PR Review</a>.</p>",
        "id": 205820022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596474341
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r464541980\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Tiny nit, but this was very confusing to me for a moment; the difference between the CLIF's <code>AtomicRmwOp</code> and the aarch64 <code>Inst</code>'s <code>AtomicRMWOp</code> is just capitalization. Perhaps <code>use crate::ir</code> and then write <code>ir::AtomicRmwOp</code> here, for clarity?</p>\n</blockquote>",
        "id": 205820023,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596474341
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-460190824\">PR Review</a>.</p>",
        "id": 205820024,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596474341
    },
    {
        "content": "<p>julian-seward1 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a> from <code>atomics-CL</code> to <code>main</code>:</p>\n<blockquote>\n<p>The implementation is pretty straightforward.  Wasm atomic instructions fall<br>\ninto 5 groups</p>\n<ul>\n<li>atomic read-modify-write</li>\n<li>atomic compare-and-swap</li>\n<li>atomic loads</li>\n<li>atomic stores</li>\n<li>fences</li>\n</ul>\n<p>and the implementation mirrors that structure, at both the CLIF and AArch64<br>\nlevels.</p>\n<p>At the CLIF level, there are five new instructions, one for each group.  Some<br>\ncomments about these:</p>\n<ul>\n<li>\n<p>for those that take addresses (all except fences), the address is contained<br>\n  entirely in a single <code>Value</code>; there is no offset field as there is with<br>\n  normal loads and stores.  Wasm atomics require alignment checks, and<br>\n  removing the offset makes implementation of those checks a bit simpler.</p>\n</li>\n<li>\n<p>atomic loads and stores get their own instructions, rather than reusing the<br>\n  existing load and store instructions, for two reasons:</p>\n<ul>\n<li>\n<p>per above comment, makes alignment checking simpler</p>\n</li>\n<li>\n<p>reuse of existing loads and stores would require extension of <code>MemFlags</code><br>\n  to indicate atomicity, which sounds semantically unclean.  For example,<br>\n  then <em>any</em> instruction carrying <code>MemFlags</code> could be marked as atomic, even<br>\n  in cases where it is meaningless or ambiguous.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>I tried to specify, in comments, the behaviour of these instructions as<br>\n  tightly as I could.  Unfortunately there is no way (per my limited CLIF<br>\n  knowledge) to enforce the constraint that they may only be used on I8, I16,<br>\n  I32 and I64 types, and in particular not on floating point or vector types.</p>\n</li>\n</ul>\n<p>The translation from Wasm to CLIF, in <code>code_translator.rs</code> is unremarkable.</p>\n<p>At the AArch64 level, there are also five new instructions, one for each<br>\ngroup.  All of them except <code>::Fence</code> contain multiple real machine<br>\ninstructions.  Atomic r-m-w and atomic c-a-s are emitted as the usual<br>\nload-linked store-conditional loops, guarded at both ends by memory fences.<br>\nAtomic loads and stores are emitted as a load preceded by a fence, and a store<br>\nfollowed by a fence, respectively.  The amount of fencing may be overkill, but<br>\nit reflects exactly what the SM Wasm baseline compiler for AArch64 does.</p>\n<p>One reason to implement r-m-w and c-a-s as a single insn which is expanded<br>\nonly at emission time is that we must be very careful what instructions we<br>\nallow in between the load-linked and store-conditional.  In particular, we<br>\ncannot allow <em>any</em> extra memory transactions in there, since -- particularly<br>\non low-end hardware -- that might cause the transaction to fail, hence<br>\ndeadlocking the generated code.  That implies that we can't present the LL/SC<br>\nloop to the register allocator as its constituent instructions, since it might<br>\ninsert spills anywhere.  Hence we must present it as a single indivisible<br>\nunit, as we do here.  It also has the benefit of reducing the total amount of<br>\nwork the RA has to do.</p>\n<p>The only other notable feature of the r-m-w and c-a-s translations into<br>\nAArch64 code, is that they both need a scratch register internally.  Rather<br>\nthan faking one up by claiming, in <code>get_regs</code> that it modifies an extra<br>\nscratch register, and having to have a dummy initialisation of it, these new<br>\ninstructions (<code>::LLSC</code> and <code>::CAS</code>) simply use fixed registers in the range<br>\nx24-x28.  We rely on the RA's ability to coalesce V&lt;--&gt;R copies to make the<br>\ncost of the resulting extra copies zero or almost zero.  x24-x28 are chosen so<br>\nas to be call-clobbered, hence their use is less likely to interfere with long<br>\nlive ranges that span calls.</p>\n<p>One subtlety regarding the use of completely fixed input and output registers<br>\nis that we must be careful how the surrounding copy from/to of the arg/result<br>\nregisters is done.  In particular, it is not safe to simply emit copies in<br>\nsome arbitrary order if one of the arg registers is a real reg.  For that<br>\nreason, the arguments are first moved into virtual regs if they are not<br>\nalready there, using a new method <code>&lt;LowerCtx for Lower&gt;::ensure_in_vreg</code>.<br>\nAgain, we rely on coalescing to turn them into no-ops in the common case.</p>\n<p>There is also a ridealong fix for the AArch64 lowering case for<br>\n<code>Opcode::Trapif | Opcode::Trapff</code>, which removes a bug in which two trap insns<br>\nin a row were generated.</p>\n<p>In the patch as submitted there are 6 \"FIXME JRS\" comments, which mark things<br>\nwhich I believe to be correct, but for which I would appreciate a second<br>\nopinion.  Unless otherwise directed, I will remove them for the final commit<br>\nbut leave the associated code/comments unchanged.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 205877620,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596523345
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#pullrequestreview-460535584\">PR Review</a>.</p>",
        "id": 205877641,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596523395
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077#discussion_r464833051\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Er, well spotted.  I didn't even notice.  Must have looked as if I'd simply written the identity function for atomic RMW ops :-)</p>\n</blockquote>",
        "id": 205877642,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596523395
    },
    {
        "content": "<p>julian-seward1 merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2077\">PR #2077</a>.</p>",
        "id": 205880062,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596526552
    }
]