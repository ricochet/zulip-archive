[
    {
        "content": "<p>kpreisser opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <code>Environment.FailFast()</code>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/187\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>\n</blockquote>",
        "id": 314724235,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670519804
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/187\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>\n</blockquote>",
        "id": 314724705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670519948
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/187\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/187</a> for an example.</p>\n</blockquote>",
        "id": 314724788,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670519972
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, it seems that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/187\">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>\n</blockquote>",
        "id": 314724864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670519998
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/187\">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>\n</blockquote>",
        "id": 314725058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670520044
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343050650\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Using <code>panic=abort</code> for the C api is not enough. You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern \"C\"</code> is UB. In the future unwinding out from an <code>extern \"C\"</code> rust function will abort independent of the panic mode, but unwinding into rust from a function declared as <code>extern \"C\"</code> is still UB.</p>\n</blockquote>",
        "id": 314725191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670520081
    },
    {
        "content": "<p>kpreisser <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343059110\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi  @bjorn3, thanks for your reply!</p>\n<blockquote>\n<p>You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern \"C\"</code> is UB.</p>\n</blockquote>\n<p>If I understand you correctly, that should already be the case in <code>wasmtime-dotnet</code>, as it uses a <code>catch (Exception ex)</code> clause at wasmtime callbacks (e.g. defined with <code>wasmtime_func_new</code> or <code>wasmtime_func_new_unchecked</code>), to ensure no unwinding can happen beyond the native-to-managed transition (see the referenced issue in the footnote for an example where this still happend previously but was fixed).</p>\n<p>Thanks!</p>\n</blockquote>",
        "id": 314726795,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670520521
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> itself: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]</p>\n<p>Now, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/187\">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>\n</blockquote>",
        "id": 314728595,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670521027
    },
    {
        "content": "<p>kpreisser edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343059110\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi  @bjorn3, thanks for your reply!</p>\n<blockquote>\n<p>You also need to catch exceptions thrown from the .NET side as unwinding through <code>extern \"C\"</code> is UB.</p>\n</blockquote>\n<p>If I understand you correctly, that should already be the case in <code>wasmtime-dotnet</code>, as it uses a <code>catch (Exception ex)</code> clause at wasmtime callbacks (e.g. defined with <code>wasmtime_func_new</code> or <code>wasmtime_func_new_unchecked</code>), to ensure no unwinding can happen beyond the native-to-managed transition (see the referenced issue in the footnote for an example where this still happend previously but has been fixed).</p>\n<p>Thanks!</p>\n</blockquote>",
        "id": 314739687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670523323
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1343220252\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>I agree that changing to <code>panic=abort</code> is the best solution here. This will get a bit tricky with CI since it will require a lot of new artifacts to be built (can't share <code>panic=abort</code> and <code>panic=unwind</code>), but otherwise should be easy enough to configure at least.</p>\n</blockquote>",
        "id": 314751447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670526857
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> if user code actually doesn't intend to catch <code>SEHException</code>: When a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]<br>\nNow, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/187\">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>\n</blockquote>",
        "id": 314755055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670527945
    },
    {
        "content": "<p>kpreisser edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Hi!</p>\n<p>(Please note that I don't know much about Rust, so please correct me if I'm saying anything that doesn't make sense.)</p>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/192\">bytecodealliance/wasmtime-dotnet#192</a>, we found that on <strong>Windows</strong>, when a panic occurs in the Wasmtime C API, it will raise an SEH Exception (e.g. with Win32's <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\"><code>RaiseException</code></a> or <a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/cxxthrowexception?view=msvc-170\"><code>_CxxThrowException</code></a> from the MSVC runtime).</p>\n<p>However, because .NET appears to use the same mechanism to handle exceptions, such a panic will surface as <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.sehexception\"><code>SEHException</code></a> in a .NET application on the managed-to-native transition, which can be caught by the user if they have e.g. an <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause. This means that in such a case, the process will not actually terminate, but will can continue to run, which could be problematic because we may now have undefined behavior with possible security implications.</p>\n<p>This can even happen in <code>wasmtime-dotnet</code> if user code actually doesn't intend to catch <code>SEHException</code>:<br>\nWhen a .NET exception occurs in a wasm callback, <code>wasmtime-dotnet</code> will catch the exception (by using an <code>catch (Exception ex)</code> clause to catch all .NET exceptions), and transform it into a <code>wasm_trap_t*</code>, which is then returned at the native wasmtime callback. [^1]<br>\nNow, imagine there is a host-to-wasm and a wasm-to-host transition on the stack, and you call a wasmtime function that panics, resulting in a <code>SEHException</code> on Windows on the managed-to-native transition. Even if the user code on top of the wasm-to-host transition doesn't have a <code>catch (Exception)</code> or <code>catch (SEHException)</code> clause, the <code>SEHException</code> will be caught by <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/blob/972ef243be61ae60bf231fd22efd539456fbd819/src/Function.cs#L1959-L1962\"><code>Function</code>'s callback handler</a> and transformed into a <code>wasm_trap_t*</code>, which is then reported at the managed-to-native transition (like <code>wasmtime_call_func</code>) as <code>wasmtime_error_t*</code>, and that is thrown in .NET code as a <code>WasmtimeException</code>.<br>\nSo even if you just use <code>catch (WasmtimeException ...)</code> e.g. around <code>Function.Invoke()</code> (as it is expected that such an exception may be thrown here), it can happen that you catch a Rust panic that was actually intended to terminate the process.</p>\n<p>On Windows there is an alternative function <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raisefailfastexception\"><code>RaiseFailFastException</code></a>, which bypasses all exception handlers and ensures the process is terminated (I assume this is also e.g. what .NET internally does in <a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.environment.failfast?view=net-6.0#system-environment-failfast(system-string)\"><code>Environment.FailFast()</code></a>).<br>\nFrom Rust PR <a href=\"https://github.com/rust-lang/rust/issues/32900\">rust-lang/rust#32900</a>, I understand that there is another panic mode (<code>abort</code>) which would have a similar effect to calling <code>RaiseFailFastException</code>.</p>\n<p>Quoting @peterhuene from <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790\">https://github.com/bytecodealliance/wasmtime-dotnet/pull/192#issuecomment-1341345790</a> (please see the conversation there for more background on this in <code>wasmtime-dotnet</code>):</p>\n<blockquote>\n<p>That said, I do think changing the panic mode for the C API to abort would make the most sense to address this issue. Would you mind opening an issue in the Wasmtime repo to explore doing so and reference this conversation?</p>\n</blockquote>\n<p>Would it be possible to change the panic mode for the C API to <code>abort</code>, to ensure on Windows the process is terminated when a panic occurs?<br>\n(Note that e.g. on Linux, this is what already happens in .NET applications using <code>wasmtime-dotnet</code>, since the CLR cannot catch the panic there.)</p>\n<p>Thank you!</p>\n<p>[^1]: This ensures we don't let any .NET exception bubble through the native-to-managed transition. If <code>wasmtime-dotnet</code> wouldn't catch an exception thrown in .NET code, on Windows, the .NET CLR would unwind the stack up to the next .NET exception handler (that catches this exception type) even if there are managed-to-native and native-to-managed transitions on the stack, which seems to be incompatible with Wasmtime - see <a href=\"https://github.com/bytecodealliance/wasmtime-dotnet/issues/187\">bytecodealliance/wasmtime-dotnet#187</a> for an example.</p>\n</blockquote>",
        "id": 314755098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670527961
    },
    {
        "content": "<p>Muon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1365587677\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<blockquote>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n</blockquote>\n<p>To my understanding, this is not the case. A panic is a sign that whatever you tried to do was incorrect, and that logical invariants may not be upheld any more. However, <code>catch_unwind()</code> is not <code>unsafe</code>. Therefore, if you panic, it's your responsibility to ensure that UB cannot happen if the panic is caught and execution continues.</p>\n</blockquote>",
        "id": 318031284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672112775
    },
    {
        "content": "<p>Muon edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1365587677\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<blockquote>\n<p>As far as I understand panics in Rust, they indicate that an unrecoverable/serious error has occured, after which the process should be terminated (to not run into undefined behavior).</p>\n</blockquote>\n<p>To my understanding, this is not the case. A panic is a sign that whatever you tried to do was incorrect, and that logical invariants may not be upheld any more. However, <code>catch_unwind()</code> is not <code>unsafe</code>. Therefore, if you panic in a safe function, it's your responsibility to ensure that UB cannot happen if the panic is caught and execution continues.</p>\n</blockquote>",
        "id": 318031297,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672112807
    },
    {
        "content": "<p>rockwotj <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">unable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n<span class=\"nc\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>:     <span class=\"nc\">Cannot</span><span class=\"w\"> </span><span class=\"n\">allocate</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">)</span><span class=\"o\">'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">jit</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">code_memory</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">254</span>:<span class=\"mi\">18</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">fatal</span><span class=\"w\"> </span><span class=\"n\">runtime</span><span class=\"w\"> </span><span class=\"n\">error</span>: <span class=\"nc\">Rust</span><span class=\"w\"> </span><span class=\"n\">panics</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">rethrown</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Aborting</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41\">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41</a></p>\n</blockquote>",
        "id": 390973140,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1694707148
    },
    {
        "content": "<p>rockwotj edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">unable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n<span class=\"nc\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>:     <span class=\"nc\">Cannot</span><span class=\"w\"> </span><span class=\"n\">allocate</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">)</span><span class=\"o\">'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">jit</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">code_memory</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">254</span>:<span class=\"mi\">18</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">fatal</span><span class=\"w\"> </span><span class=\"n\">runtime</span><span class=\"w\"> </span><span class=\"n\">error</span>: <span class=\"nc\">Rust</span><span class=\"w\"> </span><span class=\"n\">panics</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">rethrown</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Aborting</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? </p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41\">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32C26-L32C41</a></p>\n</blockquote>",
        "id": 390973223,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1694707177
    },
    {
        "content": "<p>rockwotj edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719728836\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>I'm not sure if this is the right issue, but I'm using the C API and would like to handle panics. I'm seeing cases where there are panics if there is no memory left to allocate memory: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">thread</span><span class=\"w\"> </span><span class=\"o\">'&lt;</span><span class=\"n\">unnamed</span><span class=\"o\">&gt;'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">unable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">executable</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n<span class=\"nc\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>:     <span class=\"nc\">Cannot</span><span class=\"w\"> </span><span class=\"n\">allocate</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">)</span><span class=\"o\">'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">jit</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">code_memory</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">254</span>:<span class=\"mi\">18</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">note</span>: <span class=\"nc\">run</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">RUST_BACKTRACE</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">fatal</span><span class=\"w\"> </span><span class=\"n\">runtime</span><span class=\"w\"> </span><span class=\"n\">error</span>: <span class=\"nc\">Rust</span><span class=\"w\"> </span><span class=\"n\">panics</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">rethrown</span>\n<span class=\"n\">Sep</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"mi\">14</span>:<span class=\"mi\">49</span>:<span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"o\">-</span><span class=\"n\">node</span><span class=\"o\">-</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">overly</span><span class=\"o\">-</span><span class=\"n\">top</span><span class=\"o\">-</span><span class=\"n\">warthog</span><span class=\"w\"> </span><span class=\"n\">rpk</span><span class=\"p\">[</span><span class=\"mi\">21379</span><span class=\"p\">]</span>: <span class=\"nc\">Aborting</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>I'd like to handle that and not crash the process. Would patches be accepted to handle this specific case in <code>wasmtime_module_new</code> and return an error? </p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32-L40\">https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/c-api/src/module.rs#L32-L40</a></p>\n</blockquote>",
        "id": 390973296,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1694707202
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399#issuecomment-1719774028\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5399\">issue #5399</a>:</p>\n<blockquote>\n<p>Ah for that case specifically the panic is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4f261af155017eae09dc0b86a395090b0dfbf41/crates/jit/src/code_memory.rs#L254\">this call to <code>.expect</code></a> and that's not something you should be catching in the C API but is instead an error which should be bubbled up. If you'd like sending a PR there to use <code>?</code> to bubble up the error I believe would fix that issue (as it'd be returned through the error returned by <code>wasm_module_new</code>)</p>\n</blockquote>",
        "id": 390978550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1694708907
    }
]