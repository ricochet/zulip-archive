[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197770871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589594909
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/bnjbvr\">bnjbvr</a> and <a href=\"https://github.com/julian-seward1\">julian-seward1</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a>.</p>",
        "id": 197770872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589594909
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/bnjbvr\">bnjbvr</a> and <a href=\"https://github.com/julian-seward1\">julian-seward1</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a>.</p>",
        "id": 197770873,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589594909
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197770900,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589594993
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197779960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589610179
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197783256,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589616171
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197830967,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589691837
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197833104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589695870
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197879737,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589764651
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>Creating this PR now to start the review, but I still need to do the following before merging:</p>\n<ul>\n<li>Rebase to latest <code>master</code></li>\n<li>Update vcode filetests (since isel changed)</li>\n<li>Write tests for the island-emission cases of <code>MachBuffer</code></li>\n<li>Update the x64 backend to the slightly-changed isel API (it's disabled at the moment to allow this to compile)</li>\n</ul>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197879805,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589764717
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 197879869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589764812
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413394429\">PR Review</a>.</p>",
        "id": 197921701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802314
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413394429\">PR Review</a>.</p>",
        "id": 197921702,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802314
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426468376\">PR Review Comment</a>:</p>\n<blockquote>\n<p>What does this mean?  Can you clarify the semantics?  When is it used?</p>\n</blockquote>",
        "id": 197921703,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802314
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426469354\">PR Review Comment</a>:</p>\n<blockquote>\n<p>nit: it would be better not to use the word <code>Load</code> here since it's not a load.  Maybe <code>Compute</code> ?</p>\n</blockquote>",
        "id": 197921704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426471121\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could you add some details to say what the island consists of?  More generally, is there a top level description of the islands-and-deadlines algorithm somewhere?</p>\n</blockquote>",
        "id": 197921705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426473004\">PR Review Comment</a>:</p>\n<blockquote>\n<p>What if <code>ty</code> is a vector type?  Then <code>Inst::load_constant</code> doesn't sound right to me.  Is there some guarantee that this won't get called with such a type?  If not, can you assert/panic it out?</p>\n</blockquote>",
        "id": 197921706,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426475641\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Is there any way that this can be automatically cross-checked with reality?  This sounds to me like something that could be violated somewhere down the line, but that would not break anything except in some extremely rare huge-function input, which will make it hard to track down.  So some (any?) kind of cross-check scheme would be a Good Thing.</p>\n<p>If not possible, at least add a load comment at the top of the insn emitter to the effect that it <em>must</em> comply with what is claimed here.</p>\n</blockquote>",
        "id": 197921707,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426477124\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Interpreted signed or unsigned?</p>\n</blockquote>",
        "id": 197921708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426510592\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That doesn't read quite right; is it correct?</p>\n</blockquote>",
        "id": 197921709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426502172\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is a bit unclear; could you make it more precise?  Is there a 1:1 mapping from CLIR blocks to VCode blocks?  The use of \"subgraphs\" implies there isn't, but there's no clarification of the meaning of \"subgraphs\" here.</p>\n</blockquote>",
        "id": 197921710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426499129\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Does <code>(emit island with guard jump if needed)</code> refer to the 6 insns that follow (I think so), or does it denote further insns that need to be emitted (I think not) ?  It would be good to make this clearer in the comment.</p>\n</blockquote>",
        "id": 197921711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426524453\">PR Review Comment</a>:</p>\n<blockquote>\n<p>\"freely permuted\" .. surely they'd have to maintain the same data dependency relationships?</p>\n</blockquote>",
        "id": 197921712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426526820\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Since forgetting to do this might be a common mistake, can you say here how the system will fail should one forget to do that?</p>\n</blockquote>",
        "id": 197921713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426524657\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For the sake of clarity, could you add \"CLIR\" before \"instructions\" ?</p>\n</blockquote>",
        "id": 197921714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426531501\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Can you add a 1 liner comment saying what this does?</p>\n</blockquote>",
        "id": 197921715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426532609\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>tmp</code> doesn't give a big enough hint what this does.  A better name would be <code>new_vreg</code>.</p>\n</blockquote>",
        "id": 197921716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589802315
    },
    {
        "content": "<p>julian-seward1 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426475641\">PR Review Comment</a>.</p>",
        "id": 197925229,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589804233
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413539586\">PR Review</a>.</p>",
        "id": 197927249,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589805070
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413539586\">PR Review</a>.</p>",
        "id": 197927250,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589805070
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426587566\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Is this definition of <code>is64</code> right?  That seems like it's an unsigned criterion, but the general rule on Intel for 32-bit immediate fields is that they are sign extended to 64 bits as appropriate.  If this logic simply moved from elsewhere in this patch, then leave it as is; but otherwise maybe change to the signed variant, using <code>low32willSXto64</code> ?</p>\n</blockquote>",
        "id": 197927251,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589805071
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426583981\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This change concerns me somewhat.  What guarantees that this assertion can't fail now?</p>\n</blockquote>",
        "id": 197927252,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589805071
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426588893\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I feel like it's a shame to lose this, because it means losing the ability to easily differentiate legitimate failures due to non-implementation of a target-independent CLIR insn, vs bugs resulting in machine-specific CLIRs being handed to us.</p>\n</blockquote>",
        "id": 197927253,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589805071
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413725103\">PR Review</a>.</p>",
        "id": 197954693,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589817178
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426727598\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh, these <code>X86*</code> opcodes went away in the latest <code>master</code>, so this is just a rebase-related change. I think the rule is still (as has always been) never have a fallthrough in the big-opcode-match, and handle additions or deletions as they come, indicated by compile errors -- so if any machine-specific ops are added back in the future, we'll figure out what to do then.</p>\n</blockquote>",
        "id": 197954694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589817179
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413984037\">PR Review</a>.</p>",
        "id": 198004267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841493
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426929691\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Nothing guarantees it, but this form (<code>ResolvedOffset</code>) is used only when the lowering explicitly selects it, now; ordinary branches don't go through this code (the <code>LabelUse</code> handles them instead, and we can implement 64-bit long-form veneers there if we think we need &gt;2GB code-size).</p>\n</blockquote>",
        "id": 198004269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841493
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413984370\">PR Review</a>.</p>",
        "id": 198004331,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841545
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426929950\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think so, or at least, this was existing logic in the <code>Iconst</code> lowering prior to this patch:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/a75377565f830052094aa8aa72c5e7a6b787fa18/cranelift/codegen/src/isa/x64/lower.rs#L116\">https://github.com/bytecodealliance/wasmtime/blob/a75377565f830052094aa8aa72c5e7a6b787fa18/cranelift/codegen/src/isa/x64/lower.rs#L116</a></p>\n</blockquote>",
        "id": 198004333,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841545
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 198004493,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841640
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985014\">PR Review</a>.</p>",
        "id": 198004494,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841642
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426930472\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Was part of the old API, but no reason not to rename here :-) Now it's <code>alloc_tmp()</code>.</p>\n</blockquote>",
        "id": 198004495,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841642
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985073\">PR Review</a>.</p>",
        "id": 198004508,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841651
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426930520\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done!</p>\n</blockquote>",
        "id": 198004509,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841651
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985193\">PR Review</a>.</p>",
        "id": 198004534,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841669
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426930634\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 198004535,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841669
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985429\">PR Review</a>.</p>",
        "id": 198004585,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841700
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426930859\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yep, modulo true deps; clarified.</p>\n</blockquote>",
        "id": 198004586,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841700
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985497\">PR Review</a>.</p>",
        "id": 198004606,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841711
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426930902\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Was correct but probably too terse; fixed.</p>\n</blockquote>",
        "id": 198004607,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841711
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985709\">PR Review</a>.</p>",
        "id": 198004676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841740
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426931059\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hopefully the ASCII art and additional explanation help! This is pretty subtle so I'm happy to clarify further if needed.</p>\n</blockquote>",
        "id": 198004679,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841740
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985821\">PR Review</a>.</p>",
        "id": 198004706,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841756
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426931143\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Added some more docs on <code>EmitIsland</code> to clarify.</p>\n</blockquote>",
        "id": 198004707,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841757
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413985912\">PR Review</a>.</p>",
        "id": 198004720,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841767
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426931226\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Signed (clarified).</p>\n</blockquote>",
        "id": 198004721,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841767
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413986061\">PR Review</a>.</p>",
        "id": 198004741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841792
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426931358\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Good idea! I added a debug assert to <code>Inst::emit()</code> that verifies that no more than <code>worst_case_size()</code> bytes were emitted.</p>\n</blockquote>",
        "id": 198004742,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841792
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413986137\">PR Review</a>.</p>",
        "id": 198004756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841806
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426931419\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Added assert.</p>\n</blockquote>",
        "id": 198004757,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589841806
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413994528\">PR Review</a>.</p>",
        "id": 198006209,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843062
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426938845\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Added to the top of <code>machinst/buffer.rs</code>.</p>\n</blockquote>",
        "id": 198006210,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843063
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 198006212,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843067
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413994637\">PR Review</a>.</p>",
        "id": 198006224,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843079
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426938928\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 198006226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843079
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413994865\">PR Review</a>.</p>",
        "id": 198006257,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843115
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426939138\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Clarified; this is the same as the original \"lowered\" form, but we just call out the actual semantics and purpose a bit more explicitly now rather than conflating it with the branch-lowering process.</p>\n</blockquote>",
        "id": 198006259,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843115
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-413995023\">PR Review</a>.</p>",
        "id": 198006281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843139
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#discussion_r426939266\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 198006282,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843139
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 198006364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843205
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 198006378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589843226
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a> from <code>machinst-codebuffer</code> to <code>master</code>:</p>\n<blockquote>\n<p>tl;dr: new new-isel; better block-ordering, handling branches in one pass. 24% faster compile+run on bz2 (28% fewer instructions); 10% faster compile (10% fewer instructions).</p>\n<p>This patch includes:</p>\n<ul>\n<li>\n<p>A complete rework of the way that CLIF blocks and edge blocks are<br>\n  lowered into VCode blocks. The new mechanism in <code>BlockLoweringOrder</code><br>\n  computes RPO over the CFG, but with a twist: it merges edge blocks intto<br>\n  heads or tails of original CLIF blocks wherever possible, and it does<br>\n  this without ever actually materializing the full nodes-plus-edges<br>\n  graph first. The backend driver lowers blocks in final order so<br>\n  there's no need to reshuffle later.</p>\n</li>\n<li>\n<p>A new <code>MachBuffer</code> that replaces the <code>MachSection</code>. This is a special<br>\n  version of a code-sink that is far more than a humble <code>Vec&lt;u8&gt;</code>. In<br>\n  particular, it keeps a record of label definitions and label uses,<br>\n  with a machine-pluggable <code>LabelUse</code> trait that defines various types<br>\n  of fixups (basically internal relocations).</p>\n<p>Importantly, it implements some simple peephole-style branch rewrites<br>\n<em>inline in the emission pass</em>, without any separate traversals over<br>\nthe code to use fallthroughs, swap taken/not-taken arms, etc. It<br>\ntracks branches at the tail of the buffer and can (i) remove blocks<br>\nthat are just unconditional branches (by redirecting the label), (ii)<br>\nunderstand a conditional/unconditional pair and swap the conditional<br>\npolarity when it's helpful; and (iii) remove branches that branch to<br>\nthe fallthrough PC.</p>\n<p>The <code>MachBuffer</code> also implements branch-island support. On<br>\narchitectures like AArch64, this is needed to allow conditional<br>\nbranches within plausibly-attainable ranges (+/- 1MB on AArch64<br>\nspecifically). It also does this inline while streaming through the<br>\nemission, without any sort of fixpoint algorithm or later moving of<br>\ncode, by simply tracking outstanding references and \"deadlines\" and<br>\nemitting an island just-in-time when we're in danger of going out of<br>\nrange.</p>\n</li>\n<li>\n<p>A rework of the instruction selector driver. This is largely following<br>\n  the same algorithm as before, but is cleaned up significantly, in<br>\n  particular in the API: the machine backend can ask for an input arg<br>\n  and get any of three forms (constant, register, producing<br>\n  instruction), indicating it needs the register or can merge the<br>\n  constant or producing instruction as appropriate. This new driver<br>\n  takes special care to emit constants right at use-sites (and at phi<br>\n  inputs), minimizing their live-ranges, and also special-cases the<br>\n  \"pinned register\" to avoid superfluous moves.</p>\n</li>\n</ul>\n<p>Overall, on <code>bz2.wasm</code>, the results are:</p>\n<div class=\"codehilite\"><pre><span></span><code>    wasmtime full run (compile + runtime) of bz2:\n\n    baseline:   9774M insns, 9742M cycles, 3.918s\n    w/ changes: 7012M insns, 6888M cycles, 2.958s  (24.5% faster, 28.3% fewer insns)\n\n    clif-util wasm compile bz2:\n\n    baseline:   2633M insns, 3278M cycles, 1.034s\n    w/ changes: 2366M insns, 2920M cycles, 0.923s  (10.7% faster, 10.1% fewer insns)\n\n    All numbers are averages of two runs on an Ampere eMAG.\n</code></pre></div>\n\n\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 198007459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589844349
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718#pullrequestreview-414095295\">PR Review</a>.</p>",
        "id": 198021580,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589862997
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1718\">PR #1718</a>.</p>",
        "id": 198072095,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589897844
    }
]