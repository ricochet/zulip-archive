[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>When permitted by the ABI and optimization goals, implement omitting frame pointers in Cranelift and add an option for forcing the establishment of frame pointers.</p>\n<h4>Benefit</h4>\n<p>Some supported ABIs do not need a frame pointer for debugging or unwinding purposes.  Moderns compilers that target such ABIs tend to omit the frame pointer by default or when doing so is permissible (e.g. based on an optimization goal).</p>\n<p>Omitting the frame pointer might free up an additional general purpose register to use (e.g. RBP for x86-64).  It may also lead to more compact and efficient code depending on the function.</p>\n<p>See #1149 and #1105 for some other discussions around this issue.</p>\n<h4>Implementation</h4>\n<p>As frame pointers might be useful to some third-party tools, add a Cranelift compiler option for forcing the use of frame pointers in prologues/epilogues (an analogue to <code>-fno-omit-frame-pointer</code>).  It should default to <code>false</code>.  For ABIs where a frame pointer is required, this option will have no effect.</p>\n<p>For ABIs where it is permissible to do so, respect the option not being present by omitting the establishment of the frame pointer in the prologue and also the restoring the previous frame pointer in the epilogue. </p>\n<p>Note that, depending on the offsets used relative to a frame pointer vs. the stack pointer, omitting a frame pointer might impact code size by forcing encodings of larger offsets relative to the stack pointer.  Ultimately whether or not a frame pointer is omitted should be based on the impact to the desired optimization goals.  Currently in Cranelift, some ABIs, like Windows and SystemV for x86-64, always establish a frame pointer but are addressing the stack relative to the stack pointer, so omitting the frame pointer won't have any negative impact on code generation size.</p>\n<p>Also note that for certain ABIs, dynamic stack allocations (e.g. <code>alloca</code>) may require a \"frame pointer\" register to denote the base address of the static part of the frame as if it were the stack pointer prior to the first dynamic stack pointer adjustment.  Locals and arguments could be addressed as a positive relative offset from this frame pointer register.  Windows x64, for example, calls this a frame pointer for the purposes of unwinding.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to do what Cranelift does now which is to always establish a frame pointer, which may lead to less efficient code or otherwise unnecessary instructions for every compiled function.</p>\n</blockquote>",
        "id": 281891455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652219725
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073#issuecomment-1563279035\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<p>I think this was addressed by #4469 so I'm going to close it. If I've missed something, feel free to re-open!</p>\n</blockquote>",
        "id": 361127357,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685036577
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>When permitted by the ABI and optimization goals, implement omitting frame pointers in Cranelift and add an option for forcing the establishment of frame pointers.</p>\n<h4>Benefit</h4>\n<p>Some supported ABIs do not need a frame pointer for debugging or unwinding purposes.  Moderns compilers that target such ABIs tend to omit the frame pointer by default or when doing so is permissible (e.g. based on an optimization goal).</p>\n<p>Omitting the frame pointer might free up an additional general purpose register to use (e.g. RBP for x86-64).  It may also lead to more compact and efficient code depending on the function.</p>\n<p>See #1149 and #1105 for some other discussions around this issue.</p>\n<h4>Implementation</h4>\n<p>As frame pointers might be useful to some third-party tools, add a Cranelift compiler option for forcing the use of frame pointers in prologues/epilogues (an analogue to <code>-fno-omit-frame-pointer</code>).  It should default to <code>false</code>.  For ABIs where a frame pointer is required, this option will have no effect.</p>\n<p>For ABIs where it is permissible to do so, respect the option not being present by omitting the establishment of the frame pointer in the prologue and also the restoring the previous frame pointer in the epilogue. </p>\n<p>Note that, depending on the offsets used relative to a frame pointer vs. the stack pointer, omitting a frame pointer might impact code size by forcing encodings of larger offsets relative to the stack pointer.  Ultimately whether or not a frame pointer is omitted should be based on the impact to the desired optimization goals.  Currently in Cranelift, some ABIs, like Windows and SystemV for x86-64, always establish a frame pointer but are addressing the stack relative to the stack pointer, so omitting the frame pointer won't have any negative impact on code generation size.</p>\n<p>Also note that for certain ABIs, dynamic stack allocations (e.g. <code>alloca</code>) may require a \"frame pointer\" register to denote the base address of the static part of the frame as if it were the stack pointer prior to the first dynamic stack pointer adjustment.  Locals and arguments could be addressed as a positive relative offset from this frame pointer register.  Windows x64, for example, calls this a frame pointer for the purposes of unwinding.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to do what Cranelift does now which is to always establish a frame pointer, which may lead to less efficient code or otherwise unnecessary instructions for every compiled function.</p>\n</blockquote>",
        "id": 361127362,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685036578
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073#issuecomment-1563316626\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<p>On x86_64 we still unconditionally preserve the frame pointer even if the option is set to allow omitting them.</p>\n</blockquote>",
        "id": 361134461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685038520
    },
    {
        "content": "<p>fitzgen reopened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>When permitted by the ABI and optimization goals, implement omitting frame pointers in Cranelift and add an option for forcing the establishment of frame pointers.</p>\n<h4>Benefit</h4>\n<p>Some supported ABIs do not need a frame pointer for debugging or unwinding purposes.  Moderns compilers that target such ABIs tend to omit the frame pointer by default or when doing so is permissible (e.g. based on an optimization goal).</p>\n<p>Omitting the frame pointer might free up an additional general purpose register to use (e.g. RBP for x86-64).  It may also lead to more compact and efficient code depending on the function.</p>\n<p>See #1149 and #1105 for some other discussions around this issue.</p>\n<h4>Implementation</h4>\n<p>As frame pointers might be useful to some third-party tools, add a Cranelift compiler option for forcing the use of frame pointers in prologues/epilogues (an analogue to <code>-fno-omit-frame-pointer</code>).  It should default to <code>false</code>.  For ABIs where a frame pointer is required, this option will have no effect.</p>\n<p>For ABIs where it is permissible to do so, respect the option not being present by omitting the establishment of the frame pointer in the prologue and also the restoring the previous frame pointer in the epilogue. </p>\n<p>Note that, depending on the offsets used relative to a frame pointer vs. the stack pointer, omitting a frame pointer might impact code size by forcing encodings of larger offsets relative to the stack pointer.  Ultimately whether or not a frame pointer is omitted should be based on the impact to the desired optimization goals.  Currently in Cranelift, some ABIs, like Windows and SystemV for x86-64, always establish a frame pointer but are addressing the stack relative to the stack pointer, so omitting the frame pointer won't have any negative impact on code generation size.</p>\n<p>Also note that for certain ABIs, dynamic stack allocations (e.g. <code>alloca</code>) may require a \"frame pointer\" register to denote the base address of the static part of the frame as if it were the stack pointer prior to the first dynamic stack pointer adjustment.  Locals and arguments could be addressed as a positive relative offset from this frame pointer register.  Windows x64, for example, calls this a frame pointer for the purposes of unwinding.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to do what Cranelift does now which is to always establish a frame pointer, which may lead to less efficient code or otherwise unnecessary instructions for every compiled function.</p>\n</blockquote>",
        "id": 362258073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685468749
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073#issuecomment-1568830599\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2073\">issue #2073</a>:</p>\n<blockquote>\n<p>Yeah this isn't fully implemented yet.</p>\n</blockquote>",
        "id": 362258107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685468759
    }
]