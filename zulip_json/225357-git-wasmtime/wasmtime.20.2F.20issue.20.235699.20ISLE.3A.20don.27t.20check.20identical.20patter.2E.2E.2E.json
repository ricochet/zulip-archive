[
    {
        "content": "<p>jameysharp opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699\">issue #5699</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>If ISLE sees a pattern like <code>(rule (simplify foo (bar x) (bar x)))</code>, after checking the first <code>(bar x)</code> condition it should check whether the second argument to <code>foo</code> is equal to the first argument. If so, then we know <code>(bar x)</code> will match on the second argument as well, and don't need to check it again. If they arguments are not equal, we should go ahead and check the subpattern like we do today.</p>\n<h4>Benefit</h4>\n<p>These kinds of patterns show up in mid-end optimization rules. During those rules we've already done GVN, so if the pattern matches both values, then the values will be the same. As a result, this proposed optimization should fire a lot.</p>\n<h4>Implementation</h4>\n<p>I haven't thought that hard about this yet.</p>\n</blockquote>",
        "id": 325520945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675382181
    },
    {
        "content": "<p>jameysharp edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699\">issue #5699</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>If ISLE sees a pattern like <code>(rule (simplify foo (bar x) (bar x)))</code>, after checking the first <code>(bar x)</code> condition it should check whether the second argument to <code>foo</code> is equal to the first argument. If so, then we know <code>(bar x)</code> will match on the second argument as well, and don't need to check it again. If the arguments are not equal, we should go ahead and check the subpattern like we do today.</p>\n<h4>Benefit</h4>\n<p>These kinds of patterns show up in mid-end optimization rules. During those rules we've already done GVN, so if the pattern matches both values, then the values will be the same. As a result, this proposed optimization should fire a lot.</p>\n<h4>Implementation</h4>\n<p>I haven't thought that hard about this yet.</p>\n</blockquote>",
        "id": 325520970,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675382200
    },
    {
        "content": "<p>jameysharp edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699\">issue #5699</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>If ISLE sees a pattern like <code>(rule (simplify foo (bar x) (bar x)))</code>, after checking the first <code>(bar x)</code> condition it should check whether the second argument to <code>foo</code> is equal to the first argument. If so, then we know <code>(bar x)</code> will match on the second argument as well, and don't need to check it again. If the arguments are not equal, we should go ahead and check the subpattern like we do today.</p>\n<h4>Benefit</h4>\n<p>These kinds of patterns show up in mid-end optimization rules. During those rules we've already done GVN, so if the pattern matches both values, then the values will be the same. As a result, this proposed optimization should fire a lot.</p>\n<h4>Implementation</h4>\n<p>I haven't thought that hard about this yet.</p>\n<p>This partially undoes a transformation that <code>trie_again</code> does, except that we have to fall back to checking each subpattern in some cases. Looking at that transformation might provide some inspiration.</p>\n</blockquote>",
        "id": 325521242,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675382367
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699#issuecomment-1414719349\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699\">issue #5699</a>:</p>\n<blockquote>\n<p>After discussion with @elliottt, I can see I didn't say this very clearly.</p>\n<p>In ISLE pattern matching, every pattern is \"pure\" in the functional programming sense. In particular, <code>a==b</code> always implies that <code>f(a)==f(b)</code>. So if we've computed <code>f(a)</code> and we check that <code>a==b</code>, we can skip computing <code>f(b)</code> and reuse the result of <code>f(a)</code> instead.</p>\n<p>The reverse isn't true in general though: <code>a!=b</code> does _not_ generally imply that <code>f(a)!=f(b)</code>. So if the check that <code>a==b</code> turns out to be false, we still have to go ahead and compute <code>f(b)</code>.</p>\n<p>We have some extractors and some situations where <code>a==b</code> if _and only if_ <code>f(a)==f(b)</code>. In particular, as long as we've done GVN, this holds for any instruction extractor. It might be interesting to tell ISLE which extractors have this property. That's more complicated to get right than what I'm proposing here, though.</p>\n<p>This proposal is just: If we use the same extractor multiple times in a rule, we may be able to avoid actually calling it more than once in common cases by short-circuiting when we're calling it with arguments which are dynamically the same.</p>\n</blockquote>",
        "id": 325537610,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675392112
    },
    {
        "content": "<p>jameysharp labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5699\">issue #5699</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>If ISLE sees a pattern like <code>(rule (simplify foo (bar x) (bar x)))</code>, after checking the first <code>(bar x)</code> condition it should check whether the second argument to <code>foo</code> is equal to the first argument. If so, then we know <code>(bar x)</code> will match on the second argument as well, and don't need to check it again. If the arguments are not equal, we should go ahead and check the subpattern like we do today.</p>\n<h4>Benefit</h4>\n<p>These kinds of patterns show up in mid-end optimization rules. During those rules we've already done GVN, so if the pattern matches both values, then the values will be the same. As a result, this proposed optimization should fire a lot.</p>\n<h4>Implementation</h4>\n<p>I haven't thought that hard about this yet.</p>\n<p>This partially undoes a transformation that <code>trie_again</code> does, except that we have to fall back to checking each subpattern in some cases. Looking at that transformation might provide some inspiration.</p>\n</blockquote>",
        "id": 345813922,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680223649
    }
]