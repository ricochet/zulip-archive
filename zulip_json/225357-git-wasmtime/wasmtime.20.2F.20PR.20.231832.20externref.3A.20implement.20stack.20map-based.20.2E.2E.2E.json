[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 199944359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591399237
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a>.</p>",
        "id": 199944360,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591399237
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-425726558\">PR Review</a>.</p>",
        "id": 199965771,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-425726558\">PR Review</a>.</p>",
        "id": 199965772,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436253279\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Reminder to uncomment or remove.</p>\n</blockquote>",
        "id": 199965773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436252959\">PR Review Comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>        self.infos.sort_unstable_by_key(|info| info.code_offset);\n</code></pre></div>\n\n\n</blockquote>",
        "id": 199965774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436253498\">PR Review Comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>    /// The range of PCs that this module covers. Different modules must\n</code></pre></div>\n\n\n</blockquote>",
        "id": 199965775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436253760\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Maybe panic in the drop implementation instead and add an unsafe <code>finish</code> function?</p>\n</blockquote>",
        "id": 199965776,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436254103\">PR Review Comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>            flag_builder.enable(&quot;enable_safepoints&quot;).unwrap();\n</code></pre></div>\n\n\n</blockquote>",
        "id": 199965777,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436254059\">PR Review Comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>        if enable {\n            self.flags.enable(&quot;enable_safepoints&quot;).unwrap();\n        }\n</code></pre></div>\n\n\n</blockquote>",
        "id": 199965778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591435874
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-426405883\">PR Review</a>.</p>",
        "id": 200124575,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436832929\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this line can now be removed</p>\n</blockquote>",
        "id": 200124576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-426405883\">PR Review</a>.</p>",
        "id": 200124577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436835077\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We've got a lot of various registries floating around wasmtime, would it be possible to insert this into an existing registry somehow? For example most of the code here looks like it's copying what we do for frame information.</p>\n</blockquote>",
        "id": 200124578,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436836915\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW I've been trying to clean this up over time where <code>Instance</code> doesn't do much memory management of its internals. Is it possible to package up this and the stack map registry elsewhere? I'm not really sure entirely what that would look like but I think it would be best if we could keep <code>Instance</code> having a pretty \"raw\" feeling rather than holding onto various items.</p>\n<p>(e.g. shoving this into <code>Store</code> and passing it through for when we call wasm)</p>\n</blockquote>",
        "id": 200124579,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436837789\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Also, to keep adding to this, I'd like to get around to cleaning up the interrupts part eventually too</p>\n</blockquote>",
        "id": 200124580,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436837239\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Reading over this, I also don't think that this needs to hold onto this information? It looks like the store can hold onto it for all instances?</p>\n</blockquote>",
        "id": 200124581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436839101\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sort of continuing my comment from earlier, but this is an example where it would be great to not have this duplication. Ideally there'd be one \"register stuff\" call, although I'm not sure yet if this is fundamentally required to be two separate steps.</p>\n</blockquote>",
        "id": 200124582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436839293\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Looks like this file become executable?</p>\n</blockquote>",
        "id": 200124583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r436839836\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think I may be missing something, but how come this is stored in an <code>Engine</code>? (vs a <code>Store</code>)</p>\n</blockquote>",
        "id": 200124585,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591634501
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-427354531\">PR Review</a>.</p>",
        "id": 200258549,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591721292
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r437574964\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I really need to figure out why the heck this is happening...</p>\n</blockquote>",
        "id": 200258550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591721292
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200585563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591899841
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200611275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591912091
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200611507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591912253
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a>.</p>",
        "id": 200611555,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591912289
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200614328,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591913834
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-429878689\">PR Review</a>.</p>",
        "id": 200708079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-429878689\">PR Review</a>.</p>",
        "id": 200708080,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439521473\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Perhaps a merge conflict gone wrong?</p>\n</blockquote>",
        "id": 200708081,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439522588\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could the canary business here be moved into <code>catch_traps</code> to avoid some duplication?</p>\n</blockquote>",
        "id": 200708082,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439522070\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'd personally still prefer to avoid having this here if it's sole purpose is to keep the field alive. I think that memory management should be deferred to <code>Store</code></p>\n</blockquote>",
        "id": 200708083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439566773\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This might be a bit more compact as <code>(0..size).map(|_| ...).collect()</code></p>\n</blockquote>",
        "id": 200708084,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439522242\">PR Review Comment</a>:</p>\n<blockquote>\n<p>(same with <code>externref_activations_table</code> above too)</p>\n</blockquote>",
        "id": 200708085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439568002\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I don't actually see this end up getting used anywhere, was this perhaps from a previous iteration?</p>\n</blockquote>",
        "id": 200708086,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439568333\">PR Review Comment</a>:</p>\n<blockquote>\n<p>How is this field used from wasm code? I tried to read over but couldn't find much... It also looked like <code>VMOffsets</code> contained information about the <code>end</code> field below too, but it's not an <code>UnsafeCell</code>?</p>\n</blockquote>",
        "id": 200708088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439571234\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Since this registry only needs to be within a <code>Store</code>, how come this is an <code>RwLock</code> instead of <code>RefCell</code>?</p>\n</blockquote>",
        "id": 200708089,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439573131\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this assert that <code>sp</code> is not null for wasm frames? (help catch bugs in <code>backtrace</code>)</p>\n</blockquote>",
        "id": 200708090,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439580671\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok I confirmed on Zulip, but it sounds like this is planned to get used in the future. I presume that the idea is that with <code>table.get</code> you'd have a fast path for using these two fields to inline the <code>try_insert</code> method, and you'd fallback to an intrinsic for out-of-line growth and such?</p>\n<p>Reading over all this dealing with chunks and such feels a bit overly complicated. Could this perhaps be simplified a bit? I'm thinking that this could perhaps be restructured to something that looks like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">VMExternRefActivationsTable</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// finter into `fast_path_storage`</span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"nc\">UnsafeCell</span><span class=\"o\">&lt;</span><span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">TableElem</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// never changes after creation</span>\n<span class=\"w\">    </span><span class=\"n\">end</span>: <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">TableElem</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// used by `try_insert` and stored via `next` in jit code</span>\n<span class=\"w\">    </span><span class=\"n\">fast_path_storage</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">TableElem</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">imprecise_roots</span>: <span class=\"nc\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">VMExternRef</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">precise_roots</span>: <span class=\"nc\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">VMExternRef</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>where here <code>fast_path_storage</code> is allocated once and never changes. When an overflow of that table happens it's drained and everything is moved into <code>imprecise_roots</code>. That way <code>imprecise_roots</code> is a growing set which deduplicates things (in case you <code>table.get</code> the same thing a bunch of times) and also handles reallocation for us (we don't need to manually double capacities and such).</p>\n<p>On a GC we'd fill in <code>precise_roots</code> and then we'd <code>mem::swap</code> the precise/imprecise sets and then clear the imprecise one. Maybe with some other trickery around optimizing reference counts or something like that.</p>\n<p>I'm mostly hoping that we can simplifiy the <code>chunks</code> list because:</p>\n<ul>\n<li>It seems somewhat complicated to manage, especially if we're trying to be clever about capacities and double them</li>\n<li>I'm a bit worried about the segmented-stacks thrashing problem where you keep allocating a doubly-bigger chunk but then freeing it, when it'd be more efficient to just double the size of the internal chunk.</li>\n<li>Roots aren't deduplicated in the chunks so if you pass around the same <code>VMExternRef</code> a bunch it may accidentally fill them up quite a lot.</li>\n</ul>\n<p>With a persistent hash set I think it'd solve the duplication/capacity issues? Anyway curious what you think about this!</p>\n</blockquote>",
        "id": 200708091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987050
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439581101\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Because of this, could the activation table have a <code>Drop</code> which asserts that the <code>precise_stack_roots</code> set is empty? Otherwise we'd leak data accidentally b/c there's no dtor which drains the map.</p>\n<p>(or maybe we should also assert that all chunks are <code>None</code> since they don't get frobbed on <code>Drop</code> either?)</p>\n</blockquote>",
        "id": 200708093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591987051
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430011071\">PR Review</a>.</p>",
        "id": 200719258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591992758
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439621908\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah, when I get merge conflicts in <code>Cargo.lock</code> I generally just blow it away and let the next build recreate it, but this pulled in that problematic dep update we all talked about a couple days ago. Bleh.</p>\n</blockquote>",
        "id": 200719259,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591992758
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430012246\">PR Review</a>.</p>",
        "id": 200719423,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591992897
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439622764\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It probably doesn't matter in practice, but that would mean the canary is taken from a stack frame that has since been popped</p>\n<p>/me shrugs</p>\n<p>I guess I could switch the API to <code>table.with_stack_canary(|| { ... })</code> instead of an RAII thing? Would be harder to misuse this way too. I think I'll do that.</p>\n</blockquote>",
        "id": 200719424,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591992897
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430021084\">PR Review</a>.</p>",
        "id": 200721282,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591993944
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439629605\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is a good idea, however</p>\n<ul>\n<li>\n<p>we may still want to have the fast-path table grow shrink based on the precise size of the last root set (probably fine to skip for now, but we'll likely want to investigate this in the future)</p>\n</li>\n<li>\n<p>we lose the ability to reclaim memory once we are no longer using excessive capacity in these sets (again, probably fine for now, but we'll likely want to handle this sometime in the future)</p>\n</li>\n</ul>\n</blockquote>",
        "id": 200721283,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591993944
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430062236\">PR Review</a>.</p>",
        "id": 200729957,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591999773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439661638\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Either way's fine by me, I was mostly just hoping that we can encapsulate everything necessary to enter wasm in one function in wasmtime, which currently is <code>catch_traps</code>. I think the <code>with_stack_canary</code> call can be embedded in there too? (we can perhaps rename <code>catch_traps</code> to <code>invoke_wasm</code> or something like that)</p>\n</blockquote>",
        "id": 200729958,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591999773
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430062805\">PR Review</a>.</p>",
        "id": 200730145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591999883
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439662142\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Switching <code>fast_path_storage</code> to a <code>Vec&lt;T&gt;</code> would be an easy way to make the fast-path-table growable (that's a good point, and one thing I was curious how often it would come into play). For shrinking we could periodically call <code>HashSet::shrink_to_fit</code> I think?</p>\n</blockquote>",
        "id": 200730146,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591999883
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430067030\">PR Review</a>.</p>",
        "id": 200731321,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592000692
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439665582\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah. Would be nice if <code>HashSet::shrink_to</code> was stable, so we could shrink capacity by half when the length is a quarter of the capacity, and keep the amortized O(1). We could do <code>shrink_to_fit</code> followed by <code>reserve</code> but this is suboptimal.</p>\n<p>Anyways, I'm just gonna do the simplest thing here for now, and leave that stuff to when we actually see it in profiles.</p>\n</blockquote>",
        "id": 200731322,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592000692
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430083641\">PR Review</a>.</p>",
        "id": 200736744,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592004790
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439679723\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Also, the <code>backtrace</code> update needs these dep updates.</p>\n</blockquote>",
        "id": 200736745,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592004790
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430085715\">PR Review</a>.</p>",
        "id": 200737501,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005446
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439681507\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This runs into the weirdness at the <code>wasmtime</code> and <code>wasmtime-runtime</code> boundary again: this is inside <code>wasmtime-runtime</code> and so it has \"no\" knowledge of <code>Store</code> and whether anything else is holding the table alive for it.</p>\n<p>Would you prefer that <code>InstanceHandle::new</code> took a <code>*mut VMExternRefActivationsTable</code> instead of an <code>Rc</code> and we added this to the safetry invariants required to be maintained for <code>InstanceHandle::new</code>?</p>\n</blockquote>",
        "id": 200737502,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005446
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430085831\">PR Review</a>.</p>",
        "id": 200737523,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005485
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439681607\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Same question as above regarding <code>*mut</code> vs <code>Arc</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832/files?file-filters%5B%5D=.rs#r439681507\">https://github.com/bytecodealliance/wasmtime/pull/1832/files?file-filters%5B%5D=.rs#r439681507</a></p>\n</blockquote>",
        "id": 200737524,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005486
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430086719\">PR Review</a>.</p>",
        "id": 200737850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005761
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439682344\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah I misunderstood what you were asking for in the original comment. This is done now.</p>\n</blockquote>",
        "id": 200737851,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005761
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430087342\">PR Review</a>.</p>",
        "id": 200738061,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005958
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r439682899\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This doesn't work for disabling reference types, and there is no <code>disable</code> function to go along with <code>enable</code> either.</p>\n</blockquote>",
        "id": 200738063,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592005958
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200739683,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592007825
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430804800\">PR Review</a>.</p>",
        "id": 200912856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592238446
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440298838\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It was unnecessary, and is now removed.</p>\n</blockquote>",
        "id": 200912857,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592238446
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430807901\">PR Review</a>.</p>",
        "id": 200913379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592238681
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440301149\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Otherwise <code>Module</code> is not <code>Send</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0277]: `std::cell::RefCell&lt;wasmtime_runtime::externref::StackMapRegistryInner&gt;` cannot be shared between threads safely\n   --&gt; crates/wasmtime/src/module.rs:579:5\n    |\n578 |     fn _assert&lt;T: Send + Sync&gt;() {}\n    |                   ---- required by this bound in `module::_assert_send_sync::_assert`\n579 |     _assert::&lt;Module&gt;();\n    |     ^^^^^^^^^^^^^^^^^ `std::cell::RefCell&lt;wasmtime_runtime::externref::StackMapRegistryInner&gt;` cannot be shared between threads safely\n    |\n    = help: within `wasmtime_runtime::externref::StackMapRegistry`, the trait `std::marker::Sync` is not implemented for `std::cell::RefCell&lt;wasmtime_runtime::externref::StackMapRegistryInner&gt;`\n    = note: required because it appears within the type `wasmtime_runtime::externref::StackMapRegistry`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistry&gt;`\n    = note: required because it appears within the type `wasmtime_runtime::externref::StackMapRegistration`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistration&gt;`\n    = note: required because it appears within the type `std::option::Option&lt;std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistration&gt;&gt;`\n    = note: required because it appears within the type `std::option::Option&lt;std::option::Option&lt;std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistration&gt;&gt;&gt;`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Mutex&lt;std::option::Option&lt;std::option::Option&lt;std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistration&gt;&gt;&gt;&gt;`\n    = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;std::sync::Mutex&lt;std::option::Option&lt;std::option::Option&lt;std::sync::Arc&lt;wasmtime_runtime::externref::StackMapRegistration&gt;&gt;&gt;&gt;&gt;`\n    = note: required because it appears within the type `module::Module`\n</code></pre></div>\n\n\n</blockquote>",
        "id": 200913380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592238681
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200913542,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592238757
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200915137,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592239613
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200915651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592239835
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430903134\">PR Review</a>.</p>",
        "id": 200932289,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430903134\">PR Review</a>.</p>",
        "id": 200932290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440375514\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This seems to have gone backwards? </p>\n<p>(along with a number of other crates?)</p>\n</blockquote>",
        "id": 200932291,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440375239\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW this is likely to break CI <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1813\">until this is fixed</a></p>\n</blockquote>",
        "id": 200932292,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440375682\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Published now!</p>\n</blockquote>",
        "id": 200932293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440377553\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think I commented on this last time too, so sorry if I missed your response in the meantime, but can there be a destructor for this type which debug-asserts that all slots in this <code>chunk</code> are <code>None</code>?</p>\n</blockquote>",
        "id": 200932294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248384
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440378491\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Here on <code>insert_slow_path</code> it always inserts in the hash set, but presumably after <code>gc</code> the chunk is empty?</p>\n</blockquote>",
        "id": 200932295,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440378713\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Also, should this idiom perhaps be encapsulated in a method on the activation table?</p>\n</blockquote>",
        "id": 200932296,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440380949\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah right yeah, I think we probably need to clean up that storge of the registrations in <code>Module</code>, but for now seems fine.</p>\n</blockquote>",
        "id": 200932297,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440381768\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Instead of <code>#[cfg]</code> could this conditionally panic if <code>if cfg!</code> in the implementation of <code>Deref</code> and such?</p>\n</blockquote>",
        "id": 200932298,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440382217\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah sorry missed this earlier, but yeah let's try passing around <code>*mut</code> here instead of an owned pointer.</p>\n</blockquote>",
        "id": 200932299,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440384784\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Perhaps we should take a leaf out of <code>Rc</code>'s book and use <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html#method.strong_count\"><code>strong_count</code></a> for forwards-compatibility with weak references if we ever add them?</p>\n</blockquote>",
        "id": 200932300,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440380599\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To confirm, this for sure works, right? One thing I'd be worried about is rustc's rvalue-promotion where the 0 gets promoted into static data. If you did <code>let canary = &amp;0</code>, for example, I think that'd point into static data rather than on the stack. I'd be a bit worried that eventually if rustc did more mir inlining or something like that it'd inline the definition of <code>canary</code> to here and do the rvalue promotion anyway.</p>\n<p>In any case so long as this works today I'm fine, and I would imagine that if rustc ever changed it would cause tests to fail here too.</p>\n</blockquote>",
        "id": 200932301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440386861\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this'll need to look like <a href=\"https://github.com/bytecodealliance/wasmtime/blob/357fb11f4603afc5f81eb087e00ca9e543ab4db7/crates/wasmtime/src/runtime.rs#L890-L905\"><code>register_jit_code</code></a> ish where we register a compiled module with a <code>Store</code> and metadata about that is stored in <code>Store</code> rather than the <code>Module</code>.</p>\n<p>Honestly we should do this with <code>register_frame_info</code> too, but I can tackle that some other time.</p>\n</blockquote>",
        "id": 200932302,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440382895\">PR Review Comment</a>:</p>\n<blockquote>\n<p>you can probably avoid passing these two parameters explicitly and read them from the passed-in <code>store</code> argument inside the method.</p>\n</blockquote>",
        "id": 200932303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440385209\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Out of curiosity, could we always enable this? Presumably once reference types ships we'll enable this unconditionally anyway.</p>\n</blockquote>",
        "id": 200932304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440384394\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think that this API may actually be incorrect for GC, because you can register a module into two stores. The second store won't actually get registered in its <code>registry</code> which I think means GC won't be precise?</p>\n</blockquote>",
        "id": 200932305,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440388751\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Answering my own question, if my thought earlier about the stack canary and rvalue promotion breaks things this assertion will break. If our stack canary <em>never</em> works then nothing will get gc'd from the above loop.</p>\n</blockquote>",
        "id": 200932306,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592248385
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430955354\">PR Review</a>.</p>",
        "id": 200938708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251604
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440417080\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sorry I didn't mention this, but since switching from the list-of-chunks representation to your new suggested one, the table automatically runs the <code>Drop</code> implementations, so dropping the table will now properly avoid leaks.</p>\n<p>Therefore, I didn't think it was necessary to insert these debug assertions anymore. (Also, inserting them would require that we <code>gc</code> before dropping the table, to ensure that it gets swept. Everything is easier when we can rely on automatic <code>Drop</code>s!)</p>\n</blockquote>",
        "id": 200938709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251604
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430955946\">PR Review</a>.</p>",
        "id": 200938798,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251665
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440417566\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I figured since it is already a slow path, it might as well do de-duplication, rather than use the bump chunk. I can leave a comment to this effect, and also make a method for this idiom.</p>\n</blockquote>",
        "id": 200938800,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251665
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430957636\">PR Review</a>.</p>",
        "id": 200939131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251828
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440418968\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Whoops missed that, nice!</p>\n</blockquote>",
        "id": 200939134,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592251828
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430961254\">PR Review</a>.</p>",
        "id": 200939724,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252161
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440421876\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It does work today (the tests would fail if it didn't, since they are checking the reference counts and asserting that they go down after GC, which means we did sweep the table, which means we saw the canary).</p>\n<p>I agree that it is slightly fragile. I don't know what we could do to avoid it without something like <code>test::blackbox</code> or calling <code>getcontext</code> to get the SP (eww out-of-line call).</p>\n</blockquote>",
        "id": 200939725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252162
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430962340\">PR Review</a>.</p>",
        "id": 200939908,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252269
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440422735\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Then we would need to always have the <code>inner: T</code> member and rely on LLVM to optimize it away when not used in non-<code>cfg(debug_assertions)</code>. Does that sound OK to you?</p>\n</blockquote>",
        "id": 200939910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252269
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430965752\">PR Review</a>.</p>",
        "id": 200940582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252594
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440425300\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah given the limited usage of this I trust LLVM enough to figure everything out.</p>\n</blockquote>",
        "id": 200940583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592252594
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-430983984\">PR Review</a>.</p>",
        "id": 200943953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592254289
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440439480\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Good eye! I didn't realize that a single module could be registered with multiple stores!</p>\n</blockquote>",
        "id": 200943954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592254289
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431001279\">PR Review</a>.</p>",
        "id": 200947241,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592255940
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440453169\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We could, but it implies an additional pass over the IR by cranelift, and if we know there aren't any being used, then we can skip that unnecessary work.</p>\n</blockquote>",
        "id": 200947243,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592255940
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431001540\">PR Review</a>.</p>",
        "id": 200947271,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592255965
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440453352\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah, yep, I see you figured it out :)</p>\n</blockquote>",
        "id": 200947273,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592255966
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200947415,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256057
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200947832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256268
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431005092\">PR Review</a>.</p>",
        "id": 200947935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256345
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440456259\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Okay the new version fixes this by registering with the store, rather than with the module. This also means that we can get rid of <code>StackMapRegistration</code> entirely, and can instead rely on the store to keep the registry itself alive!</p>\n</blockquote>",
        "id": 200947936,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256346
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431005125\">PR Review</a>.</p>",
        "id": 200947943,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256350
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440456291\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This seems fine for now, but I wanted to point this out because that optimization is something we need to likely implement in short order in that case. In theory there should be a fast path for functions which don't use anyref?</p>\n<p>Put another way, if this is scoped to only reference types for performance reasons, then we need to file an issue about that and get it fixed before fully shipping reference types.</p>\n</blockquote>",
        "id": 200947944,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256351
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431010319\">PR Review</a>.</p>",
        "id": 200948984,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256909
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440460395\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Filed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1883\">https://github.com/bytecodealliance/wasmtime/issues/1883</a></p>\n</blockquote>",
        "id": 200948986,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592256909
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431022995\">PR Review</a>.</p>",
        "id": 200951801,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431022995\">PR Review</a>.</p>",
        "id": 200951802,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440471123\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think at this point this can be <code>RefCell</code>?</p>\n</blockquote>",
        "id": 200951803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440470538\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Since these strong references are dropped here, could this either take<code> &amp;...</code> or plumb through the <code>*mut</code> business?</p>\n</blockquote>",
        "id": 200951804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440472392\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To confirm, is every function guaranteed to have a stack map, even if it doesn't use reference types?</p>\n</blockquote>",
        "id": 200951806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440472175\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this can be <code>RefCell</code> now?</p>\n</blockquote>",
        "id": 200951807,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440473125\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Mind throwing a <code>cfg!</code> here for the target pointer width? (and below too)</p>\n</blockquote>",
        "id": 200951808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440472752\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh dear this is nasty, can we load flags from the <code>Store</code> instead of trying to recreate them here though?</p>\n</blockquote>",
        "id": 200951809,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258752
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440472974\">PR Review Comment</a>:</p>\n<blockquote>\n<p>(in that I think we have a <code>Box&lt;dyn TargetIsa&gt;</code> shoved somewhere in there I think</p>\n</blockquote>",
        "id": 200951810,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592258753
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440482850\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Good eye, this is a bug introduced during all the refactoring today. I'm going to just make <code>StackMapRegistry::register_stack_maps</code> idempotent, rather than trying to check if its already registered here. This is a nice little clean up, since the registry is in the best position to answer this question anyways.</p>\n</blockquote>",
        "id": 200953875,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592260290
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431037551\">PR Review</a>.</p>",
        "id": 200953876,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592260290
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200954492,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592260789
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200956414,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592262406
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200956459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592262470
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200958693,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592264318
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200958992,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592264637
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a> from <code>externref-stack-maps</code> to <code>master</code>:</p>\n<blockquote>\n<p>For host VM code, we use plain reference counting, where cloning increments the reference count, and dropping decrements it. We can avoid many of the on-stack increment/decrement operations that typically plague the performance of reference counting via Rust's ownership and borrowing system. Moving a <code>VMExternRef</code> avoids mutating its reference count, and borrowing it either avoids the reference count increment or delays it until if/when the <code>VMExternRef</code> is cloned.</p>\n<p>When passing a <code>VMExternRef</code> into compiled Wasm code, we don't want to do reference count mutations for every compiled <code>local.{get,set}</code>, nor for every function call. Therefore, we use a variation of <strong>deferred reference counting</strong>, where we only mutate reference counts when storing <code>VMExternRef</code>s somewhere that outlives the activation: into a global or table. Simultaneously, we over-approximate the set of <code>VMExternRef</code>s that are inside Wasm function activations. Periodically, we walk the stack at GC safe points, and use stack map information to precisely identify the set of <code>VMExternRef</code>s inside Wasm activations. Then we take the difference between this precise set and our over-approximation, and decrement the reference count for each of the <code>VMExternRef</code>s that are in our over-approximation but not in the precise set. Finally, the over-approximation is replaced with the precise set.</p>\n<p>The <code>VMExternRefActivationsTable</code> implements the over-approximized set of <code>VMExternRef</code>s referenced by Wasm activations. Calling a Wasm function and passing it a <code>VMExternRef</code> moves the <code>VMExternRef</code> into the table, and the compiled Wasm function logically \"borrows\" the <code>VMExternRef</code> from the table. Similarly, <code>global.get</code> and <code>table.get</code> operations clone the gotten<br>\n<code>VMExternRef</code> into the <code>VMExternRefActivationsTable</code> and then \"borrow\" the reference out of the table.</p>\n<p>When a <code>VMExternRef</code> is returned to host code from a Wasm function, the host increments the reference count (because the reference is logically \"borrowed\" from the <code>VMExternRefActivationsTable</code> and the reference count from the table will be dropped at the next GC).</p>\n<p>For more general information on deferred reference counting, see <em>An Examination of Deferred Reference Counting and Cycle Detection</em> by Quinane: <a href=\"https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf\">https://openresearch-repository.anu.edu.au/bitstream/1885/42030/2/hon-thesis.pdf</a></p>\n<p>cc #929</p>\n<p>Fixes #1804</p>\n<p>Depends on <a href=\"https://github.com/rust-lang/backtrace-rs/pull/341\">https://github.com/rust-lang/backtrace-rs/pull/341</a></p>\n</blockquote>",
        "id": 200962993,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592268834
    },
    {
        "content": "<p>fitzgen merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">PR #1832</a>.</p>",
        "id": 200964574,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592270786
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440870001\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For future instnaces of this, mind tagging this with a FIXME and an issue number so when we get around to aarch64 reference types we can make sure we run all the tests?</p>\n</blockquote>",
        "id": 201018234,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592315766
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431531362\">PR Review</a>.</p>",
        "id": 201018235,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592315766
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#pullrequestreview-431531802\">PR Review</a>.</p>",
        "id": 201018266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592315781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#discussion_r440870222\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Same comment here for the aarch64 testing</p>\n</blockquote>",
        "id": 201018267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592315781
    }
]