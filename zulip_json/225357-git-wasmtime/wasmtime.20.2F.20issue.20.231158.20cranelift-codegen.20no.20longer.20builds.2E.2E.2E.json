[
    {
        "content": "<p>Lucky4Luuk <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2149706166\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>Is this still being worked on? What are the current issues blocking no_std support?</p>\n</blockquote>",
        "id": 442772384,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717590332
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:platform-support label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">Issue #1158</a>.</p>",
        "id": 442793918,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717595421
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2150020984\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I'm at least not personally aware of this being worked on, but no blocker other than \"just needs some elbow grease\". If you'd be up for it PRs would be most welcome!</p>\n</blockquote>",
        "id": 442794052,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717595454
    },
    {
        "content": "<p>marceline-cramer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2235420489\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I made a pretty half-assed attempt at this but managed to dig up some useful info: a major blocker to getting this to work is getting several dependencies involved in <code>std::io::Write</code>-ing to objects to work on <code>no_std</code>. Here's a non-exhaustive list (i've been doing this for hours and i am exhausted enough):</p>\n<ul>\n<li>the <code>leb128</code> crate used by <code>wasm-encoder</code> has a hard dependency on <code>std::io</code></li>\n<li>the <code>termcolor</code> crate has a hard dependency on <code>std::io</code></li>\n<li><code>indexmap/std</code> is enabled by <code>wasmparser/std</code> is enabled by <code>wasmprinter</code> (which has no features that could be used to disable the dep feature)</li>\n<li><code>gimli/write</code> has a hard dependency on <code>std::io</code></li>\n<li><code>object/write</code> has a hard dependency on <code>std::io</code></li>\n</ul>\n<p>All of those issues come from the <code>wasmtime-environ</code> crate with the <code>compile</code> feature, which as far as I can tell, is pretty necessary to the functioning of <code>wasmtime-cranelift</code>. I don't know how necessary that is, but if it is absolutely crucial to have <code>compile</code> working, those crates need to be either factored out, guarded behind <code>std</code>, or in the worst case, modified upstream to not use <code>std::io</code>. Much bureaucracy ensues.</p>\n<p>The really obnoxious part about removing <code>std::io</code> from those crates is that there is no equivalent <code>io</code> API in <code>core</code> or <code>alloc</code>, making ergonomic <code>no_std</code> a great endeavor <em>per project</em>.</p>\n<p>Aside from <code>wasmtime-environ</code>, <code>wasmtime-codegen/unwind</code> has a similar breaking dependency on <code>gimli/write</code> for its <code>write</code> feature, which uses <code>std::io</code> to write objects. Disabling the <code>unwind</code> feature also causes a cascade of missing API items in the <code>wasmtime-codegen</code> crate AND <code>wasmtime-cranelift</code>. Today, I did manage to get <code>wasmtime-codegen</code> compiling locally in <code>no_std</code> but because I hadn't gotten the <code>unwind</code> feature to work I had to give up.</p>\n<p><code>thread_local</code> also breaks in <code>wasmtime-codegen</code> because that's <code>std</code>-only. I managed to take care of that with nightly <code>#[thread_local]</code> for now but obviously that's not optimal. More research is needed.</p>\n<p><code>OnceLock</code> can be replaced with <code>once_cell::OnceCell</code> trivially, although that uses the scary-sounding <code>critical-section</code> feature. More research is needed.</p>\n<p>My personal opinion is that the best way to keep <code>no_std</code> supported in the future is to just make <code>wasmtime-codegen</code> <code>no_std</code>-only. It only seems to be defining complex types of its own without a whole lot of interop with standard library types or interfaces anyways, and it was surprisingly easy to root out all of the <code>std</code>-specific code. <code>std</code> does provide hash maps, but <code>rustc-hash</code>, <code>hashbrown</code>, and <code>ahash</code> are already in the dependency tree.</p>\n<p>I haven't tried to get <code>thiserror</code> working yet but I will.</p>\n<p>I would really appreciate some guidance for what to work towards next. This is clearly going to take a LOT of work to get <code>wasmtime-cranelift</code> working on <code>no_std</code> consistently on all platforms but I'm pretty invested in it. Also, if I've made any mistakes in my probing (I'm a newcomer to the codebase), please let me know.</p>\n</blockquote>",
        "id": 452250099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721280278
    },
    {
        "content": "<p>marceline-cramer edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2235420489\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I made a pretty half-assed attempt at this but managed to dig up some useful info: a major blocker to getting this to work is getting several dependencies involved in <code>std::io::Write</code>-ing to objects to work on <code>no_std</code>. Here's a non-exhaustive list (i've been doing this for hours and i am exhausted enough):</p>\n<ul>\n<li>the <code>leb128</code> crate used by <code>wasm-encoder</code> has a hard dependency on <code>std::io</code></li>\n<li>the <code>termcolor</code> crate has a hard dependency on <code>std::io</code></li>\n<li><code>indexmap/std</code> is enabled by <code>wasmparser/std</code> is enabled by <code>wasmprinter</code> (which has no features that could be used to disable the dep feature)</li>\n<li><code>gimli/write</code> has a hard dependency on <code>std::io</code></li>\n<li><code>object/write</code> has a hard dependency on <code>std::io</code></li>\n</ul>\n<p>All of those issues come from the <code>wasmtime-environ</code> crate with the <code>compile</code> feature, which as far as I can tell, is pretty necessary to the functioning of <code>wasmtime-cranelift</code>. I don't know how necessary that is, but if it is absolutely crucial to have <code>compile</code> working, those crates need to be either factored out, guarded behind <code>std</code>, or in the worst case, modified upstream to not use <code>std::io</code>. Much bureaucracy ensues.</p>\n<p>The really obnoxious part about removing <code>std::io</code> from those crates is that there is no equivalent <code>io</code> API in <code>core</code> or <code>alloc</code>, making ergonomic <code>no_std</code> a great endeavor <em>per project</em>.</p>\n<p>Aside from <code>wasmtime-environ</code>, <code>wasmtime-codegen/unwind</code> has a similar breaking dependency on <code>gimli/write</code>, which uses <code>std::io</code> to write objects. Disabling the <code>unwind</code> feature also causes a cascade of missing API items in the <code>wasmtime-codegen</code> crate AND <code>wasmtime-cranelift</code>. Today, I did manage to get <code>wasmtime-codegen</code> compiling locally in <code>no_std</code> but because I hadn't gotten the <code>unwind</code> feature to work I had to give up.</p>\n<p><code>thread_local</code> also breaks in <code>wasmtime-codegen</code> because that's <code>std</code>-only. I managed to take care of that with nightly <code>#[thread_local]</code> for now but obviously that's not optimal. More research is needed.</p>\n<p><code>OnceLock</code> can be replaced with <code>once_cell::OnceCell</code> trivially, although that uses the scary-sounding <code>critical-section</code> feature. More research is needed.</p>\n<p>My personal opinion is that the best way to keep <code>no_std</code> supported in the future is to just make <code>wasmtime-codegen</code> <code>no_std</code>-only. It only seems to be defining complex types of its own without a whole lot of interop with standard library types or interfaces anyways, and it was surprisingly easy to root out all of the <code>std</code>-specific code. <code>std</code> does provide hash maps, but <code>rustc-hash</code>, <code>hashbrown</code>, and <code>ahash</code> are already in the dependency tree.</p>\n<p>I haven't tried to get <code>thiserror</code> working yet but I will.</p>\n<p>I would really appreciate some guidance for what to work towards next. This is clearly going to take a LOT of work to get <code>wasmtime-cranelift</code> working on <code>no_std</code> consistently on all platforms but I'm pretty invested in it. Also, if I've made any mistakes in my probing (I'm a newcomer to the codebase), please let me know.</p>\n</blockquote>",
        "id": 452250173,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721280332
    },
    {
        "content": "<p>marceline-cramer edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2235420489\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I made a pretty half-assed attempt at this but managed to dig up some useful info: a major blocker to getting this to work is getting several dependencies involved in <code>std::io::Write</code>-ing to objects to work on <code>no_std</code>. Here's a non-exhaustive list (i've been doing this for hours and i am exhausted enough):</p>\n<ul>\n<li>the <code>leb128</code> crate used by <code>wasm-encoder</code> has a hard dependency on <code>std::io</code></li>\n<li>the <code>termcolor</code> crate has a hard dependency on <code>std::io</code></li>\n<li><code>indexmap/std</code> is enabled by <code>wasmparser/std</code> is enabled by <code>wasmprinter</code> (which has no features that could be used to disable the dep feature)</li>\n<li><code>gimli/write</code> has a hard dependency on <code>std::io</code></li>\n<li><code>object/write</code> has a hard dependency on <code>std::io</code></li>\n</ul>\n<p>All of those issues come from the <code>wasmtime-environ</code> crate with the <code>compile</code> feature, which as far as I can tell, is pretty necessary to the functioning of <code>wasmtime-cranelift</code>. I don't know how necessary that is, but if it is absolutely crucial to have <code>compile</code> working, those crates need to be either factored out, guarded behind <code>std</code>, or in the worst case, modified upstream to not use <code>std::io</code>. Much bureaucracy ensues.</p>\n<p>The really obnoxious part about removing <code>std::io</code> from those crates is that there is no equivalent <code>io</code> API in <code>core</code> or <code>alloc</code>, making ergonomic <code>no_std</code> a great endeavor <em>per project</em>.</p>\n<p>Aside from <code>wasmtime-environ</code>, <code>wasmtime-codegen/unwind</code> has a similar breaking dependency on <code>gimli/write</code>, which uses <code>std::io</code> to write objects. Disabling the <code>unwind</code> feature also causes a cascade of missing API items in the <code>wasmtime-codegen</code> crate AND <code>wasmtime-cranelift</code>. Today, I did manage to get <code>wasmtime-codegen</code> compiling locally in <code>no_std</code> but because I hadn't gotten the <code>unwind</code> feature to work I had to give up.</p>\n<p><code>thread_local</code> also breaks in <code>wasmtime-codegen</code> because that's <code>std</code>-only. I managed to take care of that with nightly <code>#[thread_local]</code> for now but obviously that's not optimal. More research is needed.</p>\n<p><code>OnceLock</code> can be replaced with <code>once_cell::OnceCell</code> trivially, although that uses the scary-sounding <code>critical-section</code> feature. More research is needed.</p>\n<p>I haven't tried to get <code>thiserror</code> working yet but I will.</p>\n<p>I would really appreciate some guidance for what to work towards next. This is clearly going to take a LOT of work to get <code>wasmtime-cranelift</code> working on <code>no_std</code> consistently on all platforms but I'm pretty invested in it. Also, if I've made any mistakes in my probing (I'm a newcomer to the codebase), please let me know.</p>\n</blockquote>",
        "id": 452251297,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721281047
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2235770727\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p><code>#[thread_local]</code> is generally unavailable on no_std targets too.</p>\n</blockquote>",
        "id": 452263680,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721286018
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2236676946\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>My recommendation would be to first start off by gating \"easy\" things behind on-by-default Cargo features. For example <code>wasmprinter</code> doesn't need to be included in no_std builds (nor <code>thread_local</code> usage or <code>termcolor</code>). Basically anything that's optional functionality can be hard-disabled at compile time and that can greatly help to prune the dependency tree of crates that don't support no_std.</p>\n<p>After that next bit that I would recommend is to do this incrementally. The main crate in question I believe is <code>cranelift-codegen</code> but there are other crates as well that it depends on. I'd recommend starting at the leaves (e.g. <code>cranelift-entity</code>) and adding a \"ratchet\" to add support for <code>no_std</code> to ensure they don't regress. For example on CI you'd add lines <a href=\"https://github.com/bytecodealliance/wasmtime/blob/2aa4fde04c3d09c2d5d35bb9c3bb21332311db94/.github/workflows/main.yml#L431-L436\">around here</a> where that ensures that crates build on a no_std target. Eventually as you work your way up to <code>cranelift-codegen</code> you'll already have added support to a number of other crates and handled a number of these issues.</p>\n<p>At that point I think it might be worth reevaluating taking stock of what's remaining. I think it would be useful to classify dependencies as you've done, but with a refreshed list at that point. Some of these are going to be somewhat hard like <code>gimli/write</code> and <code>object/write</code> but we might be able to work with upstream to have new crate versions that support no_std needs, but that also sort of depends on what exactly Cranelift needs. That's why I'd recommend doing everything except <code>cranelift-codegen</code> first if possible so we can get the most precise picture of what Cranelift needs from its dependencies with no_std.</p>\n</blockquote>",
        "id": 452358849,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721312643
    },
    {
        "content": "<p>marceline-cramer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2241375517\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I'm having a hard time with removing <code>thread_local</code> usage from <code>cranelift/codegen/src/timing.rs</code>. What alternative to <code>thread_local</code> statics should I use with <code>no_std</code>, if any? As far as I can tell, the <code>timing</code> module and those statics can't be configured out. One idea I have is to just configure out all the <code>timing</code> usage with API-compatible no-op stub functions on <code>no_std</code>, but I don't know enough about the codebase to understand the consequences of something like that.</p>\n</blockquote>",
        "id": 452922248,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721526198
    },
    {
        "content": "<p>marceline-cramer edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2241375517\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>I'm having a hard time with removing <code>thread_local</code> usage from <code>cranelift/codegen/src/timing.rs</code>. What alternative to <code>thread_local</code> statics should I use with <code>no_std</code>, if any? As far as I can tell, the <code>timing</code> module and those statics can't be configured out. One idea I have is to just configure out all the <code>timing</code> usage with API-compatible no-op stub functions on <code>no_std</code>, but I don't know enough about the codebase to understand the consequences of something like that.</p>\n<p>I should also point out that the <code>set_thread_profiler()</code> function is not used anywhere in the codebase.</p>\n</blockquote>",
        "id": 452927815,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721529441
    },
    {
        "content": "<p>marceline-cramer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2241500013\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<p>For now, I just put no-op stubs in the <code>timing</code> API when the <code>timing</code> feature is not enabled and made the <code>timing</code> feature enable the <code>std</code> feature automatically. <code>thread_local! {}</code> is still in use as long as the <code>timing</code> feature is enabled.</p>\n<p>Right now, my development approach is to hack on all of these intersecting API changes and changes to the dependency trees on a fork, which I have set up to be running the full CI PR test suite: <a href=\"https://github.com/marceline-cramer/wasmtime/pull/1\">https://github.com/marceline-cramer/wasmtime/pull/1</a> Once that branch on my fork is to a place I'm happy with and all the pieces fit together practically as a rough sketch, I can start decomposing it into finer-grained, more polished things to implement as upstream-facing PRs. I did implement the \"ratcheting\" approach to get down to <code>cranelift-codegen</code> as quickly as I could and discovered all but one of its workspace dependencies already work fine in <code>no_std</code>. The one exception was <code>cranelift-control</code>, which to compile to <code>no_std</code> I slapped in a Git dep for a pending PR on <code>arbitrary</code> with <code>no_std</code> support: <a href=\"https://github.com/rust-fuzz/arbitrary/pull/177\">https://github.com/rust-fuzz/arbitrary/pull/177</a></p>\n<p>I added a field to <code>CodegenOptions</code> in <code>cranelift-isle</code> to emit <code>no_std</code>-compatible code by adding a short prelude to generated source files, because most CI compiles ISLE with <code>std</code> but <code>cranelift-codegen</code> does not. If that's an acceptable change for upstream, I'd be happy to make a little PR to get that moving along.</p>\n<p>The reason I had gotten as far with <code>cranelift-codegen</code> as to be hacking on <code>thread_local</code> is because getting it to compile to a <code>no_std</code> target turned out to be pretty easy. I mainly just swapped out all of the uses of <code>rustc-hash</code> with a combination of <code>hashbrown</code> and <code>ahash</code> and replaced any lingering uses of <code>std</code> with <code>core</code> and <code>alloc</code>. I also replaced any use of floating-point arithmetic in the instrinics code with the <code>core_math</code> crate, which just implements <code>std</code>-compatible arithmetic operators on <code>core</code> floats using <code>libm</code>. There may be some security concerns with regards to the use of <code>ahash</code> in a <code>no_std</code> environment but I have decided that taking a deeper look into that is Tomorrow Marceline's problem.</p>\n<p>The main kicker with <code>cranelift-codegen</code> right now is that so far, I've only gotten <code>all-arch</code> and <code>trace-log</code> features, with no others, to compile, and only in nightly. The reason it has to be in nightly for now is because there are some cases of <code>impl std::error::Error</code> that I'm too afraid to <code>cfg</code> out, so for now I'm using nightly and <code>core::error::Error</code> until I can figure out what to do with potential <code>no_std</code> API users of <code>cranelift-codegen</code>. I figure that the already-discussed use of <code>thiserror</code> on <code>no_std</code> would force us to use nightly for now anyways.</p>\n<p>That's about where I am now. The CI  <em>mostly</em> passes, although Cranelift's unit tests fail with <em>slightly</em> different code output compared to the expected code. I can chalk that up to either an impatient use of <code>cargo update</code> that may have minorly changed some semantics of dependencies involved in codegen, or something related to the switching of <code>rustc-hash</code> to <code>hashbrown</code>. Both are easy to test.</p>\n<p>The main issue now is that, by default, <code>cranelift-codegen</code> is configured to have <code>std,unwind,trace-log</code> enabled. <code>trace-log</code> works in <code>no_std</code> independently of <code>std</code>, but <code>unwind</code> is still blocked by that pesky <code>gimli/write</code> dep and its use of <code>std::io</code>. I can take a deeper look into how exactly that is used and what an alternative to that either in Cranelift or upstream Gimli might look like when I have more time and can afford to lock in on specific issues like that. I'm becoming a lot more comfortable navigating the codebase but there's still a lot of cognitive overhead and even swapping out dependencies takes a lot of attention.</p>\n</blockquote>",
        "id": 452950761,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721544632
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2241516086\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<blockquote>\n<p>I should also point out that the set_thread_profiler() function is not used anywhere in the codebase.</p>\n</blockquote>\n<p>It is used by cg_clif to include performance timings collected by Cranelift in rustc self profile profiles. Having thr timing module be a nop for no_std builds is fine.</p>\n</blockquote>",
        "id": 452957084,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721548485
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2241516495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<blockquote>\n<p>I added a field to CodegenOptions in cranelift-isle to emit no_std-compatible code by adding a short prelude to generated source files</p>\n</blockquote>\n<p>Unconditionally using core instead of std should work fine. In std builds, core is still available.</p>\n</blockquote>",
        "id": 452957199,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721548589
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2243160528\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<blockquote>\n<p>For now, I just put no-op stubs in the timing API when the timing feature is not enabled and made the timing feature enable the std feature automatically</p>\n</blockquote>\n<p>Sounds good! I'd recommend gating <code>set_thread_profiler</code> behind this Cargo feature entirely (and having the feature enabled by default probably too). That would avoid the confusion of calling <code>set_thread_profiler</code> and having it do nothing.</p>\n<blockquote>\n<p>The one exception was cranelift-control, which to compile to no_std I slapped in a Git dep for a pending PR on arbitrary with no_std support: <a href=\"https://github.com/rust-fuzz/arbitrary/pull/177\">https://github.com/rust-fuzz/arbitrary/pull/177</a></p>\n</blockquote>\n<p>I'd probably recommend adding a <code>fuzz</code> feature or similar to avoid needing to update the <code>arbitrary</code> crate (although updating that is definitely ok too). Basically gating this functionality on a Cargo feature is fine. (this Cargo feature may even be able to be off-by-default too)</p>\n<blockquote>\n<p>I also replaced any use of floating-point arithmetic in the instrinics code with the core_math crate, which just implements std-compatible arithmetic operators on core floats using libm. There may be some security concerns with regards to the use of ahash in a no_std environment but I have decided that taking a deeper look into that is Tomorrow Marceline's problem.</p>\n</blockquote>\n<p>This sounds generally fine and possible for us to land. When making PRs if you wouldn't mind leaving <code>cranelift-codegen</code>'s no_std support for a single standalone PR that'll make this easiest to review and discuss.</p>\n<blockquote>\n<p>The main kicker with cranelift-codegen right now is that so far, I've only gotten all-arch and trace-log features</p>\n</blockquote>\n<p>FWIW I think it's definitely ok to not get the entire crate and all its features compiling with no_std. Only getting a subset working (albeit we still need a useful subset, but the one you have is useful) is more than ok. Can always work to improve the subset supported later on.</p>\n<blockquote>\n<p>The reason it has to be in nightly for now is because there are some cases of impl std::error::Error</p>\n</blockquote>\n<p>I'm assuming that you're probably going to add a <code>std</code> feature to the <code>cranelift-codegen</code> crate no matter what, and would it be possible to gate these impls on the <code>std</code> feature? That is, \"just\" omit them for a no_std build?</p>\n<blockquote>\n<p>The main issue now is that, by default, cranelift-codegen is configured to have std,unwind,trace-log enabled</p>\n</blockquote>\n<p>In the spirit of ratcheting and progress over time I'll reiterate it's completely ok to get only some features working and not others. In this workspace most dependencies <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0d1efe742fde16a80e97802801a40831c6351a01/Cargo.toml#L181\">disable default features</a> and then individual crates will enable features in addition to specifying <code>workspace = true</code>. That would enable a state where <code>cranelift-codegen</code> itself builds with no_std but <code>wasmtime-cranelift</code> doesn't work just yet. That'd help figure out all the dependencies as we go along and get to a working state at least for one crate while the blockers of the next crate are tackled.</p>\n<p>One example here is that the <code>unwind</code> feature is only used in Wasmtime for <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.native_unwind_info\"><code>Config::native_unwind_info</code></a> which would be easy to gate behind a Cargo feature. In that sense there's no need to unconditionally enable <code>unwind</code> in Cranelift given possible future changes.</p>\n<p>If your target is <code>wasmtime-cranelift</code> the bigger problem is probably going to be <code>object::write</code> as that's pretty intrinsically depended on. It's probably best to cross that bridge when we get there though and it's the \"only\" remaining issue. If your target is just <code>cranelift-codegen</code> on <code>no_std</code> then you can disregard this last part from me :)</p>\n</blockquote>",
        "id": 453196708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721659993
    },
    {
        "content": "<p>marceline-cramer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2244090010\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>I added a field to CodegenOptions in cranelift-isle to emit no_std-compatible code by adding a short prelude to generated source files</p>\n</blockquote>\n<p>Unconditionally using core instead of std should work fine. In std builds, core is still available.</p>\n</blockquote>\n<p>It would work fine if not for the <code>impl Length for Vec</code> in the codegen. In no_std, that would have to be replaced with the <code>alloc</code> crate, and no_std or not, the <code>alloc</code> crate has to be manually declared <code>extern crate alloc;</code>.</p>\n</blockquote>",
        "id": 453305513,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721698805
    },
    {
        "content": "<p>marceline-cramer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158#issuecomment-2244110320\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">issue #1158</a>:</p>\n<blockquote>\n<blockquote>\n<p>Sounds good! I'd recommend gating <code>set_thread_profiler</code> behind this Cargo feature entirely (and having the feature enabled by default probably too). That would avoid the confusion of calling <code>set_thread_profiler</code> and having it do nothing.</p>\n</blockquote>\n<p>Sounds great, I'll remember that when I open the <code>cranelift-codegen</code> <code>no_std</code> PR.</p>\n<blockquote>\n<p>I'd probably recommend adding a <code>fuzz</code> feature or similar to avoid needing to update the <code>arbitrary</code> crate (although updating that is definitely ok too). Basically gating this functionality on a Cargo feature is fine. (this Cargo feature may even be able to be off-by-default too)</p>\n</blockquote>\n<p>Not including the <code>arbitrary</code> crate breaks <code>ControlPlane::arbitrary()</code> and <code>ControlPlane::get_arbitrary()</code>, so I've made it on by default so that none of the dependencies need to manually enable it. We can discuss that more in the <code>cranelift-control</code> PR I'm about to open. :)</p>\n<blockquote>\n<p>This sounds generally fine and possible for us to land. When making PRs if you wouldn't mind leaving <code>cranelift-codegen</code>'s no_std support for a single standalone PR that'll make this easiest to review and discuss.</p>\n<p>FWIW I think it's definitely ok to not get the entire crate and all its features compiling with no_std. Only getting a subset working (albeit we still need a useful subset, but the one you have is useful) is more than ok. Can always work to improve the subset supported later on.</p>\n<p>I'm assuming that you're probably going to add a <code>std</code> feature to the <code>cranelift-codegen</code> crate no matter what, and would it be possible to gate these impls on the <code>std</code> feature? That is, \"just\" omit them for a no_std build?</p>\n</blockquote>\n<p>Yeah, I suppose that is definitely the easiest way of going about it. I would definitely be glad to have just stripped-down <code>cranelift-codegen</code> working in <code>no_std</code> upstream for now.</p>\n<blockquote>\n<p>One example here is that the <code>unwind</code> feature is only used in Wasmtime for <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.native_unwind_info\"><code>Config::native_unwind_info</code></a> which would be easy to gate behind a Cargo feature. In that sense there's no need to unconditionally enable <code>unwind</code> in Cranelift given possible future changes.</p>\n<p>If your target is <code>wasmtime-cranelift</code> the bigger problem is probably going to be <code>object::write</code> as that's pretty intrinsically depended on. It's probably best to cross that bridge when we get there though and it's the \"only\" remaining issue. If your target is just <code>cranelift-codegen</code> on <code>no_std</code> then you can disregard this last part from me :)</p>\n</blockquote>\n<p>I was not aware that the dependency on <code>unwind</code> was so light, glad to hear! Yes, I am most interested in using the entirety of Wasmtime JIT functionality itself in a <code>no_std</code> environment. Once I can get the lower-level features working though I'll see what I can get done with the <code>object</code> crate and I'll come back here to make the rest of the push. :)</p>\n</blockquote>",
        "id": 453307481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721700180
    }
]