[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7162\">PR #7162</a> from <code>alexcrichton:rv64-use-zero-reg</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>This commit is an attempt to use the <code>zero</code> register more often in the riscv64 backend. Currently materializing an <code>iconst 0</code> value moves the <code>zero</code> register into a general purpose register, and then the general purpose register is used. This means that an extra register is used when it doesn't need to be, for example.</p>\n<p>Naively fixing this by returning <code>(zero_reg)</code> during constant emission does not work. One reason this doesn't work is that it introduces vcode aliases to the physical register 0, and during <code>OperandCollector</code> collection the physical register makes its way into normal constraints rather than being a fixed nonallocatable constraint. This is fixable by moving the \"resolve alias\" phase earlier, for example at the beginning of <code>reg_use</code> rather than lower down in <code>add_operand</code>.</p>\n<p>Even after applying such a fix, however, that solution still does not work. This produces situations such as when a 0 constant is returned from a function that the zero register is attempted to be placed into the first return register. These two physical register constraints naturally conflict and nothing is around to generate a move instruction. This happens within <code>OperandCollector</code> meaning it's not easy to generate more instructions at that time.</p>\n<p>The \"fix\", which is incomplete, that this PR implements is to introduce a pseudo-instruction which has a fixed register definition of the physical register zero. This instruction emits no code and is intended to provide a location for regalloc2 to split bundles by automatically inserting a move in the above situation. To get this working however it required removing an assertion in the <code>OperandCollector</code> and ends up violating an invariant of regalloc2 where a virtual register is assigned to a non-allocatable register. This ends up generating instructions which move general purpose registers into the zero register on riscv64, which is unlikely to be what regalloc intended.</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 395107894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696534774
    },
    {
        "content": "<p>alexcrichton closed without merge <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7162\">PR #7162</a>.</p>",
        "id": 395853179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696934024
    }
]