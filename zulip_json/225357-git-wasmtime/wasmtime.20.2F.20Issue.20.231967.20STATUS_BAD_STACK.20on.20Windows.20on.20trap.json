[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>Originally reported at <a href=\"https://github.com/bytecodealliance/wasmtime-py/issues/36\">https://github.com/bytecodealliance/wasmtime-py/issues/36</a> I'm able to reproduce this pretty easily with just <a href=\"https://github.com/bytecodealliance/wasmtime/files/4865263/yosys.wasm.gz\">this wasm file</a>. Downloading that locally I can reproduce on Windows with:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ gunzip yosys.wasm.gz\n$ cargo run --release -- run yosys.wasm -- -V\n...\n    Finished release [optimized] target(s) in 3.84s\n     Running `target\\release\\wasmtime.exe run yosys.wasm -- -V`\nerror: process didn&#39;t exit successfully: `target\\release\\wasmtime.exe run yosys.wasm -- -V` (exit code: 0xc0000028)\n</code></pre></div>\n\n\n<p>Something funny is going on here though because <code>--opt-level 0</code> does not reproduce the issue (<code>--opt-level 1</code> does though).</p>\n<p>I'm trying to run this right now through <code>wasm-reduce</code> from Binaryen but so far it's only shaved off 3MB, which isn't a whole lot given the size of this binary...</p>\n<p>@peterhuene I'm having trouble just opening things up in a debugger, would you be able to help look into this?</p>\n</blockquote>",
        "id": 202705550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593704433
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>Originally reported at <a href=\"https://github.com/bytecodealliance/wasmtime-py/issues/36\">https://github.com/bytecodealliance/wasmtime-py/issues/36</a> I'm able to reproduce this pretty easily with just <a href=\"https://github.com/bytecodealliance/wasmtime/files/4865263/yosys.wasm.gz\">this wasm file</a>. Downloading that locally I can reproduce on Windows with:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ gunzip yosys.wasm.gz\n$ cargo run --release -- run yosys.wasm -- -V\n...\n    Finished release [optimized] target(s) in 3.84s\n     Running `target\\release\\wasmtime.exe run yosys.wasm -- -V`\nerror: process didn&#39;t exit successfully: `target\\release\\wasmtime.exe run yosys.wasm -- -V` (exit code: 0xc0000028)\n</code></pre></div>\n\n\n<p>Something funny is going on here though because <code>--opt-level 0</code> does not reproduce the issue (<code>--opt-level 1</code> does though).</p>\n<p>I'm trying to run this right now through <code>wasm-reduce</code> from Binaryen but so far it's only shaved off 3MB, which isn't a whole lot given the size of this binary...</p>\n<p>@peterhuene I'm having trouble just opening things up in a debugger, would you be able to help look into this?</p>\n</blockquote>",
        "id": 202705551,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593704433
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653081682\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I'll take a look.</p>\n</blockquote>",
        "id": 202705854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593704558
    },
    {
        "content": "<p>peterhuene assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a> (assigned to peterhuene):</p>\n<blockquote>\n<p>Originally reported at <a href=\"https://github.com/bytecodealliance/wasmtime-py/issues/36\">https://github.com/bytecodealliance/wasmtime-py/issues/36</a> I'm able to reproduce this pretty easily with just <a href=\"https://github.com/bytecodealliance/wasmtime/files/4865263/yosys.wasm.gz\">this wasm file</a>. Downloading that locally I can reproduce on Windows with:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ gunzip yosys.wasm.gz\n$ cargo run --release -- run yosys.wasm -- -V\n...\n    Finished release [optimized] target(s) in 3.84s\n     Running `target\\release\\wasmtime.exe run yosys.wasm -- -V`\nerror: process didn&#39;t exit successfully: `target\\release\\wasmtime.exe run yosys.wasm -- -V` (exit code: 0xc0000028)\n</code></pre></div>\n\n\n<p>Something funny is going on here though because <code>--opt-level 0</code> does not reproduce the issue (<code>--opt-level 1</code> does though).</p>\n<p>I'm trying to run this right now through <code>wasm-reduce</code> from Binaryen but so far it's only shaved off 3MB, which isn't a whole lot given the size of this binary...</p>\n<p>@peterhuene I'm having trouble just opening things up in a debugger, would you be able to help look into this?</p>\n</blockquote>",
        "id": 202705890,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593704578
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653265416\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I've been digging into this most of today with not much to report yet.</p>\n<p>The unwind information seems correct, as well as the stack aligning done in the prologues.</p>\n<p>I haven't been able to form a minimal repro yet either.</p>\n<p>The unwind is coming from the trap returned from WASI's proc_exit.</p>\n<p>I'll keep at it.</p>\n</blockquote>",
        "id": 202756994,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593734309
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653339528\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>It appears the system unwinder can't get past the frame for <code>12746</code> for some yet-to-be-determined reason.</p>\n<p>The Wasm frames that show up in the debugger prior to the <code>STATUS_BAD_STACK</code>:</p>\n<ul>\n<li>12469 (calls <code>wasi_snapshot_preview1.proc_exit</code>)</li>\n<li>12504</li>\n<li>12746 (JIT'd function is 96059 bytes!)</li>\n</ul>\n<p>The unwind stops there.</p>\n<p>Prologue JIT for <code>12746</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>0000023CCCEAB200 48 8B 01             mov         rax,qword ptr [rcx]\n0000023CCCEAB203 48 8B 00             mov         rax,qword ptr [rax]\n0000023CCCEAB206 48 81 C0 68 06 00 00 add         rax,668h\n0000023CCCEAB20D 48 39 E0             cmp         rax,rsp\n0000023CCCEAB210 72 02                jb          0000023CCCEAB214\n0000023CCCEAB212 0F 0B                ud2\n0000023CCCEAB214 40 55                push        rbp\n0000023CCCEAB216 48 89 E5             mov         rbp,rsp\n0000023CCCEAB219 40 53                push        rbx\n0000023CCCEAB21B 40 56                push        rsi\n0000023CCCEAB21D 40 57                push        rdi\n0000023CCCEAB21F 41 54                push        r12\n0000023CCCEAB221 41 55                push        r13\n0000023CCCEAB223 41 56                push        r14\n0000023CCCEAB225 41 57                push        r15\n0000023CCCEAB227 48 81 EC 68 06 00 00 sub         rsp,668h\n0000023CCCEAB22E 44 0F 11 BC 24 50 06 00 00 movups      xmmword ptr [rsp+650h],xmm15\n</code></pre></div>\n\n\n<p>Function <code>12746</code> has the following encoded unwind information:</p>\n<p>```<br>\n01 37 0d 55 37 f8 00 00<br>\n2e 01 cd 00 27 f0 25 e0<br>\n23 d0 21 c0 1f 70 1d 60<br>\n1b 30 19 03 16 50 00 00</p>\n<div class=\"codehilite\"><pre><span></span><code>Decoded:\n</code></pre></div>\n\n\n<p>Version: 1<br>\nPrologue size: 55 bytes<br>\nUnwind codes: 13<br>\nRegister frame: RBP<br>\nRegister frame offset: 80<br>\nCodes:</p>\n<p>- Prologue offset: 55 <br>\n    Op: SaveXmm128 (note: operation is two unwind codes in length)<br>\n    Reg: XMM15<br>\n    Stack offset: 0</p>\n<p>- Prologue offset:  46<br>\n    Op: LargeStackAlloc (note: operation is two unwind codes in length)<br>\n    Size: 668 bytes</p>\n<p>- Prologue offset: 39<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R15</p>\n<p>- Prologue offset: 37<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R14</p>\n<p>- Prologue offset: 35<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R13</p>\n<p>- Prologue offset: 33<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R12</p>\n<p>- Prologue offset: 31<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RDI</p>\n<p>- Prologue offset: 29<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RSI</p>\n<p>- Prologue offset: 27<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBX</p>\n<p>- Prologue offset: 25<br>\n    Op: SetFramePointer</p>\n<p>- Prologue offset: 22<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBP<br>\nAlignment padding: 2 bytes</p>\n<div class=\"codehilite\"><pre><span></span><code>This is correct for the generated prologue.  I&#39;ve verified that the correct offset to the unwind information was registered with Windows for this function.\n\nThe stack allocation for the frame is correctly aligned: 1712 bytes, starting with call-pushed return address.\n\nNote: there appears to be a bug in the stack check code as it&#39;s not taking into account the space needed for GPR saves (FPR saves are part of the stack allocation size).\n\nStill digging.\n\n~~~\n</code></pre></div>\n\n\n</blockquote>",
        "id": 202767937,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593750650
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653339528\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>It appears the system unwinder can't get past the frame for <code>12746</code> for some yet-to-be-determined reason.</p>\n<p>The Wasm frames that show up in the debugger prior to the <code>STATUS_BAD_STACK</code>:</p>\n<ul>\n<li>12469 (calls <code>wasi_snapshot_preview1.proc_exit</code>)</li>\n<li>12504</li>\n<li>12746 (JIT'd function is 96059 bytes!)</li>\n</ul>\n<p>The unwind stops there.</p>\n<p>Prologue JIT for <code>12746</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>0000023CCCEAB200 48 8B 01             mov         rax,qword ptr [rcx]\n0000023CCCEAB203 48 8B 00             mov         rax,qword ptr [rax]\n0000023CCCEAB206 48 81 C0 68 06 00 00 add         rax,668h\n0000023CCCEAB20D 48 39 E0             cmp         rax,rsp\n0000023CCCEAB210 72 02                jb          0000023CCCEAB214\n0000023CCCEAB212 0F 0B                ud2\n0000023CCCEAB214 40 55                push        rbp\n0000023CCCEAB216 48 89 E5             mov         rbp,rsp\n0000023CCCEAB219 40 53                push        rbx\n0000023CCCEAB21B 40 56                push        rsi\n0000023CCCEAB21D 40 57                push        rdi\n0000023CCCEAB21F 41 54                push        r12\n0000023CCCEAB221 41 55                push        r13\n0000023CCCEAB223 41 56                push        r14\n0000023CCCEAB225 41 57                push        r15\n0000023CCCEAB227 48 81 EC 68 06 00 00 sub         rsp,668h\n0000023CCCEAB22E 44 0F 11 BC 24 50 06 00 00 movups      xmmword ptr [rsp+650h],xmm15\n</code></pre></div>\n\n\n<p>Function <code>12746</code> has the following encoded unwind information:</p>\n<p>```<br>\n01 37 0d 55 37 f8 00 00<br>\n2e 01 cd 00 27 f0 25 e0<br>\n23 d0 21 c0 1f 70 1d 60<br>\n1b 30 19 03 16 50 00 00</p>\n<div class=\"codehilite\"><pre><span></span><code>Decoded:\n</code></pre></div>\n\n\n<p>Version: 1<br>\nPrologue size: 55 bytes<br>\nUnwind codes: 13<br>\nRegister frame: RBP<br>\nRegister frame offset: 80<br>\nCodes:</p>\n<p>- Prologue offset: 55 <br>\n    Op: SaveXmm128 (note: operation is two unwind codes in length)<br>\n    Reg: XMM15<br>\n    Stack offset: 0</p>\n<p>- Prologue offset:  46<br>\n    Op: LargeStackAlloc (note: operation is two unwind codes in length)<br>\n    Size: 668 bytes</p>\n<p>- Prologue offset: 39<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R15</p>\n<p>- Prologue offset: 37<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R14</p>\n<p>- Prologue offset: 35<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R13</p>\n<p>- Prologue offset: 33<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R12</p>\n<p>- Prologue offset: 31<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RDI</p>\n<p>- Prologue offset: 29<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RSI</p>\n<p>- Prologue offset: 27<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBX</p>\n<p>- Prologue offset: 25<br>\n    Op: SetFramePointer</p>\n<p>- Prologue offset: 22<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBP<br>\nAlignment padding: 2 bytes</p>\n<div class=\"codehilite\"><pre><span></span><code>This is correct for the generated prologue.  I&#39;ve verified that the correct offset to the unwind information was registered with Windows for this function.\n\nThe stack allocation for the frame is correctly aligned: 1712 bytes, starting with call-pushed return address.\n\nNote: there appears to be a bug in the stack check code as it&#39;s not taking into account the space needed for GPR saves (FPR saves are part of the stack allocation size).  That bug is unrelated and would only cause a missed stack overflow trap in the unlikely case that the stack allocation size would fit, but the GPR saves push it over the limit).\n\nStill digging.\n\n~~~\n</code></pre></div>\n\n\n</blockquote>",
        "id": 202768009,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593750811
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653339528\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>It appears the system unwinder can't get past the frame for <code>12746</code> for some yet-to-be-determined reason.</p>\n<p>The Wasm frames that show up in the debugger prior to the <code>STATUS_BAD_STACK</code>:</p>\n<ul>\n<li>12469 (calls <code>wasi_snapshot_preview1.proc_exit</code>)</li>\n<li>12504</li>\n<li>12746 (JIT'd function is 96059 bytes!)</li>\n</ul>\n<p>The unwind stops there.</p>\n<p>Prologue JIT for <code>12746</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>0000023CCCEAB200 48 8B 01             mov         rax,qword ptr [rcx]\n0000023CCCEAB203 48 8B 00             mov         rax,qword ptr [rax]\n0000023CCCEAB206 48 81 C0 68 06 00 00 add         rax,668h\n0000023CCCEAB20D 48 39 E0             cmp         rax,rsp\n0000023CCCEAB210 72 02                jb          0000023CCCEAB214\n0000023CCCEAB212 0F 0B                ud2\n0000023CCCEAB214 40 55                push        rbp\n0000023CCCEAB216 48 89 E5             mov         rbp,rsp\n0000023CCCEAB219 40 53                push        rbx\n0000023CCCEAB21B 40 56                push        rsi\n0000023CCCEAB21D 40 57                push        rdi\n0000023CCCEAB21F 41 54                push        r12\n0000023CCCEAB221 41 55                push        r13\n0000023CCCEAB223 41 56                push        r14\n0000023CCCEAB225 41 57                push        r15\n0000023CCCEAB227 48 81 EC 68 06 00 00 sub         rsp,668h\n0000023CCCEAB22E 44 0F 11 BC 24 50 06 00 00 movups      xmmword ptr [rsp+650h],xmm15\n</code></pre></div>\n\n\n<p>Function <code>12746</code> has the following encoded unwind information:</p>\n<p>```<br>\n01 37 0d 55 37 f8 00 00<br>\n2e 01 cd 00 27 f0 25 e0<br>\n23 d0 21 c0 1f 70 1d 60<br>\n1b 30 19 03 16 50 00 00</p>\n<div class=\"codehilite\"><pre><span></span><code>Decoded:\n</code></pre></div>\n\n\n<p>Version: 1<br>\nPrologue size: 55 bytes<br>\nUnwind codes: 13<br>\nRegister frame: RBP<br>\nRegister frame offset: 80<br>\nCodes:</p>\n<p>- Prologue offset: 55 <br>\n    Op: SaveXmm128 (note: operation is two unwind codes in length)<br>\n    Reg: XMM15<br>\n    Stack offset: 0</p>\n<p>- Prologue offset:  46<br>\n    Op: LargeStackAlloc (note: operation is two unwind codes in length)<br>\n    Size: 668 bytes</p>\n<p>- Prologue offset: 39<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R15</p>\n<p>- Prologue offset: 37<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R14</p>\n<p>- Prologue offset: 35<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R13</p>\n<p>- Prologue offset: 33<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R12</p>\n<p>- Prologue offset: 31<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RDI</p>\n<p>- Prologue offset: 29<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RSI</p>\n<p>- Prologue offset: 27<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBX</p>\n<p>- Prologue offset: 25<br>\n    Op: SetFramePointer</p>\n<p>- Prologue offset: 22<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBP<br>\nAlignment padding: 2 bytes</p>\n<div class=\"codehilite\"><pre><span></span><code>This is correct for the generated prologue.  I&#39;ve verified that the correct offset to the unwind information was registered with Windows for this function.\n\nThe stack allocation for the frame is correctly aligned: 1712 bytes, starting with call-pushed return address.\n\nNote: there appears to be a bug in the stack check code as it&#39;s not taking into account the space needed for GPR saves (FPR saves are part of the stack pointer adjustment).  That bug is unrelated and would only cause a missed stack overflow trap in the unlikely case that the stack allocation size would fit, but the GPR saves push it over the limit).\n\nStill digging.\n\n~~~\n</code></pre></div>\n\n\n</blockquote>",
        "id": 202768281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593751204
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653339528\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>It appears the system unwinder can't get past the frame for <code>12746</code> for some yet-to-be-determined reason.</p>\n<p>The Wasm frames that show up in the debugger prior to the <code>STATUS_BAD_STACK</code>:</p>\n<ul>\n<li>12469 (calls <code>wasi_snapshot_preview1.proc_exit</code>)</li>\n<li>12504</li>\n<li>12746 (JIT'd function is 96059 bytes!)</li>\n</ul>\n<p>The unwind stops there.</p>\n<p>Prologue JIT for <code>12746</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>0000023CCCEAB200 48 8B 01             mov         rax,qword ptr [rcx]\n0000023CCCEAB203 48 8B 00             mov         rax,qword ptr [rax]\n0000023CCCEAB206 48 81 C0 68 06 00 00 add         rax,668h\n0000023CCCEAB20D 48 39 E0             cmp         rax,rsp\n0000023CCCEAB210 72 02                jb          0000023CCCEAB214\n0000023CCCEAB212 0F 0B                ud2\n0000023CCCEAB214 40 55                push        rbp\n0000023CCCEAB216 48 89 E5             mov         rbp,rsp\n0000023CCCEAB219 40 53                push        rbx\n0000023CCCEAB21B 40 56                push        rsi\n0000023CCCEAB21D 40 57                push        rdi\n0000023CCCEAB21F 41 54                push        r12\n0000023CCCEAB221 41 55                push        r13\n0000023CCCEAB223 41 56                push        r14\n0000023CCCEAB225 41 57                push        r15\n0000023CCCEAB227 48 81 EC 68 06 00 00 sub         rsp,668h\n0000023CCCEAB22E 44 0F 11 BC 24 50 06 00 00 movups      xmmword ptr [rsp+650h],xmm15\n</code></pre></div>\n\n\n<p>Function <code>12746</code> has the following encoded unwind information:</p>\n<p>```<br>\n01 37 0d 55 37 f8 00 00<br>\n2e 01 cd 00 27 f0 25 e0<br>\n23 d0 21 c0 1f 70 1d 60<br>\n1b 30 19 03 16 50 00 00</p>\n<div class=\"codehilite\"><pre><span></span><code>Decoded:\n</code></pre></div>\n\n\n<p>Version: 1<br>\nPrologue size: 55 bytes<br>\nUnwind codes: 13<br>\nFrame pointer register: RBP<br>\nFrame pointer offset: 80<br>\nCodes:</p>\n<p>- Prologue offset: 55 <br>\n    Op: SaveXmm128 (note: operation is two unwind codes in length)<br>\n    Reg: XMM15<br>\n    Stack offset: 0</p>\n<p>- Prologue offset:  46<br>\n    Op: LargeStackAlloc (note: operation is two unwind codes in length)<br>\n    Size: 668 bytes</p>\n<p>- Prologue offset: 39<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R15</p>\n<p>- Prologue offset: 37<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R14</p>\n<p>- Prologue offset: 35<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R13</p>\n<p>- Prologue offset: 33<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: R12</p>\n<p>- Prologue offset: 31<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RDI</p>\n<p>- Prologue offset: 29<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RSI</p>\n<p>- Prologue offset: 27<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBX</p>\n<p>- Prologue offset: 25<br>\n    Op: SetFramePointer</p>\n<p>- Prologue offset: 22<br>\n    Op: PushNonvolatileRegister<br>\n    Reg: RBP<br>\nAlignment padding: 2 bytes</p>\n<div class=\"codehilite\"><pre><span></span><code>This is correct for the generated prologue.  I&#39;ve verified that the correct offset to the unwind information was registered with Windows for this function.\n\nThe stack allocation for the frame is correctly aligned: 1712 bytes, starting with call-pushed return address.\n\nNote: there appears to be a bug in the stack check code as it&#39;s not taking into account the space needed for GPR saves (FPR saves are part of the stack pointer adjustment).  That bug is unrelated and would only cause a missed stack overflow trap in the unlikely case that the stack allocation size would fit, but the GPR saves push it over the limit).\n\nStill digging.\n\n~~~\n</code></pre></div>\n\n\n</blockquote>",
        "id": 202774578,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593760573
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653405653\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I've determined that the unwind information does not accurately describe the prologue after all.  As soon as I instruction step over establishing the frame pointer (e.g. <code>mov rbp,rsp</code>), stack walking fails.</p>\n<p>The problem boils down to the way the unwind information is describing the frame pointer.  Wasmtime establishes a frame pointer like one would in the x86 days: it points at the push of the previous frame pointer and thus marks the start (highest stack address) of the local frame.</p>\n<p>However, traditional frame pointers are rarely needed on Windows x64.  A \"frame pointer\" is really only established to mark a part of the frame as \"statically-sized\".  Positive offsets from this \"frame pointer\" would actually be in this static region of the local frame and <em>not</em> immediately the return address and caller's frame.  This is really important for functions that adjust the stack pointer in a way that can't be described in static unwind information (e.g. a function that calls <code>alloca</code>).</p>\n<p>The bug is a result of my confusion regarding the Windows unwind information nomenclature of \"frame pointer\".  What the unwind information really intends to describe is the \"base pointer to the static part of the local frame\".</p>\n<p>The fix should be to stop describing a \"frame pointer\" in the unwind information.  The frame pointer information in the unwind information will be changed to <code>0</code> and the <code>SetFramePointer</code> unwind code will not be emitted.  The offsets for the FPR saves will be changed to positive offsets from a post-adjusted RSP.</p>\n</blockquote>",
        "id": 202776542,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593762529
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653405653\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I've determined that the unwind information does not accurately describe the prologue after all.  As soon as I instruction step over establishing the frame pointer (e.g. <code>mov rbp,rsp</code>), stack walking fails.</p>\n<p>The problem boils down to the way the unwind information is describing the frame pointer.  Wasmtime establishes a frame pointer like one would in the x86 days: it points at the push of the previous frame pointer and thus marks the start (highest stack address) of the local frame.</p>\n<p>However, traditional frame pointers are rarely needed on Windows x64.  A \"frame pointer\" is really only established to mark a part of the frame as \"statically-sized\".  Positive offsets from this \"frame pointer\" would actually be in this static region of the local frame and <em>not</em> immediately the return address and caller's frame.  This is really important for functions that adjust the stack pointer in a way that can't be described in static unwind information (e.g. a function that calls <code>alloca</code>).</p>\n<p>The bug is a result of my confusion regarding the Windows unwind information nomenclature of \"frame pointer\".  What the unwind information really intends to describe is the \"base pointer to the static part of the local frame\".  As such, Windows really is expecting an actual offset from RSP when establishing the frame pointer (e.g. <code>lea rbp, [rsp-0x50]</code> in this case) which we're obviously not doing.</p>\n<p>The fix should be to stop describing a \"frame pointer\" in the unwind information.  The frame pointer information in the unwind information will be changed to <code>0</code> and the <code>SetFramePointer</code> unwind code will not be emitted.  The offsets for the FPR saves will be changed to positive offsets from a post-adjusted RSP.</p>\n</blockquote>",
        "id": 202776997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593763009
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653405653\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I've determined that the unwind information does not accurately describe the prologue after all.  As soon as I instruction step over establishing the frame pointer (e.g. <code>mov rbp,rsp</code>), stack walking fails.</p>\n<p>The problem boils down to the way the unwind information is describing the frame pointer for frames with FPR saves.  Wasmtime establishes a frame pointer like one would in the x86 days: it points at the push of the previous frame pointer and thus marks the start (highest stack address) of the local frame.</p>\n<p>However, traditional frame pointers are rarely needed on Windows x64.  A \"frame pointer\" is really only established to mark a part of the frame as \"statically-sized\".  Positive offsets from this \"frame pointer\" would actually be in this static region of the local frame and <em>not</em> immediately the return address and caller's frame.  This is really important for functions that adjust the stack pointer in a way that can't be described in static unwind information (e.g. a function that calls <code>alloca</code>).</p>\n<p>The bug is a result of my confusion regarding the Windows unwind information nomenclature of \"frame pointer\".  What the unwind information really intends to describe is the \"base pointer to the static part of the local frame\".  As such, Windows really is expecting an actual offset from RSP when establishing the frame pointer (e.g. <code>lea rbp, [rsp-0x50]</code> in this case) which we're obviously not doing.</p>\n<p>The fix should be to stop describing a \"frame pointer\" in the unwind information.  The frame pointer information in the unwind information will be changed to <code>0</code> and the <code>SetFramePointer</code> unwind code will not be emitted.  The offsets for the FPR saves will be changed to positive offsets from a post-adjusted RSP.</p>\n</blockquote>",
        "id": 202777288,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593763240
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653405653\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I've determined that the unwind information does not accurately describe the prologue after all.  As soon as I instruction step over establishing the frame pointer (e.g. <code>mov rbp,rsp</code>), stack walking fails.</p>\n<p>The problem boils down to the way the unwind information is describing the frame pointer for frames with FPR saves.  Cranelift establishes a frame pointer like one would in the x86 days: it points at the push of the previous frame pointer and thus marks the start (highest stack address) of the local frame.</p>\n<p>However, traditional frame pointers are rarely needed on Windows x64.  A \"frame pointer\" is really only established to mark a part of the frame as \"statically-sized\".  Positive offsets from this \"frame pointer\" would actually be in this static region of the local frame and <em>not</em> immediately the return address and caller's frame.  This is really important for functions that adjust the stack pointer in a way that can't be described in static unwind information (e.g. a function that calls <code>alloca</code>).</p>\n<p>The bug is a result of my confusion regarding the Windows unwind information nomenclature of \"frame pointer\".  What the unwind information really intends to describe is the \"base pointer to the static part of the local frame\".  As such, Windows really is expecting an actual offset from RSP when establishing the frame pointer (e.g. <code>lea rbp, [rsp-0x50]</code> in this case) which we're obviously not doing.</p>\n<p>The fix should be to stop describing a \"frame pointer\" in the unwind information.  The frame pointer information in the unwind information will be changed to <code>0</code> and the <code>SetFramePointer</code> unwind code will not be emitted.  The offsets for the FPR saves will be changed to positive offsets from a post-adjusted RSP.</p>\n</blockquote>",
        "id": 202777656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593763494
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967#issuecomment-653817481\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a>:</p>\n<blockquote>\n<p>I have a fix available, but I need to add a test case where we have a trap with frames that have FPR saves so that we don't regress this.</p>\n</blockquote>",
        "id": 202893376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1593900342
    },
    {
        "content": "<p>peterhuene labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a> (assigned to peterhuene):</p>\n<blockquote>\n<p>Originally reported at <a href=\"https://github.com/bytecodealliance/wasmtime-py/issues/36\">https://github.com/bytecodealliance/wasmtime-py/issues/36</a> I'm able to reproduce this pretty easily with just <a href=\"https://github.com/bytecodealliance/wasmtime/files/4865263/yosys.wasm.gz\">this wasm file</a>. Downloading that locally I can reproduce on Windows with:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ gunzip yosys.wasm.gz\n$ cargo run --release -- run yosys.wasm -- -V\n...\n    Finished release [optimized] target(s) in 3.84s\n     Running `target\\release\\wasmtime.exe run yosys.wasm -- -V`\nerror: process didn&#39;t exit successfully: `target\\release\\wasmtime.exe run yosys.wasm -- -V` (exit code: 0xc0000028)\n</code></pre></div>\n\n\n<p>Something funny is going on here though because <code>--opt-level 0</code> does not reproduce the issue (<code>--opt-level 1</code> does though).</p>\n<p>I'm trying to run this right now through <code>wasm-reduce</code> from Binaryen but so far it's only shaved off 3MB, which isn't a whole lot given the size of this binary...</p>\n<p>@peterhuene I'm having trouble just opening things up in a debugger, would you be able to help look into this?</p>\n</blockquote>",
        "id": 203027214,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594061738
    },
    {
        "content": "<p>peterhuene closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1967\">Issue #1967</a> (assigned to peterhuene):</p>\n<blockquote>\n<p>Originally reported at <a href=\"https://github.com/bytecodealliance/wasmtime-py/issues/36\">https://github.com/bytecodealliance/wasmtime-py/issues/36</a> I'm able to reproduce this pretty easily with just <a href=\"https://github.com/bytecodealliance/wasmtime/files/4865263/yosys.wasm.gz\">this wasm file</a>. Downloading that locally I can reproduce on Windows with:</p>\n<div class=\"codehilite\"><pre><span></span><code>$ gunzip yosys.wasm.gz\n$ cargo run --release -- run yosys.wasm -- -V\n...\n    Finished release [optimized] target(s) in 3.84s\n     Running `target\\release\\wasmtime.exe run yosys.wasm -- -V`\nerror: process didn&#39;t exit successfully: `target\\release\\wasmtime.exe run yosys.wasm -- -V` (exit code: 0xc0000028)\n</code></pre></div>\n\n\n<p>Something funny is going on here though because <code>--opt-level 0</code> does not reproduce the issue (<code>--opt-level 1</code> does though).</p>\n<p>I'm trying to run this right now through <code>wasm-reduce</code> from Binaryen but so far it's only shaved off 3MB, which isn't a whole lot given the size of this binary...</p>\n<p>@peterhuene I'm having trouble just opening things up in a debugger, would you be able to help look into this?</p>\n</blockquote>",
        "id": 203068111,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594099602
    }
]