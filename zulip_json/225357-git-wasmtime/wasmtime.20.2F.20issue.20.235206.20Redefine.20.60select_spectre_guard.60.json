[
    {
        "content": "<p>jameysharp labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>In #5201, @afonso360 observed that currently, every Cranelift backend can only lower <code>select_spectre_guard</code> when paired with <code>icmp</code>, and asked if there are any plans to implement it more generally.</p>\n<p>This instruction is currently only used in <code>cranelift/codegen/src/legalizer/heap.rs</code> and <code>cranelift/codegen/src/legalizer/table.rs</code> as part of the implementation of the <code>heap_addr</code> and <code>table_addr</code> instructions, respectively, when Spectre mitigations are enabled in the <code>TargetIsa</code> flags. And indeed, its first input is always produced by <code>icmp</code>.</p>\n<p>I think we should consider fusing the <code>icmp</code> semantics into the definition of <code>select_spectre_guard</code>'s behavior. That would clarify this question and also should give us a small compile-time speedup, due to processing fewer instructions and doing less work in instruction selection pattern-matching.</p>\n<p>I believe every use of <code>select_spectre_guard</code> is also preceded by an additional copy of the exact same <code>icmp</code>, to feed into <code>trapnz</code>. Maybe we can generate better code at the backends if we fuse that sequence into this instruction as well?</p>\n<p>The \"obvious\" way to fuse these instructions would be to make <code>select_spectre_guard</code> take two pairs of values, along with the condition code and maybe trap code. However, I believe that would make <code>InstructionData</code> bigger than 16 bytes, which we don't want to do.</p>\n<p>The <code>heap_addr</code> legalization always uses an <code>iconst 0</code> for the mispredict output, while <code>table_addr</code> uses the table base. Can we use a constant 0 address in both cases? Then we could define the fused instruction as taking only three <code>Value</code>s, which I think should fit alongside a condition code. If we also have a trap code the story is trickier since those are four bytes as well.</p>\n<p>This might also be part of, or an alternative to, #5190, so cc: @cfallin @fitzgen @alexcrichton</p>\n</blockquote>",
        "id": 308033026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667589555
    },
    {
        "content": "<p>jameysharp opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>In #5201, @afonso360 observed that currently, every Cranelift backend can only lower <code>select_spectre_guard</code> when paired with <code>icmp</code>, and asked if there are any plans to implement it more generally.</p>\n<p>This instruction is currently only used in <code>cranelift/codegen/src/legalizer/heap.rs</code> and <code>cranelift/codegen/src/legalizer/table.rs</code> as part of the implementation of the <code>heap_addr</code> and <code>table_addr</code> instructions, respectively, when Spectre mitigations are enabled in the <code>TargetIsa</code> flags. And indeed, its first input is always produced by <code>icmp</code>.</p>\n<p>I think we should consider fusing the <code>icmp</code> semantics into the definition of <code>select_spectre_guard</code>'s behavior. That would clarify this question and also should give us a small compile-time speedup, due to processing fewer instructions and doing less work in instruction selection pattern-matching.</p>\n<p>I believe every use of <code>select_spectre_guard</code> is also preceded by an additional copy of the exact same <code>icmp</code>, to feed into <code>trapnz</code>. Maybe we can generate better code at the backends if we fuse that sequence into this instruction as well?</p>\n<p>The \"obvious\" way to fuse these instructions would be to make <code>select_spectre_guard</code> take two pairs of values, along with the condition code and maybe trap code. However, I believe that would make <code>InstructionData</code> bigger than 16 bytes, which we don't want to do.</p>\n<p>The <code>heap_addr</code> legalization always uses an <code>iconst 0</code> for the mispredict output, while <code>table_addr</code> uses the table base. Can we use a constant 0 address in both cases? Then we could define the fused instruction as taking only three <code>Value</code>s, which I think should fit alongside a condition code. If we also have a trap code the story is trickier since those are four bytes as well.</p>\n<p>This might also be part of, or an alternative to, #5190, so cc: @cfallin @fitzgen @alexcrichton</p>\n</blockquote>",
        "id": 308033027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667589555
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1304081937\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>If we can I think it would be ideal to fit at least one bit for the trap code since wasm traps need to ideally distinguish between <code>MemoryOutOfBounds</code> and <code>TableOutOfBounds</code> here. The full-blown 4-byte trap code is definitely not needed for wasm, however.</p>\n</blockquote>",
        "id": 308036275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667590799
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1304142399\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<blockquote>\n<p>The \"obvious\" way to fuse these instructions would be to make <code>select_spectre_guard</code> take two pairs of values, along with the condition code and maybe trap code. However, I believe that would make <code>InstructionData</code> bigger than 16 bytes, which we don't want to do.</p>\n</blockquote>\n<p>We could move all this stuff into a side table and have the <code>InstructionData</code> just reference the side table by entity/index.</p>\n</blockquote>",
        "id": 308040987,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667592728
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1304255982\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>Hmm -- adding a side-table to hold some instruction data out-of-band, or picking just a single bit of trapcode to store, both seem somewhat suboptimal to me. We could do either if we <em>needed</em> this, but I'm trying to understand the need: is the argument for this fusion based only on the question of what <code>select_spectre_guard</code> means otherwise? Because answering that question seems much easier to me; in fact the answer is basically \"just <code>select</code>, but always a cmove in machine code / never folded away\".</p>\n</blockquote>",
        "id": 308048252,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595618
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1305909019\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>I guess my main question is, why make the backends handle the general case if we don't need it? My impression is that would be a little annoying if we kept all the iflags infrastructure, and worse as we're removing it.</p>\n<p>Besides, we've been talking about smaller numbers of more complex instructions as one of the tools in our toolbox for reducing time spent in Cranelift. Since these two instructions are always paired, I figured they seem like a natural candidate for that. In the most extreme case, we could stop legalizing <code>heap_addr</code> and add corresponding pseudo-instructions in the backends. I don't currently have an intuition for how the trade-offs work out among these options.</p>\n<p>I've considered the counter-argument that the <code>icmp</code> might be optimized away if it's the same as a preceding one. I don't think that's currently possible, because the backends always lower this pair of instructions together, regardless of whether the <code>icmp</code> was already lowered for another use. At this point we'd need machine-code peephole optimization for that, I think.</p>\n<p>I don't see any other way that this split has a performance advantage in either compile time or run time, and some chance that a combined instruction might have an advantage in both.</p>\n<p>In short: I don't know if this is a good idea, but I don't currently understand why we'd prefer the status quo.</p>\n</blockquote>",
        "id": 308431197,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667840356
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1474424512\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>One baby step simplification we could make to <code>select_spectre_guard</code>: make the zero operand implicit.</p>\n<p>It would have the following semantics (plus the speculation sandboxing guarantees):</p>\n<div class=\"codehilite\"><pre><span></span><code>spectre_guard 0, value = value\nspectre_guard n, _     = 0        if n != 0\n</code></pre></div>\n\n<p>(Since it isn't a select at the clif level anymore, I removed the \"select\" from the instruction name.)</p>\n<p>That is, this sequence today</p>\n<div class=\"codehilite\"><pre><span></span><code>v0 = ...\nv1 = iconst.i32 0\nv2 = icmp ugt ...\nv3 = select_spectre_guard v2, v1, v0\n</code></pre></div>\n\n<p>becomes</p>\n<div class=\"codehilite\"><pre><span></span><code>v0 = ...\nv1 = icmp ugt ...\nv2 = spectre_guard v1, v0\n</code></pre></div>\n\n</blockquote>",
        "id": 342668865,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679088935
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1478429164\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>Would it be useful to merge <code>select_spectre_guard</code> into a new variant of <code>trapz</code>? So <code>spectre_trapz v0, heap_oob, v1</code> would trap with <code>heap_oob</code> if <code>v0</code> is zero, and otherwise it would evaluate to <code>v1</code>. But in case of a branch mispredict, it would evaluate to zero on the speculated path.</p>\n<p>This would work safely with the idempotent side-effects machinery: as long as an identical instruction dominates the current one, you can reuse its result instead of evaluating it again, and be assured that both the trapping side-effect and the Spectre guard are preserved.</p>\n<p>It also fits into the approach we're discussing in #5908: we'd be able to write ISLE rules that rewrite this instruction to <code>v1</code> if <code>v0</code> is known to be non-zero. That's safe as long as <code>v0</code> doesn't depend on an earlier unguarded branch, which we've been discussing is something we need to think about regardless.</p>\n<p>With #6080, this could also be rewritten to an unconditional trap if <code>v0</code> is known to be zero. This is always safe no matter what earlier branches we've seen.</p>\n<p>With #6055, during elaboration, we could rewrite this to a plain <code>trapz</code> if its result is unused.</p>\n</blockquote>",
        "id": 343495716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679425015
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1478444330\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>I like this! In conjunction with a \"no path-sensitive deductions\" rule that we hold throughout optimizations, I think the constant-folding you're describing would be safe too. To elaborate on that a bit (@jameysharp and I talked offline a bit about this with others a few days ago):</p>\n<ul>\n<li>We need to be safe even in misspeculated executions of bounds-checks (this is \"Spectre safety\");</li>\n<li>In such an execution, we can ensure safety by short-circuiting an accessed memory address to NULL or another safe value based only on a comparison result, and not a branch (this relies on a microarchitecture guarantee that no value speculation is occurring, which we generally have, either explicitly via <code>csdb</code> barriers on aarch64 or via Spectre-safety recommendations on other CPUs);</li>\n<li>If we're going to optimize the cmove used for that short-circuiting, the \"choice\" input can't have the wrong value, even speculatively, relative to other values in the executed path;</li>\n<li>So we can't make any deductions and do constant propagation based on conditional or indirect branches (which <em>can be</em> speculated).</li>\n</ul>\n<p>Concretely this would mean that if we have a rule that sees <code>brif v0, truthyblock(...), falsyblock(...)</code>, we <em>cannot</em> const-fold any Spectre-guards based on <code>v0</code> being truthy in <code>truthyblock</code>. So if we want to fold <code>spectre_trapz v0, ...</code> with <code>v0</code> known to be <code>0</code> or <code>1</code>, we have to avoid such reasoning. But we don't currently have any such deductions, and we can keep it that way; then this unlocks some other nice optimizations, unless we've missed something...</p>\n</blockquote>",
        "id": 343498321,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679425732
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1478468252\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>We would have to be careful that we still get the lowering we want, where the <code>cmov</code> produces a zero that is what gets loaded. This seems kind of tricky while the <code>spectre_trapnz</code> is not fused as a single instruction with the load.</p>\n<p>For example this clif:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"err\">v</span><span class=\"mi\">0</span> <span class=\"err\">=</span> <span class=\"err\">icmp</span> <span class=\"err\">ugt</span> <span class=\"err\">index,</span> <span class=\"err\">heap_bound</span>\n<span class=\"err\">v</span><span class=\"mi\">1</span> <span class=\"err\">=</span> <span class=\"err\">iadd</span> <span class=\"err\">index,</span> <span class=\"err\">heap_base</span>\n<span class=\"err\">v</span><span class=\"mi\">2</span> <span class=\"err\">=</span> <span class=\"err\">spectre_trapnz</span> <span class=\"err\">v</span><span class=\"mi\">0</span><span class=\"err\">,</span> <span class=\"err\">heap_oob,</span> <span class=\"err\">v</span><span class=\"mi\">1</span>\n<span class=\"err\">v</span><span class=\"mi\">3</span> <span class=\"err\">=</span> <span class=\"err\">load.</span><span class=\"kt\">i32</span> <span class=\"err\">v</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>we would want to make sure does not expand into something like</p>\n<div class=\"codehilite\" data-code-language=\"NASM\"><pre><span></span><code><span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">index</span>\n<span class=\"w\">    </span><span class=\"nf\">add</span><span class=\"w\"> </span><span class=\"nv\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">heap_base</span>\n<span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"nf\">test</span><span class=\"w\"> </span><span class=\"nv\">index</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">heap_bound</span>\n<span class=\"w\">    </span><span class=\"nf\">cmova</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">v1</span>\n<span class=\"w\">    </span><span class=\"nf\">ja</span><span class=\"w\"> </span><span class=\"nv\">trap</span>\n<span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nv\">v2</span><span class=\"p\">]</span>\n\n<span class=\"nl\">trap:</span>\n<span class=\"w\">    </span><span class=\"nf\">ud2</span>\n</code></pre></div>\n<p>where there is an unnecessary jump-to-<code>ud2</code> (created by <code>MInst::TrapIf</code>) because of the way that <code>spectre_trapnz</code> is lowered independently of the <code>load.i32</code>.</p>\n<p>It seems like we <em>could</em> match <code>load(spectre_trapnz(...))</code> in the backends to make sure we generate the right code here, but this also seems a bit fragile and not obviously better than the <code>spectre_guard</code> variant I proposed above to me.</p>\n</blockquote>",
        "id": 343502067,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679427019
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1478468252\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>We would have to be careful that we still get the lowering we want, where the <code>cmov</code> produces a zero that is what gets loaded, and loading this zero value is what produces the trap. This seems kind of tricky while the <code>spectre_trapnz</code> is not fused as a single instruction with the load.</p>\n<p>For example this clif:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"err\">v</span><span class=\"mi\">0</span> <span class=\"err\">=</span> <span class=\"err\">icmp</span> <span class=\"err\">ugt</span> <span class=\"err\">index,</span> <span class=\"err\">heap_bound</span>\n<span class=\"err\">v</span><span class=\"mi\">1</span> <span class=\"err\">=</span> <span class=\"err\">iadd</span> <span class=\"err\">index,</span> <span class=\"err\">heap_base</span>\n<span class=\"err\">v</span><span class=\"mi\">2</span> <span class=\"err\">=</span> <span class=\"err\">spectre_trapnz</span> <span class=\"err\">v</span><span class=\"mi\">0</span><span class=\"err\">,</span> <span class=\"err\">heap_oob,</span> <span class=\"err\">v</span><span class=\"mi\">1</span>\n<span class=\"err\">v</span><span class=\"mi\">3</span> <span class=\"err\">=</span> <span class=\"err\">load.</span><span class=\"kt\">i32</span> <span class=\"err\">v</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>we would want to make sure does not expand into something like</p>\n<div class=\"codehilite\" data-code-language=\"NASM\"><pre><span></span><code><span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">index</span>\n<span class=\"w\">    </span><span class=\"nf\">add</span><span class=\"w\"> </span><span class=\"nv\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">heap_base</span>\n<span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"nf\">test</span><span class=\"w\"> </span><span class=\"nv\">index</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">heap_bound</span>\n<span class=\"w\">    </span><span class=\"nf\">cmova</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">v1</span>\n<span class=\"w\">    </span><span class=\"nf\">ja</span><span class=\"w\"> </span><span class=\"nv\">trap</span>\n<span class=\"w\">    </span><span class=\"nf\">mov</span><span class=\"w\"> </span><span class=\"nv\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nv\">v2</span><span class=\"p\">]</span>\n\n<span class=\"nl\">trap:</span>\n<span class=\"w\">    </span><span class=\"nf\">ud2</span>\n</code></pre></div>\n<p>where there is an unnecessary jump-to-<code>ud2</code> (created by <code>MInst::TrapIf</code>) because of the way that <code>spectre_trapnz</code> is lowered independently of the <code>load.i32</code>.</p>\n<p>It seems like we <em>could</em> match <code>load(spectre_trapnz(...))</code> in the backends to make sure we generate the right code here, but this also seems a bit fragile and not obviously better than the <code>spectre_guard</code> variant I proposed above to me.</p>\n</blockquote>",
        "id": 343502211,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679427084
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206#issuecomment-1478503987\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5206\">issue #5206</a>:</p>\n<blockquote>\n<p>I think what happened here is that I forgot that it's the <code>load</code>/<code>store</code> that traps, not a preceding conditional-trap instruction. Which means I'm not sure we have the pattern anywhere that a conditional trap precedes a <code>select_spectre_guard</code>, in which case the instruction I'm suggesting isn't one that we would use anywhere. Soâ€¦ nevermind?</p>\n<p>We probably still do want the kind of \"no path-sensitive deductions\" rule that Chris described, though.</p>\n</blockquote>",
        "id": 343507556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679428781
    }
]