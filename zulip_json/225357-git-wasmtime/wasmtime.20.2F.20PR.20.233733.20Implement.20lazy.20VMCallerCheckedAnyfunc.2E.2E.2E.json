[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>:</p>\n<blockquote>\n<p>Currently, in the instance initialization path, we build an \"anyfunc\"<br>\nfor every imported function and every function in the module. These<br>\nanyfuncs are used as function references in tables, both within a module<br>\nand across modules (via function imports).</p>\n<p>Building all of these is quite wasteful if we never use most of them.<br>\nInstead, it would be better to build only the ones that we use.</p>\n<p>This commit implements a technique to lazily initialize them: at the<br>\npoint that a pointer to an anyfunc is taken, we check whether it has<br>\nactually been initialized. If it hasn't, we do so. We track whether an<br>\nanyfunc has been initialized with a separate bitmap, and we only need to<br>\nzero this bitmap at instantiation time. (This is important for<br>\nperformance too: even just zeroing a large array of anyfunc structs can<br>\nbe expensive, at the microsecond scale, for a module with thousands of<br>\nfunctions.)</p>\n<p>Keeping the information around that is needed for this lazy init<br>\nrequired a bit of refactoring in the InstanceAllocationRequest; a few<br>\nfields now live in an <code>Arc</code> held by the instance while it exists.</p>\n<p>This was split out from #3699 (I'll rebase it out of that PR next).</p>\n<p>The benign-race trickery to make both instantiation and the access-time check<br>\nfast is a little hairy, but I left a long comment that tries to explain why<br>\nit works. More eyeballs on this (and/or thoughts on if there is a better<br>\nway to do this in semi-idiomatic Rust -- <code>UnsafeCell</code>? something else?)<br>\nwould be welcome!</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 269637677,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643317470
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a>.</p>",
        "id": 269637678,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643317470
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 269637988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643317593
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>:</p>\n<blockquote>\n<p>Currently, in the instance initialization path, we build an \"anyfunc\"<br>\nfor every imported function and every function in the module. These<br>\nanyfuncs are used as function references in tables, both within a module<br>\nand across modules (via function imports).</p>\n<p>Building all of these is quite wasteful if we never use most of them.<br>\nInstead, it would be better to build only the ones that we use.</p>\n<p>This commit implements a technique to lazily initialize them: at the<br>\npoint that a pointer to an anyfunc is taken, we check whether it has<br>\nactually been initialized. If it hasn't, we do so. We track whether an<br>\nanyfunc has been initialized with a separate bitmap, and we only need to<br>\nzero this bitmap at instantiation time. (This is important for<br>\nperformance too: even just zeroing a large array of anyfunc structs can<br>\nbe expensive, at the microsecond scale, for a module with thousands of<br>\nfunctions.)</p>\n<p>Keeping the information around that is needed for this lazy init<br>\nrequired a bit of refactoring in the InstanceAllocationRequest; a few<br>\nfields now live in an <code>Arc</code> held by the instance while it exists.</p>\n<p>This was split out from #3697 (I'll rebase it out of that PR next).</p>\n<p>The benign-race trickery to make both instantiation and the access-time check<br>\nfast is a little hairy, but I left a long comment that tries to explain why<br>\nit works. More eyeballs on this (and/or thoughts on if there is a better<br>\nway to do this in semi-idiomatic Rust -- <code>UnsafeCell</code>? something else?)<br>\nwould be welcome!</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 269638789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643317988
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 269640244,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643318721
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 269647954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643321630
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 269679561,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643338189
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 269831077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643423115
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>.</p>",
        "id": 270510502,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643874095
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3733\">PR #3733</a> from <code>lazy-anyfuncs</code> to <code>main</code>:</p>\n<blockquote>\n<p>During instance initialization, we build two sorts of arrays eagerly:</p>\n<ul>\n<li>\n<p>We create an \"anyfunc\" (a <code>VMCallerCheckedAnyfunc</code>) for every function<br>\n  in an instance.</p>\n</li>\n<li>\n<p>We initialize every element of a funcref table with an initializer to<br>\n  a pointer to one of these anyfuncs.</p>\n</li>\n</ul>\n<p>Most instances will not touch (via call_indirect or table.get) all<br>\nfuncref table elements. And most anyfuncs will never be referenced,<br>\nbecause most functions are never placed in tables or used with<br>\n<code>ref.func</code>. Thus, both of these initialization tasks are quite wasteful.<br>\nProfiling shows that a significant fraction of the remaining<br>\ninstance-initialization time after our other recent optimizations is<br>\ngoing into these two tasks.</p>\n<p>This PR implements two basic ideas:</p>\n<ul>\n<li>\n<p>The anyfunc array can be lazily initialized as long as we retain the<br>\n  information needed to do so. A zero in the func-ptr part of the tuple<br>\n  means \"uninitalized\"; a null-check and slowpath does the<br>\n  initialization whenever we take a pointer to an anyfunc.</p>\n</li>\n<li>\n<p>A funcref table can be lazily initialized as long as we retain a link<br>\n  to its corresponding instance and function index for each element. A<br>\n  zero in a table element means \"uninitialized\", and a slowpath does the<br>\n  initialization.</p>\n</li>\n</ul>\n<p>The use of all-zeroes to mean \"uninitialized\" means that we can use fast<br>\nmemory clearing techniques, like madvise(DONTNEED) on Linux or just<br>\nfreshly-mmap'd anonymous memory, to get to the initial state without<br>\na lot of memory writes.</p>\n<p>Funcref tables are a little tricky because funcrefs can be null. We need<br>\nto distinguish \"element was initially non-null, but user stored explicit<br>\nnull later\" from \"element never touched\" (ie the lazy init should not<br>\nblow away an explicitly stored null). We solve this by stealing the LSB<br>\nfrom every funcref (anyfunc pointer): when the LSB is set, the funcref<br>\nis initialized and we don't hit the lazy-init slowpath. We insert the<br>\nbit on storing to the table and mask it off after loading.</p>\n<p>Performance effect on instantiation in the on-demand allocator (pooling<br>\nallocator effect should be similar as the table-init path is the same):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">sequential</span><span class=\"o\">/</span><span class=\"n\">default</span><span class=\"o\">/</span><span class=\"n\">spidermonkey</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">time</span>:   <span class=\"p\">[</span><span class=\"mf\">71.886</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">72.012</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">72.133</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"n\">sequential</span><span class=\"o\">/</span><span class=\"n\">default</span><span class=\"o\">/</span><span class=\"n\">spidermonkey</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">time</span>:   <span class=\"p\">[</span><span class=\"mf\">22.243</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">22.256</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">22.270</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">change</span>: <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">69.117</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mf\">69.060</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mf\">69.000</span><span class=\"o\">%</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">0.00</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mf\">0.05</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">Performance</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">improved</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So, 72µs to 22µs, or a 69% reduction.</p>\n</blockquote>",
        "id": 270511489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643874977
    }
]