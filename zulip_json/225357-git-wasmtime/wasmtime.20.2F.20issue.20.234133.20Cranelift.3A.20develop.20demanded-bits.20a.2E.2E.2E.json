[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133\">issue #4133</a>:</p>\n<blockquote>\n<p>In some cases, it is possible to perform better optimizations and instruction selection if one knows that only part of a value is needed (demanded bits). At other times, it is possible to do better if one knows that the operation or instruction actually generating a value sets more bits than are necessary in the destination register (defined-bits).</p>\n<p>We should develop these analyses and use them during optimization and during lowering. Some examples:</p>\n<ul>\n<li>Bitmasks can be simplified or elided when demanded-bits allows: for example, <code>and x, 1</code> with only the LSB demanded is just <code>x</code>.</li>\n<li>An extend operator can be elided if the upper (extended-into) bits are not demanded.</li>\n<li>An extend operator can be elided if the upper bits are already actually defined by the chosen producer instruction(s).</li>\n</ul>\n<p>The demanded-bits analysis should be at the CLIF level as it is a machine-independent concept (what bits do the CLIF semantics of the use(s) actually depend on). The defined-bits analysis is fundamentally a lowered-MachInst-level concept, as it has to do (in our case, since no bits within the type are undefined) with bits above a value in a register (e.g., upper 32 for an <code>I32</code> a 64-bit register).</p>\n</blockquote>",
        "id": 281900889,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652226309
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133\">issue #4133</a>:</p>\n<blockquote>\n<p>In some cases, it is possible to perform better optimizations and instruction selection if one knows that only part of a value is needed (demanded bits). At other times, it is possible to do better if one knows that the operation or instruction actually generating a value sets more bits than are necessary in the destination register (defined-bits).</p>\n<p>We should develop these analyses and use them during optimization and during lowering. Some examples:</p>\n<ul>\n<li>Bitmasks can be simplified or elided when demanded-bits allows: for example, <code>and x, 1</code> with only the LSB demanded is just <code>x</code>.</li>\n<li>An extend operator can be elided if the upper (extended-into) bits are not demanded.</li>\n<li>An extend operator can be elided if the upper bits are already actually defined by the chosen producer instruction(s).</li>\n</ul>\n<p>The demanded-bits analysis should be at the CLIF level as it is a machine-independent concept (what bits do the CLIF semantics of the use(s) actually depend on). The defined-bits analysis is fundamentally a lowered-MachInst-level concept, as it has to do (in our case, since no bits within the type are undefined) with bits above a value in a register (e.g., upper 32 for an <code>I32</code> a 64-bit register).</p>\n</blockquote>",
        "id": 281900890,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652226309
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133\">issue #4133</a>:</p>\n<blockquote>\n<p>In some cases, it is possible to perform better optimizations and instruction selection if one knows that only part of a value is needed (demanded bits). At other times, it is possible to do better if one knows that the operation or instruction actually generating a value sets more bits than are necessary in the destination register (defined-bits).</p>\n<p>We should develop these analyses and use them during optimization and during lowering. Some examples:</p>\n<ul>\n<li>Bitmasks can be simplified or elided when demanded-bits allows: for example, <code>and x, 1</code> with only the LSB demanded is just <code>x</code>.</li>\n<li>An extend operator can be elided if the upper (extended-into) bits are not demanded.</li>\n<li>An extend operator can be elided if the upper bits are already actually defined by the chosen producer instruction(s).</li>\n</ul>\n<p>The demanded-bits analysis should be at the CLIF level as it is a machine-independent concept (what bits do the CLIF semantics of the use(s) actually depend on). The defined-bits analysis is fundamentally a lowered-MachInst-level concept, as it has to do (in our case, since no bits within the type are undefined) with bits above a value in a register (e.g., upper 32 for an <code>I32</code> a 64-bit register).</p>\n</blockquote>",
        "id": 281900891,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652226309
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133#issuecomment-1124024256\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133\">issue #4133</a>:</p>\n<blockquote>\n<blockquote>\n<p>The defined-bits analysis is fundamentally a lowered-MachInst-level concept, as it has to do (in our case, since no bits within the type are undefined) with bits above a value in a register</p>\n</blockquote>\n<p>I just realized I've been saying \"defined bits\" in conversation with you when I meant \"known bits\". I was about to comment that there is nothing fundamentally register-oriented about it, but of course I was talking about the wrong thing.</p>\n<p>For posterity/clarity, _known_ bits is a forwards analysis where we logically keep track of this join semi-lattice per bit in a value:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"w\"></span>\n<span class=\"mi\">0</span><span class=\"w\">   </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and we would have transfer functions that do things like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"o\">????</span><span class=\"mi\">0011</span><span class=\"w\"></span>\n<span class=\"n\">bor</span><span class=\"w\"> </span><span class=\"o\">????????</span><span class=\"w\"></span>\n<span class=\"o\">------------</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">??????</span><span class=\"mi\">11</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It's like per-bit (rather than per-value) partial evaluation.</p>\n<p>This is totally something we can do at the CLIF level. Nothing here is fundamentally dealing with registers here.</p>\n<p>In addition to being useful for peepholes, we can do neat things like remove CFG edges that we know will never be taken (look at the known bits for a <code>br_table</code>'s block index argument and remove edges to the table's blocks that conflict with those known bits). The CFG edge trimming is something that is definitely more of a CLIF thing than a mach inst thing.</p>\n</blockquote>",
        "id": 281996965,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652288684
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133#issuecomment-1124062631\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4133\">issue #4133</a>:</p>\n<blockquote>\n<p>That totally makes sense too! Per-bit partial evaluation (or per-bit constant folding I guess) is a good description. A value with all known bits graduates to a full <code>iconst</code> then and can enable further opts.</p>\n</blockquote>",
        "id": 282001228,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652290632
    }
]