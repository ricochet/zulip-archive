[
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175#issuecomment-663747846\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175\">Issue #1175</a>:</p>\n<blockquote>\n<p>Having a specialized <code>load_splat</code> Cranelift instruction would be beneficial for the AArch64 backend (so that it could generate <code>LD1R</code> instructions). I tried the alternative approach quickly, i.e. smarter codegen, which in the AArch64 case means using <code>maybe_input_insn()</code>, but it didn't work (I was getting <code>None</code> as the return value) - the reason was probably because the load might have side effects.</p>\n</blockquote>",
        "id": 204970359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595627295
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175#issuecomment-663751071\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175\">Issue #1175</a>:</p>\n<blockquote>\n<p>Let's do that then; in the past, it's always been ok to create Cranelift instructions that map exactly to Wasm SIMD instructions so that seems like a good path forward. If you add it (somewhere in <code>meta/src/shared/instructions.rs</code>) feel free to tag me and I'll review it.</p>\n</blockquote>",
        "id": 204971116,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595627985
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175#issuecomment-664671331\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175\">Issue #1175</a>:</p>\n<blockquote>\n<p>I'd be interested in having a wider discussion; in particular, @cfallin might have a different opinion with respect to the AArch64 backend.</p>\n</blockquote>",
        "id": 205176256,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595889089
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175#issuecomment-664677240\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175\">Issue #1175</a>:</p>\n<blockquote>\n<p>I think it's a reasonably pragmatic solution to have the dedicated instruction; it reduces work overall in the pipeline if we can carry the whole package of operations together as one unit from Wasm to machine code.</p>\n<p>There's a possible concern if we have a lot of these; it's certainly nice to only have to worry about literal \"load\" and \"store\" instructions when analyzing loads and stores. But perhaps we get around that by having accessors on the instruction (\"this inst is a load of some form, with address X and size Y\"). Or, in the worst case, the instruction is a black-box with unknown side-effects from the point of view of other optimization passes, so it inhibits some optimization but is still correct.</p>\n<p>@akirilov-arm, the reason that your (quite reasonable!) approach attempting to merge the ops in the backend didn't work is indeed because load is side-effecting, so will never be returned by <code>maybe_input_insn()</code>. This prevents the backend from arbitrarily sinking a side-effecting op, which could lead to a miscompile (consider if the load-splat were sunk past a store to an aliasing pointer, for example). The \"correct\" thing to do is to hoist the splat instead and then merge, but the framework isn't really set up to allow that.</p>\n</blockquote>",
        "id": 205177714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595890142
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1175\">Issue #1175</a>:</p>\n<blockquote>\n<h4>What is the feature or code improvement you would like to do in Cranelift?</h4>\n<p>In <a href=\"https://github.com/bytecodealliance/cranelift/issues/1347\">bytecodealliance/cranelift#1347</a> I added a temporary lowering for Wasm's <code>load_splat</code> to two Cranelift instructions, <code>load + splat</code>. This generates extra instructions that could be removed by a specialized Cranelift <code>load_splat</code> instruction or by smarter codegen (e.g. complex addressing on splat).</p>\n<h4>What is the value of adding this in Cranelift?</h4>\n<p>Fewer instructions produced.</p>\n<h4>Do you have an implementation plan, and/or ideas for data structures or algorithms to use?</h4>\n<p>Seeking feedback on which way to proceed: specialized <code>load_splat</code> or smarter codegen.</p>\n<h4>Have you considered alternative implementations? If so, how are they better or worse than your proposal?</h4>\n<p>See above.</p>\n</blockquote>",
        "id": 214889057,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1603914845
    }
]