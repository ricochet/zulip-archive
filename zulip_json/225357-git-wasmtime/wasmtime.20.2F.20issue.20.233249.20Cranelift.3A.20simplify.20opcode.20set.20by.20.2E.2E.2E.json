[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>In #3233 we discussed various simplifications we could perform to reduce the number of CLIF opcodes that exist. In general, we should strive for simplicity -- fewer opcodes mean less cost for every consumer of the IR -- as long as simplifications don't impose other overheads, such as unnecessary expansion and pattern-matching.</p>\n<p>The \"flags\"-related opcodes, such as <code>ifcmp</code> / <code>ffcmp</code>, <code>brif</code> / <code>brff</code>, <code>trapif</code> / <code>trapff</code>, and those that communicate carry/borrow flags via the full flags value, seem to be good candidates for removal. This is for at least a few reasons:</p>\n<ul>\n<li>A flag value behaves differently than most others in the IR, and as such, imposes complexity cost. For example, only one flag value may be live at a time. This constraint, enforced by the validator, is meant to allow the flags value to be directly lowered onto a machine's CPU flags register, but our backends no longer work this way. For another example, a flag value cannot be stored/loaded to/from memory.</li>\n<li>The flags do not have a well-defined value but rather serve as a sort of opaque connection between producer (e.g., a compare) and consumer (e.g., a branch). For example, a bitcast/raw-bitcast from a flag value to an integer is undefined (and disallowed by the validator).</li>\n<li>There is redundancy in the instruction set, as some conditions can <em>also</em> be materialized as bools. For example, we have both <code>iadd_carry</code>, which produces the carry flag as a bool, and <code>iadd_ifcout</code>, which produces a flags value with the carry embedded in it.</li>\n</ul>\n<p>With better pattern-matching in the backends (both as they stand today and potentially with a DSL to help as proposed in <a href=\"https://github.com/bytecodealliance/rfcs/issues/15\">bytecodealliance/rfcs#15</a>), it is less important for the CLIF to directly correspond to machine code; we can pattern-match a producer and consumer (e.g. a compare and a branch) that communicate via a <code>b1</code> (bool) just as well as we can those that communicate via opaque flags values.</p>\n<p>Thus, we should look into removing all uses of \"flags\" values, instead consuming the flags where they are produced to generate a bool condition as appropriate.</p>\n<p>One downside of this approach is that we cannot directly express reuse of flags for more than one condition (e.g. <code>ifcmp</code> then multiple <code>trueif</code>s with multiple flag conditions). Potentially we could instead pattern-match on multiple compare instructions with the same arguments and merge them instead, so e.g. <code>icmp ge v0, v1</code> and <code>icmp eq v0, v1</code> become a comopare-setcc-setcc three-instruction sequence.</p>\n<p>cc @abrown @afonso360 @bjorn3 from earlier discussion</p>\n</blockquote>",
        "id": 250807695,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629998191
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-906604881\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>A consideration here is that there's only one flags register and it's expensive to store and load, at least on x86. With a special flags type, it's easy for things like gvn and licm to \"do the right thing\" and avoid breaking up compare+branch patterns and inducing flags spills/reloads which are usually much more expensive than computing them redundantly. And, the constraints on the flags type, that at most one value be live at a time, and that it not be live across instructions which might clobber it, mean that the backend doesn't need code for spilling and restoring flags values.<br>\n</p>\n</blockquote>",
        "id": 250809964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629999140
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-906613037\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>That's a good point! The approach that we use today is to recompute the compare wherever we need it; so the compare always comes just before its use in the final machine code, by construction and without spills/reloads. I think we see the equivalent of this problem though when we do the pattern-matching, in that if we can't look back far enough (if the compare has been hoisted way up) then we just error out -- so actually, we are relying on the validator's single-flags-live constraint for that too, now that I think about it (with the constraint in place we can never hit the panic).</p>\n<p>I was about to propose all-in-one (\"compare+branch\") instructions -- actually I think we already have bricmp, but we'd want the same for <code>trueif</code>, <code>selectif</code>, <code>trapif</code>, ... -- but then this gives us an unfortunate O(n^2) explosion of all producers * all consumers. Essentially the single-flags-live constraint is a way of joining the two halves in a way that they're factored, but can't stray too far away.</p>\n<p>Needs more thought...</p>\n</blockquote>",
        "id": 250811696,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629999878
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-906616084\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>A bit of refinement of the above: if we can't look back far enough to see a <em>bool</em> condition, the worst that happens is that we materialize it (<code>setcc</code> on x86, <code>cset</code> on aarch64) and then use that later. The panic-if-we-can't-look-back-far-enough case specifically is for matching flags producers with consumers (e.g. <code>ifcmp</code> + <code>brif</code>).</p>\n<p>So I could see a design where we (i) standardize on bools, (ii) have some notion of \"cheap to recompute, expensive to keep value live\" that inhibits LICM / GVN on <code>icmp</code>, <code>fcmp</code>, <code>iadd_carry</code>, and friends, and (iii) hit the happy path most of the time in matching the bool producer to consumer. This seems like an OK compromise between IR semantics/simplicity and performance. Thoughts?</p>\n</blockquote>",
        "id": 250812337,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630000158
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-906651027\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>At a high level, that sounds reasonable to me :-).</p>\n</blockquote>",
        "id": 250819579,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630003251
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-910259729\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>+1 to standardizing on bools, as they're not hard to materialize into a register and it makes the IR much cleaner. Also, with existing nodes for min/max and saturating arithmetic, I think that a lot of important cases where the producer and consumer could be, unfortunately, separated have been negated.</p>\n</blockquote>",
        "id": 251553195,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630501197
    },
    {
        "content": "<p>chc4 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-923526364\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>I'm writing a dynamic recompilation engine targetting Cranelift. For part of that, it requires tracking processor flags for proper lifting, so that e.g. <code>add x, y; jz ...</code> works correctly. This is technically representational in Cranelift (though doesn't currently work, see <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2860#issuecomment-922574641\">https://github.com/bytecodealliance/wasmtime/issues/2860#issuecomment-922574641</a>), but wouldn't map to the proposed reduced instruction set; the explicit carry-out B1 is only the CF flag, and so doesn't allow a way for me to directly wire other processor flags (ZF, OF, PF) from producers to consumers.</p>\n</blockquote>",
        "id": 254145821,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632190109
    },
    {
        "content": "<p>chc4 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249#issuecomment-923526364\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>I'm writing a dynamic recompilation engine targetting Cranelift. For part of that, it requires tracking processor flags for proper lifting, so that e.g. <code>add x, y; jz ...</code> works correctly. This is technically representational in Cranelift (though doesn't currently work, see <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2860#issuecomment-922574641\">https://github.com/bytecodealliance/wasmtime/issues/2860#issuecomment-922574641</a>), but wouldn't map to the proposed reduced instruction set; the explicit carry-out B1 is only the CF flag, and so doesn't allow a way for me to directly wire other processor flags (ZF, OF, PF) from producers to consumers.</p>\n<p>B1 flags may work here if I can just emit \"manual\" processor flags recomputation, that are removed by Cranelift in cases where the values can be pulled from an internal live iflags value at selection time; some kind of <code>zf(val)</code> /<code>cf(x, y)</code> intrinsic might be better for that, so that the flag recomputation is a clear candidate for live range inclusion?</p>\n</blockquote>",
        "id": 254152397,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632196732
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>In #3233 we discussed various simplifications we could perform to reduce the number of CLIF opcodes that exist. In general, we should strive for simplicity -- fewer opcodes mean less cost for every consumer of the IR -- as long as simplifications don't impose other overheads, such as unnecessary expansion and pattern-matching.</p>\n<p>The \"flags\"-related opcodes, such as <code>ifcmp</code> / <code>ffcmp</code>, <code>brif</code> / <code>brff</code>, <code>trapif</code> / <code>trapff</code>, and those that communicate carry/borrow flags via the full flags value, seem to be good candidates for removal. This is for at least a few reasons:</p>\n<ul>\n<li>A flag value behaves differently than most others in the IR, and as such, imposes complexity cost. For example, only one flag value may be live at a time. This constraint, enforced by the validator, is meant to allow the flags value to be directly lowered onto a machine's CPU flags register, but our backends no longer work this way. For another example, a flag value cannot be stored/loaded to/from memory.</li>\n<li>The flags do not have a well-defined value but rather serve as a sort of opaque connection between producer (e.g., a compare) and consumer (e.g., a branch). For example, a bitcast/raw-bitcast from a flag value to an integer is undefined (and disallowed by the validator).</li>\n<li>There is redundancy in the instruction set, as some conditions can <em>also</em> be materialized as bools. For example, we have both <code>iadd_carry</code>, which produces the carry flag as a bool, and <code>iadd_ifcout</code>, which produces a flags value with the carry embedded in it.</li>\n</ul>\n<p>With better pattern-matching in the backends (both as they stand today and potentially with a DSL to help as proposed in <a href=\"https://github.com/bytecodealliance/rfcs/issues/15\">bytecodealliance/rfcs#15</a>), it is less important for the CLIF to directly correspond to machine code; we can pattern-match a producer and consumer (e.g. a compare and a branch) that communicate via a <code>b1</code> (bool) just as well as we can those that communicate via opaque flags values.</p>\n<p>Thus, we should look into removing all uses of \"flags\" values, instead consuming the flags where they are produced to generate a bool condition as appropriate.</p>\n<p>One downside of this approach is that we cannot directly express reuse of flags for more than one condition (e.g. <code>ifcmp</code> then multiple <code>trueif</code>s with multiple flag conditions). Potentially we could instead pattern-match on multiple compare instructions with the same arguments and merge them instead, so e.g. <code>icmp ge v0, v1</code> and <code>icmp eq v0, v1</code> become a comopare-setcc-setcc three-instruction sequence.</p>\n<p>cc @abrown @afonso360 @bjorn3 from earlier discussion</p>\n</blockquote>",
        "id": 255810070,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1633123724
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>In #3233 we discussed various simplifications we could perform to reduce the number of CLIF opcodes that exist. In general, we should strive for simplicity -- fewer opcodes mean less cost for every consumer of the IR -- as long as simplifications don't impose other overheads, such as unnecessary expansion and pattern-matching.</p>\n<p>The \"flags\"-related opcodes, such as <code>ifcmp</code> / <code>ffcmp</code>, <code>brif</code> / <code>brff</code>, <code>trapif</code> / <code>trapff</code>, and those that communicate carry/borrow flags via the full flags value, seem to be good candidates for removal. This is for at least a few reasons:</p>\n<ul>\n<li>A flag value behaves differently than most others in the IR, and as such, imposes complexity cost. For example, only one flag value may be live at a time. This constraint, enforced by the validator, is meant to allow the flags value to be directly lowered onto a machine's CPU flags register, but our backends no longer work this way. For another example, a flag value cannot be stored/loaded to/from memory.</li>\n<li>The flags do not have a well-defined value but rather serve as a sort of opaque connection between producer (e.g., a compare) and consumer (e.g., a branch). For example, a bitcast/raw-bitcast from a flag value to an integer is undefined (and disallowed by the validator).</li>\n<li>There is redundancy in the instruction set, as some conditions can <em>also</em> be materialized as bools. For example, we have both <code>iadd_carry</code>, which produces the carry flag as a bool, and <code>iadd_ifcout</code>, which produces a flags value with the carry embedded in it.</li>\n</ul>\n<p>With better pattern-matching in the backends (both as they stand today and potentially with a DSL to help as proposed in <a href=\"https://github.com/bytecodealliance/rfcs/issues/15\">bytecodealliance/rfcs#15</a>), it is less important for the CLIF to directly correspond to machine code; we can pattern-match a producer and consumer (e.g. a compare and a branch) that communicate via a <code>b1</code> (bool) just as well as we can those that communicate via opaque flags values.</p>\n<p>Thus, we should look into removing all uses of \"flags\" values, instead consuming the flags where they are produced to generate a bool condition as appropriate.</p>\n<p>One downside of this approach is that we cannot directly express reuse of flags for more than one condition (e.g. <code>ifcmp</code> then multiple <code>trueif</code>s with multiple flag conditions). Potentially we could instead pattern-match on multiple compare instructions with the same arguments and merge them instead, so e.g. <code>icmp ge v0, v1</code> and <code>icmp eq v0, v1</code> become a comopare-setcc-setcc three-instruction sequence.</p>\n<p>cc @abrown @afonso360 @bjorn3 from earlier discussion</p>\n</blockquote>",
        "id": 281211608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694387
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3249\">issue #3249</a>:</p>\n<blockquote>\n<p>In #3233 we discussed various simplifications we could perform to reduce the number of CLIF opcodes that exist. In general, we should strive for simplicity -- fewer opcodes mean less cost for every consumer of the IR -- as long as simplifications don't impose other overheads, such as unnecessary expansion and pattern-matching.</p>\n<p>The \"flags\"-related opcodes, such as <code>ifcmp</code> / <code>ffcmp</code>, <code>brif</code> / <code>brff</code>, <code>trapif</code> / <code>trapff</code>, and those that communicate carry/borrow flags via the full flags value, seem to be good candidates for removal. This is for at least a few reasons:</p>\n<ul>\n<li>A flag value behaves differently than most others in the IR, and as such, imposes complexity cost. For example, only one flag value may be live at a time. This constraint, enforced by the validator, is meant to allow the flags value to be directly lowered onto a machine's CPU flags register, but our backends no longer work this way. For another example, a flag value cannot be stored/loaded to/from memory.</li>\n<li>The flags do not have a well-defined value but rather serve as a sort of opaque connection between producer (e.g., a compare) and consumer (e.g., a branch). For example, a bitcast/raw-bitcast from a flag value to an integer is undefined (and disallowed by the validator).</li>\n<li>There is redundancy in the instruction set, as some conditions can <em>also</em> be materialized as bools. For example, we have both <code>iadd_carry</code>, which produces the carry flag as a bool, and <code>iadd_ifcout</code>, which produces a flags value with the carry embedded in it.</li>\n</ul>\n<p>With better pattern-matching in the backends (both as they stand today and potentially with a DSL to help as proposed in <a href=\"https://github.com/bytecodealliance/rfcs/issues/15\">bytecodealliance/rfcs#15</a>), it is less important for the CLIF to directly correspond to machine code; we can pattern-match a producer and consumer (e.g. a compare and a branch) that communicate via a <code>b1</code> (bool) just as well as we can those that communicate via opaque flags values.</p>\n<p>Thus, we should look into removing all uses of \"flags\" values, instead consuming the flags where they are produced to generate a bool condition as appropriate.</p>\n<p>One downside of this approach is that we cannot directly express reuse of flags for more than one condition (e.g. <code>ifcmp</code> then multiple <code>trueif</code>s with multiple flag conditions). Potentially we could instead pattern-match on multiple compare instructions with the same arguments and merge them instead, so e.g. <code>icmp ge v0, v1</code> and <code>icmp eq v0, v1</code> become a comopare-setcc-setcc three-instruction sequence.</p>\n<p>cc @abrown @afonso360 @bjorn3 from earlier discussion</p>\n</blockquote>",
        "id": 281211614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694390
    }
]