[
    {
        "content": "<p>tomaka opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <br>\nI have an existing code that is using <code>wasmtime 0.27</code>, and that is doing more or less something like this (pseudo-code):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_func</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_memory</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"p\">.</span><span class=\"n\">call_async</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span><span class=\"w\"></span>\n<span class=\"n\">futures</span>::<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Execute a bit of Wasm.</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">).</span><span class=\"n\">now_or_never</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Read the memory of the Wasm VM.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_cond</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The actual code is a bit more complicated than that (I'm also sharing a struct between the host functions and the caller), but I'm basically using <code>call_async</code> in order to start execution, manually polling the future returned by <code>call_async</code>, and while the execution is paused I can read/write the memory of the Wasm function.</p>\n<p>I've been trying to upgrade to <code>wasmtime 0.28</code>, but <a href=\"https://github.com/bytecodealliance/rfcs/pull/11\">the new API</a> is giving me a lot of trouble.<br>\nCalling <code>call_async</code> now requires passing an <code>impl AsMutContext</code>, meaning that we lose the ability to read/write memory from outside the host functions while the asynchronous call is in progress.</p>\n<p>I was wondering if you could give me suggestions on how to upgrade <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<h2>What I've tried</h2>\n<p>My little snippet maybe implies that the Wasm memory is used as a vector of communication between the host functions and the \"outside\", and that this could be refactored. But in practice the fact that I can read/write the memory of the Wasm function while execution is paused is something deeply ingrained in the API of my code (as this seems like a sensible thing to do).</p>\n<p>I've been trying to think of a way to pass to <code>call_async</code> some sort of glorified <code>Arc&lt;Mutex&lt;Store&gt;&gt;</code> that would implement <code>AsMutContext</code>, but I believe that the way the trait is defined makes it impossible to do in a safe way.</p>\n<p>There is a way to implement this safely:<br>\nThe <code>Caller&lt;_&gt;</code> that is accessible by the host functions can be used to read and write memory, so in principle one could imagine a system where an <code>Rc&lt;RefCell&lt;Vec&lt;Operation&gt;&gt;&gt;</code> is shared between the \"outside\" and the host functions, where <code>Operation</code> is some sort of <code>enum { ReadMemory(_), WriteMemory(_) }</code> and host functions process these operations after each <code>await</code>.<br>\nHowever this seems like a lot of complication.</p>\n<p>One potential change in <code>wasmtime</code> that could make sense to me would be to implement <code>AsContext</code> and <code>AsContextMut</code> on the future returned by <code>call_async</code>. In practice, however, this seems almost impossible to implement.</p>\n<p>Thanks in advance!<br>\n</p>\n</blockquote>",
        "id": 242703832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623746689
    },
    {
        "content": "<p>tomaka edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <br>\nI have an existing code that is using <code>wasmtime 0.27</code>, and that is doing more or less something like this (pseudo-code):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_func</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_memory</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"p\">.</span><span class=\"n\">call_async</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span><span class=\"w\"></span>\n<span class=\"n\">futures</span>::<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Execute a bit of Wasm.</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">).</span><span class=\"n\">now_or_never</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Read the memory of the Wasm VM.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_cond</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The actual code is a bit more complicated than that (I'm also sharing a struct between the host functions and the caller), but I'm basically using <code>call_async</code> in order to start execution, manually polling the future returned by <code>call_async</code>, and while the execution is paused I can read/write the memory of the Wasm function.</p>\n<p>I've been trying to upgrade to <code>wasmtime 0.28</code>, but <a href=\"https://github.com/bytecodealliance/rfcs/pull/11\">the new API</a> is giving me a lot of trouble.<br>\nCalling <code>call_async</code> now requires passing an <code>impl AsMutContext</code>, meaning that we lose the ability to read/write memory from outside the host functions while the asynchronous call is in progress.</p>\n<p>I was wondering if you could give me suggestions on how to upgrade <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<h2>What I've tried</h2>\n<p>My little snippet maybe implies that the Wasm memory is used as a vector of communication between the host functions and the \"outside\", and that this could be refactored. But in practice the fact that I can read/write the memory of the Wasm function while execution is paused is something deeply ingrained in the API of my code (as this seems like a sensible thing to do), and tens of thousands of lines of code depend on the ability to do that.</p>\n<p>I've been trying to think of a way to pass to <code>call_async</code> some sort of glorified <code>Arc&lt;Mutex&lt;Store&gt;&gt;</code> that would implement <code>AsMutContext</code>, but I believe that the way the trait is defined makes it impossible to do in a safe way.</p>\n<p>There is a way to implement this safely:<br>\nThe <code>Caller&lt;_&gt;</code> that is accessible by the host functions can be used to read and write memory, so in principle one could imagine a system where an <code>Rc&lt;RefCell&lt;Vec&lt;Operation&gt;&gt;&gt;</code> is shared between the \"outside\" and the host functions, where <code>Operation</code> is some sort of <code>enum { ReadMemory(_), WriteMemory(_) }</code> and host functions process these operations after each <code>await</code>.<br>\nHowever this seems like a lot of complication.</p>\n<p>One potential change in <code>wasmtime</code> that could make sense to me would be to implement <code>AsContext</code> and <code>AsContextMut</code> on the future returned by <code>call_async</code>. In practice, however, this seems almost impossible to implement.</p>\n<p>Thanks in advance!<br>\n</p>\n</blockquote>",
        "id": 242703971,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623746768
    },
    {
        "content": "<p>tomaka edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <br>\nI have an existing code that is using <code>wasmtime 0.27</code>, and that is doing more or less something like this (pseudo-code):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_func</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_memory</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"p\">.</span><span class=\"n\">call_async</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span><span class=\"w\"></span>\n<span class=\"n\">futures</span>::<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Execute a bit of Wasm.</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">).</span><span class=\"n\">now_or_never</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Read the memory of the Wasm VM.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_cond</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The actual code is a bit more complicated than that (I'm also sharing a struct between the host functions and the caller), but I'm basically using <code>call_async</code> in order to start execution, manually polling the future returned by <code>call_async</code>, and while the execution is paused I can read/write the memory of the Wasm function.</p>\n<p>I've been trying to upgrade to <code>wasmtime 0.28</code>, but <a href=\"https://github.com/bytecodealliance/rfcs/pull/11\">the new API</a> is giving me a lot of trouble.<br>\nCalling <code>call_async</code> now requires passing an <code>impl AsMutContext</code> that is being held for the entire duration of the call, meaning that we lose the ability to read/write memory from outside the host functions while the asynchronous call is in progress.</p>\n<p>I was wondering if you could give me suggestions on how to upgrade <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<h2>What I've tried</h2>\n<p>My little snippet maybe implies that the Wasm memory is used as a vector of communication between the host functions and the \"outside\", and that this could be refactored. But in practice the fact that I can read/write the memory of the Wasm function while execution is paused is something deeply ingrained in the API of my code (as this seems like a sensible thing to do), and tens of thousands of lines of code depend on the ability to do that.</p>\n<p>I've been trying to think of a way to pass to <code>call_async</code> some sort of glorified <code>Arc&lt;Mutex&lt;Store&gt;&gt;</code> that would implement <code>AsMutContext</code>, but I believe that the way the trait is defined makes it impossible to do in a safe way.</p>\n<p>There is a way to implement this safely:<br>\nThe <code>Caller&lt;_&gt;</code> that is accessible by the host functions can be used to read and write memory, so in principle one could imagine a system where an <code>Rc&lt;RefCell&lt;Vec&lt;Operation&gt;&gt;&gt;</code> is shared between the \"outside\" and the host functions, where <code>Operation</code> is some sort of <code>enum { ReadMemory(_), WriteMemory(_) }</code> and host functions process these operations after each <code>await</code>.<br>\nHowever this seems like a lot of complication.</p>\n<p>One potential change in <code>wasmtime</code> that could make sense to me would be to implement <code>AsContext</code> and <code>AsContextMut</code> on the future returned by <code>call_async</code>. In practice, however, this seems almost impossible to implement.</p>\n<p>Thanks in advance!<br>\n</p>\n</blockquote>",
        "id": 242718381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623755809
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986#issuecomment-861556357\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p>Thanks for the report, and this is a good question! I think you cover the problem pretty well here and have a pretty good grasp on what the limitations are. I agree that there's no great way (even with workarounds) to do this today. I personally would think that the best fix would be to implement <code>AsContext</code> and <code>AsContextMut</code> for the returned futures. That would indeed be significantly difficult for us on an implementation side but that's not necessarily a deterrent per-se.</p>\n<p>I think that the only workaround possible for now is the <code>Rc&lt;...&gt;</code>-based solution where the <code>Store</code> contains a channel through which communication can be done with the original call-site. The future closes over the <code>StoreContext&lt;'_, T&gt;</code> which means you can't get access to <code>T</code> while the future is running, so that sort of side-channel is the only method.</p>\n</blockquote>",
        "id": 242742417,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623767916
    },
    {
        "content": "<p>tomaka edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> <br>\nI have an existing code that is using <code>wasmtime 0.27</code>, and that is doing more or less something like this (pseudo-code):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_func</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">into_memory</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"p\">.</span><span class=\"n\">call_async</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span><span class=\"w\"></span>\n<span class=\"n\">futures</span>::<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Execute a bit of Wasm.</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">).</span><span class=\"n\">now_or_never</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Read the memory of the Wasm VM.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_memory</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_cond</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The actual code is a bit more complicated than that (I'm also sharing a struct between the host functions and the caller), but I'm basically using <code>call_async</code> in order to start execution, manually polling the future returned by <code>call_async</code>, and while the execution is paused I can read/write the memory of the Wasm VM.</p>\n<p>I've been trying to upgrade to <code>wasmtime 0.28</code>, but <a href=\"https://github.com/bytecodealliance/rfcs/pull/11\">the new API</a> is giving me a lot of trouble.<br>\nCalling <code>call_async</code> now requires passing an <code>impl AsMutContext</code> that is being held for the entire duration of the call, meaning that we lose the ability to read/write memory from outside the host functions while the asynchronous call is in progress.</p>\n<p>I was wondering if you could give me suggestions on how to upgrade <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<h2>What I've tried</h2>\n<p>My little snippet maybe implies that the Wasm memory is used as a vector of communication between the host functions and the \"outside\", and that this could be refactored. But in practice the fact that I can read/write the memory of the Wasm function while execution is paused is something deeply ingrained in the API of my code (as this seems like a sensible thing to do), and tens of thousands of lines of code depend on the ability to do that.</p>\n<p>I've been trying to think of a way to pass to <code>call_async</code> some sort of glorified <code>Arc&lt;Mutex&lt;Store&gt;&gt;</code> that would implement <code>AsMutContext</code>, but I believe that the way the trait is defined makes it impossible to do in a safe way.</p>\n<p>There is a way to implement this safely:<br>\nThe <code>Caller&lt;_&gt;</code> that is accessible by the host functions can be used to read and write memory, so in principle one could imagine a system where an <code>Rc&lt;RefCell&lt;Vec&lt;Operation&gt;&gt;&gt;</code> is shared between the \"outside\" and the host functions, where <code>Operation</code> is some sort of <code>enum { ReadMemory(_), WriteMemory(_) }</code> and host functions process these operations after each <code>await</code>.<br>\nHowever this seems like a lot of complication.</p>\n<p>One potential change in <code>wasmtime</code> that could make sense to me would be to implement <code>AsContext</code> and <code>AsContextMut</code> on the future returned by <code>call_async</code>. In practice, however, this seems almost impossible to implement.</p>\n<p>Thanks in advance!<br>\n</p>\n</blockquote>",
        "id": 242757889,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623773302
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986#issuecomment-864154473\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2986\">issue #2986</a>:</p>\n<blockquote>\n<p>I've posted some initial work for this at <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2999\">https://github.com/bytecodealliance/wasmtime/pull/2999</a>, but I think that manually implementing futures for <code>Instance::new_async</code> and friends is not really feasible to do. That means that only <code>call_async</code> gives access to the underlying context for now, so I'm not sure if it's the best to merge.</p>\n</blockquote>",
        "id": 243183370,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624033995
    }
]