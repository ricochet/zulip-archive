[
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688286175\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>This might be good for a <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/isa/x64/lower.isle#L1365-L1381\">rule like on x64</a> where much of the logic of bitselect can be skipped if the mask is known to have a particular pattern? (e.g. generated by icmp or fcmp)</p>\n</blockquote>",
        "id": 386621338,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692714137
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that</p>\n</blockquote>",
        "id": 386628203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692715822
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>\n</blockquote>",
        "id": 386628233,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692715831
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>\n<p>Edit: Hmm actually I don't think we can quite deduplicate this as neatly since we have different ways of generating a <code>icmp</code> mask and <code>fcmp</code> mask.</p>\n</blockquote>",
        "id": 386628853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692715976
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688341369\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Yeah, that's a neat way of de-duplicating these rules. I also think it might be worth copying that <code>vconst_all_ones_or_zeros</code> pattern into an egraphs rule, since it looks like we should be able to const propagate that.</p>\n<p>Edit: Hmm actually I don't think we can quite deduplicate this as neatly since we have different ways of generating a <code>icmp</code> mask and <code>fcmp</code> mask.</p>\n<p>Edit2: Wait, now I'm confused. We're already sort of skipping the main bitselect lowering by using <code>vmerge</code> instead, that merges whole lanes instead of bits. We can't skip generating the <code>icmp</code>/<code>fcmp</code> mask since in RISC-V the masks are 1 bit per lane, so we always need to make the conversion from 1 bit per bit, into 1 bit per lane. Is that what you meant?</p>\n</blockquote>",
        "id": 386629993,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692716298
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688393132\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Oh this may not be applicable for riscv64, but on x64 at least there's no bitselect instruction so it uses the and/or/not/etc combo by default, but x64 does have lane-based select so if a bitselect's input mask is a comparison then the and/or/not/etc combo can be skipped in favor of a single lane-based instruction. I figured the same might be possible for riscv64 where bitselect could skip the combo of instructions and generate a single <code>vmerge*</code> (which I interpreted, perhaps mistakenly, as a lane-based instruction) after the normal instruction generated for the comparison. That way the rules for <code>bitselect</code> wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into <code>vmerge</code>. </p>\n<blockquote>\n<p>since we have different ways of generating a icmp mask and fcmp mask.</p>\n</blockquote>\n<p>On x64 I believe this is handled by <code>bitselect</code> not actually generating the icmp/fcmp, instead basically calling <code>put_in_reg</code> for the output of the icmp/fcmp which then will later use other lowering rules to generate the icmp/fcmp.</p>\n<blockquote>\n<p>We can't skip generating the icmp/fcmp mask since in RISC-V the masks are 1 bit per lane, so we always need to make the conversion from 1 bit per bit, into 1 bit per lane. Is that what you meant?</p>\n</blockquote>\n<p>Right yeah, my thinking was that like on x64 the lowering for <code>bitselect</code> wouldn't generate the cmp, only the <code>vmerge</code>, but because the mask of the <code>bitselect</code> is only pattern-matched on but we don't use the sub-operands that it would still generate the cmp naturally via other lowering rules.</p>\n</blockquote>",
        "id": 386634301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692717426
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688527263\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Oh, okay so it's pretty much the same on RISC-V. We don't have a direct <code>bitselect</code> equivalent, we lower to <code>and/or/not</code> combo as well by default. <code>vmerge</code> is a lanewise select as you mentioned.</p>\n<blockquote>\n<p>That way the rules for bitselect wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into vmerge.</p>\n</blockquote>\n<p>Here's where this diverges. <code>vmerge</code> does not support the regular masks that are fed into <code>bitselect</code>. For a <code>i8x16</code> we need a 16bit mask instead of a 128bit mask. (Or a 8 bit mask for <code>i16x8</code>, etc...)</p>\n<p>In the regular <code>icmp</code> and <code>fcmp</code> instruction lowerings we do two things, first we generate the small mask (1 bit per lane), and then we do a second step of expanding that into a big mask.</p>\n<p>In this PR <code>gen_icmp_mask</code> and <code>gen_fcmp_mask</code> only generate the small mask, that is compatible with <code>vmerge</code>. But we never expand it, which is what would happen if we let the regular <code>icmp</code> and <code>fcmp</code> instructions get lowered.</p>\n<p>Does that make sense? I think I might be missing something, sorry if I am. <br>\n</p>\n</blockquote>",
        "id": 386646581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692721191
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688527263\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>Oh, okay so it's pretty much the same on RISC-V. We don't have a direct <code>bitselect</code> equivalent, we lower to <code>and/or/not</code> combo as well by default. <code>vmerge</code> is a lanewise select as you mentioned.</p>\n<blockquote>\n<p>That way the rules for bitselect wouldn't generate icmp/fcmp instructions at all, instead the output of those instructions will be fed directly into vmerge.</p>\n</blockquote>\n<p>Here's where this diverges. <code>vmerge</code> does not support the regular masks that are fed into <code>bitselect</code>. For a <code>i8x16</code> we need a 16bit mask instead of a 128bit mask. (Or a 8 bit mask for <code>i16x8</code>, etc...)</p>\n<p>In the regular <code>icmp</code> and <code>fcmp</code> instruction lowerings we do two things, first we generate the small mask (1 bit per lane), and then we do a second step of expanding that into a big mask.</p>\n<p>In this PR <code>gen_icmp_mask</code> and <code>gen_fcmp_mask</code> only generate the small mask, that is compatible with <code>vmerge</code>. But we never expand it, which is what would happen if we let the regular <code>icmp</code> and <code>fcmp</code> instructions get lowered.</p>\n<p>Does that make sense? I think I might be missing something, sorry if I am. </p>\n<p>--<br>\nEdit:</p>\n<p>Yeah I think this is where x64 and RISC-V are different. Reading the spec for the <a href=\"https://www.felixcloutier.com/x86/blendvpd\"><code>blend</code> instruction</a> it looks like it makes a decision based on the MSB on each lane, which allows it to directly use the input for <code>bitselect</code>, if we know its all the same for the entire lane.</p>\n<p>On RISC-V our masks are completely different we only use the lowest <code>n</code> bits of the entire register (where <code>n</code> is the lane count). So they are sort of \"compressed\" masks. But that makes them incompatible with WASM and Cranelift's <code>icmp/fcmp</code>, so we need to pretend that they are the same by expanding them, and that prevents just generating <code>vmerge</code> as part of <code>bitselect</code> even if <em>know</em> that the input is a <code>icmp</code>/<code>fcmp</code>. </p>\n</blockquote>",
        "id": 386649173,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692721829
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876#issuecomment-1688615987\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6876\">issue #6876</a>:</p>\n<blockquote>\n<p>A different way to deduplicate these rules would be along the lines of <code>maybe_uextend</code>; riscv could use a <code>maybe_bitcast</code> extractor to have just one bitselect rule for each of icmp and fcmp, instead of two for each.</p>\n<p>But I'm not sure that would be more broadly useful so I'm not sure it's worth doing. Just a thought in case it helps with something later.</p>\n</blockquote>",
        "id": 386660110,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692724897
    }
]