[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 217343913,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605827825
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 217344083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605827993
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-534942287\">PR Review</a>.</p>",
        "id": 217345108,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605828726
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r527273742\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The bottom 64 bits of <code>v8</code> -- <code>v15</code> (aka <code>q8</code> -- <code>q15</code>) are callee-saved as well (yeah, it's kinda weird!). <code>stp q8, q9, ...</code>, etc. should work.</p>\n</blockquote>",
        "id": 217345109,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605828726
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-535138238\">PR Review</a>.</p>",
        "id": 217365848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605852627
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r527448623\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this is the first time I've done aarch64 assembly, so want to confirm something to make sure. According <a href=\"https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/registers-in-aarch64-general-purpose-registers\">to this</a> the low 64-bits of the vector registers are <code>dN</code>, does that sound right? From what <a href=\"https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/procedure-call-standard\">this is saying though</a> is it true that <code>d8</code> to <code>d31</code> all need to be saved? (wow that's a lot of registers)</p>\n</blockquote>",
        "id": 217365850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605852628
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-535149369\">PR Review</a>.</p>",
        "id": 217367072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605854499
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r527471451\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Err, sorry, <code>d8</code> -- <code>d15</code>, yes. That document is a bit perplexing to me, though; the AArch64 \"AAPCS\" (standard ABI) (<a href=\"https://c9x.me/compile/bib/abi-arm64.pdf\">direct pdf link</a> to ABI doc, or <a href=\"https://developer.arm.com/documentation/ihi0055/b/\">ARM's download page</a>) says in 5.1.2 that <code>v0</code> -- <code>v7</code> and <code>v16</code> -- <code>v31</code> are caller-saved, and that's what we've implemented elsewhere (and what our friendly local ARM engineers have pointed us to -- see e.g. #2254).</p>\n<p>I'm actually wondering if the ARM page you've linked has a typo; they segment the registers into 8-15 and 16-31, but write \"callee-save\" for both; there'd be no reason to write the two ranges separately otherwise. In any case, hopefully the above helps somewhat!</p>\n</blockquote>",
        "id": 217367073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605854499
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 217414803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605886026
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 217415428,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605886320
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-535532270\">PR Review</a>.</p>",
        "id": 217415778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605886449
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r527771734\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh interesting! That does indeed look like a typo. Ok cool, then I think this should be handled in e40bd97</p>\n</blockquote>",
        "id": 217415780,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605886449
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 223571441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611263745
    },
    {
        "content": "<p>smacleod submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-576692084\">PR Review</a>.</p>",
        "id": 224093172,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611690787
    },
    {
        "content": "<p>smacleod submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-576692084\">PR Review</a>.</p>",
        "id": 224093173,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611690787
    },
    {
        "content": "<p>smacleod created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r564777811\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    // instruction which just aborts, but I don't know such an instruction in\n    // aarch64 land.\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 224093174,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611690787
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224094185,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611691226
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224493468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611936437
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224499990,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611938811
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224510870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611943337
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224510910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611943356
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224783456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612210091
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224791500,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612213857
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224809433,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612222567
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 224922223,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612293701
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-582982523\">PR Review</a>.</p>",
        "id": 225111822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612405491
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r569896886\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So I think <code>CreateFiberEx</code> should probably be used here as we probably want <code>stack_size</code> to be the reserve size and not the commit size on Windows.</p>\n<p><code>CreateFiber</code>'s <code>dwStackSize</code> parameter is the commit size and 1 MiB is typically used for the reserve size (it's from the PE header, but 1 MiB is what Microsoft's linker uses).</p>\n<p>If <code>dwStackSize</code> is larger than the default reserve size, then it reserves <code>dwStackSize</code> rounded up 1 MiB as the reserve size.</p>\n<p>With <code>CreateFiberEx</code>, there are two parameters: <code>dwStackCommitSize</code> and <code>dwStackReserveSize</code>. The former we'll want to pass 0 to get the default commit size (which will be 1 page in size, I believe).</p>\n<p>So suggested change:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fiber</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">CreateFiberEx</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">stack_size</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// FIBER_FLAG_FLOAT_SWITCH (might not be in the winapi crate)</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fiber_start</span>::<span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;*</span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">StartState</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This should help prevent the fiber stacks from counting towards the commit limit upfront.</p>\n</blockquote>",
        "id": 225111823,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612405491
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r569896886\">PR Review Comment</a>.</p>",
        "id": 225111835,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612405502
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225172725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612451800
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225178941,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612454303
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225179234,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612454419
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225206988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612465695
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225209540,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612466844
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225213933,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612468724
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-584061645\">PR Review</a>.</p>",
        "id": 225266553,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612507705
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r570753878\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    // The first 16 bytes of stack are reserved for metadata, so we start\n    // storing values beneath that.\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 225266554,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612507705
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is an implementation of [RFC 2] in Wasmtime which is to support<br>\n<code>async</code>-defined host functions. At a high level support is added by<br>\nexecuting WebAssembly code that might invoke an asynchronous host<br>\nfunction on a separate native stack. When the host function's future is<br>\nnot ready we switch back to the main native stack to continue execution.</p>\n<p>There's a whole bunch of details in this commit, and it's a bit much to<br>\ngo over them all here in this commit message. The most important changes<br>\nhere are:</p>\n<ul>\n<li>\n<p>A new <code>wasmtime-fiber</code> crate has been written to manage the low-level<br>\n  details of stack-switching. Unixes use <code>mmap</code> to allocate a stack and<br>\n  Windows uses the native fibers implementation. We'll surely want to<br>\n  refactor this to move stack allocation elsewhere in the future. Fibers<br>\n  are intended to be relatively general with a lot of type paremters to<br>\n  fling values back and forth across suspension points. The whole crate<br>\n  is a giant wad of <code>unsafe</code> unfortunately and involves handwritten<br>\n  assembly with custom dwarf CFI directives to boot. Definitely deserves<br>\n  a close eye in review!</p>\n</li>\n<li>\n<p>The <code>Store</code> type has two new methods -- <code>block_on</code> and <code>on_fiber</code><br>\n  which bridge between the async and non-async worlds. Lots of unsafe<br>\n  fiddly bits here as we're trying to communicate context pointers<br>\n  between disparate portions of the code. Extra eyes and care in review<br>\n  is greatly appreciated.</p>\n</li>\n<li>\n<p>The APIs for binding <code>async</code> functions are unfortunately pretty ugly<br>\n  in <code>Func</code>. This is mostly due to language limitations and compiler<br>\n  bugs (I believe) in Rust. Instead of <code>Func::wrap</code> we have a<br>\n<code>Func::wrapN_async</code> family of methods, and we've also got a whole<br>\n  bunch of <code>Func::getN_async</code> methods now too. It may be worth<br>\n  rethinking the API of <code>Func</code> to try to make the documentation page<br>\n  actually grok'able.</p>\n</li>\n</ul>\n<p>This isn't super heavily tested but the various test should suffice for<br>\nengaging hopefully nearly all the infrastructure in one form or another.<br>\nThis is just the start though!</p>\n<p>[RFC 2]: <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">https://github.com/bytecodealliance/rfcs/pull/2</a></p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 225348731,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612555168
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>.</p>",
        "id": 226830435,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613663369
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>.</p>",
        "id": 226830657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613663435
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/peterhuene\">peterhuene</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a>.</p>",
        "id": 227941164,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614352321
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-599866949\">PR Review</a>.</p>",
        "id": 227976946,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614366771
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r583859960\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll ping some Microsoft debugger folks to see if it's a known limitation of <code>StackWalkEx</code> when the given thread is a fiber.  I suspect <code>RtlVirtualUnwind</code> might not have this problem.</p>\n</blockquote>",
        "id": 227976947,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614366771
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-599909229\">PR Review</a>.</p>",
        "id": 227986177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614370470
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r583892410\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>These methods are the most heavily optimized...</p>\n</blockquote>\n<p>Perhaps I'm reading this sentence wrong, but \"most heavily optimized\" sounds like the opposite intention.</p>\n</blockquote>",
        "id": 227986178,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614370470
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-599931345\">PR Review</a>.</p>",
        "id": 227991522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614372572
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#discussion_r583910007\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>        // We don't actually care about the fiber's return value here (no one's\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 227991523,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614372572
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434#pullrequestreview-599933077\">PR Review</a>.</p>",
        "id": 227992058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614372742
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a> from <code>async</code> to <code>main</code>.</p>",
        "id": 227997349,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614375062
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2434\">PR #2434</a>.</p>",
        "id": 228004470,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614377997
    }
]