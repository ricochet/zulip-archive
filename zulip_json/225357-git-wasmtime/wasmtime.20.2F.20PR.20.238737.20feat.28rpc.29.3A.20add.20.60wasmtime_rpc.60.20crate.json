[
    {
        "content": "<p>rvolosatovs edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>.</p>",
        "id": 442566970,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717517056
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>.</p>",
        "id": 442567202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717517124
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>.</p>",
        "id": 442750334,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717583916
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>.</p>",
        "id": 442750803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1717584099
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737#pullrequestreview-2108633997\">PR review</a>:</p>\n<blockquote>\n<p>Thanks again for your patience while I found time to get to review this. At a high level this all looks good modulo minor comments here or there but I wanted to drill in in some more of the details before we land this. </p>\n<p>First, to clarify, the main intention of landing this in-repo is to serve as both an example for other users and to integrate this with the <code>wasmtime</code> CLI, right? In that case one part of examples in theory should be a \"hello world\" of how to set it up, for example given a component that imports something create/compile a client that serves it in addition to the CLI flags necessary to run the component at hand. One difficult part about this is going to be that the client source will live in a separate repository (and/or have many of its dependencies there), but if the end goal is to have CLI support for this I think we'll want to plan for an example too (ideally one run in CI).</p>\n<p>Next I'm also sort of coming at this from the perspective of if APIs in <code>wasmtime</code> need to change or if APIs need to be updated. For example the usage of <code>Val</code> here feels unnecessarily inefficient. I've long thought the representation of <code>Val</code> is pretty inefficient (e.g. heap allocation for nested values and things like strings-for-flags right nwo). It's also pretty unfortunate that types need to be passed around manually here instead since especially with resources that gets tricky and requires shenanigans like <code>substituted_component_type</code> which is pretty non-obvious. Long-term what I think we'd ideally have is something along the lines of <code>func_new_unchecked</code> but without the unsafety. What I'm envisioning is that host functions could be defined as <code>fn(StoreContextMut&lt;'_, T&gt;,  args: ComponentArgs&lt;'_&gt;, ret: ComponentRet&lt;'_&gt;) -&gt; Result&lt;()&gt;</code>. The <code>ComponentArgs</code> structure would serve as a deserializer of sorts and the <code>ComponentRet</code> structure would act as a serializer of sorts. That way you could plug those directly into this protocol and avoid an intermediate copy through the host (e.g. the creation of a <code>Val</code>). That would also enable <code>args.serialize() -&gt; Vec&lt;u8&gt;</code> and <code>ret.deserialize(&amp;[u8]) -&gt; Result&lt;()&gt;</code> where the component encoding format could be implemented directly in those two.</p>\n<p>I'm writing down this idea with the purpose of explicitly saying that this implementation as-is is debt that we're accruing and don't have a plan to pay it down. Debt I mean in th sense of leaning on a known-explicitly-inefficient abstraction <code>Val</code> without a concrete plan on improving it. It's not necessarily required that this is paid down immediately but I do think it's important to consider this at the same time.</p>\n<p>Similarly though I'm at least personally surprised by the complexity here. Namely <code>link_function</code> has an 11-line <code>where</code> clause along with two extra generics in the arguments themselves. Much of the complexity seems to be unused too, for example I couldn't actually figure out where <code>deferred</code> came into play, is it perhaps resources? It also seemed a little complex to have <code>async</code> work at all parts of the stack here, would it be reasonable to require that a single component value is required to be entirely in-memory during serialization or deserialization?</p>\n<p>We try to be judicious about picking up new dependencies in Wasmtime so ideally this could be trimmed down to an <code>AsyncWrite</code> plus <code>AsyncRead</code> pair or, better yet, something like <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> where this crate would define just a single trait and the trait could be implemented by downstream consumers.</p>\n<p>Overall my current feeling is that I'm at least personally not understanding the long-term of this. I think it makes sense to add to <code>wasmtime</code>-the-CLI but it feels like an overly complex implementation for that use case. As-is it feels like this could suitably be an external crate to guide some API changes in Wasmtime itself, but I also realize you probably have more long-term goals for this being in-tree so I also think it would be good to get those written down to.</p>\n</blockquote>",
        "id": 443851653,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718049064
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737#issuecomment-2165250669\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>:</p>\n<blockquote>\n<p>To make sure we're on the same page: this PR is a work-in-progress PoC at best, really just opened to align on the direction here, I would not expect it to be ready-for-review for another week at least. I've just recently reworked the transport abstraction, and a few changes, I think, are still coming. It is my absolute intention to add a simple to follow end-to-end example to this PR (most probably using QUIC transport I've just finished yesterday <a href=\"https://github.com/wrpc/wrpc/pull/127\">https://github.com/wrpc/wrpc/pull/127</a>) before marking it as ready-for-review. I'm just now starting with updating the bindgen to a few changes made in value definition encoding and the new transport - that's the biggest blocker for now.</p>\n<blockquote>\n<p>First, to clarify, the main intention of landing this in-repo is to serve as both an example for other users and to integrate this with the <code>wasmtime</code> CLI, right? In that case one part of examples in theory should be a \"hello world\" of how to set it up, for example given a component that imports something create/compile a client that serves it in addition to the CLI flags necessary to run the component at hand. One difficult part about this is going to be that the client source will live in a separate repository (and/or have many of its dependencies there), but if the end goal is to have CLI support for this I think we'll want to plan for an example too (ideally one run in CI).</p>\n</blockquote>\n<p>The intention here is to, given an off-the-shelf <code>wrpc_transport::Invoke</code> implementation, likely contained within <a href=\"https://github.com/wrpc/wrpc\">https://github.com/wrpc/wrpc</a> (BA transfer pending), provide developers the tools to satisfy component imports of their choosing at runtime. Eventually I'd like to also add functionality to serve exports given a <code>wrpc_transport::Serve</code> implementation. The key benefit here is the standardized, generic traits (the <code>Invoke</code> and <code>Serve</code>) and the associated collection of fully-specified transports. I was a bit hesitant adding CLI support in this PR since I did not want to prematurely flesh out the UX of that, but since that feature would be feature gated and opt-in anyway (at least to start with), I guess I will just go ahead and add a simple CLI support for this in this PR as well. This PR will not be considered ready until there's both a \"low-level\", library use example <em>and</em> CLI usage example available (or documented).</p>\n<blockquote>\n<p>Next I'm also sort of coming at this from the perspective of if APIs in <code>wasmtime</code> need to change or if APIs need to be updated. For example the usage of <code>Val</code> here feels unnecessarily inefficient. I've long thought the representation of <code>Val</code> is pretty inefficient (e.g. heap allocation for nested values and things like strings-for-flags right nwo). It's also pretty unfortunate that types need to be passed around manually here instead since especially with resources that gets tricky and requires shenanigans like <code>substituted_component_type</code> which is pretty non-obvious. Long-term what I think we'd ideally have is something along the lines of <code>func_new_unchecked</code> but without the unsafety. What I'm envisioning is that host functions could be defined as <code>fn(StoreContextMut&lt;'_, T&gt;, args: ComponentArgs&lt;'_&gt;, ret: ComponentRet&lt;'_&gt;) -&gt; Result&lt;()&gt;</code>. The <code>ComponentArgs</code> structure would serve as a deserializer of sorts and the <code>ComponentRet</code> structure would act as a serializer of sorts. That way you could plug those directly into this protocol and avoid an intermediate copy through the host (e.g. the creation of a <code>Val</code>). That would also enable <code>args.serialize() -&gt; Vec&lt;u8&gt;</code> and <code>ret.deserialize(&amp;[u8]) -&gt; Result&lt;()&gt;</code> where the component encoding format could be implemented directly in those two.</p>\n</blockquote>\n<p>Absolutely agree, in fact I was always hoping that at one point we could make the runtime be \"wRPC-aware\" and directly convert to/from canon ABI values to \"value definition\" values. I believe, for some of these, the conversion is just an identity function, e.g. a <code>bool</code> encoding is exactly the same for both.<br>\nRegarding the traits, my (rough) suggestion for wRPC value trait analogues for this can be found here <a href=\"https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683\">https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683</a></p>\n<blockquote>\n<p>Similarly though I'm at least personally surprised by the complexity here. Namely <code>link_function</code> has an 11-line <code>where</code> clause along with two extra generics in the arguments themselves. Much of the complexity seems to be unused too, for example I couldn't actually figure out where <code>deferred</code> came into play, is it perhaps resources? It also seemed a little complex to have <code>async</code> work at all parts of the stack here, would it be reasonable to require that a single component value is required to be entirely in-memory during serialization or deserialization?</p>\n<p>We try to be judicious about picking up new dependencies in Wasmtime so ideally this could be trimmed down to an <code>AsyncWrite</code> plus <code>AsyncRead</code> pair or, better yet, something like <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> where this crate would define just a single trait and the trait could be implemented by downstream consumers.</p>\n</blockquote>\n<p>Like mentioned above, this is still a PoC and the interface will change slightly, that said, these are the two biggest complexity sources I've identified:</p>\n<ul>\n<li><code>wasmtime::Error</code> usage (i.e. just a <code>anyhow::Error</code>), which <em>does not</em> implement <code>std::error::Error</code>. I'd <em>love</em> to bind the associated error types to <em>just</em> implement <code>std::error::Error</code>, which would eliminate most of these awkward trait bounds, but unfortunately that would prevent anyone from using <code>anyhow::Error</code> as the implementation for these. <code>anyhow::Error</code> implements <code>AsRef&lt;dyn Error&gt;</code> <a href=\"https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error\">https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error</a>, but it does not look like an \"idiomatic\" approach, e.g. it does not look like a blanket implementation would exist for <code>std::error::Error</code>, similarly, <code>std::io::Error</code> also does not implement such.<ul>\n<li>Another way to handle this could potentially be using associated type defaults, but that's not stable in Rust yet</li>\n</ul>\n</li>\n<li>async values (<code>stream</code> and <code>future</code>). As briefly mentioned in OP, wRPC has native support for async types. I fully acknowledge that Wasmtime today does not support async, however, I believe that's coming soon(ish?). Regardless, as we discussed offline, the implementation will be \"smart\" about host WASI resources and transfer <code>outgoing-stream</code> resource as <code>stream&lt;u8&gt;</code>. That's what the <code>deferred</code> field and the path indexes are for. For example, consider:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">   </span><span class=\"c1\">// reads bytes from rx and writes them to each stream in tx</span>\n<span class=\"w\">   </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">tee</span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">input</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">list</span><span class=\"o\">&lt;</span><span class=\"n\">output</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">result</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><code>tee</code> contract requires <code>tx</code> to be received <em>before</em> full contents of <code>rx</code> are available. The <code>rx</code> field would be encoded as <code>option&lt;list&lt;u8&gt;&gt;</code> in the first, \"sync\" pass - if full contents of <code>rx</code> are not available at encoding time, it would be sent as <code>option::none</code>, while a \"deferred\" writer of the underlying <code>stream&lt;u8&gt;</code> would be registered with index <code>0</code> (first parameter). <code>tx</code> would be fully encoded \"synchronously\". After the \"sync\" parameters are sent, the implementation would concurrently be sending more bytes of <code>rx</code> and await the <code>result&lt;u64&gt;</code>.</p>\n<p>There is no resource support in PR currently, so <code>deferred</code> is not used indeed, I am happy to add that in this PR - was hoping to keep the scope small, but I don't mind adding more things here if that's desired.</p>\n<p>So to answer your question, neither \"just\"  <code>AsyncRead</code>/<code>AsyncWrite</code>, nor <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> could actually satisfy the requirements here without breaking the contracts in general case, for two reasons:</p>\n<ol>\n<li>values may not fit in memory and may even not even be \"finite\" in some sense (e.g. if the <code>input-stream</code> is an HTTP body stream or a TCP stream)</li>\n<li>\n<p>values may be arbitrarily nested (e.g. a <code>record { foo: stream&lt;stream&lt;stream&lt;vec&lt;stream&lt;future&lt;u8&gt;&gt;&gt;&gt;&gt;&gt;  }</code>). Wasmtime would need to implement it's own framing of some kind to differentiate different chunks of the async values, which I believe is not desired, because:</p>\n<ul>\n<li>That would require a Wasmtime \"proprietary\" framing spec</li>\n<li>Require more complexity in Wasmtime integration</li>\n<li>Lead to inefficiency for transport with \"native\" multiplexing (e.g. QUIC)<br>\nTo address this, <code>wrpc_transport</code> crate provides an <code>Index</code> trait, e.g. see example QUIC implementation here <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484</a>. There's also a standardized frame definition available in <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261</a> for transport without native multiplexing (e.g. a TCP stream or an in-memory pipe)</li>\n</ul>\n</li>\n</ol>\n<p>All that said, I'm happy to add a fully-synchronous <code>Invoke</code> trait to this crate with blanket impl for <code>wrpc_transport::Invoke</code>, which would also bind the error types to be <code>wasmtime::Error</code> and use that in bounds removing the async support from this PR for now. That would mean that this trait would require breaking changes later on, but perhaps it would be easier to align on the async design in a follow-up PR?</p>\n</blockquote>",
        "id": 444432570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718274401
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737#issuecomment-2165250669\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>:</p>\n<blockquote>\n<p>To make sure we're on the same page: this PR is a work-in-progress PoC at best, really just opened to align on the direction here, I would not expect it to be ready-for-review for another week at least. I've just recently reworked the transport abstraction, and a few changes, I think, are still coming. It is my absolute intention to add a simple to follow end-to-end example to this PR (most probably using QUIC transport I've just finished yesterday <a href=\"https://github.com/wrpc/wrpc/pull/127\">https://github.com/wrpc/wrpc/pull/127</a>) before marking it as ready-for-review. I'm just now starting with updating the bindgen to a few changes made in value definition encoding and the new transport - that's the biggest blocker for now.</p>\n<blockquote>\n<p>First, to clarify, the main intention of landing this in-repo is to serve as both an example for other users and to integrate this with the <code>wasmtime</code> CLI, right? In that case one part of examples in theory should be a \"hello world\" of how to set it up, for example given a component that imports something create/compile a client that serves it in addition to the CLI flags necessary to run the component at hand. One difficult part about this is going to be that the client source will live in a separate repository (and/or have many of its dependencies there), but if the end goal is to have CLI support for this I think we'll want to plan for an example too (ideally one run in CI).</p>\n</blockquote>\n<p>The intention here is to, given an off-the-shelf <code>wrpc_transport::Invoke</code> implementation, likely contained within <a href=\"https://github.com/wrpc/wrpc\">https://github.com/wrpc/wrpc</a> (BA transfer pending), provide developers the tools to satisfy component imports of their choosing at runtime. Eventually I'd like to also add functionality to serve exports given a <code>wrpc_transport::Serve</code> implementation. The key benefit here is the standardized, generic traits (the <code>Invoke</code> and <code>Serve</code>) and the associated collection of fully-specified transports. I was a bit hesitant adding CLI support in this PR since I did not want to prematurely flesh out the UX of that, but since that feature would be feature gated and opt-in anyway (at least to start with), I guess I will just go ahead and add a simple CLI support for this in this PR as well. This PR will not be considered ready until there's both a \"low-level\", library use example <em>and</em> CLI usage example available (or documented).</p>\n<blockquote>\n<p>Next I'm also sort of coming at this from the perspective of if APIs in <code>wasmtime</code> need to change or if APIs need to be updated. For example the usage of <code>Val</code> here feels unnecessarily inefficient. I've long thought the representation of <code>Val</code> is pretty inefficient (e.g. heap allocation for nested values and things like strings-for-flags right nwo). It's also pretty unfortunate that types need to be passed around manually here instead since especially with resources that gets tricky and requires shenanigans like <code>substituted_component_type</code> which is pretty non-obvious. Long-term what I think we'd ideally have is something along the lines of <code>func_new_unchecked</code> but without the unsafety. What I'm envisioning is that host functions could be defined as <code>fn(StoreContextMut&lt;'_, T&gt;, args: ComponentArgs&lt;'_&gt;, ret: ComponentRet&lt;'_&gt;) -&gt; Result&lt;()&gt;</code>. The <code>ComponentArgs</code> structure would serve as a deserializer of sorts and the <code>ComponentRet</code> structure would act as a serializer of sorts. That way you could plug those directly into this protocol and avoid an intermediate copy through the host (e.g. the creation of a <code>Val</code>). That would also enable <code>args.serialize() -&gt; Vec&lt;u8&gt;</code> and <code>ret.deserialize(&amp;[u8]) -&gt; Result&lt;()&gt;</code> where the component encoding format could be implemented directly in those two.</p>\n</blockquote>\n<p>Absolutely agree, in fact I was always hoping that at one point we could make the runtime be \"wRPC-aware\" and directly convert to/from canon ABI values to \"value definition\" values. I believe, for some of these, the conversion is just an identity function, e.g. a <code>bool</code> encoding is exactly the same for both.<br>\nRegarding the traits, my (rough) suggestion for wRPC value trait analogues for this can be found here <a href=\"https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683\">https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683</a></p>\n<blockquote>\n<p>Similarly though I'm at least personally surprised by the complexity here. Namely <code>link_function</code> has an 11-line <code>where</code> clause along with two extra generics in the arguments themselves. Much of the complexity seems to be unused too, for example I couldn't actually figure out where <code>deferred</code> came into play, is it perhaps resources? It also seemed a little complex to have <code>async</code> work at all parts of the stack here, would it be reasonable to require that a single component value is required to be entirely in-memory during serialization or deserialization?</p>\n<p>We try to be judicious about picking up new dependencies in Wasmtime so ideally this could be trimmed down to an <code>AsyncWrite</code> plus <code>AsyncRead</code> pair or, better yet, something like <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> where this crate would define just a single trait and the trait could be implemented by downstream consumers.</p>\n</blockquote>\n<p>Like mentioned above, this is still a PoC and the interface will change slightly, that said, these are the two biggest complexity sources I've identified:</p>\n<ul>\n<li><code>wasmtime::Error</code> usage (i.e. just a <code>anyhow::Error</code>), which <em>does not</em> implement <code>std::error::Error</code>. I'd <em>love</em> to bind the associated error types to <em>just</em> implement <code>std::error::Error</code>, which would eliminate most of these awkward trait bounds, but unfortunately that would prevent anyone from using <code>anyhow::Error</code> as the implementation for these. <code>anyhow::Error</code> implements <code>AsRef&lt;dyn Error&gt;</code> <a href=\"https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error\">https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error</a>, but it does not look like an \"idiomatic\" approach, e.g. it does not look like a blanket implementation would exist for <code>std::error::Error</code>, similarly, <code>std::io::Error</code> also does not implement such.<ul>\n<li>Another way to handle this could potentially be using associated type defaults, but that's not stable in Rust yet</li>\n</ul>\n</li>\n<li>async values (<code>stream</code> and <code>future</code>). As briefly mentioned in OP, wRPC has native support for async types. I fully acknowledge that Wasmtime today does not support async, however, I believe that's coming soon(ish?). Regardless, as we discussed offline, the implementation will be \"smart\" about host WASI resources and transfer <code>outgoing-stream</code> resource as <code>stream&lt;u8&gt;</code>. That's what the <code>deferred</code> field and the path indexes are for. For example, consider:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">   </span><span class=\"c1\">// reads bytes from rx and writes them to each stream in tx</span>\n<span class=\"w\">   </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">tee</span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">input</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">list</span><span class=\"o\">&lt;</span><span class=\"n\">output</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">result</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><code>tee</code> contract requires <code>tx</code> to be received <em>before</em> full contents of <code>rx</code> are available. The <code>rx</code> field would be encoded as <code>option&lt;list&lt;u8&gt;&gt;</code> in the first, \"sync\" pass - if full contents of <code>rx</code> are not available at encoding time, it would be sent as <code>option::none</code>, while a \"deferred\" writer of the underlying <code>stream&lt;u8&gt;</code> would be registered with index <code>0</code> (first parameter). <code>tx</code> would be fully encoded \"synchronously\". After the \"sync\" parameters are sent, the implementation would concurrently be sending more bytes of <code>rx</code> and await the <code>result&lt;u64&gt;</code>.</p>\n<p>There is no resource support in PR currently, so <code>deferred</code> is not used indeed, I am happy to add that in this PR - was hoping to keep the scope small, but I don't mind adding more things here if that's desired.</p>\n<p>So to answer your question, neither \"just\"  <code>AsyncRead</code>/<code>AsyncWrite</code>, nor <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> could actually satisfy the requirements here without breaking the contracts in general case, for two reasons:</p>\n<ol>\n<li>values may not fit in memory and may even not even be \"finite\" in some sense (e.g. if the <code>input-stream</code> is an HTTP body stream or a TCP stream), in fact, the input async value could depend on the output async value, so blocking here is not acceptable </li>\n<li>\n<p>values may be arbitrarily nested (e.g. a <code>record { foo: stream&lt;stream&lt;stream&lt;vec&lt;stream&lt;future&lt;u8&gt;&gt;&gt;&gt;&gt;&gt;  }</code>). Wasmtime would need to implement it's own framing of some kind to differentiate different chunks of the async values, which I believe is not desired, because:</p>\n<ul>\n<li>That would require a Wasmtime \"proprietary\" framing spec</li>\n<li>Require more complexity in Wasmtime integration</li>\n<li>Lead to inefficiency for transport with \"native\" multiplexing (e.g. QUIC)<br>\nTo address this, <code>wrpc_transport</code> crate provides an <code>Index</code> trait, e.g. see example QUIC implementation here <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484</a>. There's also a standardized frame definition available in <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261</a> for transport without native multiplexing (e.g. a TCP stream or an in-memory pipe)</li>\n</ul>\n</li>\n</ol>\n<p>All that said, I'm happy to add a fully-synchronous <code>Invoke</code> trait to this crate with blanket impl for <code>wrpc_transport::Invoke</code>, which would also bind the error types to be <code>wasmtime::Error</code> and use that in bounds removing the async support from this PR for now. That would mean that this trait would require breaking changes later on, but perhaps it would be easier to align on the async design in a follow-up PR?</p>\n</blockquote>",
        "id": 444433395,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718274658
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737#issuecomment-2165250669\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>:</p>\n<blockquote>\n<p>To make sure we're on the same page: this PR is a work-in-progress PoC at best, really just opened to align on the direction here, I would not expect it to be ready-for-review for another week at least. I've just recently reworked the transport abstraction, and a few changes, I think, are still coming. It is my absolute intention to add a simple to follow end-to-end example to this PR (most probably using QUIC transport I've just finished yesterday <a href=\"https://github.com/wrpc/wrpc/pull/127\">https://github.com/wrpc/wrpc/pull/127</a>) before marking it as ready-for-review. I'm just now starting with updating the bindgen to a few changes made in value definition encoding and the new transport - that's the biggest blocker for now.</p>\n<p>Note, that I will also add a more formal Wasmtime RFC for this</p>\n<blockquote>\n<p>First, to clarify, the main intention of landing this in-repo is to serve as both an example for other users and to integrate this with the <code>wasmtime</code> CLI, right? In that case one part of examples in theory should be a \"hello world\" of how to set it up, for example given a component that imports something create/compile a client that serves it in addition to the CLI flags necessary to run the component at hand. One difficult part about this is going to be that the client source will live in a separate repository (and/or have many of its dependencies there), but if the end goal is to have CLI support for this I think we'll want to plan for an example too (ideally one run in CI).</p>\n</blockquote>\n<p>The intention here is to, given an off-the-shelf <code>wrpc_transport::Invoke</code> implementation, likely contained within <a href=\"https://github.com/wrpc/wrpc\">https://github.com/wrpc/wrpc</a> (BA transfer pending), provide developers the tools to satisfy component imports of their choosing at runtime. Eventually I'd like to also add functionality to serve exports given a <code>wrpc_transport::Serve</code> implementation. The key benefit here is the standardized, generic traits (the <code>Invoke</code> and <code>Serve</code>) and the associated collection of fully-specified transports. I was a bit hesitant adding CLI support in this PR since I did not want to prematurely flesh out the UX of that, but since that feature would be feature gated and opt-in anyway (at least to start with), I guess I will just go ahead and add a simple CLI support for this in this PR as well. This PR will not be considered ready until there's both a \"low-level\", library use example <em>and</em> CLI usage example available (or documented).</p>\n<blockquote>\n<p>Next I'm also sort of coming at this from the perspective of if APIs in <code>wasmtime</code> need to change or if APIs need to be updated. For example the usage of <code>Val</code> here feels unnecessarily inefficient. I've long thought the representation of <code>Val</code> is pretty inefficient (e.g. heap allocation for nested values and things like strings-for-flags right nwo). It's also pretty unfortunate that types need to be passed around manually here instead since especially with resources that gets tricky and requires shenanigans like <code>substituted_component_type</code> which is pretty non-obvious. Long-term what I think we'd ideally have is something along the lines of <code>func_new_unchecked</code> but without the unsafety. What I'm envisioning is that host functions could be defined as <code>fn(StoreContextMut&lt;'_, T&gt;, args: ComponentArgs&lt;'_&gt;, ret: ComponentRet&lt;'_&gt;) -&gt; Result&lt;()&gt;</code>. The <code>ComponentArgs</code> structure would serve as a deserializer of sorts and the <code>ComponentRet</code> structure would act as a serializer of sorts. That way you could plug those directly into this protocol and avoid an intermediate copy through the host (e.g. the creation of a <code>Val</code>). That would also enable <code>args.serialize() -&gt; Vec&lt;u8&gt;</code> and <code>ret.deserialize(&amp;[u8]) -&gt; Result&lt;()&gt;</code> where the component encoding format could be implemented directly in those two.</p>\n</blockquote>\n<p>Absolutely agree, in fact I was always hoping that at one point we could make the runtime be \"wRPC-aware\" and directly convert to/from canon ABI values to \"value definition\" values. I believe, for some of these, the conversion is just an identity function, e.g. a <code>bool</code> encoding is exactly the same for both.<br>\nRegarding the traits, my (rough) suggestion for wRPC value trait analogues for this can be found here <a href=\"https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683\">https://github.com/wrpc/wrpc/issues/101#issuecomment-2150525683</a></p>\n<blockquote>\n<p>Similarly though I'm at least personally surprised by the complexity here. Namely <code>link_function</code> has an 11-line <code>where</code> clause along with two extra generics in the arguments themselves. Much of the complexity seems to be unused too, for example I couldn't actually figure out where <code>deferred</code> came into play, is it perhaps resources? It also seemed a little complex to have <code>async</code> work at all parts of the stack here, would it be reasonable to require that a single component value is required to be entirely in-memory during serialization or deserialization?</p>\n<p>We try to be judicious about picking up new dependencies in Wasmtime so ideally this could be trimmed down to an <code>AsyncWrite</code> plus <code>AsyncRead</code> pair or, better yet, something like <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> where this crate would define just a single trait and the trait could be implemented by downstream consumers.</p>\n</blockquote>\n<p>Like mentioned above, this is still a PoC and the interface will change slightly, that said, these are the two biggest complexity sources I've identified:</p>\n<ul>\n<li><code>wasmtime::Error</code> usage (i.e. just a <code>anyhow::Error</code>), which <em>does not</em> implement <code>std::error::Error</code>. I'd <em>love</em> to bind the associated error types to <em>just</em> implement <code>std::error::Error</code>, which would eliminate most of these awkward trait bounds, but unfortunately that would prevent anyone from using <code>anyhow::Error</code> as the implementation for these. <code>anyhow::Error</code> implements <code>AsRef&lt;dyn Error&gt;</code> <a href=\"https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error\">https://docs.rs/anyhow/latest/anyhow/struct.Error.html#impl-AsRef%3Cdyn+Error%3E-for-Error</a>, but it does not look like an \"idiomatic\" approach, e.g. it does not look like a blanket implementation would exist for <code>std::error::Error</code>, similarly, <code>std::io::Error</code> also does not implement such.<ul>\n<li>Another way to handle this could potentially be using associated type defaults, but that's not stable in Rust yet</li>\n</ul>\n</li>\n<li>async values (<code>stream</code> and <code>future</code>). As briefly mentioned in OP, wRPC has native support for async types. I fully acknowledge that Wasmtime today does not support async, however, I believe that's coming soon(ish?). Regardless, as we discussed offline, the implementation will be \"smart\" about host WASI resources and transfer <code>outgoing-stream</code> resource as <code>stream&lt;u8&gt;</code>. That's what the <code>deferred</code> field and the path indexes are for. For example, consider:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">   </span><span class=\"c1\">// reads bytes from rx and writes them to each stream in tx</span>\n<span class=\"w\">   </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">tee</span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">input</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">list</span><span class=\"o\">&lt;</span><span class=\"n\">output</span><span class=\"o\">-</span><span class=\"n\">stream</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">result</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><code>tee</code> contract requires <code>tx</code> to be received <em>before</em> full contents of <code>rx</code> are available. The <code>rx</code> field would be encoded as <code>option&lt;list&lt;u8&gt;&gt;</code> in the first, \"sync\" pass - if full contents of <code>rx</code> are not available at encoding time, it would be sent as <code>option::none</code>, while a \"deferred\" writer of the underlying <code>stream&lt;u8&gt;</code> would be registered with index <code>0</code> (first parameter). <code>tx</code> would be fully encoded \"synchronously\". After the \"sync\" parameters are sent, the implementation would concurrently be sending more bytes of <code>rx</code> and await the <code>result&lt;u64&gt;</code>.</p>\n<p>There is no resource support in PR currently, so <code>deferred</code> is not used indeed, I am happy to add that in this PR - was hoping to keep the scope small, but I don't mind adding more things here if that's desired.</p>\n<p>So to answer your question, neither \"just\"  <code>AsyncRead</code>/<code>AsyncWrite</code>, nor <code>async fn(&amp;Context, &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code> could actually satisfy the requirements here without breaking the contracts in general case, for two reasons:</p>\n<ol>\n<li>values may not fit in memory and may even not even be \"finite\" in some sense (e.g. if the <code>input-stream</code> is an HTTP body stream or a TCP stream), in fact, the input async value could depend on the output async value, so blocking here is not acceptable </li>\n<li>\n<p>values may be arbitrarily nested (e.g. a <code>record { foo: stream&lt;stream&lt;stream&lt;vec&lt;stream&lt;future&lt;u8&gt;&gt;&gt;&gt;&gt;&gt;  }</code>). Wasmtime would need to implement it's own framing of some kind to differentiate different chunks of the async values, which I believe is not desired, because:</p>\n<ul>\n<li>That would require a Wasmtime \"proprietary\" framing spec</li>\n<li>Require more complexity in Wasmtime integration</li>\n<li>Lead to inefficiency for transport with \"native\" multiplexing (e.g. QUIC)<br>\nTo address this, <code>wrpc_transport</code> crate provides an <code>Index</code> trait, e.g. see example QUIC implementation here <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport-quic/src/lib.rs#L435-L484</a>. There's also a standardized frame definition available in <a href=\"https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261\">https://github.com/wrpc/wrpc/blob/c97b710641451ce7150e5b2f247203e0cc29cba2/crates/transport/src/frame.rs#L7-L261</a> for transport without native multiplexing (e.g. a TCP stream or an in-memory pipe)</li>\n</ul>\n</li>\n</ol>\n<p>All that said, I'm happy to add a fully-synchronous <code>Invoke</code> trait to this crate with blanket impl for <code>wrpc_transport::Invoke</code>, which would also bind the error types to be <code>wasmtime::Error</code> and use that in bounds removing the async support from this PR for now. That would mean that this trait would require breaking changes later on, but perhaps it would be easier to align on the async design in a follow-up PR?</p>\n</blockquote>",
        "id": 444433760,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718274801
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737#issuecomment-2182912625\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8737\">PR #8737</a>:</p>\n<blockquote>\n<p>Sorry for the delay in getting back to this, but this all sounds reasonable enough to me. I think it'd be best to go an RFC route on this as it sounds like you're already intending to do where there can be a better understanding of the high-level goals and directions of this.</p>\n<p>For example I would not want to take on all the complexity of planning for <code>stream&lt;T&gt;</code> and <code>future&lt;T&gt;</code> at this time. I'd rather defer that to later. I would, however, find it useful to see what the plan for resources will be. Furthermore I think the basic performance profile of this will guide the implementation (e.g. <code>Val</code>-or-not, all-in-memory or not, etc) pretty significantly so I think it would be best to settle these sorts of high-level details through that.</p>\n</blockquote>",
        "id": 446099842,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718981759
    }
]