[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721262540\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>Hmm -- this will potentially pessimize x64 and aarch64, as on both of those platforms the extension modes are actually used sometimes, and not ignored. Specifically, in the SpiderMonkey embedding (Baldrdash calling convention), the JIT requires all args to be zero-extended, so we do respect the extension modes. This change could thus result in extraneous extension instructions in the non-Baldrdash (i.e. normal SysV convention) case.</p>\n<p>It's a bit confusing to me why the platform-independent IR leaks platform-specific ABI details, and perhaps we should clarify the design eventually. But in the meantime: is there a reason that the relevant backend(s) (this is an issue with IBM Z, I'm assuming?) can't unconditionally extend args, given that that is the ABI?</p>\n</blockquote>",
        "id": 215483237,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604423536
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721267610\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>Hmm -- this will potentially pessimize x64 and aarch64, as on both of those platforms the extension modes are actually used sometimes, and not ignored. Specifically, in the SpiderMonkey embedding (Baldrdash calling convention), the JIT requires all args to be zero-extended, so we do respect the extension modes. This change could thus result in extraneous extension instructions in the non-Baldrdash (i.e. normal SysV convention) case.</p>\n<p>It's a bit confusing to me why the platform-independent IR leaks platform-specific ABI details, and perhaps we should clarify the design eventually. But in the meantime: is there a reason that the relevant backend(s) (this is an issue with IBM Z, I'm assuming?) can't unconditionally extend args, given that that is the ABI?</p>\n</blockquote>\n<p>The extension marker specifies that the argument should be extended <strong>if and only if required by the ABI</strong>.  So if there is a difference between ABIs, the back-end should handle this accordingly.</p>\n<p>The only reason why the extension marker is provided by the front-end is to specify signedness.  <strong>If</strong> the back-end decides the ABI requires extension, then it needs to know whether to zero- or sign-extend, and the only place that information can come from is the front-end.</p>\n</blockquote>",
        "id": 215484343,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604424084
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721284100\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>Interesting -- this doesn't match the definition that I had understood (namely, that the <code>ArgumentExtension</code> if present indicates that the argument <em>must</em> be extended as specified), so I went digging a bit:</p>\n<ul>\n<li>\n<p>In the doc-comment for <code>ArgumentExtension</code>, all that is specified is \"on some architectures, small integer function arguments are extended\" (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/ir/extfunc.rs#L257-L260\">link</a>) -- somewhat ambiguous, so let's look at what backends do...</p>\n</li>\n<li>\n<p>In the current (production) x86 backend, it seems that <code>uext</code> and <code>sext</code> will unconditionally result in extend ops:</p>\n<ul>\n<li>In the x86 ABI code, the <code>ArgumentExtension</code> value is translated into a <code>ValueConversion</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/isa/x86/abi.rs#L149-L153\">link</a></li>\n<li>Then, in the legalizer, this <code>ValueConversion</code> results in a <code>uextend</code> or <code>sextend</code> op: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/legalizer/boundary.rs#L591-L592\">link</a></li>\n</ul>\n</li>\n<li>\n<p>In the new x64 and aarch64 backends, the <code>ArgumentExtension</code> unconditionally results in extend ops (from <code>ABIMachineSpec::gen_extend()</code>) if <code>Uext</code> or <code>Sext</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/machinst/abi_impl.rs#L1202-L1218\">link</a></p>\n</li>\n</ul>\n<p>So the doc-comment spec is somewhat ambiguous, but all three backends currently treat the extension mode as a mandatory request (always extend if specified), so it's certainly the lowest-overhead choice to keep that definition. And, given that we have other Cranelift users out-of-tree, we should consider it a public interface and be hesitant to change it.</p>\n<hr>\n<p>I think I understand the difficulty here, though: it seems that in the past, the most common use (or at least the initial driving use) of this feature was SpiderMonkey's ABI, for which the environment definition could attach the required extension modes because it controls generation of signatures and callsite IR. No \"vanilla\" system ABI has this requirement, so for other environments, we have no way to infer the signedness of the value once we get to the backend, as this has to come from the frontend (as you say).</p>\n<p>That said: at least for the <code>cranelift-wasm</code> crate and Wasmtime, we don't have a signed-<code>I32</code> type so I'm curious where the signedness may come from. In this patch, we're just unconditionally adding a <code>uext</code> attribute. Is the concern for other frontends, with the assumption that they will (also?) add their own sext/uext attributes?</p>\n<p>If we truly need a notion of signedness for some ABIs to be implemented properly, then we can definitely discuss how to get this -- perhaps a signedness bit on types. That would need a wider discussion, of course. Anyone else have thoughts on this?</p>\n</blockquote>",
        "id": 215488533,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604425949
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721284100\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>Interesting -- this doesn't match the definition that I had understood (namely, that the <code>ArgumentExtension</code> if present indicates that the argument <em>must</em> be extended as specified), so I went digging a bit:</p>\n<ul>\n<li>\n<p>In the doc-comment for <code>ArgumentExtension</code>, all that is specified is \"on some architectures, small integer function arguments are extended\" (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/ir/extfunc.rs#L257-L260\">link</a>) -- somewhat ambiguous, so let's look at what backends do...</p>\n</li>\n<li>\n<p>In the current (production) x86 backend, it seems that <code>uext</code> and <code>sext</code> will unconditionally result in extend ops:</p>\n<ul>\n<li>In the x86 ABI code, the <code>ArgumentExtension</code> value is translated into a <code>ValueConversion</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/isa/x86/abi.rs#L149-L153\">link</a></li>\n<li>Then, in the legalizer, this <code>ValueConversion</code> results in a <code>uextend</code> or <code>sextend</code> op: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/legalizer/boundary.rs#L591-L592\">link</a></li>\n</ul>\n</li>\n<li>\n<p>In the new x64 and aarch64 backends, the <code>ArgumentExtension</code> unconditionally results in extend ops (from <code>ABIMachineSpec::gen_extend()</code>) if <code>Uext</code> or <code>Sext</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/machinst/abi_impl.rs#L1202-L1218\">link</a></p>\n</li>\n</ul>\n<p>So the doc-comment spec is somewhat ambiguous, but all three backends currently treat the extension mode as a mandatory request (always extend if specified), so it's certainly the lowest-overhead choice to keep that definition. And, given that we have other Cranelift users out-of-tree, we should consider it a public interface and be hesitant to change it.</p>\n<hr>\n<p>I think I understand the difficulty here, though: it seems that in the past, the most common use (or at least the initial driving use) of this feature was SpiderMonkey's ABI, for which the environment definition could attach the required extension modes because it controls generation of signatures and callsite IR. No \"vanilla\" system ABI has had this requirement yet, so for other environments, we have no way to infer the signedness of the value once we get to the backend, as this has to come from the frontend (as you say).</p>\n<p>That said: at least for the <code>cranelift-wasm</code> crate and Wasmtime, we don't have a signed-<code>I32</code> type so I'm curious where the signedness may come from. In this patch, we're just unconditionally adding a <code>uext</code> attribute. Is the concern for other frontends, with the assumption that they will (also?) add their own sext/uext attributes?</p>\n<p>If we truly need a notion of signedness for some ABIs to be implemented properly, then we can definitely discuss how to get this -- perhaps a signedness bit on types. That would need a wider discussion, of course. Anyone else have thoughts on this?</p>\n</blockquote>",
        "id": 215488812,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604426057
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721284100\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>Interesting -- this doesn't match the definition that I had understood (namely, that the <code>ArgumentExtension</code> if present indicates that the argument <em>must</em> be extended as specified), so I went digging a bit:</p>\n<ul>\n<li>\n<p>In the doc-comment for <code>ArgumentExtension</code>, all that is specified is \"on some architectures, small integer function arguments are extended\" (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/ir/extfunc.rs#L257-L260\">link</a>) -- somewhat ambiguous, so let's look at what backends do...</p>\n</li>\n<li>\n<p>In the current (production) x86 backend, it seems that <code>uext</code> and <code>sext</code> will unconditionally result in extend ops:</p>\n<ul>\n<li>In the x86 ABI code, the <code>ArgumentExtension</code> value is translated into a <code>ValueConversion</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/isa/x86/abi.rs#L149-L153\">link</a></li>\n<li>Then, in the legalizer, this <code>ValueConversion</code> results in a <code>uextend</code> or <code>sextend</code> op: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/legalizer/boundary.rs#L591-L592\">link</a></li>\n</ul>\n</li>\n<li>\n<p>In the new x64 and aarch64 backends, the <code>ArgumentExtension</code> unconditionally results in extend ops (from <code>ABIMachineSpec::gen_extend()</code>) if <code>Uext</code> or <code>Sext</code>: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5ab7b4aa7fdf2ec00d0c04c0dffc9c7b4c89ca83/cranelift/codegen/src/machinst/abi_impl.rs#L1202-L1218\">link</a></p>\n</li>\n</ul>\n<p>So the doc-comment spec is somewhat ambiguous, but all three backends currently treat the extension mode as a mandatory request (always extend if specified), so it's certainly the lowest-overhead choice to keep that definition. And, given that we have other Cranelift users out-of-tree, we should consider it a public interface and be hesitant to change it.</p>\n<hr>\n<p>I think I understand the difficulty here, though: it seems that in the past, the most common use (or at least the initial driving use) of this feature was SpiderMonkey's ABI, for which the environment definition could attach the required extension modes because it controls generation of signatures and callsite IR. No \"vanilla\" system ABI has had this requirement yet, so for other environments, we have no way to infer the signedness of the value once we get to the backend, as this has to come from the frontend (as you say).</p>\n<p>That said: at least for the <code>cranelift-wasm</code> crate and Wasmtime, we don't have a signed-<code>I32</code> type so I'm curious where the signedness may come from. In this patch, we're just unconditionally adding a <code>uext</code> attribute. Is the concern for other frontends, with the assumption that they will (also?) add their own sext/uext attributes? (Edit: @bjorn3, how does <code>cg_clif</code> handle signedness -- does it add uext/sext attributes?)</p>\n<p>If we truly need a notion of signedness for some ABIs to be implemented properly, then we can definitely discuss how to get this -- perhaps a signedness bit on types. That would need a wider discussion, of course. Anyone else have thoughts on this?</p>\n</blockquote>",
        "id": 215489079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604426180
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721288949\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>The LLVM LangRef states:</p>\n<p><a href=\"https://llvm.org/docs/LangRef.html#parameter-attributes\">https://llvm.org/docs/LangRef.html#parameter-attributes</a></p>\n<blockquote>\n<p>&lt;dl&gt;<br>\n&lt;dt&gt;zeroext&lt;/dt&gt;<br>\n&lt;dd&gt;This indicates to the code generator that the parameter or return value should be zero-extended to the extent required by the target’s ABI by the caller (for a parameter) or the callee (for a return value).&lt;/dd&gt;<br>\n&lt;dt&gt;signext&lt;/dt&gt;<br>\n&lt;dd&gt;This indicates to the code generator that the parameter or return value should be sign-extended to the extent required by the target’s ABI (which is usually 32-bits) by the caller (for a parameter) or the callee (for a return value).&lt;/dd&gt;<br>\n&lt;/dl&gt;</p>\n</blockquote>\n<p>Unnecessarily extending the arguments shouldn't be observable unless you use a different type on the caller and callee side, which risks causing trouble on some architectures anyway. For this reason I wouldn't consider stopping with unnecessary extension a breaking change.</p>\n<blockquote>\n<p>Edit: @bjorn3, how does cg_clif handle signedness -- does it add uext/sext attributes?</p>\n</blockquote>\n<p>I don't handle this part of the C abi yet like many other things. I just never add uext/sext.</p>\n<blockquote>\n<p>If we truly need a notion of signedness for some ABIs to be implemented properly, then we can definitely discuss how to get this -- perhaps a signedness bit on types. That would need a wider discussion, of course. Anyone else have thoughts on this?</p>\n</blockquote>\n<p>LLVM doesn't have separate types for unsigned and signed integers either.</p>\n</blockquote>",
        "id": 215489786,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604426522
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721298175\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>Interesting; thanks for the LLVM reference -- a lot of valuable experience to learn from in their design decisions.</p>\n<p>From first principles, I agree that it should actually make sense to have an \"if you need to extend this, here is the signedness\" bit of information on parameters; \"always extend in this way\" makes less sense, because it is hoisting the question of \"do we extend\", which is an ABI-level question, up to the machine-independent IR. So I'm coming to agree that we should align with that.</p>\n<p>That said, the two concerns are:</p>\n<ul>\n<li>Performance: in the current backends, we always do the extends if extend-mode is specified. So we would want to alter this logic to \"only extend if ABI requires it\". But...</li>\n<li>Compatibility: this <em>is</em> a breaking change in the sense that a user could currently be using the default ABI (e.g. <code>SystemV</code>), yet specifying extend-modes, and relying on the behavior that we always extend. The only case I am currently aware of where extensions matter is in SpiderMonkey, where we specify a different ABI anyway, so that's fine; but perhaps there are other uses for which this is not true.</li>\n</ul>\n<p>So, to accept this patch, I'd want to do the following things first:</p>\n<ul>\n<li>Verify that we don't have other users (frontends that generate CLIF directly, rather than through the wasm crate) that would rely on the current always-extend behavior.</li>\n<li>Alter the behavior in the three backends (current-x86, new-x64, aarch64) to extend only in the <code>Baldrdash</code> ABI, so we don't have performance regressions.</li>\n</ul>\n<p>I can help with the latter -- it should be a pretty easy change. As to the former -- @sunfishcode or others, are we aware of any frontends that might break if we no longer unconditionally extend with sext/uext attributes are present?</p>\n</blockquote>",
        "id": 215492112,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604427635
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721310622\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>I went through all mentions of <code>ArgumentExtension</code> on github. After ignoring all vendorings of cranelift, I found the following uses:</p>\n<p><a href=\"https://github.com/aranajhonny/lucet-membrane/blob/0b7598bf3fa24fbea5d7012331d9115cc3e5f55a/lucetc/src/types.rs\">https://github.com/aranajhonny/lucet-membrane/blob/0b7598bf3fa24fbea5d7012331d9115cc3e5f55a/lucetc/src/types.rs</a></p>\n<p><a href=\"https://github.com/aranajhonny/private-wasmer/blob/aa8b968d40cf998845643ce02f1a40c098b139ff/lib/clif-backend/src/trampoline.rs\">https://github.com/aranajhonny/private-wasmer/blob/aa8b968d40cf998845643ce02f1a40c098b139ff/lib/clif-backend/src/trampoline.rs</a></p>\n<p><a href=\"https://github.com/nebulet/nebulet/blob/f171d5ee81306e536f60af3617a12d82c5918e69/src/wasm/mod.rs\">https://github.com/nebulet/nebulet/blob/f171d5ee81306e536f60af3617a12d82c5918e69/src/wasm/mod.rs</a></p>\n<p>All use only <code>ArgumentExtension::None</code>.</p>\n</blockquote>",
        "id": 215495263,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604429202
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721310622\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>I went through all mentions of <code>ArgumentExtension</code> on github. After ignoring all vendorings of cranelift, I found the following uses:</p>\n<p><a href=\"https://github.com/aranajhonny/lucet-membrane/blob/0b7598bf3fa24fbea5d7012331d9115cc3e5f55a/lucetc/src/types.rs\">https://github.com/aranajhonny/lucet-membrane/blob/0b7598bf3fa24fbea5d7012331d9115cc3e5f55a/lucetc/src/types.rs</a></p>\n<p><a href=\"https://github.com/aranajhonny/private-wasmer/blob/aa8b968d40cf998845643ce02f1a40c098b139ff/lib/clif-backend/src/trampoline.rs\">https://github.com/aranajhonny/private-wasmer/blob/aa8b968d40cf998845643ce02f1a40c098b139ff/lib/clif-backend/src/trampoline.rs</a></p>\n<p><a href=\"https://github.com/nebulet/nebulet/blob/f171d5ee81306e536f60af3617a12d82c5918e69/src/wasm/mod.rs\">https://github.com/nebulet/nebulet/blob/f171d5ee81306e536f60af3617a12d82c5918e69/src/wasm/mod.rs</a></p>\n<p>All use only <code>ArgumentExtension::None</code>.</p>\n<p>Edit: that doesn't include <code>.uext()</code> and <code>.sext()</code>.</p>\n</blockquote>",
        "id": 215495421,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604429287
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721311843\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>In the subset of the crates that <a href=\"http://grep.app\">grep.app</a> searches, <code>.uext()</code> and <code>.sext()</code> are only used inside a test of Cranelift.</p>\n</blockquote>",
        "id": 215495525,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604429356
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721313757\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>The only case I am currently aware of where extensions matter is in SpiderMonkey, where we specify a different ABI anyway, so that's fine; but perhaps there are other uses for which this is not true.</p>\n</blockquote>\n<p>Actually, many 64-bit platform ABIs require extension to the full word size.  In addition to IBM Z (which is my problem), this is true for Power, Riscv, Mips, Sparc (just at first glance).   The only 64-bit platforms that do <em>not</em> require extension to 64 bits are x86_64 and aarch64 as far as I'm aware. (And note that even those still require extension for <em>smaller</em> types to at least 32 bits.)</p>\n<blockquote>\n<p>That said: at least for the cranelift-wasm crate and Wasmtime, we don't have a signed-I32 type so I'm curious where the signedness may come from. In this patch, we're just unconditionally adding a uext attribute. Is the concern for other frontends, with the assumption that they will (also?) add their own sext/uext attributes?</p>\n</blockquote>\n<p>I guess I could fix my problem for now by always doing an unsigned extend in the backend, if wasmtime types are always unsigned.  That just doesn't seem quite right if we want to consider other uses of cranelift going forward (e.g. I understand there's a Rust frontend in progress?).</p>\n<p>Going back from the general discussion to this specific patch, it is actually not a very far-reaching change in that it only affects calls to certain external builtin functions.  (For calls strictly between two wasmtime functions, it does not really matter whether we adhere 100% to the platform ABI, as long as both sides agree.  So I haven't really bothered to change all generated calls to do the extension.)</p>\n<p>Therefore, I'm not sure that any performance impact due to unnecessary extensions on just those builtin calls would actually be measurable on either x86_64 or aarch64.  So it may not even be immediately required to follow up with back-end changes there ...</p>\n</blockquote>",
        "id": 215495964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604429605
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721318268\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>(e.g. I understand there's a Rust frontend in progress?).</p>\n</blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>\n<p>By the way I noticed that you only applied this change to the <code>cranelift-tools</code> crate, not Wasmtime or Cranelift itself.</p>\n</blockquote>",
        "id": 215497107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604430141
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721323045\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>(e.g. I understand there's a Rust frontend in progress?).</p>\n</blockquote>\n<p>wave</p>\n</blockquote>\n<p>Ah, I see :-)</p>\n<blockquote>\n<p>By the way I noticed that you only applied this change to the <code>cranelift-tools</code> crate, not Wasmtime or Cranelift itself.</p>\n</blockquote>\n<p>As I said in my reply to Chris, I didn't systematically attempt to change <em>all</em> places that generate function call IR, only those where the call interfaces between wasmtime-generated code and some external platform code -- those are the only places where this makes a real difference (without this change, some wasm tests will fail or even crash on my platform).</p>\n</blockquote>",
        "id": 215498214,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604430756
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721324008\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>@bjorn3, thanks for doing that survey, and for creating the issue in the saltwater project!</p>\n<p>@uweigand: I'll plan to update the extend behavior in the backends, likely tomorrow or Thursday (I actually have a day off today; I should probably disappear soon <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>). As per my latest message above, I agree that we should align to the \"only extend if ABI specifies\" behavior. I think it's fine to land this patch once the backends are updated (I'm hesitant to do so beforehand as even small perf regressions can be problematic for some users).</p>\n<p>Anyway, thanks for the prodding on the extend semantics -- I feel like we're in a much clearer place now! I'll update the doc comment as well so that this is more precisely specified going forward.</p>\n</blockquote>",
        "id": 215498422,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604430885
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721324008\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>@bjorn3, thanks for doing that survey, and for creating the issue in the saltwater project!</p>\n<p>@uweigand: I'll plan to update the extend behavior in the backends, likely tomorrow or Thursday (I actually have a day off today; I should probably disappear soon :-) ). As per my latest message above, I agree that we should align to the \"only extend if ABI specifies\" behavior. I think it's fine to land this patch once the backends are updated (I'm hesitant to do so beforehand as even small perf regressions can be problematic for some users).</p>\n<p>Anyway, thanks for the prodding on the extend semantics -- I feel like we're in a much clearer place now! I'll update the doc comment as well so that this is more precisely specified going forward.</p>\n</blockquote>",
        "id": 215498478,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604430925
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721327882\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<p>@cfallin Thanks!</p>\n</blockquote>",
        "id": 215499262,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604431366
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721340171\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>As I said in my reply to Chris, I didn't systematically attempt to change all places that generate function call IR, only those where the call interfaces between wasmtime-generated code and some external platform code -- those are the only places where this makes a real difference (without this change, some wasm tests will fail or even crash on my platform).</p>\n</blockquote>\n<p>You only changed the cranelift-tools crate, which exists for testing purposes only. It isn't used by Wasmtime. You probably also need to change it in Wasmtime to make interfacing between wasm and native code work.</p>\n<blockquote>\n<p>Is the concern for other frontends, with the assumption that they will (also?) add their own sext/uext attributes?</p>\n</blockquote>\n<p>Any change to Wasmtime will not affect other users of Cranelift. Only if you were to change Cranelift to default to a certain extension mode, would it affect other frontends.</p>\n</blockquote>",
        "id": 215501851,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604432913
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721771824\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>You only changed the cranelift-tools crate, which exists for testing purposes only. It isn't used by Wasmtime. You probably also need to change it in Wasmtime to make interfacing between wasm and native code work.</p>\n</blockquote>\n<p>Maybe I'm confused.  My understanding is that this patch touches crates/cranelift/src/func_environ.rs, which exports routines to emit calls to builtin functions (using the AbiParam specs I'm modifying), e.g. the translate_memory_grow routine.  This is part of a clause<br>\n<code>impl&lt;'module_environment&gt; cranelift_wasm::FuncEnvironment for FuncEnvironment&lt;'module_environment&gt; {\n</code><br>\nand the translate_memory_grow routine in that FuncEnvironment is then used from cranelift/wasm/src/code_translator.rs to implement the wasm memory.grow primitive.</p>\n<p>Is that not correct?</p>\n</blockquote>",
        "id": 215589457,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604500904
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354#issuecomment-721805731\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2354\">Issue #2354</a>:</p>\n<blockquote>\n<blockquote>\n<p>crates/cranelift/src/func_environ.rs</p>\n</blockquote>\n<p>I thought it was <code>cranelift/src/...</code>. My bad. This will indeed apply the change to Wasmtime.</p>\n</blockquote>",
        "id": 215598258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604504316
    }
]