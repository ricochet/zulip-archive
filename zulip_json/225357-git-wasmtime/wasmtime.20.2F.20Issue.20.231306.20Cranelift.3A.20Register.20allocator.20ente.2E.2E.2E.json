[
    {
        "content": "<p>abrown opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into <code>clif\n[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)\n.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444042,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046564
    },
    {
        "content": "<p>abrown labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into <code>clif\n[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)\n.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046564
    },
    {
        "content": "<p>abrown labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into <code>clif\n[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)\n.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046564
    },
    {
        "content": "<p>abrown edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into <code>clif\n[clif.txt](https://github.com/bytecodealliance/wasmtime/files/4326538/clif.txt)\n.txt</code> (attached) and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\">clif.txt</a></p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046594
    },
    {
        "content": "<p>abrown edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into the attached <a href=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint scratch.clif</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv scratch.clif</code>.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046639
    },
    {
        "content": "<p>abrown edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into the attached <a href=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>\n<div class=\"codehilite\"><pre><span></span>$ target/debug/clif-util compile -dDpv text.clif\nthread <span class=\"s1\">&#39;main&#39;</span> panicked at <span class=\"s1\">&#39;FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]&#39;</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9\n</pre></div>\n\n\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046725
    },
    {
        "content": "<p>abrown edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\"><pre><span></span>...\n DEBUG cranelift_codegen::regalloc::solver     &gt; add_killed_var(v6985:FPR, from=%xmm0)\n DEBUG cranelift_codegen::regalloc::solver     &gt; -&gt; new var: v6985(FPR, from %xmm0, in)\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, global, def), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Not enough global registers for v191, trying as local\n DEBUG cranelift_codegen::regalloc::solver     &gt; real_solve for Solver { inputs_done: true,\n  in:  [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  out: [ GPR: ---b--sd89012345 FPR32: 0----------------789012345678901 FPR: 0--------------- FLAG: f ]\n  assignments: []\n  vars: [v191(FPR, out, def, 1), v6985(FPR, from %xmm0, in, 1)]\n  moves: []\n}\n\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     color v191 -&gt; %xmm0 (global to be replaced)\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Replacing global defs on v191 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt;   + v191 = copy.i64x2 v6986 with v6986 in %xmm0\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Done: v6986 = copy.i64x2 v6985\n DEBUG cranelift_codegen::regalloc::coloring   &gt; Coloring v191 = copy.i64x2 v6986\n    from [ GPR: ---b--sd89012345 FPR32: -----------------789012345678901 FPR: ---------------- FLAG: f ]\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     kill v6986 in %xmm0 (local FPR)\n DEBUG cranelift_codegen::regalloc::coloring   &gt;     glob [ GPR: a--b--sd89012345 FPR32: ----------------6789012345678901 FPR: ---------------- FLAG: f ]\n...\n</pre></div>\n\n\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into the attached <a href=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>\n<div class=\"codehilite\"><pre><span></span>$ target/debug/clif-util compile -dDpv clif.txt\nthread <span class=\"s1\">&#39;main&#39;</span> panicked at <span class=\"s1\">&#39;FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]&#39;</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9\n</pre></div>\n\n\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\" target=\"_blank\" title=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 190444385,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584046746
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>I attempted removing the <code>FPR32</code> register class entirely but that doesn't seem to solve the problem. I mean, the <code>FPR32</code> is gone from the logging but I still get a <code>FPR8:%xmm2 is already free in...</code> error. Also, without <code>FPR32</code> the endless loop seems to be gone and I can run bugpoint to get a 172-instruction version to reproduce: <a href=\"https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt\">clif-reduced.txt</a>.</p>\n</blockquote>",
        "id": 190458035,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584056934
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-598481007\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>I attempted removing the <code>FPR32</code> register class entirely but that doesn't seem tototally  solve the problem. I mean, the <code>FPR32</code> is gone from the logging but I still get a <code>FPR8:%xmm2 is already free in...</code> error when I attempt to <code>compile</code>. On the bright side, without <code>FPR32</code> the endless loop seems to be gone and I can run <code>bugpoint</code> to get a 172-instruction version to reproduce: <a href=\"https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/files/4327130/clif-reduced.txt\">clif-reduced.txt</a>.</p>\n</blockquote>",
        "id": 190458072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584056986
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>In an attempt to reduce this down to something comprehensible, I started playing around with small test cases:</p>\n<div class=\"codehilite\"><pre><span></span>test compile\nset enable_simd\ntarget x86_64 skylake\n\nfunction u0:35() system_v {\nblock0:\n    ; v0 = vconst.i32x4 [0 1 2 3]\n    v0 = iconst.i64 0xdeadbeef\n    v1 = load.i32x4 v0\n    v2 = load.i32x4 v0\n    v3 = load.i32x4 v0\n    v4 = load.i32x4 v0\n    v5 = load.i32x4 v0\n    v6 = load.i32x4 v0\n    v7 = load.i32x4 v0\n    v8 = load.i32x4 v0\n    v9 = load.i32x4 v0\n    v10 = load.i32x4 v0\n    v11 = load.i32x4 v0\n    v12 = load.i32x4 v0\n    v13 = load.i32x4 v0\n    v14 = load.i32x4 v0\n    v15 = load.i32x4 v0\n    v16 = load.i32x4 v0\n    ;; this causes the error\n    ;; v17 = load.i32x4 v0\n\n    store v1, v0\n    store v2, v0\n    store v3, v0\n    store v4, v0\n    store v5, v0\n    store v6, v0\n    store v7, v0\n    store v8, v0\n    store v9, v0\n    store v10, v0\n    store v11, v0\n    store v12, v0\n    store v13, v0\n    store v14, v0\n    store v15, v0\n    store v16, v0\n    return\n}\n</pre></div>\n\n\n<p>On the <code>remove-fpr32</code> branch (see #1318), I run <code>cargo run -p cranelift-tools -- compile -dDpv scratch-tiny.clif</code>. This fails with:</p>\n<div class=\"codehilite\"><pre><span></span>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `68`,\n right: `64`: Invalid registers for REX-less Op2 encoding&#39;, cranelift/codegen/src/isa/x86/binemit.rs:119:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n</pre></div>\n\n\n<p>When I turn on logging, I see the following right before the failure:</p>\n<div class=\"codehilite\"><pre><span></span> DEBUG cranelift_codegen::context              &gt; Compiled:\nfunction u0:35(i64 fp [%rbp]) -&gt; i64 fp [%rbp] system_v {\n    ss0 = spill_slot 16, offset -32\n    ss1 = incoming_arg 16, offset -16\n\n                                block0(v20: i64 [%rbp]):\n[RexOp1pushq#50]                    x86_push v20\n[RexOp1copysp#8089]                 copy_special %rsp -&gt; %rbp\n[RexOp1adjustsp_ib#d083]            adjust_sp_down_imm 16\n[RexOp1pu_id#b8,%rax]               v0 = iconst.i64 0xdead_beef\n[DynRexOp2fld#410,%xmm0]            v18 = load.i32x4 v0\n[Op2fspillSib32#411,ss0]            v1 = spill v18\n[DynRexOp2fld#410,%xmm0]            v2 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm1]            v3 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm2]            v4 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm3]            v5 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm4]            v6 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm5]            v7 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm6]            v8 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm7]            v9 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm8]            v10 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm9]            v11 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm10]           v12 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm11]           v13 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm12]           v14 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm13]           v15 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm14]           v16 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm15]           v17 = load.i32x4 v0\n[Op2frmov#428]                      regmove v2, %xmm0 -&gt; %xmm15\n[Op2ffillSib32#410,%xmm0]           v19 = fill v1\n[DynRexOp2fst#411]                  store v19, v0\n[DynRexOp2fst#411]                  store v2, v0\n[DynRexOp2fst#411]                  store v3, v0\n[DynRexOp2fst#411]                  store v4, v0\n[DynRexOp2fst#411]                  store v5, v0\n[DynRexOp2fst#411]                  store v6, v0\n[DynRexOp2fst#411]                  store v7, v0\n[DynRexOp2fst#411]                  store v8, v0\n[DynRexOp2fst#411]                  store v9, v0\n[DynRexOp2fst#411]                  store v10, v0\n[DynRexOp2fst#411]                  store v11, v0\n[DynRexOp2fst#411]                  store v12, v0\n[DynRexOp2fst#411]                  store v13, v0\n[DynRexOp2fst#411]                  store v14, v0\n[DynRexOp2fst#411]                  store v15, v0\n[DynRexOp2fst#411]                  store v16, v0\n[RexOp1adjustsp_ib#8083]            adjust_sp_up_imm 16\n[RexOp1popq#58,%rbp]                v21 = x86_pop.i64\n[Op1ret#c3]                         return v21\n}\n</pre></div>\n\n\n<p>The immediate spilling of <code>v1</code> seems to make sense, and the <code>regmove v2, %xmm0-&gt;%xmm15</code> in order to fill <code>v1</code> into <code>v19</code> does too: <code>v17/%xmm15</code> is never used again so we should be able to use <code>%xmm15</code> for <code>v2</code>'s value. But when I debug the <code>regmove</code> is the instruction causing the failure. Because <code>load</code> and <code>store</code> have the <code>infer_rex()</code> meta-property, they can access all 16 FPR registers but <code>regmove</code>, which has neither <code>infer_rex()</code> nor <code>rex()</code>, can only access FPR8. When I give <code>regmove</code> a <code>rex()</code> prefix the snippet compiles. We have an issue to track that I need to add REX prefixes to a bunch of SIMD instructions, #1127, so I think I will submit a PR for that and then revisit this.</p>\n<p>Regardless of whether I fix #1127 or not, though, regalloc should know better than to try to move to a register it can't encode. For SIMD and floats, <code>regmove</code> uses the <code>frmov</code> recipe, which takes a single FPR as an input. I would have expected cranelift to know that the lack of <code>infer_rex()</code> nor <code>rex()</code> meant that <code>regmove</code> would be limited to FPR8, but no. Perhaps it assumes that the source and destination registers are in the same register class.</p>\n<p>My plan for now is:</p>\n<ul>\n<li>fix #1127 by telling adding REX prefixes in a bunch of places</li>\n<li>see if the original clif.txt will compile with that fix and without FPR32 support</li>\n<li>if that works, try again with FPR32 support</li>\n</ul>\n</blockquote>",
        "id": 190786025,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584396396
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599779267\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>In an attempt to reduce this down to something comprehensible, I started playing around with small test cases:</p>\n<div class=\"codehilite\"><pre><span></span>test compile\nset enable_simd\ntarget x86_64 skylake\n\nfunction u0:35() system_v {\nblock0:\n    v0 = iconst.i64 0xdeadbeef\n    v1 = load.i32x4 v0\n    v2 = load.i32x4 v0\n    v3 = load.i32x4 v0\n    v4 = load.i32x4 v0\n    v5 = load.i32x4 v0\n    v6 = load.i32x4 v0\n    v7 = load.i32x4 v0\n    v8 = load.i32x4 v0\n    v9 = load.i32x4 v0\n    v10 = load.i32x4 v0\n    v11 = load.i32x4 v0\n    v12 = load.i32x4 v0\n    v13 = load.i32x4 v0\n    v14 = load.i32x4 v0\n    v15 = load.i32x4 v0\n    v16 = load.i32x4 v0\n    ;; this causes the error\n    v17 = load.i32x4 v0\n\n    store v1, v0\n    store v2, v0\n    store v3, v0\n    store v4, v0\n    store v5, v0\n    store v6, v0\n    store v7, v0\n    store v8, v0\n    store v9, v0\n    store v10, v0\n    store v11, v0\n    store v12, v0\n    store v13, v0\n    store v14, v0\n    store v15, v0\n    store v16, v0\n    return\n}\n</pre></div>\n\n\n<p>On the <code>remove-fpr32</code> branch (see #1318), I run <code>cargo run -p cranelift-tools -- compile -dDpv scratch-tiny.clif</code>. This fails with:</p>\n<div class=\"codehilite\"><pre><span></span>thread &#39;main&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `68`,\n right: `64`: Invalid registers for REX-less Op2 encoding&#39;, cranelift/codegen/src/isa/x86/binemit.rs:119:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n</pre></div>\n\n\n<p>When I turn on logging, I see the following right before the failure:</p>\n<div class=\"codehilite\"><pre><span></span> DEBUG cranelift_codegen::context              &gt; Compiled:\nfunction u0:35(i64 fp [%rbp]) -&gt; i64 fp [%rbp] system_v {\n    ss0 = spill_slot 16, offset -32\n    ss1 = incoming_arg 16, offset -16\n\n                                block0(v20: i64 [%rbp]):\n[RexOp1pushq#50]                    x86_push v20\n[RexOp1copysp#8089]                 copy_special %rsp -&gt; %rbp\n[RexOp1adjustsp_ib#d083]            adjust_sp_down_imm 16\n[RexOp1pu_id#b8,%rax]               v0 = iconst.i64 0xdead_beef\n[DynRexOp2fld#410,%xmm0]            v18 = load.i32x4 v0\n[Op2fspillSib32#411,ss0]            v1 = spill v18\n[DynRexOp2fld#410,%xmm0]            v2 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm1]            v3 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm2]            v4 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm3]            v5 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm4]            v6 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm5]            v7 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm6]            v8 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm7]            v9 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm8]            v10 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm9]            v11 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm10]           v12 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm11]           v13 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm12]           v14 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm13]           v15 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm14]           v16 = load.i32x4 v0\n[DynRexOp2fld#410,%xmm15]           v17 = load.i32x4 v0\n[Op2frmov#428]                      regmove v2, %xmm0 -&gt; %xmm15\n[Op2ffillSib32#410,%xmm0]           v19 = fill v1\n[DynRexOp2fst#411]                  store v19, v0\n[DynRexOp2fst#411]                  store v2, v0\n[DynRexOp2fst#411]                  store v3, v0\n[DynRexOp2fst#411]                  store v4, v0\n[DynRexOp2fst#411]                  store v5, v0\n[DynRexOp2fst#411]                  store v6, v0\n[DynRexOp2fst#411]                  store v7, v0\n[DynRexOp2fst#411]                  store v8, v0\n[DynRexOp2fst#411]                  store v9, v0\n[DynRexOp2fst#411]                  store v10, v0\n[DynRexOp2fst#411]                  store v11, v0\n[DynRexOp2fst#411]                  store v12, v0\n[DynRexOp2fst#411]                  store v13, v0\n[DynRexOp2fst#411]                  store v14, v0\n[DynRexOp2fst#411]                  store v15, v0\n[DynRexOp2fst#411]                  store v16, v0\n[RexOp1adjustsp_ib#8083]            adjust_sp_up_imm 16\n[RexOp1popq#58,%rbp]                v21 = x86_pop.i64\n[Op1ret#c3]                         return v21\n}\n</pre></div>\n\n\n<p>The immediate spilling of <code>v1</code> seems to make sense, and the <code>regmove v2, %xmm0-&gt;%xmm15</code> in order to fill <code>v1</code> into <code>v19</code> does too: <code>v17/%xmm15</code> is never used again so we should be able to use <code>%xmm15</code> for <code>v2</code>'s value. But when I debug the <code>regmove</code> is the instruction causing the failure. Because <code>load</code> and <code>store</code> have the <code>infer_rex()</code> meta-property, they can access all 16 FPR registers but <code>regmove</code>, which has neither <code>infer_rex()</code> nor <code>rex()</code>, can only access FPR8. When I give <code>regmove</code> a <code>rex()</code> prefix the snippet compiles. We have an issue to track that I need to add REX prefixes to a bunch of SIMD instructions, #1127, so I think I will submit a PR for that and then revisit this.</p>\n<p>Regardless of whether I fix #1127 or not, though, regalloc should know better than to try to move to a register it can't encode. For SIMD and floats, <code>regmove</code> uses the <code>frmov</code> recipe, which takes a single FPR as an input. I would have expected cranelift to know that the lack of <code>infer_rex()</code> nor <code>rex()</code> meant that <code>regmove</code> would be limited to FPR8, but no. Perhaps it assumes that the source and destination registers are in the same register class.</p>\n<p>My plan for now is:</p>\n<ul>\n<li>fix #1127 by telling adding REX prefixes in a bunch of places</li>\n<li>see if the original clif.txt will compile with that fix and without FPR32 support</li>\n<li>if that works, try again with FPR32 support</li>\n</ul>\n</blockquote>",
        "id": 190786080,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584396443
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599831922\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-599831922\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>#1318 and #1335, when merged, should clarify this a bit more.</p>\n</blockquote>",
        "id": 190800118,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584408606
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306#issuecomment-772721968\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>The new backend framework uses a different register allocator.</p>\n</blockquote>",
        "id": 225058516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612376754
    },
    {
        "content": "<p>abrown closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1306\">Issue #1306</a>:</p>\n<blockquote>\n<p>As I was attempting to compile some SIMD Wasm code, I discovered that wasmtime would enter an infinite loop in the register allocator. With logging enabled, the register allocator gets stuck with the number of global registers:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">solver</span><span class=\"w\">     </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">add_killed_var</span><span class=\"p\">(</span><span class=\"n\">v6985</span>:<span class=\"nc\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"o\">=%</span><span class=\"n\">xmm0</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">solver</span><span class=\"w\">     </span><span class=\"o\">&gt;</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">new</span><span class=\"w\"> </span><span class=\"n\">var</span>: <span class=\"nc\">v6985</span><span class=\"p\">(</span><span class=\"n\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">solver</span><span class=\"w\">     </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">real_solve</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Solver</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inputs_done</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">in</span>:  <span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"o\">---</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"mi\">0</span><span class=\"o\">----------------</span><span class=\"mi\">789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"mi\">0</span><span class=\"o\">---------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">out</span>: <span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"o\">---</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"mi\">0</span><span class=\"o\">----------------</span><span class=\"mi\">789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"mi\">0</span><span class=\"o\">---------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assignments</span>: <span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">vars</span>: <span class=\"p\">[</span><span class=\"n\">v191</span><span class=\"p\">(</span><span class=\"n\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">def</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">v6985</span><span class=\"p\">(</span><span class=\"n\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">moves</span>: <span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"n\">enough</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"n\">registers</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">v191</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">trying</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">local</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">solver</span><span class=\"w\">     </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">real_solve</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Solver</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">inputs_done</span>: <span class=\"nc\">true</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">in</span>:  <span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"o\">---</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"mi\">0</span><span class=\"o\">----------------</span><span class=\"mi\">789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"mi\">0</span><span class=\"o\">---------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">out</span>: <span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"o\">---</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"mi\">0</span><span class=\"o\">----------------</span><span class=\"mi\">789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"mi\">0</span><span class=\"o\">---------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">assignments</span>: <span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">vars</span>: <span class=\"p\">[</span><span class=\"n\">v191</span><span class=\"p\">(</span><span class=\"n\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">def</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">v6985</span><span class=\"p\">(</span><span class=\"n\">FPR</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">moves</span>: <span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\">     </span><span class=\"n\">color</span><span class=\"w\"> </span><span class=\"n\">v191</span><span class=\"w\"> </span>-&gt; <span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">replaced</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Replacing</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">v191</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy</span><span class=\"p\">.</span><span class=\"n\">i64x2</span><span class=\"w\"> </span><span class=\"n\">v6985</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\">   </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">v191</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy</span><span class=\"p\">.</span><span class=\"n\">i64x2</span><span class=\"w\"> </span><span class=\"n\">v6986</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">v6986</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Done</span>: <span class=\"nc\">v6986</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy</span><span class=\"p\">.</span><span class=\"n\">i64x2</span><span class=\"w\"> </span><span class=\"n\">v6985</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Coloring</span><span class=\"w\"> </span><span class=\"n\">v191</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy</span><span class=\"p\">.</span><span class=\"n\">i64x2</span><span class=\"w\"> </span><span class=\"n\">v6986</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"o\">---</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"o\">-----------------</span><span class=\"mi\">789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"o\">----------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\">     </span><span class=\"n\">kill</span><span class=\"w\"> </span><span class=\"n\">v6986</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">xmm0</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">local</span><span class=\"w\"> </span><span class=\"n\">FPR</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span>::<span class=\"n\">regalloc</span>::<span class=\"n\">coloring</span><span class=\"w\">   </span><span class=\"o\">&gt;</span><span class=\"w\">     </span><span class=\"n\">glob</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"n\">GPR</span>: <span class=\"nc\">a</span><span class=\"o\">--</span><span class=\"n\">b</span><span class=\"o\">--</span><span class=\"n\">sd89012345</span><span class=\"w\"> </span><span class=\"n\">FPR32</span>: <span class=\"o\">----------------</span><span class=\"mi\">6789012345678901</span><span class=\"w\"> </span><span class=\"n\">FPR</span>: <span class=\"o\">----------------</span><span class=\"w\"> </span><span class=\"n\">FLAG</span>: <span class=\"nc\">f</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>You can see how <code>v6986</code> is replacing <code>v6985</code> above and this is the pattern that will repeat forever. You may notice as well that the code above is using 16 FPR registers which I temporarily added at <a href=\"https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346\">https://github.com/abrown/wasmtime/blob/7b0463a24cdcf525057349c53c6a46a436c21a80/cranelift/codegen/meta/src/isa/x86/encodings.rs#L346</a> to see if relieving register pressure would get rid of the issue. It doesn't.</p>\n<p>I extracted the function that I believe is causing the issue into the attached <a href=\"https://github.com/bytecodealliance/wasmtime/files/4326543/clif.txt\">clif.txt</a> and you can see below a couple of different ways of looking at the problem (<code>bugpoint</code> loops forever, <code>compile</code> fails). I can attach the original Wasm if that would be helpful but that introduces even more functions to worry about.</p>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case, ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>clif-util bugpoint clif.txt</code> loops forever.</p>\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and if so, with which assertion?</li>\n</ul>\n<p>To panic, run <code>clif-util compile -dDpv clif.txt</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ target/debug/clif-util compile -dDpv clif.txt\nthread <span class=\"s1\">'main'</span> panicked at <span class=\"s1\">'FPR8:%xmm5 is already free in [ GPR: -------d89012345 FPR32: -----5---------56789012345678901 FPR: -----5---------5 FLAG: f ]'</span>, cranelift/codegen/src/regalloc/register_set.rs:73:9\n</code></pre></div>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p><a href=\"https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift\">https://github.com/abrown/wasmtime/tree/fix-simd-locals/cranelift</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>rustc 1.41.1, cargo 1.41.0, Fedora 31 on kernel 5.5.7</p>\n</blockquote>",
        "id": 225059019,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612376951
    }
]