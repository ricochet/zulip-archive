[
    {
        "content": "<p>L-as <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-914330707\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Any update on this? Is it easy enough that an outsider could do it?</p>\n</blockquote>",
        "id": 252309369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631023179
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-914420622\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Hi @L-as -- no, there unfortunately hasn't been progress on this. I'd love for that to be different; if you or another motivated person wants to tackle it, it's <em>possible</em>, but it's likely a month or more of delicate surgery updating our ABI and runtime code to use a new calling convention that supports tail calls.</p>\n<p>It's the sort of problem that feels simple-ish at first -- indeed if you only have args that go in registers, and no callee-saves or spillslots, it can be as simple as some moves to set up the tailcall args and then a jump... but imposing those requirements on the CLIF producer to obtain a guaranteed tailcall would lead to some surprisingly brittle behavior where e.g. changing some unrelated code requires a spill and suddenly breaks the tailcall. Basically, in the general case, one needs to clean up one's own stackframe, restore callee-saves, and remove one's stack args from the stack, and then set up args on the stack for the callee, but possibly some of those args need to come from your spillslots or stack args (and if there are enough of them you can't hold all of them in the register file at once) so you need to do the arbitrary-state-permute possibly with some temps somewhere, or maybe in the worst case you set up the new frame before you pop your own then <code>memmove()</code> it up, but then what about return-area pointers that need to be fixed up... ah and take care to mind any stack-limit checks we need to do as well... in short, it's a mess.</p>\n<p>The Bugzilla bug for SpiderMonkey's Wasm tail call support <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1599723\">here</a> contains a link to <a href=\"https://docs.google.com/document/d/1oi6ROZJuE-hBb21Tgq-XcUegPktecF52gADzBJcYL34\">25-page Google Doc</a> that outlines in some good detail new ABI that the SpiderMonkey folks have designed to support this... it's a lot of work, but understanding that (or at least the reasons for its decisions) would be a good starting point.</p>\n<p>Anyway, if you or anyone else has the resources to tackle this and want to dig in more, I'd be happy to help work out details!</p>\n</blockquote>",
        "id": 252325905,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631029574
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>To write a functional language compiler using this IR, tail call eliminations would be desirable. Are there any plans to support this? I couldn't find any details in the docs.</p>\n</blockquote>",
        "id": 281214767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651695930
    },
    {
        "content": "<p>andrew-johnson-4 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367011364\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>@cfallin This may be really na√Øve of me, but what happens if the caller is made responsible for the tail-call elimination. In the simplest case of a recursive tail-call this is just a reentrant function call with new parameters. How much of a pain and/or performance hit would this be. I am just interested in this issue in general, even if it isn't \"the best option possible\".</p>\n</blockquote>",
        "id": 318346606,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672276423
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367015529\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>@andrew-johnson-4 can you give a bit more detail what you mean by \"caller is made responsible\"? E.g., do you mean the callee should return some value that means \"now call the next function\"? (So <code>f</code> calls <code>g</code> tail-calls <code>h</code> becomes: <code>f</code> calls <code>g</code>, <code>g</code> returns to <code>f</code>, <code>f</code> calls <code>h</code>, somehow.) Or something else?</p>\n<p>The general problem to wrestle with is easiest to see (IMHO) in a minimized example: <code>f</code> and <code>g</code> tail-call each other, both have enough arguments that some of them are passed on the stack, and they have <em>different</em> numbers of arguments. E.g., on x86-64 where the first six <code>i64</code> args are passed in registers, say that <code>f</code> has 8 <code>i64</code> args and <code>g</code> has 10 <code>i64</code> args.</p>\n<p>Then when <code>f</code> tail-calls <code>g</code>, it needs 32 bytes of stack-arg space (the remaining 4 <code>i64</code> args), but it itself only was given 16 bytes of stack-arg space. Furthermore, the original caller of <code>f</code>, in the standard SysV ABI, is responsible for popping those 16 bytes of space. There's no way to satisfy all the constraints for a true tail-call in this case in the SysV ABI. That's why the usual way to achieve true tail-calls in the arbitrary case is to adopt a \"callee-pop\" ABI instead: <code>f</code> and <code>g</code> both expect a certain number of args on the stack, <em>and pop them before returning</em>. This way, <code>f</code>'s tail-call to <code>g</code> can do that pop, and then push <code>g</code>'s args; and when <code>g</code> returns to the original caller of <code>f</code>, there's no need to somehow know that the actual returnee had 32 bytes rather than 16 of stack args.</p>\n<p>It's also possible to make it work in a \"caller-pop\" scheme, but requires dynamic information to be passed around about the size of argument and return-value areas. In the general case, dynamic approaches are less efficient (at the very least they require an extra arg and retval).</p>\n<p>I suspect that what you're thinking of with \"caller is made responsible\" is either something like caller-pop, or else is a sort of \"trampoline\" scheme where the callee returns either \"next func to call\" or \"final return\" states and the callsite runs a worklist/driver loop. I'm curious to hear more what you have in mind though!</p>\n</blockquote>",
        "id": 318347572,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672277468
    },
    {
        "content": "<p>andrew-johnson-4 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367019946\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Yes, the <code>f</code> <code>g</code> recursion is the worst variant. I use that as a benchmark for testing that tail-calls are optimized.</p>\n<p>To synthesize tail-call optimization right now (I want to use cranelift for a pet project) I am looking at the option of writing a function with an <code>Either</code> return type of <code>Either&lt;TailCall,RetVal&gt;</code>. Every marked tailcall function is executed in a loop that loads up the call, then either reenters <em>some</em> function or breaks the loop with a return value.</p>\n<p>I am currently transpiling my interpreted toy language into JIT segments. I have the benefit of whole program optimization, which makes it a bit easier. This <code>Either</code> is the worst case scenario that would still potentially go into compiled code. If the <code>f</code> and <code>g</code> et. al. are finite and known then this can be optimized. Again, if it is only <code>f</code> recursion that makes this so much simpler.</p>\n<p>For a test right now I am using this function in Javascript:</p>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">x</span><span class=\"w\"> </span><span class=\"o\">===</span><span class=\"w\"> </span><span class=\"mf\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mf\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"o\">-</span><span class=\"mf\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"o\">-</span><span class=\"mf\">1</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Without tce this is O(2^n) vs O(n) space.<br>\n</p>\n</blockquote>",
        "id": 318348568,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672278656
    },
    {
        "content": "<p>andrew-johnson-4 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367019946\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Yes, the <code>f</code> <code>g</code> recursion is the worst variant. I use that as a benchmark for testing that tail-calls are optimized.</p>\n<p>To synthesize tail-call optimization right now (I want to use cranelift for a pet project) I am looking at the option of writing a function with an <code>Either</code> return type of <code>Either&lt;TailCall,RetVal&gt;</code>. Every marked tailcall function is executed in a loop that loads up the call, then either reenters <em>some</em> function or breaks the loop with a return value.</p>\n<p>I am currently transpiling my interpreted toy language into JIT segments. I have the benefit of whole program optimization, which makes it a bit easier. This <code>Either</code> is the worst case scenario that would still potentially go into compiled code. If the <code>f</code> and <code>g</code> et. al. are finite and known then this can be optimized. Again, if it is only <code>f</code> recursion that makes this so much simpler.<br>\n</p>\n</blockquote>",
        "id": 318348668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672278795
    },
    {
        "content": "<p>andrew-johnson-4 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367019946\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Yes, the <code>f</code> <code>g</code> recursion is the worst variant. I use that as a benchmark for testing that tail-calls are optimized.</p>\n<p>To synthesize tail-call optimization right now (I want to use cranelift for a pet project) I am looking at the option of writing a function with an <code>Either</code> return type of <code>Either&lt;TailCall,RetVal&gt;</code>. Every marked tailcall function is executed in a loop that loads up the call, then either reenters <em>some</em> function or breaks the loop with a return value.</p>\n<p>I am currently transpiling my interpreted toy language into JIT segments. I have the benefit of whole program optimization, which makes it a bit easier. This <code>Either</code> is the worst case scenario that would still potentially go into compiled code. If the <code>f</code> and <code>g</code> et. al. are finite and known then this can be optimized. Again, if it is only <code>f</code> recursion that makes this so much simpler.</p>\n<p>I see this as primarily a space optimization problem, not so much a speed problem. For simple functional programs with loops this is a huge deal.<br>\n</p>\n</blockquote>",
        "id": 318349436,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672279608
    },
    {
        "content": "<p>andrew-johnson-4 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367019946\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Yes, the <code>f</code> <code>g</code> recursion is the worst variant. I use that as a benchmark for testing that tail-calls are optimized.</p>\n<p>To synthesize tail-call optimization right now (I want to use cranelift for a pet project) I am looking at the option of writing a function with an <code>Either</code> return type of <code>Either&lt;TailCall,RetVal&gt;</code>. Every marked tailcall function is executed in a loop that loads up the call, then either reenters <em>some</em> function or breaks the loop with a return value.</p>\n<p>I am currently transpiling my interpreted toy language into JIT segments. I have the benefit of whole program optimization, which makes it a bit easier. This <code>Either</code> is the worst case scenario that would still potentially go into compiled code. If the <code>f</code> and <code>g</code> et. al. are finite and known then this can be optimized. Again, if it is only <code>f</code> recursion that makes this so much simpler.</p>\n<p>I see this as primarily a space optimization problem, not so much a speed problem. For simple functional programs with loops this is a huge deal.</p>\n<p>\"There's no way to satisfy all the constraints for a true tail-call in this case\" yes, no unified calling convention. \"there's no need to somehow know that the actual returnee had 32 bytes rather than 16 of stack args.\" that is certainly advantageous to have a unified interface. What would that entail development-wise to support?<br>\n</p>\n</blockquote>",
        "id": 318350734,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672280973
    },
    {
        "content": "<p>andrew-johnson-4 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367019946\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>Yes, the <code>f</code> <code>g</code> recursion is the worst variant. I use that as a benchmark for testing that tail-calls are optimized.</p>\n<p>To synthesize tail-call optimization right now (I want to use cranelift for a pet project) I am looking at the option of writing a function with an <code>Either</code> return type of <code>Either&lt;TailCall,RetVal&gt;</code>. Every marked tailcall function is executed in a loop that loads up the call, then either reenters <em>some</em> function or breaks the loop with a return value.</p>\n<p>I am currently transpiling my interpreted toy language into JIT segments. I have the benefit of whole program optimization, which makes it a bit easier. This <code>Either</code> is the worst case scenario that would still potentially go into compiled code. If the <code>f</code> and <code>g</code> et. al. are finite and known then this can be optimized. Again, if it is only <code>f</code> recursion that makes this so much simpler.</p>\n<p>I see this as primarily a space optimization problem, not so much a speed problem. For simple functional programs with loops this is a huge deal.</p>\n<p>\"There's no way to satisfy all the constraints for a true tail-call in this case\" yes, no unified calling convention. \"there's no need to somehow know that the actual returnee had 32 bytes rather than 16 of stack args.\" that is certainly advantageous to have a unified interface. What would that entail development-wise to support?</p>\n<p>From a previously linked doc \"Agreeing on common conventions allows SpiderMonkey to freely choose the compilation strategy for different WebAssembly functions, and to change that choice over time.\" This is a design constraint that I specifically don't care about right now, but probably wasmtime does.<br>\n</p>\n</blockquote>",
        "id": 318351051,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672281307
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367037816\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<blockquote>\n<p><code>Either&lt;TailCall,RetVal&gt;</code></p>\n</blockquote>\n<p>Indeed, that's the \"trampoline\" approach. It's definitely used in the wild; e.g. when targeting Wasm there's <a href=\"https://github.com/WebAssembly/tail-call/issues/15#issuecomment-975798647\">this</a> comment about a Haskell compiler, and IIRC, Clojure provides this (via an explicit API exposed to the user?) as a replacement for tail calls on the JVM. It seems like by far the easiest option at the moment, and could be extended to the corecursive case (tail-call to another function) by returning a \"function pointer\" (index into function table) as part of the <code>TailCall</code> type...</p>\n<blockquote>\n<p>that is certainly advantageous to have a unified interface. What would that entail development-wise to support?</p>\n</blockquote>\n<p>Probably about a month of effort, depending on who's doing the work and their familiarity with the codebase :-) Adding a new ABI is not <em>too</em> technically challenging on its own, but the cross-cutting interactions with everything else -- backtraces, trampolines elsewhere in the system, unwind info, etc. -- make for a likely somewhat gnarly project.</p>\n</blockquote>",
        "id": 318351778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672282034
    },
    {
        "content": "<p>andrew-johnson-4 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367038935\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>I'll try to familiarize myself more with cranelift before I volunteer. There is lots of low-hanging fruit on my end before tce is important. I would be afraid of completely beggaring your devs if I tried now :O</p>\n</blockquote>",
        "id": 318352133,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672282353
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367046105\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>It's actually somewhat likely that @fitzgen will work on this sometime early next year, or at least, that was my most recent understanding :-) Having others interested in the issue as well is never a bad thing, of course!</p>\n</blockquote>",
        "id": 318353733,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672283890
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1367115626\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>By the way tail calls to <code>_Unwind_Resume</code> will be necessary for exceptions. This should be less hard than the general case though as it doesn't require any args being passed on the stack.</p>\n</blockquote>",
        "id": 318367646,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672297715
    },
    {
        "content": "<p>andrew-johnson-4 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1371492230\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>@cfallin Is it safe to assume that <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.jump\">jumping to the entry block</a> is one special case of a true tail-call? Does this violate SSA or other invariants potentially?</p>\n</blockquote>",
        "id": 319482754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672870496
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1371509085\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>I don't know that we've documented this, but no, Cranelift doesn't allow branching back to the entry block. I know one reason is that <a href=\"https://github.com/bytecodealliance/wasmtime/blob/25bf8e0/cranelift/codegen/src/egraph/elaborate.rs#L160-L187\">there's no block to hoist loop-invariant code into if the loop's entry doesn't have a dominator</a>. I feel like this has come up as a problem in other contexts too but I don't remember them.</p>\n<p>That said, you can always emit an entry block that immediately jumps to another block with the same signature, forwarding the arguments, and branch back to that second block instead of tail-calling.</p>\n<p>Either way this only works for a function that tail-calls itself. Cranelift has no way to express a jump to a block in a different function, since block IDs are function-scoped. But in that special case, yes, you could implement tail-calls today.</p>\n</blockquote>",
        "id": 319485813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1672871899
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1377557335\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>FWIW, I am working on an RFC for this at the moment.</p>\n</blockquote>",
        "id": 320495847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1673369370
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1405470715\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>The RFC in question is <a href=\"https://github.com/bytecodealliance/rfcs/pull/29\">https://github.com/bytecodealliance/rfcs/pull/29</a>.</p>\n</blockquote>",
        "id": 323816156,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1674759942
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065#issuecomment-1518201038\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a>:</p>\n<blockquote>\n<p>The big blocker for tail calls was overhauling Wasmtime's trampolines, which I've just posted a PR for: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6262\">https://github.com/bytecodealliance/wasmtime/pull/6262</a></p>\n<p>Will start on Cranelift support for tail calls when that lands.</p>\n</blockquote>",
        "id": 351705760,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1682102027
    },
    {
        "content": "<p>fitzgen assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1065\">issue #1065</a> (assigned to fitzgen):</p>\n<blockquote>\n<p>To write a functional language compiler using this IR, tail call eliminations would be desirable. Are there any plans to support this? I couldn't find any details in the docs.</p>\n</blockquote>",
        "id": 351705782,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1682102035
    }
]