[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620333565\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620333565\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\" title=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 195495383,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588039663
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620501985\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620501985\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>if you have a need for working x86_32 sooner than that work might be done</p>\n</blockquote>\n<p>I believe I do have something close to working x86_32 codegen, at least, it doesn't crash in the compiler and it seems to emit reasonably looking code. It doesn't actually work if you call it, of course.</p>\n</blockquote>",
        "id": 195540498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588067522
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>I do notice that you test <code>ishl</code> in all six, did you mean to have half <code>ishl</code> and half <code>ushr</code>?</p>\n</blockquote>\n<p>Oops.</p>\n<blockquote>\n<p>I think this is entirely reasonable.</p>\n</blockquote>\n<p>Actually, I think this PR, while it might be an entirely reasonable transformation in isolation, isn't sufficient on its own, because it causes all wide shifts to be legalized into SIMD operations and you have to pass <code>--enable-simd</code> for the compiler to accept it.</p>\n</blockquote>",
        "id": 195540663,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588067614
    },
    {
        "content": "<p>whitequark edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>I do notice that you test <code>ishl</code> in all six, did you mean to have half <code>ishl</code> and half <code>ushr</code>?</p>\n</blockquote>\n<p>Oops.</p>\n<blockquote>\n<p>I think this is entirely reasonable.</p>\n</blockquote>\n<p>Actually, I think this PR, while it might be an entirely reasonable transformation in isolation, isn't sufficient on its own, because it causes all wide shifts to be legalized into SIMD operations and you have to pass <code>--enable-simd</code> for the compiler to accept it. Apparently PEXTR is a part of SSE4.1.</p>\n</blockquote>",
        "id": 195540698,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588067639
    },
    {
        "content": "<p>whitequark edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620502714\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>I do notice that you test <code>ishl</code> in all six, did you mean to have half <code>ishl</code> and half <code>ushr</code>?</p>\n</blockquote>\n<p>Oops.</p>\n<blockquote>\n<p>I think this is entirely reasonable.</p>\n</blockquote>\n<p>Actually, I think this PR, while it might be an entirely reasonable transformation in isolation, isn't sufficient on its own, because it causes all wide shifts to be legalized into SIMD operations and you have to pass <code>--enable-simd</code> for the compiler to accept it. Apparently PEXTR and PINSR are a part of SSE4.1.</p>\n</blockquote>",
        "id": 195540796,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588067679
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620510078\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620510078\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>The split <code>load.i32</code> is wrong. The legalizer split the <code>load.i64</code> into two <code>load.i32</code> with eight bytes between them!</p>\n</blockquote>\n<p>Oh, I actually noticed that and never figured out what the hell was going on! I eventually disregarded it under the assumption that I'm misreading something. Wasn't expecting it to be a bug.</p>\n</blockquote>",
        "id": 195542088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588068463
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620566542\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620566542\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<p>@iximeow And we have liftoff!<br>\n![Screenshot_20200428_120942](<a href=\"https://user-images.githubusercontent.com/54771/80485537-24b9dd80-8949-11ea-94bc-6603a6302674.png\" title=\"https://user-images.githubusercontent.com/54771/80485537-24b9dd80-8949-11ea-94bc-6603a6302674.png\">https://user-images.githubusercontent.com/54771/80485537-24b9dd80-8949-11ea-94bc-6603a6302674.png</a>)</p>\n<p>This is without stack overflow checks since I find it utterly incomprehensible how one would emit a <code>mov %scratch, 0(%esp)</code> with Cranelift, but other than that it's basically ready for upstream.</p>\n</blockquote>",
        "id": 195553822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588075920
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620846998\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620846998\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>And we have liftoff!<br>\n<span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<p>because it causes all wide shifts to be legalized into SIMD operations<br>\nIt shouldn't... for x86_64 there are legal encodings for <code>(I64, _)</code> so they shouldn't require legalization. A test to confirm that wouldn't hurt, though.</p>\n<p>Apparently PEXTR and PINSR are a part of SSE4.1.<br>\nwell.. most of them. <code>PEXTRW</code> and <code>PINSRW</code> exist back in SSE2. That still requires <code>--enable-simd</code>, so a legalization using only integer registers would still be an improvement.</p>\n<p>how one would emit a mov %scratch, 0(%esp) with Cranelift<br>\nSomething to the tune of <code>stack_store</code> with an appropriate stack slot should generate this, but I think \"appropriate stack slot\" is the harder part there. I'm actually not sure if Cranelift emits stack canaries anywhere, now that you mention it..</p>\n</blockquote>\n</blockquote>",
        "id": 195624872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588106971
    },
    {
        "content": "<p>iximeow edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620846998\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620846998\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>And we have liftoff!</p>\n</blockquote>\n<p><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<blockquote>\n<p>because it causes all wide shifts to be legalized into SIMD operations</p>\n</blockquote>\n<p>It shouldn't... for x86_64 there are legal encodings for <code>(I64, _)</code> so they shouldn't require legalization. A test to confirm that wouldn't hurt, though.</p>\n<blockquote>\n<p>Apparently PEXTR and PINSR are a part of SSE4.1.</p>\n</blockquote>\n<p>well.. most of them. <code>PEXTRW</code> and <code>PINSRW</code> exist back in SSE2. That still requires <code>--enable-simd</code>, so a legalization using only integer registers would still be an improvement.</p>\n<blockquote>\n<p>how one would emit a mov %scratch, 0(%esp) with Cranelift</p>\n</blockquote>\n<p>Something to the tune of <code>stack_store</code> with an appropriate stack slot should generate this, but I think \"appropriate stack slot\" is the harder part there. I'm actually not sure if Cranelift emits stack canaries anywhere, now that you mention it..</p>\n</blockquote>",
        "id": 195624906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588106984
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620976812\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-620976812\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>It shouldn't... for x86_64 there are legal encodings for <code>(I64, _)</code> so they shouldn't require legalization. A test to confirm that wouldn't hurt, though.</p>\n</blockquote>\n<p>I mean only on x86_32. There are lots of wasm files that shift 64-bit values and as is, on x86_32 Cranelift cannot emit them in any way other than by using SIMD.</p>\n</blockquote>",
        "id": 195657665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588132788
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-624410838\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-624410838\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<p>After noodling over how legalizations fit together today I noticed the failing test cases can be made to pass; your two failing cases with 64-bit shift amounts can be legalized by a different approach:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gh\">diff --git a/cranelift/codegen/meta/src/isa/x86/legalize.rs b/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gh\">index 6bcc2b94f..e2ff2150e 100644</span>\n<span class=\"gd\">--- a/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gi\">+++ b/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gu\">@@ -55,6 +55,26 @@ pub(crate) fn define(shared: &amp;mut SharedDefinitions, x86_instructions: &amp;Instruct</span>\n\n     let imm = &amp;shared.imm;\n\n\n<span class=\"gi\">+    // Left-shift by a 64-bit amount is equivalent to a shift by that amount mod 32, so we can</span>\n<span class=\"gi\">+    // reduce the size of the shift amount. This is useful for x86_32, where an I64 shift amount is</span>\n<span class=\"gi\">+    // not encodable.</span>\n<span class=\"gi\">+    let a = var(&quot;a&quot;);</span>\n<span class=\"gi\">+    let x = var(&quot;x&quot;);</span>\n<span class=\"gi\">+    let y = var(&quot;y&quot;);</span>\n<span class=\"gi\">+    let z = var(&quot;z&quot;);</span>\n<span class=\"gi\">+</span>\n\n<span class=\"gi\">+    let ishl = insts.by_name(&quot;ishl&quot;);</span>\n<span class=\"gi\">+    let ireduce = insts.by_name(&quot;ireduce&quot;);</span>\n<span class=\"gi\">+    let reduction = ireduce.bind(I32).bind(I64);</span>\n<span class=\"gi\">+    let inst = ishl.bind(I32).bind(I64);</span>\n<span class=\"gi\">+    group.legalize(</span>\n<span class=\"gi\">+        def!(a = inst(x, y)),</span>\n<span class=\"gi\">+        vec![</span>\n<span class=\"gi\">+            def!(z = reduction(y)),</span>\n<span class=\"gi\">+            def!(a = ishl(x, z)),</span>\n<span class=\"gi\">+        ]</span>\n<span class=\"gi\">+    );</span>\n<span class=\"gi\">+</span>\n     // Division and remainder.\n     //\n     // The srem expansion requires custom code because srem INT_MIN, -1 is not\n</code></pre></div>\n\n\n<p>The same applies for <code>ushr</code>.</p>\n<p>With a <code>rustfmt</code> and test cases (with the second half being <code>ushr</code> rather than <code>ishl</code>) I think this is good to go, i686 is better than no x86_32 at all.</p>\n</blockquote>",
        "id": 196391343,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588732190
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626118172\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626118172\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>I noticed the failing test cases can be made to pass; your two failing cases with 64-bit shift amounts can be legalized by a different approach:</p>\n</blockquote>\n<p>How are you testing this? I can't get them to pass with your patch applied. It seems to me that they won't ever pass no matter how the legalizer is changed while the encoding tables (incorrectly) list that any shift amount is acceptable.</p>\n</blockquote>",
        "id": 196977373,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589007441
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626129132\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626129132\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>How are you testing this?</p>\n</blockquote>\n<p>incorrectly, is how. I had misplaced the tests in a file ending with <code>.clf</code> instead of <code>.clif</code>, so the tests weren't actually run. You're right, x86 encodings needed a tweak for to deny i64 shift amounts fror x86_32. This diff _actually_ results in passing tests, with your tests properly placed in a .clif under filetests:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gh\">diff --git a/cranelift/codegen/meta/src/isa/x86/encodings.rs b/cranelift/codegen/meta/src/isa/x86/encodings.rs</span>\n<span class=\"gh\">index 7aee35bdb..1e395967c 100644</span>\n<span class=\"gd\">--- a/cranelift/codegen/meta/src/isa/x86/encodings.rs</span>\n<span class=\"gi\">+++ b/cranelift/codegen/meta/src/isa/x86/encodings.rs</span>\n<span class=\"gu\">@@ -1488,7 +1488,15 @@ fn define_alu(</span>\n         // Cannot use enc_i32_i64 for this pattern because instructions require\n         // to bind any.\n         e.enc32(\n\n<span class=\"gd\">-            inst.bind(I32).bind(Any),</span>\n<span class=\"gi\">+            inst.bind(I32).bind(I8),</span>\n<span class=\"gi\">+            rec_rc.opcodes(&amp;ROTATE_CL).rrr(rrr),</span>\n<span class=\"gi\">+        );</span>\n<span class=\"gi\">+        e.enc32(</span>\n<span class=\"gi\">+            inst.bind(I32).bind(I16),</span>\n<span class=\"gi\">+            rec_rc.opcodes(&amp;ROTATE_CL).rrr(rrr),</span>\n<span class=\"gi\">+        );</span>\n<span class=\"gi\">+        e.enc32(</span>\n<span class=\"gi\">+            inst.bind(I32).bind(I32),</span>\n             rec_rc.opcodes(&amp;ROTATE_CL).rrr(rrr),\n         );\n         e.enc64(\n<span class=\"gh\">diff --git a/cranelift/codegen/meta/src/isa/x86/legalize.rs b/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gh\">index 6bcc2b94f..e2ff2150e 100644</span>\n<span class=\"gd\">--- a/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gi\">+++ b/cranelift/codegen/meta/src/isa/x86/legalize.rs</span>\n<span class=\"gu\">@@ -55,6 +55,26 @@ pub(crate) fn define(shared: &amp;mut SharedDefinitions, x86_instructions: &amp;Instruct</span>\n\n     let imm = &amp;shared.imm;\n\n\n<span class=\"gi\">+    // Left-shift by a 64-bit amount is equivalent to a shift by that amount mod 32, so we can</span>\n<span class=\"gi\">+    // reduce the size of the shift amount. This is useful for x86_32, where an I64 shift amount is</span>\n<span class=\"gi\">+    // not encodable.</span>\n<span class=\"gi\">+    let a = var(&quot;a&quot;);</span>\n<span class=\"gi\">+    let x = var(&quot;x&quot;);</span>\n<span class=\"gi\">+    let y = var(&quot;y&quot;);</span>\n<span class=\"gi\">+    let z = var(&quot;z&quot;);</span>\n<span class=\"gi\">+</span>\n\n<span class=\"gi\">+    let ishl = insts.by_name(&quot;ishl&quot;);</span>\n<span class=\"gi\">+    let ireduce = insts.by_name(&quot;ireduce&quot;);</span>\n<span class=\"gi\">+    let reduction = ireduce.bind(I32).bind(I64);</span>\n<span class=\"gi\">+    let inst = ishl.bind(I32).bind(I64);</span>\n<span class=\"gi\">+    group.legalize(</span>\n<span class=\"gi\">+        def!(a = inst(x, y)),</span>\n<span class=\"gi\">+        vec![</span>\n<span class=\"gi\">+            def!(z = reduction(y)),</span>\n<span class=\"gi\">+            def!(a = ishl(x, z)),</span>\n<span class=\"gi\">+        ]</span>\n<span class=\"gi\">+    );</span>\n<span class=\"gi\">+</span>\n     // Division and remainder.\n     //\n     // The srem expansion requires custom code because srem INT_MIN, -1 is not\n</code></pre></div>\n\n\n</blockquote>",
        "id": 196980681,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589013163
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626132472\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626132472\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<blockquote>\n<p>This diff _actually_ results in passing tests</p>\n</blockquote>\n<p>Ah wonderful, I see how you changed the encodings; I tried a few things but none seemed to work. Let me see if I can integrate everything nicely.</p>\n</blockquote>",
        "id": 196981530,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589014756
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626137807\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612#issuecomment-626137807\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1612\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1612\">Issue #1612</a>:</p>\n<blockquote>\n<p>Okay, I think I've addressed all review.</p>\n<p>@iximeow Thanks for your help, it was vital for getting this done.</p>\n</blockquote>",
        "id": 196982710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589017084
    }
]