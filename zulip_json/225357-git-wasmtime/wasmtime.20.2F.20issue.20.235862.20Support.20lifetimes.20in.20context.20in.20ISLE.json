[
    {
        "content": "<p>lynzrand opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Add lifetime parameters in ISLE-generated <code>Context</code>, so that it can return values with lifetime parameters (not <code>'static</code> lifetime).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// ISLE generated Context</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>In this way, the context can be implemented like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#[derive(Debug)]</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Foo</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(previously discussed in Zulip: <a href=\"#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime\">https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime</a>)</p>\n<h4>Benefit</h4>\n<p>I'm currently using <code>cranelift-isle</code> for a project of my own. However, unlike Cranelift, the types that I use with ISLE cannot be cheaply cloned like those used in Cranelift. If a <code>Context</code> can return values with non-<code>'static</code> lifetime, I can efficiently reference into readonly input data structures.</p>\n<h4>Implementation</h4>\n<p>I am implementing it in my fork: <a href=\"https://github.com/lynzrand/wasmtime/tree/isle-patch\">https://github.com/lynzrand/wasmtime/tree/isle-patch</a></p>\n<p>Additions to the language:</p>\n<ul>\n<li>Lifetime identifiers: <code>'a</code> is a valid lifetime identifier.</li>\n<li>A pragma statement: <code>(pragma context_lifetime 'a 'b ...)</code>.</li>\n<li>A new kind of primitive type definition with lifetime: <code>(type Node (primitive (NodeRef 'a)))</code>.</li>\n</ul>\n<p>Modifications:</p>\n<p>By adding a pragma statement:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">pragma</span><span class=\"w\"> </span><span class=\"nv\">context_lifetime</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"w\"> </span><span class=\"ss\">'b</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... the codegen will now generate the context trait with the specified lifetimes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>These lifetimes can then be used in primitive type definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">NodeRef</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>... and reflected in generated code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">constructor_lower</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span>\n<span class=\"w\">    </span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">arg0</span>: <span class=\"nc\">NodeRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>My implementation is currently pretty naive and lacks polishing. I plan to continue testing and polishing it as I continue on my project.</p>\n<h4>Alternatives</h4>\n<p>I can choose to use <code>impl Copy</code> indices or other kinds of keys to index structures instead of fancy references, like Cranelift does.</p>\n</blockquote>",
        "id": 329725927,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677160849
    },
    {
        "content": "<p>lynzrand edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Add lifetime parameters in ISLE-generated <code>Context</code>, so that it can return values with lifetime parameters (not <code>'static</code> lifetime).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// ISLE generated Context</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>In this way, the context can be implemented like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#[derive(Debug)]</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Foo</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(previously discussed in Zulip: <a href=\"#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime\">https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime</a>)</p>\n<h4>Benefit</h4>\n<p>I'm currently using <code>cranelift-isle</code> for a project of my own. However, unlike Cranelift, the types that I use with ISLE cannot be cheaply cloned like those used in Cranelift. If a <code>Context</code> can return values with non-<code>'static</code> lifetime, I can efficiently reference into readonly input data structures.</p>\n<h4>Implementation</h4>\n<p>I am implementing it in my fork: <a href=\"https://github.com/lynzrand/wasmtime/tree/isle-patch\">https://github.com/lynzrand/wasmtime/tree/isle-patch</a></p>\n<p>Additions to the language:</p>\n<ul>\n<li>Lifetime identifiers: <code>'a</code> is a valid lifetime identifier.</li>\n<li>A pragma statement: <code>(pragma context_lifetime 'a 'b ...)</code>.</li>\n<li>A new kind of primitive type definition with lifetime: <code>(type Node (primitive (NodeRef 'a)))</code>.</li>\n</ul>\n<p>Modifications:</p>\n<p>By adding a pragma statement:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">pragma</span><span class=\"w\"> </span><span class=\"nv\">context_lifetime</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"w\"> </span><span class=\"ss\">'b</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... the codegen will now generate the context trait with the specified lifetimes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>These lifetimes can then be used in primitive type definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">NodeRef</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... and reflected in generated code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">constructor_lower</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span>\n<span class=\"w\">    </span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">arg0</span>: <span class=\"nc\">NodeRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>My implementation is currently pretty naive and lacks polishing. I plan to continue testing and polishing it as I continue on my project.</p>\n<h4>Alternatives</h4>\n<p>I can choose to use <code>impl Copy</code> indices or other kinds of keys to index structures instead of fancy references, like Cranelift does.</p>\n</blockquote>",
        "id": 329726334,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677160951
    },
    {
        "content": "<p>lynzrand edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Add lifetime parameters in ISLE-generated <code>Context</code>, so that it can return values with lifetime parameters (not <code>'static</code> lifetime).</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// ISLE generated Context</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>In this way, the context can be implemented like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#[derive(Debug)]</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Foo</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">FooCtx</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">FooRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(previously discussed in Zulip: <a href=\"#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime\">https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift/topic/ISLE.20support.20for.20references.20with.20context.20lifetime</a>)</p>\n<h4>Benefit</h4>\n<p>I'm currently using <code>cranelift-isle</code> for a project of my own. However, unlike Cranelift, the types that I use with ISLE cannot be cheaply cloned like those used in Cranelift. If a <code>Context</code> can return values with non-<code>'static</code> lifetime, I can efficiently reference into readonly input data structures.</p>\n<h4>Implementation</h4>\n<p>I am implementing it in my fork: <a href=\"https://github.com/lynzrand/wasmtime/tree/isle-patch\">https://github.com/lynzrand/wasmtime/tree/isle-patch</a></p>\n<p>Additions to the language:</p>\n<ul>\n<li>Lifetime identifiers: <code>'a</code> is a valid lifetime identifier.</li>\n<li>A pragma statement: <code>(pragma context_lifetime 'a 'b ...)</code>.</li>\n<li>A new kind of primitive type definition with lifetime: <code>(type Node (primitive (NodeRef 'a)))</code>.</li>\n</ul>\n<p>Modifications:</p>\n<p>By adding a pragma statement:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">pragma</span><span class=\"w\"> </span><span class=\"nv\">context_lifetime</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"w\"> </span><span class=\"ss\">'b</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... the codegen will now generate the context trait with the specified lifetimes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>These lifetimes can then be used in primitive type definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">NodeRef</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>... and reflected in generated code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">constructor_lower</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span>\n<span class=\"w\">    </span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">arg0</span>: <span class=\"nc\">NodeRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>(I have yet to look into enums.)</p>\n<p>My implementation is currently pretty naive and lacks polishing. I plan to continue testing and polishing it as I continue on my project.</p>\n<h4>Alternatives</h4>\n<p>I can choose to use <code>impl Copy</code> indices or other kinds of keys to index structures instead of fancy references, like Cranelift does.</p>\n</blockquote>",
        "id": 329729388,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677161701
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862#issuecomment-1444971028\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<p>This design looks reasonable to me!</p>\n<p>The main reasons not to do it, IMHO, would be either that it significantly complexifies the codegen or is somehow incompatible with it. But both of these are implementation-related and we can judge them objectively once we see your implementation. At the language level, the way that you've proposed to add this seems pretty unintrusive. We likely won't use it in the Cranelift application of ISLE but we can keep it working and exercised with islec tests.</p>\n<p>@jameysharp, do you foresee any issues with the new codegen in managing the new kinds of types?</p>\n</blockquote>",
        "id": 337927850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677294723
    },
    {
        "content": "<p>lynzrand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862#issuecomment-1444972378\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<p>For the implementation, please see this branch: <a href=\"https://github.com/lynzrand/wasmtime/tree/isle-patch?rgh-link-date=2023-02-23T14%3A00%3A47Z\">lynzrand/wasmtime@isle-patch</a></p>\n<p>I have implemented it for primitive types, and are already using it in a tiny part of my codebase. I haven't met any issues _yet_.</p>\n<p>Here's a piece of the actual source code I used:</p>\n<p><div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"c1\">;; Anything related to function refeerences are 'f, and to LLVM are 'a</span>\n<span class=\"p\">(</span><span class=\"nv\">pragma</span><span class=\"w\"> </span><span class=\"nv\">context_lifetime</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"w\"> </span><span class=\"ss\">'f</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">OpCode</span><span class=\"w\"> </span><span class=\"nv\">extern</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">enum</span>\n<span class=\"w\">        </span><span class=\"c1\">;; Duplicated code with ir/src/opcode.rs. TODO: deduplicate</span>\n<span class=\"w\">        </span><span class=\"nv\">Start</span>\n<span class=\"w\">        </span><span class=\"nv\">Region</span>\n<span class=\"w\">        </span><span class=\"nv\">EndRegion</span>\n<span class=\"w\">        </span><span class=\"nv\">If</span>\n<span class=\"w\">        </span><span class=\"nv\">IfTrue</span>\n<span class=\"w\">        </span><span class=\"nv\">IfFalse</span>\n<span class=\"w\">        </span><span class=\"nv\">Merge</span>\n<span class=\"w\">        </span><span class=\"nv\">Return</span>\n<span class=\"w\">        </span><span class=\"nv\">Finish</span>\n<span class=\"w\">        </span><span class=\"nv\">IConst</span>\n<span class=\"w\">        </span><span class=\"c1\">;; ...</span>\n<span class=\"w\">        </span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">Ty</span><span class=\"w\"> </span><span class=\"nv\">extern</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">enum</span>\n<span class=\"w\">        </span><span class=\"nv\">Any</span>\n<span class=\"w\">        </span><span class=\"c1\">;; ...</span>\n<span class=\"w\">        </span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">NodeRef</span><span class=\"w\"> </span><span class=\"ss\">'f</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">ParamFmt</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">ParamFmtRef</span><span class=\"w\"> </span><span class=\"ss\">'f</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">NodeId</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"nv\">NodeId</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"nv\">LLV</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">primitive</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">BasicValueEnum</span><span class=\"w\"> </span><span class=\"ss\">'a</span><span class=\"p\">)))</span><span class=\"w\"> </span><span class=\"c1\">;; LLVM Value</span>\n\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">ParamFmt</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">extern</span><span class=\"w\"> </span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">param_i32</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">OpCode</span><span class=\"w\"> </span><span class=\"nv\">ParamFmt</span><span class=\"w\"> </span><span class=\"nv\">Ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">extern</span><span class=\"w\"> </span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"nv\">ex_node</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">LLV</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Node</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">OpCode.IConst</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">llvm_iconst</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"p\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 337928398,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677295187
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862#issuecomment-1444978300\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5862\">issue #5862</a>:</p>\n<blockquote>\n<p>Skimming the diff on your branch, the implementation looks pretty reasonable -- please do feel free to put up a PR and we'll do a proper review, likely early next week :-)</p>\n</blockquote>",
        "id": 337930157,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677296838
    }
]