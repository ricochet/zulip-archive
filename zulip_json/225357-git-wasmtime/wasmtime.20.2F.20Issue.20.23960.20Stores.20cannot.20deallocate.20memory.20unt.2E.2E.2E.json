[
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>From our discussion today on the wasmtime call the topic of GC, <code>table.set</code>, and <a href=\"https://github.com/bytecodealliance/wasmtime/issues/954\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/954\">https://github.com/bytecodealliance/wasmtime/issues/954</a> all came up. It was concluded that <em>today</em> with the MVP you can actually create a cyclic dependency between modules, for example:</p>\n<div class=\"codehilite\"><pre><span></span>(module $a\n  (table (export &quot;table&quot;) 2 2 funcref)\n  (func\n    i32.const 1\n    call_indirect)\n  (elem (i32.const 0) func 0))\n\n(module $b\n  (import &quot;a&quot; &quot;table&quot; (table 2 2 funcref))\n  (func\n    i32.const 0\n    call_indirect)\n  (elem (i32.const 1) func 0))\n</pre></div>\n\n\n<p>These two modules only use MVP features but they have a shared table which cyclically references the two modules.</p>\n<p>Our conclusion from this was that <code>Store</code> is actually a \"clique\" of instances together, and once you instantiate something you can never deallocate anything until all the instances have gone. Internally this would entail ensuring that all types exported in <code>wasmtime</code> have some sort of handle on their store (basically all of them already do, this isn't hard).</p>\n<p>Implementation-wise I don't think this will be hard to do, but this does have some critical implications I'd like to sort out first:</p>\n<ul>\n<li>\n<p>We need to acknowledge that an <code>Instance</code> will never be fully deallocated until all objects referencing the <code>Store</code> have gone away. This feels like a pretty bad crutch to lean on (but it's not like we have much choice) and is something we would need to document thoroughly. You would basically never want user code generating instances into a <code>Store</code> because it means you could OOM quickly. Instead your instance-creation patterns must be known statically. (this may eventually be different with the whole linking proposal, but this would be the status quo that we would have to document)</p>\n</li>\n<li>\n<p>If we start thinking of <code>Store</code> as a \"clique of instances\" then I don't think the API is quite aligned for that today. For example if you compile a <code>Module</code> I wouldn't expect that to be tied to a particular store. A <code>Module</code> should have its own compiled memory cached, but this can be instantiated into any <code>Store</code> object since it's just adding new references to the compiled memory in multiple stores (possibly). Furthermore I don't know how to rationalize the thread-safety here. For example an <code>Instance</code> cannot be sent across threads (although this is <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/793\">up for debate</a>), but you almost for sure want to share a <code>Module</code> across threads. You may even want multiple threads to be part of a single <code>Store</code>, but if a <code>Store</code> has to have a handle to all of its <code>Instance</code> objects then this is sort of a backwards relation because <code>Store</code> needs to be threadsafe, but it can't be threadsafe because <code>Instance</code> can't be threadsafe.</p>\n</li>\n</ul>\n<p>I think a bunch of this may just boil down to \"Alex needs further clarification of what's already there\", but I don't really see how <code>Store</code> and <code>Engine</code> map to concepts of what you would want today. I understand they came from v8, but I'm not sure why we want them in our API as well and how it maps to thread safety and such. This is all stuff we need to sort out, though, because the current way we treat multiple stores and instances referencing each other is not memory safe and can easily segfault.</p>\n</blockquote>",
        "id": 189699323,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583334184
    },
    {
        "content": "<p>pepyakin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-599616086\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-599616086\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>I think it came from <a href=\"https://github.com/WebAssembly/wasm-c-api/blob/master/include/wasm.h\" target=\"_blank\" title=\"https://github.com/WebAssembly/wasm-c-api/blob/master/include/wasm.h\">wasm-c-api</a> (which seems to be heavily influenced by v8). It seems that wasm-c-api was inspired by the wasm spec, but in contrast to it, wasm-c-api's <code>Module</code> requires <code>Store</code> for some reason. Looking at their impl, their store is thread-safe in the sense that it is <code>Send</code> but not thread-safe in the sense that multiple threads can use it at the same time.</p>\n<p>So, by this</p>\n<blockquote>\n<p>You may even want multiple threads to be part of a single <code>Store</code></p>\n</blockquote>\n<p>you also mean <code>Send</code>?</p>\n</blockquote>",
        "id": 190742449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584374273
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-600240793\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-600240793\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>Somehow we're going to want to be able to support threaded wasm where instances are connected to each other via a <code>Memory</code> and they can all instantiate the same <code>Module</code> on multiple threads. That's sort of the bare minimum required, but today we've painted ourselves a bit into a corner where <code>Module</code> stores a <code>Store</code> which is not thread safe inherently because <code>Instance</code> fields should never be dropped until a <code>Store</code> is dropped. Furthermore we also require that all imports come from the same <code>Store</code>, which would cause more issues if we were to try to make targeted fixes.</p>\n<p>We're basically in a corner right now which I dont think makes sense. We need to figure out, probably from scratch, what we want our multithreading story to be. For example what structures are supposed to be shared, what's the idioms we are expecting for multithreaded instances, etc.</p>\n</blockquote>",
        "id": 190894833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584471213
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>From our discussion today on the wasmtime call the topic of GC, <code>table.set</code>, and <a href=\"https://github.com/bytecodealliance/wasmtime/issues/954\" title=\"https://github.com/bytecodealliance/wasmtime/issues/954\">https://github.com/bytecodealliance/wasmtime/issues/954</a> all came up. It was concluded that <em>today</em> with the MVP you can actually create a cyclic dependency between modules, for example:</p>\n<div class=\"codehilite\"><pre><span></span><code>(module $a\n  (table (export &quot;table&quot;) 2 2 funcref)\n  (func\n    i32.const 1\n    call_indirect)\n  (elem (i32.const 0) func 0))\n\n(module $b\n  (import &quot;a&quot; &quot;table&quot; (table 2 2 funcref))\n  (func\n    i32.const 0\n    call_indirect)\n  (elem (i32.const 1) func 0))\n</code></pre></div>\n\n\n<p>These two modules only use MVP features but they have a shared table which cyclically references the two modules.</p>\n<p>Our conclusion from this was that <code>Store</code> is actually a \"clique\" of instances together, and once you instantiate something you can never deallocate anything until all the instances have gone. Internally this would entail ensuring that all types exported in <code>wasmtime</code> have some sort of handle on their store (basically all of them already do, this isn't hard).</p>\n<p>Implementation-wise I don't think this will be hard to do, but this does have some critical implications I'd like to sort out first:</p>\n<ul>\n<li>\n<p>We need to acknowledge that an <code>Instance</code> will never be fully deallocated until all objects referencing the <code>Store</code> have gone away. This feels like a pretty bad crutch to lean on (but it's not like we have much choice) and is something we would need to document thoroughly. You would basically never want user code generating instances into a <code>Store</code> because it means you could OOM quickly. Instead your instance-creation patterns must be known statically. (this may eventually be different with the whole linking proposal, but this would be the status quo that we would have to document)</p>\n</li>\n<li>\n<p>If we start thinking of <code>Store</code> as a \"clique of instances\" then I don't think the API is quite aligned for that today. For example if you compile a <code>Module</code> I wouldn't expect that to be tied to a particular store. A <code>Module</code> should have its own compiled memory cached, but this can be instantiated into any <code>Store</code> object since it's just adding new references to the compiled memory in multiple stores (possibly). Furthermore I don't know how to rationalize the thread-safety here. For example an <code>Instance</code> cannot be sent across threads (although this is <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\" title=\"https://github.com/bytecodealliance/wasmtime/issues/793\">up for debate</a>), but you almost for sure want to share a <code>Module</code> across threads. You may even want multiple threads to be part of a single <code>Store</code>, but if a <code>Store</code> has to have a handle to all of its <code>Instance</code> objects then this is sort of a backwards relation because <code>Store</code> needs to be threadsafe, but it can't be threadsafe because <code>Instance</code> can't be threadsafe.</p>\n</li>\n</ul>\n<p>I think a bunch of this may just boil down to \"Alex needs further clarification of what's already there\", but I don't really see how <code>Store</code> and <code>Engine</code> map to concepts of what you would want today. I understand they came from v8, but I'm not sure why we want them in our API as well and how it maps to thread safety and such. This is all stuff we need to sort out, though, because the current way we treat multiple stores and instances referencing each other is not memory safe and can easily segfault.</p>\n</blockquote>",
        "id": 195746103,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588182471
    },
    {
        "content": "<p>DemiMarie-parity <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-625868939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-625868939\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>@alexcrichton what about doing some form of garbage collection pass?</p>\n</blockquote>",
        "id": 196909240,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588951452
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-625888584\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960#issuecomment-625888584\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/960\" title=\"https://github.com/bytecodealliance/wasmtime/issues/960\">Issue #960</a>:</p>\n<blockquote>\n<p>Indeed that should be able to help clear out memory sooner! That's a pretty major feature though and one we haven't planned on adding any time soon (AFAIK) to wasmtime, so it's aways out if at all.</p>\n</blockquote>",
        "id": 196915154,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588953983
    }
]