[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4131\">issue #4131</a>:</p>\n<blockquote>\n<p>We should build a simple <a href=\"https://en.wikipedia.org/wiki/Alias_analysis\">alias analysis</a> over CLIF to determine when loads and stores are referring to overlapping (may-alias) or the same (must-alias) data, and allow optimizations as appropriate (redundant-load elimination, store-to-load forwarding, dead-store elimination, code motion in general in LICM or lowering).</p>\n<p>It is likely we will want to build a bitset-style analysis, where we have a small, finite set of disjoint divisions of the heap, and every load or store is marked as potentially accessing one or more.</p>\n<p>For example, one could imagine a set of four bits for a Wasm frontend: accesses to any heap, accesses to any table, accesses to any global, or everything else (and explicitly not one of the above).</p>\n<p>Given these bits for every load/store, we then have a \"vector color\" of sorts, in the sense that the current instruction coloring scheme could be seen to have a color <em>per disjoint segment of world-state</em>. We don't actually necessarily want to compute these vectors of colors, but we want to be able to answer questions using them.</p>\n</blockquote>",
        "id": 281900148,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652225759
    },
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4131\">issue #4131</a>:</p>\n<blockquote>\n<p>We should build a simple <a href=\"https://en.wikipedia.org/wiki/Alias_analysis\">alias analysis</a> over CLIF to determine when loads and stores are referring to overlapping (may-alias) or the same (must-alias) data, and allow optimizations as appropriate (redundant-load elimination, store-to-load forwarding, dead-store elimination, code motion in general in LICM or lowering).</p>\n<p>It is likely we will want to build a bitset-style analysis, where we have a small, finite set of disjoint divisions of the heap, and every load or store is marked as potentially accessing one or more.</p>\n<p>For example, one could imagine a set of four bits for a Wasm frontend: accesses to any heap, accesses to any table, accesses to any global, or everything else (and explicitly not one of the above).</p>\n<p>Given these bits for every load/store, we then have a \"vector color\" of sorts, in the sense that the current instruction coloring scheme could be seen to have a color <em>per disjoint segment of world-state</em>. We don't actually necessarily want to compute these vectors of colors, but we want to be able to answer questions using them.</p>\n</blockquote>",
        "id": 281900149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652225759
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4131\">issue #4131</a>:</p>\n<blockquote>\n<p>We should build a simple <a href=\"https://en.wikipedia.org/wiki/Alias_analysis\">alias analysis</a> over CLIF to determine when loads and stores are referring to overlapping (may-alias) or the same (must-alias) data, and allow optimizations as appropriate (redundant-load elimination, store-to-load forwarding, dead-store elimination, code motion in general in LICM or lowering).</p>\n<p>It is likely we will want to build a bitset-style analysis, where we have a small, finite set of disjoint divisions of the heap, and every load or store is marked as potentially accessing one or more.</p>\n<p>For example, one could imagine a set of four bits for a Wasm frontend: accesses to any heap, accesses to any table, accesses to any global, or everything else (and explicitly not one of the above).</p>\n<p>Given these bits for every load/store, we then have a \"vector color\" of sorts, in the sense that the current instruction coloring scheme could be seen to have a color <em>per disjoint segment of world-state</em>. We don't actually necessarily want to compute these vectors of colors, but we want to be able to answer questions using them.</p>\n</blockquote>",
        "id": 281900150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652225759
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4131\">issue #4131</a>:</p>\n<blockquote>\n<p>We should build a simple <a href=\"https://en.wikipedia.org/wiki/Alias_analysis\">alias analysis</a> over CLIF to determine when loads and stores are referring to overlapping (may-alias) or the same (must-alias) data, and allow optimizations as appropriate (redundant-load elimination, store-to-load forwarding, dead-store elimination, code motion in general in LICM or lowering).</p>\n<p>It is likely we will want to build a bitset-style analysis, where we have a small, finite set of disjoint divisions of the heap, and every load or store is marked as potentially accessing one or more.</p>\n<p>For example, one could imagine a set of four bits for a Wasm frontend: accesses to any heap, accesses to any table, accesses to any global, or everything else (and explicitly not one of the above).</p>\n<p>Given these bits for every load/store, we then have a \"vector color\" of sorts, in the sense that the current instruction coloring scheme could be seen to have a color <em>per disjoint segment of world-state</em>. We don't actually necessarily want to compute these vectors of colors, but we want to be able to answer questions using them.</p>\n</blockquote>",
        "id": 283121091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653077974
    }
]