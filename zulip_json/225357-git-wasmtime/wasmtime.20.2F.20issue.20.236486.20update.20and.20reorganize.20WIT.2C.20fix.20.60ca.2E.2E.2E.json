[
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<p>Thanks, I'll look at this in detail this afternoon.</p>\n<p>To answer the first design question, yes lets please use the wit-deps binary in CI just like we did in p2-p. Please make a shell script inside <code>ci/</code> (lets say <code>./ci/wit-deps-check.sh</code>) which invokes the wit-deps CLI &amp; runs git diff in the correct directories, and call that script from a CI step that is just like the one we added to build the component adapter.</p>\n<p>It would also be nice if the shell script had (e.g. <code>./ci/wit-deps-check.sh update</code>) would modify the working tree to what should be committed for the check to pass in CI, and print that out with the error in CI so folks who don't know this tool don't stumble over it.</p>\n</blockquote>",
        "id": 362559326,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685563187
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1571001500\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>fix cargo vendor use cases</p>\n</blockquote>\n<p>Theoretically the \"verify-publish\" step in CI should be checking this by running <code>cargo package</code> on all component crates and then building them from the result. That should verify that all crates build as they'll appear on <a href=\"http://crates.io\">crates.io</a>, but given how things are probably broken currently to motivate the change in this PR my guess is that this isn't working as expected.</p>\n<p>Do you have an example crate/coment with <code>cargo vendor</code> that's not working? If so I'd like to poke around at it and see if the \"verify-publish\" step can be improved to verify this continues to work into the future.</p>\n</blockquote>",
        "id": 362578534,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685569296
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1571018442\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<p>The diff here looks good. Roman and I had a discussion on zulip for how to add the CI check for this.</p>\n<p>The component-adapter and test-programs crates would not have worked with cargo-vendor before this PR. I don't know which of those was a problem for vendoring into wasmcloud, but both of those are excluded from our verify-publish step.</p>\n</blockquote>",
        "id": 362581323,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685570344
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1571563344\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>The diff here looks good. Roman and I had a discussion on zulip for how to add the CI check for this.</p>\n<p>The component-adapter and test-programs crates would not have worked with cargo-vendor before this PR. I don't know which of those was a problem for vendoring into wasmcloud, but both of those are excluded from our verify-publish step.</p>\n</blockquote>\n<p>For the record, we're vendoring the component adapter as a bindep <a href=\"https://github.com/wasmCloud/wasmCloud/tree/8544ef854e1695381def129c68c341a5fd9940e3/tests/wasi-adapter\">https://github.com/wasmCloud/wasmCloud/tree/8544ef854e1695381def129c68c341a5fd9940e3/tests/wasi-adapter</a>, if you're interested, that's how it's built: <a href=\"https://github.com/wasmCloud/wasmCloud/blob/8544ef854e1695381def129c68c341a5fd9940e3/tests/actors/build.rs#L116-L134\">https://github.com/wasmCloud/wasmCloud/blob/8544ef854e1695381def129c68c341a5fd9940e3/tests/actors/build.rs#L116-L134</a> along with other Wasm as part of tests (so just <code>cargo test</code> from root is sufficient to run the whole test suite when using nightly, while the crate itself can be depended upon by stable Rust)</p>\n<p>The trick is that our reproducible build process happens in a sandbox with no access to non-deterministic I/O, e.g. no networking without the matching content hash specified. It looks something like this:</p>\n<ol>\n<li>All dependencies are fetched from either a package registry (e.g. <a href=\"http://crates.io\">crates.io</a>) or git repositories using hashes from <code>Cargo.lock</code> (which lets us fetch the actual contents, since we know the content hashes upfront)</li>\n<li>With all dependencies fetched a \"vendor tree\" is build, like <code>cargo vendor</code> would do (e.g. for published packages: <a href=\"https://github.com/ipetkov/crane/blob/35110cccf28823320f4fd697fcafcb5038683982/lib/downloadCargoPackage.nix#L19-L23\">https://github.com/ipetkov/crane/blob/35110cccf28823320f4fd697fcafcb5038683982/lib/downloadCargoPackage.nix#L19-L23</a> and <a href=\"https://github.com/ipetkov/crane/blob/35110cccf28823320f4fd697fcafcb5038683982/lib/vendorCargoRegistries.nix#L45-L103\">https://github.com/ipetkov/crane/blob/35110cccf28823320f4fd697fcafcb5038683982/lib/vendorCargoRegistries.nix#L45-L103</a>, there's similar logic for <code>git</code> dependencies, which we rely upon to vendor this repository)</li>\n<li>Later the actual <code>cargo build</code> step happens \"offline\", using the <code>vendor</code> directory constructed in (2.), just like it would work using plain <code>cargo vendor</code></li>\n</ol>\n</blockquote>",
        "id": 362662368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685606776
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572607462\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n<hr>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>",
        "id": 362851919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685645587
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) do not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.<br>\n</li>\n</ul>\n</blockquote>",
        "id": 362857175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685646788
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) do not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes</li>\n</ul>\n</blockquote>",
        "id": 362858308,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647026
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) do not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n</blockquote>",
        "id": 362858393,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647046
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) do not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n<p>Update 2:<br>\nHere's the \"local path\" case implementation <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212</a></p>\n</blockquote>",
        "id": 362858875,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647163
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) do not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n<p>Update 2:<br>\nHere's the \"local path\" case implementation <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212</a></p>\n<p>Update 3:<br>\nYou could try running <code>wasmtime-wit-deps</code> with <code>RUST_LOG=trace</code> to see what happens on disk</p>\n</blockquote>",
        "id": 362859665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647360
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code></p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) does not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n<p>Update 2:<br>\nHere's the \"local path\" case implementation <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212</a></p>\n<p>Update 3:<br>\nYou could try running <code>wasmtime-wit-deps</code> with <code>RUST_LOG=trace</code> to see what happens on disk</p>\n</blockquote>",
        "id": 362860271,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647505
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code>, that's also why order matters in <code>PATHS</code> (<code>crates/wasi/wit</code> is a dependency of the other two crates)</p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) does not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L69</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n<p>Update 2:<br>\nHere's the \"local path\" case implementation <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212</a></p>\n<p>Update 3:<br>\nYou could try running <code>wasmtime-wit-deps</code> with <code>RUST_LOG=trace</code> to see what happens on disk</p>\n</blockquote>",
        "id": 362860847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647632
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think it would simplify things for Wasmtime quite a bit if there could only be one set of WIT files managed here, rather than three. A large risk with multiple sets of WIT files that are all duplicates is that they can get out of sync, and there's no protection against that right now. In theory they should all be the exact same and ideally use something like symlinks but that doesn't all work out for windows/vendoring reasons.</p>\n</blockquote>\n<p>There's only one set of WIT files managed \"from external sources\" - in <code>crates/wasi/wit</code>, both component adapter and <code>reactor-tests</code> inherit from whatever is used within <code>crates/wasi/wit</code>, that's also why order matters in <code>PATHS</code> (<code>crates/wasi/wit</code> is a dependency of the other two crates)</p>\n<blockquote>\n<p>Would it be possible to update your vendoring process of the component adapter to manually copy around the WIT files or similarly? Or alternatively could the vendored artifact be the Wasmtime repository since that's what the component adapter expects to be built within the context of?</p>\n</blockquote>\n<p>That's exactly how it works in this PR, e.g. <a href=\"https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1\">https://github.com/rvolosatovs/wasmtime/blob/b22c571b911c1bbdd2d9356d72de18606d3e08ce/crates/test-programs/reactor-tests/wit/deps.toml#L1</a> this just means copy all WIT definitions from this path along with all transitive dependencies</p>\n<blockquote>\n<p>Also, as an orthogonal point, right now <code>deps.toml</code> points to <code>main.tar.gz</code> archives but I think that <code>main</code> will need to be replaced with a commit or otherwise re-vendoring the WIT files will change over time as the branches get updated.</p>\n</blockquote>\n<p>That's not the case, <code>wit-deps</code> is lazy by default, so for any dependency X, for which <code>Y = hash(X)</code>, if <code>deps.lock</code> contains <code>Y</code> as the hash of <code>X</code>, <code>wit-deps lock</code> (and corresponding <code>wit_deps::lock_path</code>) does not do anything.</p>\n<ul>\n<li>Roughly, <code>hash(X) = sha256sum(tar(filter_wit(X))</code> where <code>X</code> is a path to a dependency, e.g. <code>crates/wasi/wit/deps/io</code> and <code>filter_wit</code> filters all top-level WIT files in the directory. <code>tar</code> is deterministic.</li>\n</ul>\n<p>Update:</p>\n<ul>\n<li><code>tar</code> <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/lib.rs#L260-L278</a> - this is run on unpacked WIT package contents and <code>deps/*</code> contents all the same</li>\n<li>Hashing: <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L167\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/digest.rs#L11-L167</a> this just hashes read/write bytes (the output of <code>tar</code>)</li>\n</ul>\n<p>Update 2:<br>\nHere's the \"local path\" case implementation <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/crates/wit-deps/src/manifest.rs#L193-L212</a></p>\n<p>Update 3:<br>\nYou could try running <code>wasmtime-wit-deps</code> with <code>RUST_LOG=trace</code> to see what happens on disk</p>\n</blockquote>",
        "id": 362861894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685647872
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572687614\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<p>Ah ok this PR has changed radically since I last looked at it, I apologize for not bringing myself back up to speed before leaving a comment. I'll also admit that I have yet to investigate, learn, and understand <code>wit-deps</code> in depth. I was previously naively assuming that it worked the same way as Cargo, or that it was intended to work similarly to Cargo. There's a few things I want to comment about though:</p>\n<ul>\n<li>In a vacuum I don't think there's any reason to have multiple copies of WIT files in-tree. The previous build where relative paths are used works out for this repository's build. The crates in this repository using relative paths are not intended to be repackaged/re-vendored elsewhere. Your build process tries to use <code>cargo vendor</code> and what I'm asking is whether it's possible to update your build process to not do that. Can you use Wasmtime as a git checkout or something similar which allows building the crates as-is in-tree? Otherwise while the <code>preview = \"..\"</code> directive in <code>deps.toml</code> does solve the duplication issue I mentioned above that, to me at least, seems like a questionable design decision for <code>wit-deps</code> as a tool. I'll say again though that I don't fully understand the motivations of <code>wit-deps</code> beyond \"it should be like Cargo\" and I am also not following the development of it closely. That being said a blind \"include that other file here\" (as I'm interpreting what <code>preview = \"...\"</code> means) is not supported by Cargo and I'm not sure why would necessarily want to be supported long-term with <code>wit-deps</code>.</li>\n<li>Along the lines of \"I think <code>wit-deps</code> is like Cargo\" the lock file format here does not work. The purpose of Cargo is that given a manifest and a lock file it can redownload and recover all artifacts to be able to build locally. Instead, however, this lock file is instead only recording the hash of what's vendored locally, which if that's the case I don't know why a lock file is used because there's not much need to hash what's already in the repository. Using <code>main.tar.gz</code> there's no reliable way for anyone else to reproduce the vendoring process which is what <code>Cargo.lock</code> is used for. I understand that <code>wit-deps</code> could probably be smart enough to not update things if not requested, but that to me seems like a subtle anti-pattern in the design of <code>wit-deps</code> where it's not as robust as it otherwise could be in terms of vendoring dependencies. This is why I dont' think <code>main.tar.gz</code> is used because in my mind the vendored state should be reproducible at any time by anyone.</li>\n<li>Personally I don't understand why there's a new tool, much less and entire new workspace, being added to Wasmtime. If <code>wit-deps</code> is a CLI tool then it seems like we should run that CLI tool. Pat and I talked a bit this morning about this and one concern was that local developers may not have the same version as <code>wit-deps</code> used in CI, but we already have that \"problem\" with <code>cargo vet</code> and it generally works out fine. Basically CI and local developers track the latest version of <code>wit-deps</code> and if you get a newer version in CI when updating WIT files you'd update the CI version at the same time.</li>\n</ul>\n<p>Orthogonally from my above comments, why are <code>crates/wasi/wit/{cli,clocks,filesystem}</code> added in this PR? Are they an aritfact of an intermediate state which weren't removed? I don't believe they're read by <code>wit-parser</code> and otherwise they aren't sharing bits with the copies under <code>deps/{cli,clocks,filesystem}</code>.</p>\n<p>Additionally the world <code>command</code>, <code>command-extended</code>, <code>proxy</code>, and <code>reactor</code> I see are added as top-level \"local\" files in <code>crates/wasi/wit/*.wit</code>. Are these not present in any other upstream WASI repository? If not could they be added to the <code>wasi:cli</code> and <code>wasi:http</code> repositories respectively and referred-to from there?</p>\n</blockquote>",
        "id": 362867332,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685649439
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1573206638\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>In a vacuum I don't think there's any reason to have multiple copies of WIT files in-tree. The previous build where relative paths are used works out for this repository's build. The crates in this repository using relative paths are not intended to be repackaged/re-vendored elsewhere. Your build process tries to use <code>cargo vendor</code> and what I'm asking is whether it's possible to update your build process to not do that. Can you use Wasmtime as a git checkout or something similar which allows building the crates as-is in-tree? Otherwise while the <code>preview = \"..\"</code> directive in <code>deps.toml</code> does solve the duplication issue I mentioned above that, to me at least, seems like a questionable design decision for <code>wit-deps</code> as a tool. I'll say again though that I don't fully understand the motivations of <code>wit-deps</code> beyond \"it should be like Cargo\" and I am also not following the development of it closely. That being said a blind \"include that other file here\" (as I'm interpreting what <code>preview = \"...\"</code> means) is not supported by Cargo and I'm not sure why would necessarily want to be supported long-term with <code>wit-deps</code>.</li>\n</ul>\n</blockquote>\n<p>How is this any different from <code>cargo</code> path dependencies as documented here: <a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies\">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies</a> ? Sure I wish copying WIT files would not be necessary, but the reason it behaves this way is the fact that <code>wit-bindgen</code> requires all dependencies to be located in <code>deps</code> directory, which I would rather call a questionable design decision of <code>wit-bindgen</code>.<br>\nUsage of path dependencies (in <code>wit-deps</code>, but similarly in <code>cargo</code>) is generally discouraged and the use case is mostly just development, quickly replacing a dependency by a local, modified, copy.<br>\nIdeally, all WIT packages should specify their \"real\" dependencies with an external source. (e.g. the standard repositories) I'd be happy to do that, but 2 things are blocking that:</p>\n<ol>\n<li>Wasmtime does not use upstream WIT interfaces (filesystem, most importantly - clocks and cli are \"transitively broken\" due to different filesystem package used)</li>\n<li>There's no standard repository containing the <code>command</code>, <code>reactor</code> from what I can see</li>\n</ol>\n<blockquote>\n<ul>\n<li>Along the lines of \"I think <code>wit-deps</code> is like Cargo\" the lock file format here does not work. The purpose of Cargo is that given a manifest and a lock file it can redownload and recover all artifacts to be able to build locally. Instead, however, this lock file is instead only recording the hash of what's vendored locally, which if that's the case I don't know why a lock file is used because there's not much need to hash what's already in the repository. Using <code>main.tar.gz</code> there's no reliable way for anyone else to reproduce the vendoring process which is what <code>Cargo.lock</code> is used for.</li>\n</ul>\n</blockquote>\n<p>That's not true, for any given gzipped tarball URL X: <code>hash(untar(fetch(X)))</code> will give you the exact same hash as I described in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483</a>, see also that comment for <code>hash</code> definition. The reasoning here is simple, <code>X</code> could be a URL to a <code>zip</code> file or whatever else, still the hash in the lock would be the same and the integrity/equality of the contents could be verified. The lock file provides enough data precisely to be able to reproduce previous operation. </p>\n<p>Note again, that soon it should not to use <code>tar</code>, but rather it will be able to consume dependencies as Wasm <a href=\"https://github.com/bytecodealliance/wit-deps/issues/25\">https://github.com/bytecodealliance/wit-deps/issues/25</a>, at which point the Wasm is also what'd be hashed - but that again depends on <code>wit-bindgen</code> being able to actually consume dependencies as Wasm and not require raw WIT.</p>\n<p>Note, that this tool was built originally as a temporary solution to address unmaintainable mess of copy-pasting WIT files around from external sources. Soon, downstream users of WIT interfaces will not need to actually use WIT directly, so it'll only be WIT interface developers, who will need some kind of <code>wit</code> management tool.</p>\n<blockquote>\n<p>I understand that <code>wit-deps</code> could probably be smart enough to not update things if not requested, but that to me seems like a subtle anti-pattern in the design of <code>wit-deps</code> where it's not as robust as it otherwise could be in terms of vendoring dependencies. This is why I dont' think <code>main.tar.gz</code> is used because in my mind the vendored state should be reproducible at any time by anyone.</p>\n</blockquote>\n<p>It's true that in the absence of an entry in local cache, <code>main</code> branch references and similar cannot be reproduced if they change. The only way around that would be implementing <code>git</code> support directly in <code>wit-deps</code> to record the rev that <code>main</code> pointed to at the time. I went with the quickest and simplest solution for MVP, just so that, again, downstream users of WIT packages, standard or not, could reasonably consume them without resorting to adding multiple submodules/subtrees/copy-pasting. The intended use case is indeed to pin to exact commits like so <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2</a>, in which case all of this is fully reproducible. I've only added the <code>update</code> functionality and examples with \"dynamic\" branch references after the first usage here <a href=\"https://github.com/WebAssembly/wasi-http/pull/23\">https://github.com/WebAssembly/wasi-http/pull/23</a>, when I realized there's a need downstream to be able to \"simply\" pull in changes.</p>\n<p>Note that <code>wit-bindgen</code>, again, cannot consume WIT standard repositories as-is, because of the <code>wit</code> directory within those repositories, which means that simply adding a submodule to a repository in <code>wit/deps/pkg</code> is not possible. Again, I'd say that's a <code>wit-bindgen</code> design drawback, which <code>wit-deps</code>, again, addresses to eliminate this headache from downstream developers consuming real WIT packages.</p>\n<blockquote>\n<ul>\n<li>Personally I don't understand why there's a new tool, much less and entire new workspace, being added to Wasmtime. If <code>wit-deps</code> is a CLI tool then it seems like we should run that CLI tool. Pat and I talked a bit this morning about this and one concern was that local developers may not have the same version as <code>wit-deps</code> used in CI, but we already have that \"problem\" with <code>cargo vet</code> and it generally works out fine. Basically CI and local developers track the latest version of <code>wit-deps</code> and if you get a newer version in CI when updating WIT files you'd update the CI version at the same time.</li>\n</ul>\n</blockquote>\n<p>The new workspace is only there due to <code>cargo vet</code> auditing, please see OP, I'm happy to drop <a href=\"https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce\">https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce</a> if someone could certify all the dependencies used. The reason for a new tool is, in fact, simplification of the update and consistency checking process, originally @pchickey's request <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614</a> - rather than having to manually copy-paste WIT around as is done today (and prone to mistakes, note how a bunch of WIT files were missed by the update in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6390\">https://github.com/bytecodealliance/wasmtime/pull/6390</a>) there are just 1 tool with 2 subcommands with no arguments, which can automate all of this and do \"the right thing\", as well as check consistency in CI.</p>\n<p>It's <em>nice</em> to provide a working dev environment out-of-the-box. Requiring developers of Wasmtime to manually install development dependencies, to me, is an anti-pattern, that's why a Rust crate instead is very useful - it works cross-platform and developers do not need to install yet another binary executable.</p>\n<blockquote>\n<p>Orthogonally from my above comments, why are <code>crates/wasi/wit/{cli,clocks,filesystem}</code> added in this PR? Are they an aritfact of an intermediate state which weren't removed? I don't believe they're read by <code>wit-parser</code> and otherwise they aren't sharing bits with the copies under <code>deps/{cli,clocks,filesystem}</code>.</p>\n</blockquote>\n<p>Assuming that every WIT dependency must have an external source (e.g. a standard repo), <code>deps/{cli,clocks,filesystem}</code> are these sources, which should eventually be removed in favor of using upstream (see the <code>TODO</code> comment). Regarding different contents I cannot reproduce:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc0e88e8d630d7fd1bc0d29f7e13  clocks/wall-clock.wit</span>\n<span class=\"cm\">ce4e225baf21a915435f807a0bb47bc34f43227c0424156cab7c6c536a5d1755  filesystem/filesystem.wit</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"n\">deps</span><span class=\"o\">/</span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  deps/cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  deps/cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  deps/cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  deps/cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  deps/clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  deps/clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc0e88e8d630d7fd1bc0d29f</span>\n<span class=\"cm\">[message truncated]</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 362938971,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685686235
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1573206638\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>In a vacuum I don't think there's any reason to have multiple copies of WIT files in-tree. The previous build where relative paths are used works out for this repository's build. The crates in this repository using relative paths are not intended to be repackaged/re-vendored elsewhere. Your build process tries to use <code>cargo vendor</code> and what I'm asking is whether it's possible to update your build process to not do that. Can you use Wasmtime as a git checkout or something similar which allows building the crates as-is in-tree? Otherwise while the <code>preview = \"..\"</code> directive in <code>deps.toml</code> does solve the duplication issue I mentioned above that, to me at least, seems like a questionable design decision for <code>wit-deps</code> as a tool. I'll say again though that I don't fully understand the motivations of <code>wit-deps</code> beyond \"it should be like Cargo\" and I am also not following the development of it closely. That being said a blind \"include that other file here\" (as I'm interpreting what <code>preview = \"...\"</code> means) is not supported by Cargo and I'm not sure why would necessarily want to be supported long-term with <code>wit-deps</code>.</li>\n</ul>\n</blockquote>\n<p>How is this any different from <code>cargo</code> path dependencies as documented here: <a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies\">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies</a> ? Sure I wish copying WIT files would not be necessary, but the reason it behaves this way is the fact that <code>wit-bindgen</code> requires all dependencies to be located in <code>deps</code> directory, which I would rather call a questionable design decision of <code>wit-bindgen</code>.<br>\nUsage of path dependencies (in <code>wit-deps</code>, but similarly in <code>cargo</code>) is generally discouraged and the use case is mostly just development, quickly replacing a dependency by a local, modified, copy.<br>\nIdeally, all WIT packages should specify their \"real\" dependencies with an external source. (e.g. the standard repositories) I'd be happy to do that, but 2 things are blocking that:</p>\n<ol>\n<li>Wasmtime does not use upstream WIT interfaces (filesystem, most importantly - clocks and cli are \"transitively broken\" due to different filesystem package used)</li>\n<li>There's no standard repository containing the <code>command</code>, <code>reactor</code> from what I can see</li>\n</ol>\n<blockquote>\n<ul>\n<li>Along the lines of \"I think <code>wit-deps</code> is like Cargo\" the lock file format here does not work. The purpose of Cargo is that given a manifest and a lock file it can redownload and recover all artifacts to be able to build locally. Instead, however, this lock file is instead only recording the hash of what's vendored locally, which if that's the case I don't know why a lock file is used because there's not much need to hash what's already in the repository. Using <code>main.tar.gz</code> there's no reliable way for anyone else to reproduce the vendoring process which is what <code>Cargo.lock</code> is used for.</li>\n</ul>\n</blockquote>\n<p>That's not true, for any given gzipped tarball URL X: <code>hash(untar(fetch(X)))</code> will give you the exact same hash as I described in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483</a>, see also that comment for <code>hash</code> definition. The reasoning here is simple, <code>X</code> could be a URL to a <code>zip</code> file or whatever else, still the hash in the lock would be the same and the integrity/equality of the contents could be verified. The lock file provides enough data precisely to be able to reproduce previous operation. </p>\n<p>Soon it should not have to use <code>tar</code>, but rather it will be able to consume dependencies as Wasm <a href=\"https://github.com/bytecodealliance/wit-deps/issues/25\">https://github.com/bytecodealliance/wit-deps/issues/25</a>, at which point the Wasm is also what'd be hashed - but that again depends on <code>wit-bindgen</code> being able to actually consume dependencies as Wasm and not require raw WIT.</p>\n<p>Note, that this tool was built originally as a temporary solution to address unmaintainable mess of copy-pasting WIT files around from external sources. Soon, downstream users of WIT interfaces will not need to actually use WIT directly, so it'll only be WIT interface developers, who will need some kind of <code>wit</code> management tool.</p>\n<blockquote>\n<p>I understand that <code>wit-deps</code> could probably be smart enough to not update things if not requested, but that to me seems like a subtle anti-pattern in the design of <code>wit-deps</code> where it's not as robust as it otherwise could be in terms of vendoring dependencies. This is why I dont' think <code>main.tar.gz</code> is used because in my mind the vendored state should be reproducible at any time by anyone.</p>\n</blockquote>\n<p>It's true that in the absence of an entry in local cache, <code>main</code> branch references and similar cannot be reproduced if they change. The only way around that would be implementing <code>git</code> support directly in <code>wit-deps</code> to record the rev that <code>main</code> pointed to at the time. I went with the quickest and simplest solution for MVP, just so that, again, downstream users of WIT packages, standard or not, could reasonably consume them without resorting to adding multiple submodules/subtrees/copy-pasting. The intended use case is indeed to pin to exact commits like so <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2</a>, in which case all of this is fully reproducible. I've only added the <code>update</code> functionality and examples with \"dynamic\" branch references after the first usage here <a href=\"https://github.com/WebAssembly/wasi-http/pull/23\">https://github.com/WebAssembly/wasi-http/pull/23</a>, when I realized there's a need downstream to be able to \"simply\" pull in changes.</p>\n<p>Note that <code>wit-bindgen</code>, again, cannot consume WIT standard repositories as-is, because of the <code>wit</code> directory within those repositories, which means that simply adding a submodule to a repository in <code>wit/deps/pkg</code> is not possible. Again, I'd say that's a <code>wit-bindgen</code> design drawback, which <code>wit-deps</code>, again, addresses to eliminate this headache from downstream developers consuming real WIT packages.</p>\n<blockquote>\n<ul>\n<li>Personally I don't understand why there's a new tool, much less and entire new workspace, being added to Wasmtime. If <code>wit-deps</code> is a CLI tool then it seems like we should run that CLI tool. Pat and I talked a bit this morning about this and one concern was that local developers may not have the same version as <code>wit-deps</code> used in CI, but we already have that \"problem\" with <code>cargo vet</code> and it generally works out fine. Basically CI and local developers track the latest version of <code>wit-deps</code> and if you get a newer version in CI when updating WIT files you'd update the CI version at the same time.</li>\n</ul>\n</blockquote>\n<p>The new workspace is only there due to <code>cargo vet</code> auditing, please see OP, I'm happy to drop <a href=\"https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce\">https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce</a> if someone could certify all the dependencies used. The reason for a new tool is, in fact, simplification of the update and consistency checking process, originally @pchickey's request <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614</a> - rather than having to manually copy-paste WIT around as is done today (and prone to mistakes, note how a bunch of WIT files were missed by the update in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6390\">https://github.com/bytecodealliance/wasmtime/pull/6390</a>) there are just 1 tool with 2 subcommands with no arguments, which can automate all of this and do \"the right thing\", as well as check consistency in CI.</p>\n<p>It's <em>nice</em> to provide a working dev environment out-of-the-box. Requiring developers of Wasmtime to manually install development dependencies, to me, is an anti-pattern, that's why a Rust crate instead is very useful - it works cross-platform and developers do not need to install yet another binary executable.</p>\n<blockquote>\n<p>Orthogonally from my above comments, why are <code>crates/wasi/wit/{cli,clocks,filesystem}</code> added in this PR? Are they an aritfact of an intermediate state which weren't removed? I don't believe they're read by <code>wit-parser</code> and otherwise they aren't sharing bits with the copies under <code>deps/{cli,clocks,filesystem}</code>.</p>\n</blockquote>\n<p>Assuming that every WIT dependency must have an external source (e.g. a standard repo), <code>deps/{cli,clocks,filesystem}</code> are these sources, which should eventually be removed in favor of using upstream (see the <code>TODO</code> comment). Regarding different contents I cannot reproduce:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc0e88e8d630d7fd1bc0d29f7e13  clocks/wall-clock.wit</span>\n<span class=\"cm\">ce4e225baf21a915435f807a0bb47bc34f43227c0424156cab7c6c536a5d1755  filesystem/filesystem.wit</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"n\">deps</span><span class=\"o\">/</span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  deps/cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  deps/cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  deps/cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  deps/cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  deps/clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  deps/clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc0e88e8d630d7fd1bc0d29f7e13</span>\n<span class=\"cm\">[message truncated]</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 362939220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685686325
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1573206638\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>In a vacuum I don't think there's any reason to have multiple copies of WIT files in-tree. The previous build where relative paths are used works out for this repository's build. The crates in this repository using relative paths are not intended to be repackaged/re-vendored elsewhere. Your build process tries to use <code>cargo vendor</code> and what I'm asking is whether it's possible to update your build process to not do that. Can you use Wasmtime as a git checkout or something similar which allows building the crates as-is in-tree? Otherwise while the <code>preview = \"..\"</code> directive in <code>deps.toml</code> does solve the duplication issue I mentioned above that, to me at least, seems like a questionable design decision for <code>wit-deps</code> as a tool. I'll say again though that I don't fully understand the motivations of <code>wit-deps</code> beyond \"it should be like Cargo\" and I am also not following the development of it closely. That being said a blind \"include that other file here\" (as I'm interpreting what <code>preview = \"...\"</code> means) is not supported by Cargo and I'm not sure why would necessarily want to be supported long-term with <code>wit-deps</code>.</li>\n</ul>\n</blockquote>\n<p>How is this any different from <code>cargo</code> path dependencies as documented here: <a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies\">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies</a> ? Sure I wish copying WIT files would not be necessary, but the reason it behaves this way is the fact that <code>wit-bindgen</code> requires all dependencies to be located in <code>deps</code> directory, which I would rather call a questionable design decision of <code>wit-bindgen</code>.<br>\nUsage of path dependencies (in <code>wit-deps</code>, but similarly in <code>cargo</code>) is generally discouraged and the use case is mostly just development, quickly replacing a dependency by a local, modified, copy.<br>\nIdeally, all WIT packages should specify their \"real\" dependencies with an external source. (e.g. the standard repositories) I'd be happy to do that, but 2 things are blocking that:</p>\n<ol>\n<li>Wasmtime does not use upstream WIT interfaces (filesystem, most importantly - clocks and cli are \"transitively broken\" due to different filesystem package used)</li>\n<li>There's no standard repository containing the <code>command</code>, <code>reactor</code> from what I can see</li>\n</ol>\n<blockquote>\n<ul>\n<li>Along the lines of \"I think <code>wit-deps</code> is like Cargo\" the lock file format here does not work. The purpose of Cargo is that given a manifest and a lock file it can redownload and recover all artifacts to be able to build locally. Instead, however, this lock file is instead only recording the hash of what's vendored locally, which if that's the case I don't know why a lock file is used because there's not much need to hash what's already in the repository. Using <code>main.tar.gz</code> there's no reliable way for anyone else to reproduce the vendoring process which is what <code>Cargo.lock</code> is used for.</li>\n</ul>\n</blockquote>\n<p>That's not true, for any given gzipped tarball URL X: <code>hash(untar(fetch(X)))</code> will give you the exact same hash as I described in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1572635483</a>, see also that comment for <code>hash</code> definition. The reasoning here is simple, <code>X</code> could be a URL to a <code>zip</code> file or whatever else, still the hash in the lock would be the same and the integrity/equality of the contents could be verified. The lock file provides enough data precisely to be able to reproduce previous operation. </p>\n<p>Soon it should not have to use <code>tar</code>, but rather it will be able to consume dependencies as Wasm <a href=\"https://github.com/bytecodealliance/wit-deps/issues/25\">https://github.com/bytecodealliance/wit-deps/issues/25</a>, at which point the Wasm is also what'd be hashed - but that again depends on <code>wit-bindgen</code> being able to actually consume dependencies as Wasm and not require raw WIT.</p>\n<p>Note, that this tool was built originally as a temporary solution to address unmaintainable mess of copy-pasting WIT files around from external sources. Soon, downstream users of WIT interfaces will not need to actually use WIT directly, so it'll only be WIT interface developers, who will need some kind of <code>wit</code> management tool.</p>\n<blockquote>\n<p>I understand that <code>wit-deps</code> could probably be smart enough to not update things if not requested, but that to me seems like a subtle anti-pattern in the design of <code>wit-deps</code> where it's not as robust as it otherwise could be in terms of vendoring dependencies. This is why I dont' think <code>main.tar.gz</code> is used because in my mind the vendored state should be reproducible at any time by anyone.</p>\n</blockquote>\n<p>It's true that in the absence of an entry in local cache, <code>main</code> branch references and similar cannot be reproduced if they change. The only way around that would be implementing <code>git</code> support directly in <code>wit-deps</code> to record the rev that <code>main</code> pointed to at the time. I went with the quickest and simplest solution for MVP, just so that, again, downstream users of WIT packages, standard or not, could reasonably consume them without resorting to adding multiple submodules/subtrees/copy-pasting. The intended use case is indeed to pin to exact commits like so <a href=\"https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2\">https://github.com/bytecodealliance/wit-deps/blob/b4314067818a45413fc6c366983f19a80b2626fa/tests/build/wit/deps.toml#L1-L2</a>, in which case all of this is fully reproducible. I've only added the <code>update</code> functionality and examples with \"dynamic\" branch references after the first usage here <a href=\"https://github.com/WebAssembly/wasi-http/pull/23\">https://github.com/WebAssembly/wasi-http/pull/23</a>, when I realized there's a need downstream to be able to \"simply\" pull in changes.</p>\n<p>Note that <code>wit-bindgen</code>, again, cannot consume WIT standard repositories as-is, because of the <code>wit</code> directory within those repositories, which means that simply adding a submodule to a repository in <code>wit/deps/pkg</code> is not possible. Again, I'd say that's a <code>wit-bindgen</code> design drawback, which <code>wit-deps</code>, again, addresses to eliminate this headache from downstream developers consuming real WIT packages.</p>\n<blockquote>\n<ul>\n<li>Personally I don't understand why there's a new tool, much less and entire new workspace, being added to Wasmtime. If <code>wit-deps</code> is a CLI tool then it seems like we should run that CLI tool. Pat and I talked a bit this morning about this and one concern was that local developers may not have the same version as <code>wit-deps</code> used in CI, but we already have that \"problem\" with <code>cargo vet</code> and it generally works out fine. Basically CI and local developers track the latest version of <code>wit-deps</code> and if you get a newer version in CI when updating WIT files you'd update the CI version at the same time.</li>\n</ul>\n</blockquote>\n<p>The new workspace is only there due to <code>cargo vet</code> auditing, please see OP, I'm happy to drop <a href=\"https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce\">https://github.com/bytecodealliance/wasmtime/commit/b22c571b911c1bbdd2d9356d72de18606d3e08ce</a> if someone could certify all the dependencies used. The reason for a new tool is, in fact, simplification of the update and consistency checking process, originally @pchickey's request <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614\">https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1570860614</a> - rather than having to manually copy-paste WIT around as is done today (and prone to mistakes, note how a bunch of WIT files were missed by the update in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6390\">https://github.com/bytecodealliance/wasmtime/pull/6390</a>) there is now just one tool with 2 subcommands, which take no arguments and can automate all of this tedious procedure and do \"the right thing\", as well as check consistency in CI.</p>\n<p>It's <em>nice</em> to provide a working dev environment out-of-the-box. Requiring developers of Wasmtime to manually install development dependencies, to me, is an anti-pattern, that's why a Rust crate instead is very useful - it works cross-platform and developers do not need to install yet another binary executable.</p>\n<blockquote>\n<p>Orthogonally from my above comments, why are <code>crates/wasi/wit/{cli,clocks,filesystem}</code> added in this PR? Are they an aritfact of an intermediate state which weren't removed? I don't believe they're read by <code>wit-parser</code> and otherwise they aren't sharing bits with the copies under <code>deps/{cli,clocks,filesystem}</code>.</p>\n</blockquote>\n<p>Assuming that every WIT dependency must have an external source (e.g. a standard repo), <code>deps/{cli,clocks,filesystem}</code> are these sources, which should eventually be removed in favor of using upstream (see the <code>TODO</code> comment). Regarding different contents I cannot reproduce:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc0e88e8d630d7fd1bc0d29f7e13  clocks/wall-clock.wit</span>\n<span class=\"cm\">ce4e225baf21a915435f807a0bb47bc34f43227c0424156cab7c6c536a5d1755  filesystem/filesystem.wit</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">rvolosatovs</span><span class=\"o\">@</span><span class=\"n\">cobalt</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"n\">ecodealliance</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"o\">/</span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">git</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">[</span><span class=\"n\">fix</span><span class=\"o\">/</span><span class=\"n\">cargo</span><span class=\"o\">-</span><span class=\"n\">vendor</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">dep</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"w\"> </span><span class=\"n\">clocks</span><span class=\"w\"> </span><span class=\"n\">filesystem</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">sha256sum</span><span class=\"w\"> </span><span class=\"n\">deps</span><span class=\"o\">/</span><span class=\"cp\">$dep</span><span class=\"cm\">/*; done</span>\n<span class=\"cm\">99f45bfa45638e87bcb8e1c7b8fad65c2ac60fd70500fa447268371a0d87ed10  deps/cli/environment.wit</span>\n<span class=\"cm\">a917b0e0381f0cb3f86e9c88c0fc84b46388595cf4858f02de2d597caee82e31  deps/cli/exit.wit</span>\n<span class=\"cm\">2c60a8c95149393ac3698eb766da44c3e570dfca38646256c888ecb34f9717ab  deps/cli/preopens.wit</span>\n<span class=\"cm\">57f8549af0058bf1bf58eccb9820715a907b2c17825e8eb7213ab647381935be  deps/cli/stdio.wit</span>\n<span class=\"cm\">f0418770f24f7130d2eaf5f43316edc145ec4a524e77f02ace7db6171dcd8c76  deps/clocks/monotonic-clock.wit</span>\n<span class=\"cm\">caf183ddda4bb6693f0cc9d3249e42a58a21091ff1764e92f652dfc8a1bbff6c  deps/clocks/timezone.wit</span>\n<span class=\"cm\">44e062d552753f939b4dec8ce87b499ba46fdc</span>\n<span class=\"cm\">[message truncated]</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 362939564,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1685686449
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486#issuecomment-1592856731\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6486\">issue #6486</a>:</p>\n<blockquote>\n<p>I've removed all dependency updates and any reorganization from this PR, it's just fixing the <code>cargo vendor</code> use case for downstream crates. I really hope we can align on getting this fix over the line</p>\n</blockquote>",
        "id": 366459434,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686827963
    }
]