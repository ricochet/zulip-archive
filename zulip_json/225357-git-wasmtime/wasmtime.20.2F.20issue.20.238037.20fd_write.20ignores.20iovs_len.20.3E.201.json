[
    {
        "content": "<p><a href=\"https://github.com/ThisGuyCodes\">ThisGuyCodes</a> added the bug label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">Issue #8037</a>.</p>",
        "id": 424282954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709310818
    },
    {
        "content": "<p>ThisGuyCodes opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>Am I crazy? I thought I might be misunderstanding something, but then I found someone else's example online that also doesn't work.</p>\n<h3>Test Case</h3>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"c1\">;; hello.wat</span>\n<span class=\"p\">(</span><span class=\"k\">module</span>\n    <span class=\"c1\">;; define the expected type for fd_write</span>\n    <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$write_type</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">param</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"kt\">i32</span><span class=\"p\">)))</span>\n    <span class=\"p\">(</span><span class=\"k\">import</span> <span class=\"s2\">\"wasi_snapshot_preview1\"</span> <span class=\"s2\">\"fd_write\"</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"nv\">$write</span> <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$write_type</span><span class=\"p\">)))</span>\n\n    <span class=\"c1\">;; Define a memory that is one page in size (64KiB).</span>\n    <span class=\"p\">(</span><span class=\"k\">memory</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"memory\"</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">;; At offset 66 and 80 in the memory, we store the data.</span>\n    <span class=\"p\">(</span><span class=\"k\">data</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">66</span><span class=\"p\">)</span> <span class=\"s2\">\"Hello, World!</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">data</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">80</span><span class=\"p\">)</span> <span class=\"s2\">\"Howdy!</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n\n    <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"nv\">$main</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"_start\"</span><span class=\"p\">)</span>\n        <span class=\"c1\">;; Store the iovs</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">66</span><span class=\"p\">))</span> <span class=\"c1\">;; Start of data (= *buf)</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">14</span><span class=\"p\">))</span> <span class=\"c1\">;; Length of data (= buf_len)</span>\n\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">8</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">80</span><span class=\"p\">))</span> <span class=\"c1\">;; Start of data (= *buf)</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">12</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">8</span><span class=\"p\">))</span> <span class=\"c1\">;; Length of data (= buf_len)</span>\n\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">1</span> <span class=\"c1\">;; fd param. In Unix this means: 0 = stdin, 1 = stdout, 2 = stderr</span>\n\n        <span class=\"c1\">;; here are different combinations possible:</span>\n        <span class=\"c1\">;; 0,1 would read only \"Hello, World!\"</span>\n        <span class=\"c1\">;; 8,1 would read only 'Howdy'</span>\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">0</span> <span class=\"c1\">;; iovs -&gt; Offset. Points to first iovec</span>\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">2</span> <span class=\"c1\">;; iovs_len -&gt; How many iovs should be read, set it to 2 to read also Howdy</span>\n\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">92</span> <span class=\"c1\">;; Pointer to the place in memory where the number of written bytes shall be placed.</span>\n\n        <span class=\"nb\">call</span> <span class=\"nv\">$write</span> <span class=\"c1\">;; call fd_write and drop the result code</span>\n        <span class=\"nb\">drop</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<h3>Steps to Reproduce</h3>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>wasmtime<span class=\"w\"> </span>hello.wat\n</code></pre></div>\n<h3>Expected Results</h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Hello</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">World</span><span class=\"o\">!</span>\n<span class=\"n\">Howdy</span><span class=\"o\">!</span>\n</code></pre></div>\n<h3>Actual Results</h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Hello</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">World</span><span class=\"o\">!</span>\n</code></pre></div>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: <code>wasmtime-cli 18.0.2 (90db6e99f 2024-02-28)</code></p>\n<p>Operating system: MacOS 14.3.1</p>\n<p>Architecture: arm64 (M1 Pro)</p>\n<h3>Extra Info</h3>\n<p>Anything else you'd like to add?<br>\n</p>\n</blockquote>",
        "id": 424282963,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709310819
    },
    {
        "content": "<p>ThisGuyCodes edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>Am I crazy? I thought I might be misunderstanding something, but then I found someone else's example online that also doesn't work.</p>\n<h3>Test Case</h3>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"c1\">;; hello.wat</span>\n<span class=\"p\">(</span><span class=\"k\">module</span>\n    <span class=\"c1\">;; define the expected type for fd_write</span>\n    <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$write_type</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">param</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"kt\">i32</span><span class=\"p\">)))</span>\n    <span class=\"p\">(</span><span class=\"k\">import</span> <span class=\"s2\">\"wasi_snapshot_preview1\"</span> <span class=\"s2\">\"fd_write\"</span> <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"nv\">$write</span> <span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"nv\">$write_type</span><span class=\"p\">)))</span>\n\n    <span class=\"c1\">;; Define a memory that is one page in size (64KiB).</span>\n    <span class=\"p\">(</span><span class=\"k\">memory</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"memory\"</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">;; At offset 66 and 80 in the memory, we store the data.</span>\n    <span class=\"p\">(</span><span class=\"k\">data</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">66</span><span class=\"p\">)</span> <span class=\"s2\">\"Hello, World!</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">data</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">80</span><span class=\"p\">)</span> <span class=\"s2\">\"Howdy!</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n\n    <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"nv\">$main</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"_start\"</span><span class=\"p\">)</span>\n        <span class=\"c1\">;; Store the iovs</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">66</span><span class=\"p\">))</span> <span class=\"c1\">;; Start of data (= *buf)</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">14</span><span class=\"p\">))</span> <span class=\"c1\">;; Length of data (= buf_len)</span>\n\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">8</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">80</span><span class=\"p\">))</span> <span class=\"c1\">;; Start of data (= *buf)</span>\n        <span class=\"p\">(</span><span class=\"nb\">i32.store</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">12</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">8</span><span class=\"p\">))</span> <span class=\"c1\">;; Length of data (= buf_len)</span>\n\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">1</span> <span class=\"c1\">;; fd param. In Unix this means: 0 = stdin, 1 = stdout, 2 = stderr</span>\n\n        <span class=\"c1\">;; here are different combinations possible:</span>\n        <span class=\"c1\">;; 0,1 would read only \"Hello, World!\"</span>\n        <span class=\"c1\">;; 8,1 would read only 'Howdy'</span>\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">0</span> <span class=\"c1\">;; iovs -&gt; Offset. Points to first iovec</span>\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">2</span> <span class=\"c1\">;; iovs_len -&gt; How many iovs should be read, set it to 2 to read also Howdy</span>\n\n        <span class=\"nb\">i32.const</span> <span class=\"mi\">92</span> <span class=\"c1\">;; Pointer to the place in memory where the number of written bytes shall be placed.</span>\n\n        <span class=\"nb\">call</span> <span class=\"nv\">$write</span> <span class=\"c1\">;; call fd_write and drop the result code</span>\n        <span class=\"nb\">drop</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<h3>Steps to Reproduce</h3>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>wasmtime<span class=\"w\"> </span>hello.wat\n</code></pre></div>\n<h3>Expected Results</h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Hello</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">World</span><span class=\"o\">!</span>\n<span class=\"n\">Howdy</span><span class=\"o\">!</span>\n</code></pre></div>\n<h3>Actual Results</h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Hello</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">World</span><span class=\"o\">!</span>\n</code></pre></div>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: <code>wasmtime-cli 18.0.2 (90db6e99f 2024-02-28)</code></p>\n<p>Operating system: MacOS 14.3.1</p>\n<p>Architecture: arm64 (M1 Pro)<br>\n</p>\n</blockquote>",
        "id": 424282983,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709310827
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973512565\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>The wasi-preview1 support in wasmtime is since recently layered on top of wasi 0.2, which doesn't have support for vectored reads and writes. To avoid breaking the atomicity guarantee of readv and writev (all parts that have been read/written have been done so atomically), the current implementation of fd_read and fd_write only look at the first iovec and ignore the rest. This is an entirely valid implementation. reads and writes in both unix and wasi are allowed to only partially happen. The OS/wasi runtime just has to return the exact amount of bytes that was read/written. The program can then try writing the rest.</p>\n<p>By the way this is a duplicate of <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7757\">https://github.com/bytecodealliance/wasmtime/issues/7757</a>.</p>\n</blockquote>",
        "id": 424284324,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311137
    },
    {
        "content": "<p>ThisGuyCodes <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973532650\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>@bjorn3 is it required that <a href=\"https://github.com/bytecodealliance/wasmtime/blob/57ecb4c584c3339b7e2d62d28592cb13544cb393/crates/wasi-preview1-component-adapter/src/lib.rs#L1415-L1483\"><code>fd_write</code></a> not perform any internal allocations? While it seems the current implementation is _technically_ correct I wonder if the atomicity guarantee could be maintained while still supporting vectored writes.</p>\n<p>I have difficulty believing that any implementation calling this with a vector would prefer to loop. And if they did they could optimize to do a no-alloc version with one write at a time themselves.</p>\n</blockquote>",
        "id": 424286989,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311870
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973537938\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>If you are using a vectored write that is likely because you want to avoid having to copy the data to a new allocation before calling the write, right?</p>\n</blockquote>",
        "id": 424287667,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709312055
    },
    {
        "content": "<p>ThisGuyCodes <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973648231\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>I suppose that makes sense. And if wasi 0.2 doesn't allow it anyway less and less implementations are going to target using vectored writes anyway. </p>\n</blockquote>",
        "id": 424299959,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709316129
    },
    {
        "content": "<p>ThisGuyCodes edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973648231\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037\">issue #8037</a>:</p>\n<blockquote>\n<p>I suppose that makes sense. And if wasi 0.2 doesn't allow it anyway less and less implementations are going to target using vectored writes over time. </p>\n</blockquote>",
        "id": 424299984,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709316139
    }
]