[
    {
        "content": "<p>KennanHunter opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9188\">issue #9188</a>:</p>\n<blockquote>\n<p>I'm still new to this codebase and may not have a perfect understanding or description of how the engine handles imported functions or epoch canceling. Any feedback is appreciated.</p>\n<h4>Improvement</h4>\n<p>As it stands, epoch cancellation is checked in two spots, when entering a Wasm function, and at the top of Wasm loops. This falls flat when using imported functions such as from WASI as if the epoch is incremented while inside said function, the program will only trap when the function is completed. My request is to find some way for these imported functions to respond to epoch updates.</p>\n<h4>Benefit</h4>\n<p>It is important for Wasmtime consumers to be able to define some form of timeout, especially when executing untrusted code. One example where the current epoch timer system fails to clean up code on time is in the following C code.</p>\n<p>I compiled this with <code>/opt/wasi-sdk/bin/clang ./main.c -o app.wasm --target=wasm32-wasip2 -v</code> on WASI-SDK version <code>24.0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdio.h&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;time.h&gt;</span>\n\n<span class=\"cp\">#define TIMER_RELATIVE_FLAG 0</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">timespec</span><span class=\"w\"> </span><span class=\"n\">deadline</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">deadline</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"C code set to sleep for %lld s</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">deadline</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"n\">clock_nanosleep</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">TIMER_RELATIVE_FLAG</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">deadline</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">NULL</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Sleep completed</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The epoch timer is checked at the beginning of the <code>clock_nanosleep</code> function and the beginning of the <code>printf</code>, but the <code>clock_nanosleep</code> function blocks the VM for the full 10-second runtime, even if the epoch timeout is reached in the middle of its evaluation.</p>\n<h4>Implementation</h4>\n<p>As more of a band-aid solution, is it possible to change the WASI function implementations themselves to be cancelable? This particular example relies upon the WASI-IO poll function, which itself utilizes Tokio futures. Tokio has several ways to, if not cancel, at least return early and discard the result, such as <code>tokio::timeout</code>.</p>\n<p>Is there a way to change the implementation of epoch-interruption to be more robust, in the sense that it could cause a trap outside of a specific location in the Wasm code?</p>\n<h4>Alternatives</h4>\n<p>While there are other methods, such as the fuel system, to cancel code execution, there isn't a robust way to ensure the engine kills a program after a certain amount of time.<br>\n</p>\n</blockquote>",
        "id": 466140248,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1724982139
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9188#issuecomment-2321531232\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9188\">issue #9188</a>:</p>\n<blockquote>\n<p>Thanks for the report! This is a good reminder to me at least that our documentation of these configuration options doesn't cover this case so I'll look to expand that. Otherwise though it's intentional that epochs/fuel only work at the wasm-is-running level. Interruption/timeout of host code is left to the embedder and is not a feature provided by Wasmtime (as we can't cancel arbitrary code in Rust). </p>\n<p>The primary way to cancel host code is to use <code>async</code> for host imports which may block for a long period of time. That means that a suspended computation blocked on something is \"just\" a future which can be dropped at any time to cancel it. This is the solution pursued by <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9184\">https://github.com/bytecodealliance/wasmtime/pull/9184</a> which switch the CLI to using async for host imports instead of sync and when coupled with <code>tokio::time::timeout</code> has the desired semantics of cancelling the computation even if it's sleeping. Other embedders will need to be sure they're using <code>async</code> imports and not actually blocking the host thread for similar behavior.</p>\n<p>Were you interested in primarily the CLI for this issue? Or for other embeddings as well? It's a known issue, for example, that async isn't easily usable in other-language embeddings through the C API (technically possible, but not fully realized in all bindings yet)</p>\n</blockquote>",
        "id": 466287353,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1725029973
    }
]