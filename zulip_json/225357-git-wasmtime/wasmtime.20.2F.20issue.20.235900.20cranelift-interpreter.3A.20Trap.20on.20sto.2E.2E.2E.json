[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>readonly</code> flag, and always trap if there is a write to it.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>Loads with this flag have no memory dependencies. This results in undefined behavior if the dereferenced memory is mutated at any time between when the function is called and when it is exited.</p>\n</blockquote>\n<p>There is a world where we keep track of these flags (in both loads and stores) and can trap at any time a store to a previously <code>readonly</code>'d memory location. But this is a good start.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L330-L335\"><code>State::checked_store</code></a> check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.readonly\">readonly</a> flag set and return a <code>MemoryError</code> if so.</p>\n</li>\n<li>\n<p>We can't build the usual tests for this. </p>\n<ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The current implementation is fine, and we should technically never see a store with a <code>readonly</code> flag.</p>\n</blockquote>",
        "id": 338804141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668747
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>readonly</code> flag, and always trap if there is a write to it.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>Loads with this flag have no memory dependencies. This results in undefined behavior if the dereferenced memory is mutated at any time between when the function is called and when it is exited.</p>\n</blockquote>\n<p>There is a world where we keep track of these flags (in both loads and stores) and can trap at any time a store to a previously <code>readonly</code>'d memory location. But this is a good start.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L330-L335\"><code>State::checked_store</code></a> check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.readonly\">readonly</a> flag set and return a <code>MemoryError</code> if so.</p>\n</li>\n<li>\n<p>We can't build the usual tests for this. </p>\n<ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The current implementation is fine, and we should technically never see a store with a <code>readonly</code> flag.</p>\n</blockquote>",
        "id": 338804142,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668747
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>readonly</code> flag, and always trap if there is a write to it.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>Loads with this flag have no memory dependencies. This results in undefined behavior if the dereferenced memory is mutated at any time between when the function is called and when it is exited.</p>\n</blockquote>\n<p>There is a world where we keep track of these flags (in both loads and stores) and can trap at any time a store to a previously <code>readonly</code>'d memory location. But this is a good start.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L330-L335\"><code>State::checked_store</code></a> check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.readonly\">readonly</a> flag set and return a <code>MemoryError</code> if so.</p>\n</li>\n<li>\n<p>We can't build the usual tests for this. </p>\n<ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The current implementation is fine, and we should technically never see a store with a <code>readonly</code> flag.</p>\n</blockquote>",
        "id": 338804144,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668747
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>readonly</code> flag, and always trap if there is a write to it.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>Loads with this flag have no memory dependencies. This results in undefined behavior if the dereferenced memory is mutated at any time between when the function is called and when it is exited.</p>\n</blockquote>\n<p>There is a world where we keep track of these flags (in both loads and stores) and can trap at any time a store to a previously <code>readonly</code>'d memory location. But this is a good start.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L330-L335\"><code>State::checked_store</code></a> check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.readonly\">readonly</a> flag set and return a <code>MemoryError</code> if so.</p>\n</li>\n<li>\n<p>We can't build the usual tests for this. </p>\n<ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The current implementation is fine, and we should technically never see a store with a <code>readonly</code> flag.</p>\n</blockquote>",
        "id": 338804145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668747
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1449975837\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Maybe disallow the readonly flag on stores in the clif ir verifier instead of the interpreter? Checking at runtime that no stores to readonly memory happen can't be done in the verifier, but checking that the readonly flag isn't set for stores can easily be checked in the verifier. I can't imagine any case why you would intentionally want the readonly flag on a store. It did unconditionally be UB, so you might as well insert the trap instruction instead.</p>\n</blockquote>",
        "id": 338812856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677670971
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1450053834\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>I think we had a similar situation <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167#issuecomment-1300917768\">here</a> and I think a similar reasoning might apply? We can optimize other <code>loads</code>/<code>stores</code> such that we now statically know this memory region is <code>readonly</code> and thus we are now in the same situation where we get invalid CLIF by optimizing valid CLIF.</p>\n</blockquote>",
        "id": 338821280,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677673074
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1450053834\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>I think we had a similar situation <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167#issuecomment-1300917768\">here</a> and I think a similar reasoning might apply? We can optimize other <code>loads</code>/<code>stores</code> such that we now statically know this memory region is <code>readonly</code> and thus we are now in the same situation where we get invalid CLIF by optimizing valid CLIF.</p>\n<p>Edit: Although replacing with a <code>trap</code> is somewhat different, since it keeps it as legal IR. I'm not sure about this one.</p>\n</blockquote>",
        "id": 338822713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677673469
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1450133884\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>The readonly flag applies to a specific instruction. If an optimization propagates readonly to other memory accesses, it has to explicitly set it for store operations. I don't think the same reasoning as #5167 applies as an access being in bounds of a memory region is a dynamic property where optimizations may cause more knowledge being gained, and only being known in the general case at runtime, while a store being marked as readonly is a static property that is always known at compile time. While the accesses memory region being readonly is a dynamic property, the actual flag on the store is a static property.</p>\n</blockquote>",
        "id": 338835095,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677676306
    },
    {
        "content": "<p>littlebenlittle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595082378\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Just opened a draft PR for this. The implementation is straightforward. To write a test case I need a little more info.</p>\n<p>In the cranelift IR, what are the semantics of a read only store? Is it just \"error\", as in a conformant compiler should never do this?</p>\n<p>The next issue is how to invoke a read only store using CLIF. How are <code>MemFlags</code> set? Is that the responsibility of the compiler or the programmer? If its on the programmer, i.e. read only stores are supported by CLIF, then this should be easy. If it's on the compiler, then we might need to write a non-conformant compiler and that's quite a bit more complex, I would assume.</p>\n</blockquote>",
        "id": 366913428,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686939031
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595115802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>I like @bjorn3's suggestion in this thread that we should reject read-only stores in the verifier (<code>cranelift/codegen/src/verifier/mod.rs</code>), rather than in the interpreter. The <code>MemFlags</code> are a static property of the store instruction so we don't need to wait until we're running the program to check this. The <code>aligned</code> flag (#5899) is different because although the flag is static, the address is not.</p>\n<p>I have to think some about @afonso360's comments, about whether optimizations could discover that a store is to a location which should be read-only. I'm not sure what optimization we might want to implement that would do that, and I think it's more likely that if there's a store after a read-only load we need to conclude that the load was wrong. But in any case this would still be an error that we should detect during or immediately after optimization, not at runtime.</p>\n<p>As for how to test this: <code>MemFlags</code> are specified by whoever constructed the CLIF. That can be a frontend like Wasmtime or cg-clif, or it can be in the text representation; see <code>cranelift/filetests/filetests/egraph/load-hoist.clif</code> for an example with several readonly loads.</p>\n</blockquote>",
        "id": 366916719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686940051
    },
    {
        "content": "<p>littlebenlittle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595129211\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Is this already implemented in the verifier on the <code>main</code> branch? [1]</p>\n<p>There doesn't appear to be a test case, however.</p>\n<p>[1] <a href=\"https://github.com/bytecodealliance/wasmtime/blob/62019b2e9bd931a73f8007c111d10ac3ac7d6c3b/cranelift/codegen/src/verifier/mod.rs#L1601\">https://github.com/bytecodealliance/wasmtime/blob/62019b2e9bd931a73f8007c111d10ac3ac7d6c3b/cranelift/codegen/src/verifier/mod.rs#L1601</a></p>\n</blockquote>",
        "id": 366919287,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686940786
    },
    {
        "content": "<p>littlebenlittle edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595129211\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Is this already implemented in the verifier on the <code>main</code> branch?</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/62019b2e9bd931a73f8007c111d10ac3ac7d6c3b/cranelift/codegen/src/verifier/mod.rs#L1601\">https://github.com/bytecodealliance/wasmtime/blob/62019b2e9bd931a73f8007c111d10ac3ac7d6c3b/cranelift/codegen/src/verifier/mod.rs#L1601</a></p>\n<p>There doesn't appear to be a test case, however.<br>\n</p>\n</blockquote>",
        "id": 366919389,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686940807
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595130918\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Hah, you're right!</p>\n<p>Want to open a PR with a test case confirming that it works? There are other verifier tests in <code>cranelift/filetests/filetests/verifier/</code>.</p>\n</blockquote>",
        "id": 366919633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686940888
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900#issuecomment-1595467252\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p>Closing this as @littlebenlittle just provided a test in #6593 showing that this already works the way we've decided it should. Thank you!</p>\n</blockquote>",
        "id": 367020983,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686957831
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5900\">issue #5900</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>readonly</code> flag, and always trap if there is a write to it.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>Loads with this flag have no memory dependencies. This results in undefined behavior if the dereferenced memory is mutated at any time between when the function is called and when it is exited.</p>\n</blockquote>\n<p>There is a world where we keep track of these flags (in both loads and stores) and can trap at any time a store to a previously <code>readonly</code>'d memory location. But this is a good start.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L330-L335\"><code>State::checked_store</code></a> check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.readonly\">readonly</a> flag set and return a <code>MemoryError</code> if so.</p>\n</li>\n<li>\n<p>We can't build the usual tests for this. </p>\n<ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The current implementation is fine, and we should technically never see a store with a <code>readonly</code> flag.</p>\n</blockquote>",
        "id": 367020985,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686957831
    }
]