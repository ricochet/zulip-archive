[
    {
        "content": "<p>pepyakin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466\">PR #4466</a> from <code>pep-outband-fuel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is a prototype of the solution for <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109[^1]\">https://github.com/bytecodealliance/wasmtime/issues/4109[^1]</a>. This is very rough and is not intended to be landed as is. Rather, this PR here is to validate that this approach is sensible.</p>\n<p>[^1]: I decided to change the name from slacked metering. First, I wanted to avoid mentioning async, so that's why it's not async fuel metering, since that async is orthogonal to the async currently used in wasmtime (as in <code>Func::call_async</code>). At the same time I don't know if slacked conveys the meaning (English is not my mother tongue). So I figured that that \"out-of-band metering\" is a better name. I contract it to <code>outband</code> in code, I assume it's fine since I saw people using it elsewhere. Please let me know if you have a better name!</p>\n<h2>Introduction</h2>\n<p>The regular fuel metering holds the fuel in the <code>vmctx-&gt;rumtime_limits-&gt;fuel_consumed</code>. At the beginning of each function, the value is loaded into a local variable. Roughly every basic block the value is increased with the cost of that basic block. The value is checked for overflow at function entries and loop headers. If fuel overflowed, then a certain libcall handles it.  Before leaving a function (normally, through a call or before a trap), the fuel is dumped into the VMRuntimeLimits.</p>\n<p>WIth the out-of-band fuel metering, the fuel is now promoted to a dedicated register tapping to the <code>pinned_reg</code> cranelift feature. The value is still increased every basic block, but the value does not leave the pinned register within wasm. Only at the wasm-host boundaries, i.e. trampolines &amp; libcalls (not implemented as of this PR, coming later), is the fuel value loaded in or flushed from the pinned register into the <code>VMRuntimeLimits</code>. </p>\n<p>Also, no checks are performed in the wasm. The checks are meant to be performed either when crossing the wasm-host boundary or asynchronously. Specifically, on Linux, the check is performed by sending a signal each, e.g., 1ms. The signal handler checks if the signal came from the wasmtime (on a best effort basis) and if the program counter points at some the JIT code. If it does, then that means the pinned register holds the currently consumed fuel value. If the fuel value is overflown, we bail out unwinding the wasm stack.</p>\n<p>This kind of mechanism showed a great improvement in performance on our tests while still being deterministic as long as the in-wasm state is irrelevant in the case of the OOG.</p>\n<p>Now, the prototype here right now targets x86_64 Linux. There is a plan to support aarch64 and macOS. Windows should also be possible to implement. The prototype does not support async. It would be great to support it, but additional work is required.</p>\n<h2>Implementation Notes and Rationale</h2>\n<h3>Mutex</h3>\n<p>Right now, before entering we save the tid of the calling thread. This is because theoretically the store can be called from different threads. I also wanted to prepare for the async: potentially the future can be polled on any thread, with each fiber switch we can find ourselves on a new thread.</p>\n<p>The problem is with Linux, it turns out that sending signals is a bit of a hassle. The signal's sender cannot know if the destination thread is dead or alive. Moreover, the tid can theoretically be reused and thus a signal could be sent to the wrong thread.</p>\n<p>At first, I thought it might be a problem performance-wise, but now I don't think so. The reason is: that the mutex does not get too contended. The mutex is taken on wasm entry &amp; exit and also during the out-of-band fuel check. The latter also uses <code>try_lock</code>. The interesting case is when the wasm tries to exit to host but the mutex is held: in that case, the exit will be delayed until the out-of-band check request is finished.</p>\n<h3><code>rt_tgsigqueueinfo</code></h3>\n<p>I resorted to using a raw syscall <code>rt_tgsigqueueinfo</code> on Linux to send the signal. </p>\n<p>I thought about using <code>pthread_sigqueue</code> (in constrast to just <code>pthread_kill</code>) because it allows to send a <code>sival</code>. This is helpful to tell if the signal is coming from wasmtime or not. However, turns out that at least glibc does a bunch of syscalls that we probably don't want to have inside of the out-of-band fuel check request. So I decided to go straight for <code>rt_tgsigqueueinfo</code>. It takes the <code>siginfo_t</code> but it seems like the kernel does not use that and passes it as is, so I used this opportunity pass dummy values.</p>\n<p>Another potential problem that I am not sure needs to be tackled: the <code>pid</code> is cached during the creation of the out-of-band check handle. This is not entirely correct since theoretically, it can change, but I figured it does not warrant worrying.</p>\n<h2>Future Work</h2>\n<p>If this gets a green light, then several things will need to be done in the future:</p>\n<p>As I mentioned above it should work on other platforms, namely aarch64, macOS, and possibly Windows.</p>\n<p>Then, make it work with async. That is actually a bit tricky. The main problem revolves around handling the yields. Specifically with Linux, if a signal handler interrupted the wasm code and figured it was OOG, it should yield the execution. Not sure how good is the idea to switch fibers from inside a signal handler. With macOS/Windows it's not any better: the check thread should manipulate the target thread so that it's possible to switch the fiber.</p>\n<p>In case, that works, we can think of applying the same technique we use here for a high-performance substitution for the <a href=\"#narrow/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F\">epoch interrupts</a>.<br>\n</p>\n</blockquote>",
        "id": 290134738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252185
    },
    {
        "content": "<p>pepyakin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466\">PR #4466</a> from <code>pep-outband-fuel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is a prototype of the solution for <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\">https://github.com/bytecodealliance/wasmtime/issues/4109</a> [^1]. This is very rough and is not intended to be landed as is. Rather, this PR here is to validate that this approach is sensible.</p>\n<p>[^1]: I decided to change the name from slacked metering. First, I wanted to avoid mentioning async, so that's why it's not async fuel metering, since that async is orthogonal to the async currently used in wasmtime (as in <code>Func::call_async</code>). At the same time I don't know if slacked conveys the meaning (English is not my mother tongue). So I figured that that \"out-of-band metering\" is a better name. I contract it to <code>outband</code> in code, I assume it's fine since I saw people using it elsewhere. Please let me know if you have a better name!</p>\n<h2>Introduction</h2>\n<p>The regular fuel metering holds the fuel in the <code>vmctx-&gt;rumtime_limits-&gt;fuel_consumed</code>. At the beginning of each function, the value is loaded into a local variable. Roughly every basic block the value is increased with the cost of that basic block. The value is checked for overflow at function entries and loop headers. If fuel overflowed, then a certain libcall handles it.  Before leaving a function (normally, through a call or before a trap), the fuel is dumped into the VMRuntimeLimits.</p>\n<p>WIth the out-of-band fuel metering, the fuel is now promoted to a dedicated register tapping to the <code>pinned_reg</code> cranelift feature. The value is still increased every basic block, but the value does not leave the pinned register within wasm. Only at the wasm-host boundaries, i.e. trampolines &amp; libcalls (not implemented as of this PR, coming later), is the fuel value loaded in or flushed from the pinned register into the <code>VMRuntimeLimits</code>. </p>\n<p>Also, no checks are performed in the wasm. The checks are meant to be performed either when crossing the wasm-host boundary or asynchronously. Specifically, on Linux, the check is performed by sending a signal each, e.g., 1ms. The signal handler checks if the signal came from the wasmtime (on a best effort basis) and if the program counter points at some the JIT code. If it does, then that means the pinned register holds the currently consumed fuel value. If the fuel value is overflown, we bail out unwinding the wasm stack.</p>\n<p>This kind of mechanism showed a great improvement in performance on our tests while still being deterministic as long as the in-wasm state is irrelevant in the case of the OOG.</p>\n<p>Now, the prototype here right now targets x86_64 Linux. There is a plan to support aarch64 and macOS. Windows should also be possible to implement. The prototype does not support async. It would be great to support it, but additional work is required.</p>\n<h2>Implementation Notes and Rationale</h2>\n<h3>Mutex</h3>\n<p>Right now, before entering we save the tid of the calling thread. This is because theoretically the store can be called from different threads. I also wanted to prepare for the async: potentially the future can be polled on any thread, with each fiber switch we can find ourselves on a new thread.</p>\n<p>The problem is with Linux, it turns out that sending signals is a bit of a hassle. The signal's sender cannot know if the destination thread is dead or alive. Moreover, the tid can theoretically be reused and thus a signal could be sent to the wrong thread.</p>\n<p>At first, I thought it might be a problem performance-wise, but now I don't think so. The reason is: that the mutex does not get too contended. The mutex is taken on wasm entry &amp; exit and also during the out-of-band fuel check. The latter also uses <code>try_lock</code>. The interesting case is when the wasm tries to exit to host but the mutex is held: in that case, the exit will be delayed until the out-of-band check request is finished.</p>\n<h3><code>rt_tgsigqueueinfo</code></h3>\n<p>I resorted to using a raw syscall <code>rt_tgsigqueueinfo</code> on Linux to send the signal. </p>\n<p>I thought about using <code>pthread_sigqueue</code> (in constrast to just <code>pthread_kill</code>) because it allows to send a <code>sival</code>. This is helpful to tell if the signal is coming from wasmtime or not. However, turns out that at least glibc does a bunch of syscalls that we probably don't want to have inside of the out-of-band fuel check request. So I decided to go straight for <code>rt_tgsigqueueinfo</code>. It takes the <code>siginfo_t</code> but it seems like the kernel does not use that and passes it as is, so I used this opportunity pass dummy values.</p>\n<p>Another potential problem that I am not sure needs to be tackled: the <code>pid</code> is cached during the creation of the out-of-band check handle. This is not entirely correct since theoretically, it can change, but I figured it does not warrant worrying.</p>\n<h2>Future Work</h2>\n<p>If this gets a green light, then several things will need to be done in the future:</p>\n<p>As I mentioned above it should work on other platforms, namely aarch64, macOS, and possibly Windows.</p>\n<p>Then, make it work with async. That is actually a bit tricky. The main problem revolves around handling the yields. Specifically with Linux, if a signal handler interrupted the wasm code and figured it was OOG, it should yield the execution. Not sure how good is the idea to switch fibers from inside a signal handler. With macOS/Windows it's not any better: the check thread should manipulate the target thread so that it's possible to switch the fiber.</p>\n<p>In case, that works, we can think of applying the same technique we use here for a high-performance substitution for the <a href=\"#narrow/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F\">epoch interrupts</a>.<br>\n</p>\n</blockquote>",
        "id": 290134777,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252205
    },
    {
        "content": "<p>pepyakin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466\">PR #4466</a> from <code>pep-outband-fuel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is a prototype of the solution for <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\">https://github.com/bytecodealliance/wasmtime/issues/4109</a> [^1]. This is very rough and is not intended to be landed as is. Rather, this PR here is to validate that this approach is sensible.</p>\n<p>[^1]: I decided to change the name from slacked metering. First, I wanted to avoid mentioning async, so that's why it's not async fuel metering, since that async is orthogonal to the async currently used in wasmtime (as in <code>Func::call_async</code>). At the same time I don't know if slacked conveys the meaning (English is not my mother tongue). So I figured that that \"out-of-band metering\" is a better name. I contract it to <code>outband</code> in code, I assume it's fine since I saw people using it elsewhere. Please let me know if you have a better name!</p>\n<h2>Introduction</h2>\n<p>The regular fuel metering holds the fuel in the <code>vmctx-&gt;rumtime_limits-&gt;fuel_consumed</code>. At the beginning of each function, the value is loaded into a local variable. Roughly every basic block the value is increased with the cost of that basic block. The value is checked for overflow at function entries and loop headers. If fuel overflowed, then a certain libcall handles it.  Before leaving a function (normally, through a call or before a trap), the fuel is dumped into the VMRuntimeLimits.</p>\n<p>WIth the out-of-band fuel metering, the fuel is now promoted to a dedicated register tapping to the <code>pinned_reg</code> cranelift feature. The value is still increased every basic block, but the value does not leave the pinned register within wasm. Only at the wasm-host boundaries, i.e. trampolines &amp; libcalls (not implemented as of this PR, coming later), is the fuel value loaded in or flushed from the pinned register into the <code>VMRuntimeLimits</code>. </p>\n<p>Also, no checks are performed in the wasm. The checks are meant to be performed either when crossing the wasm-host boundary or asynchronously. Specifically, on Linux, the check is performed by sending a signal each, e.g., 1ms. The signal handler checks if the signal came from the wasmtime (on a best effort basis) and if the program counter points at some the JIT code. If it does, then that means the pinned register holds the currently consumed fuel value. If the fuel value is overflown, we bail out unwinding the wasm stack.</p>\n<p>This kind of mechanism showed a great improvement in performance on our tests while still being deterministic as long as the in-wasm state is irrelevant in the case of the OOG.</p>\n<p>Now, the prototype here right now targets x86_64 Linux. There is a plan to support aarch64 and macOS. Windows should also be possible to implement. The prototype does not support async. It would be great to support it, but additional work is required.</p>\n<h2>Implementation Notes and Rationale</h2>\n<h3>Mutex</h3>\n<p>Right now, before entering we save the tid of the calling thread. This is because theoretically the store can be called from different threads. I also wanted to prepare for the async: potentially the future can be polled on any thread, with each fiber switch we can find ourselves on a new thread.</p>\n<p>The problem is with Linux, it turns out that sending signals is a bit of a hassle. The signal's sender cannot know if the destination thread is dead or alive. Moreover, the tid can theoretically be reused and thus a signal could be sent to the wrong thread.</p>\n<p>At first, I thought it might be a problem performance-wise, but now I don't think so. The reason is: that the mutex does not get too contended. The mutex is taken on wasm entry &amp; exit and also during the out-of-band fuel check. The latter also uses <code>try_lock</code>. The interesting case is when the wasm tries to exit to host but the mutex is held: in that case, the exit will be delayed until the out-of-band check request is finished.</p>\n<h3><code>rt_tgsigqueueinfo</code></h3>\n<p>I resorted to using a raw syscall <code>rt_tgsigqueueinfo</code> on Linux to send the signal. </p>\n<p>I thought about using <code>pthread_sigqueue</code> (in constrast to just <code>pthread_kill</code>) because it allows to send a <code>sival</code>. This is helpful to tell if the signal is coming from wasmtime or not. However, turns out that at least glibc does a bunch of syscalls that we probably don't want to have inside of the out-of-band fuel check request. So I decided to go straight for <code>rt_tgsigqueueinfo</code>. It takes the <code>siginfo_t</code> but it seems like the kernel does not use that and passes it as is, so I used this opportunity pass dummy values.</p>\n<p>Another potential problem that I am not sure needs to be tackled: the <code>pid</code> is cached during the creation of the out-of-band check handle. This is not entirely correct since theoretically, it can change, but I figured it does not warrant worrying.</p>\n<h2>Future Work</h2>\n<p>If this gets a green light, then several things will need to be done in the future:</p>\n<p>As I mentioned above it should work on other platforms, namely aarch64, macOS, and possibly Windows.</p>\n<p>Then, make it work with async. That is actually a bit tricky. The main problem revolves around handling the yields. Specifically with Linux, if a signal handler interrupted the wasm code and figured it was OOG, it should yield the execution. Not sure how good is the idea to switch fibers from inside a signal handler. With macOS/Windows it's not any better: the check thread should manipulate the target thread so that it's possible to switch the fiber.</p>\n<p>In case, that works, we can think of applying the same technique we use here for a high-performance substitution for the <a href=\"#narrow/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F\">epoch interrupts</a>.</p>\n<p>Big thanks to @alexcrichton &amp; @cfallin for their great support !</p>\n</blockquote>",
        "id": 290134853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252242
    },
    {
        "content": "<p>pepyakin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466\">PR #4466</a> from <code>pep-outband-fuel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This is a prototype of the solution for <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\">https://github.com/bytecodealliance/wasmtime/issues/4109</a> [^1]. This is very rough and is not intended to be landed as is. Rather, this PR here is to validate that this approach is sensible and to source some preliminary feedback.</p>\n<p>[^1]: I decided to change the name from slacked metering. First, I wanted to avoid mentioning async, so that's why it's not async fuel metering, since that async is orthogonal to the async currently used in wasmtime (as in <code>Func::call_async</code>). At the same time I don't know if slacked conveys the meaning (English is not my mother tongue). So I figured that that \"out-of-band metering\" is a better name. I contract it to <code>outband</code> in code, I assume it's fine since I saw people using it elsewhere. Please let me know if you have a better name!</p>\n<h2>Introduction</h2>\n<p>The regular fuel metering holds the fuel in the <code>vmctx-&gt;rumtime_limits-&gt;fuel_consumed</code>. At the beginning of each function, the value is loaded into a local variable. Roughly every basic block the value is increased with the cost of that basic block. The value is checked for overflow at function entries and loop headers. If fuel overflowed, then a certain libcall handles it.  Before leaving a function (normally, through a call or before a trap), the fuel is dumped into the VMRuntimeLimits.</p>\n<p>WIth the out-of-band fuel metering, the fuel is now promoted to a dedicated register tapping to the <code>pinned_reg</code> cranelift feature. The value is still increased every basic block, but the value does not leave the pinned register within wasm. Only at the wasm-host boundaries, i.e. trampolines &amp; libcalls (not implemented as of this PR, coming later), is the fuel value loaded in or flushed from the pinned register into the <code>VMRuntimeLimits</code>. </p>\n<p>Also, no checks are performed in the wasm. The checks are meant to be performed either when crossing the wasm-host boundary or asynchronously. Specifically, on Linux, the check is performed by sending a signal each, e.g., 1ms. The signal handler checks if the signal came from the wasmtime (on a best effort basis) and if the program counter points at some the JIT code. If it does, then that means the pinned register holds the currently consumed fuel value. If the fuel value is overflown, we bail out unwinding the wasm stack.</p>\n<p>This kind of mechanism showed a great improvement in performance on our tests while still being deterministic as long as the in-wasm state is irrelevant in the case of the OOG.</p>\n<p>Now, the prototype here right now targets x86_64 Linux. There is a plan to support aarch64 and macOS. Windows should also be possible to implement. The prototype does not support async. It would be great to support it, but additional work is required.</p>\n<h2>Implementation Notes and Rationale</h2>\n<h3>Mutex</h3>\n<p>Right now, before entering we save the tid of the calling thread. This is because theoretically the store can be called from different threads. I also wanted to prepare for the async: potentially the future can be polled on any thread, with each fiber switch we can find ourselves on a new thread.</p>\n<p>The problem is with Linux, it turns out that sending signals is a bit of a hassle. The signal's sender cannot know if the destination thread is dead or alive. Moreover, the tid can theoretically be reused and thus a signal could be sent to the wrong thread.</p>\n<p>At first, I thought it might be a problem performance-wise, but now I don't think so. The reason is: that the mutex does not get too contended. The mutex is taken on wasm entry &amp; exit and also during the out-of-band fuel check. The latter also uses <code>try_lock</code>. The interesting case is when the wasm tries to exit to host but the mutex is held: in that case, the exit will be delayed until the out-of-band check request is finished.</p>\n<h3><code>rt_tgsigqueueinfo</code></h3>\n<p>I resorted to using a raw syscall <code>rt_tgsigqueueinfo</code> on Linux to send the signal. </p>\n<p>I thought about using <code>pthread_sigqueue</code> (in constrast to just <code>pthread_kill</code>) because it allows to send a <code>sival</code>. This is helpful to tell if the signal is coming from wasmtime or not. However, turns out that at least glibc does a bunch of syscalls that we probably don't want to have inside of the out-of-band fuel check request. So I decided to go straight for <code>rt_tgsigqueueinfo</code>. It takes the <code>siginfo_t</code> but it seems like the kernel does not use that and passes it as is, so I used this opportunity pass dummy values.</p>\n<p>Another potential problem that I am not sure needs to be tackled: the <code>pid</code> is cached during the creation of the out-of-band check handle. This is not entirely correct since theoretically, it can change, but I figured it does not warrant worrying.</p>\n<h2>Future Work</h2>\n<p>If this gets a green light, then several things will need to be done in the future:</p>\n<p>As I mentioned above it should work on other platforms, namely aarch64, macOS, and possibly Windows.</p>\n<p>Then, make it work with async. That is actually a bit tricky. The main problem revolves around handling the yields. Specifically with Linux, if a signal handler interrupted the wasm code and figured it was OOG, it should yield the execution. Not sure how good is the idea to switch fibers from inside a signal handler. With macOS/Windows it's not any better: the check thread should manipulate the target thread so that it's possible to switch the fiber.</p>\n<p>In case, that works, we can think of applying the same technique we use here for a high-performance substitution for the <a href=\"#narrow/stream/217126-wasmtime/topic/Can.20async.20traps.20subsume.20epoch-interruptions.3F\">epoch interrupts</a>.</p>\n<p>Big thanks to @alexcrichton &amp; @cfallin for their great support !</p>\n</blockquote>",
        "id": 290135238,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252402
    },
    {
        "content": "<p>pepyakin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#pullrequestreview-1043853420\">PR review</a>.</p>",
        "id": 290135909,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252732
    },
    {
        "content": "<p>pepyakin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r924798094\">PR review comment</a>:</p>\n<blockquote>\n<p>The platform-specific code here and elsewhere in this PR relies on quite some C&amp;P.</p>\n<p>I wondered if it would be a good idea to reshuffle the low-level code into a separate <code>sys</code> module. It will then contain the platform-specific parts for traphandlers, out-of-band fuel and whatnot. </p>\n</blockquote>",
        "id": 290135910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252732
    },
    {
        "content": "<p>pepyakin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#pullrequestreview-1043854359\">PR review</a>.</p>",
        "id": 290136047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252778
    },
    {
        "content": "<p>pepyakin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r924798712\">PR review comment</a>:</p>\n<blockquote>\n<p>Alternatively, we could use a magic constant.</p>\n</blockquote>",
        "id": 290136048,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252778
    },
    {
        "content": "<p>pepyakin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r924798094\">PR review comment</a>.</p>",
        "id": 290136191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658252848
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#pullrequestreview-1048054335\">PR review</a>.</p>",
        "id": 290526506,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504040
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#pullrequestreview-1048054335\">PR review</a>.</p>",
        "id": 290526507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504040
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927755763\">PR review comment</a>:</p>\n<blockquote>\n<p>Is this function ever executed with <code>outband_fuel</code>? This seems like a confusing implementation of this function since the purpose of the pinned register is that it's always valid and doesn't need reloading.</p>\n</blockquote>",
        "id": 290526508,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504040
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927756040\">PR review comment</a>:</p>\n<blockquote>\n<p>Similar to <code>fuel_load_into_var</code> I think this function may never be executed if <code>outband_fuel</code> is true?</p>\n</blockquote>",
        "id": 290526509,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504040
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927757050\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind leaving a <code>compile_error!</code> for now?</p>\n</blockquote>",
        "id": 290526510,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504041
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927753755\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this also check fuel during spilling? Otherwise I think nondeterminism might creep in where host functions could execute when the wasm module has no fuel left?</p>\n</blockquote>",
        "id": 290526512,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504041
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927756506\">PR review comment</a>:</p>\n<blockquote>\n<p>Similar to above I think that <code>fuel_check</code> is never executed with <code>outband_fuel</code>?</p>\n</blockquote>",
        "id": 290526513,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504041
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927765661\">PR review comment</a>:</p>\n<blockquote>\n<p>Oh I see that this is a slightly different query, but could the query be passed through a function parameter? Something like <code>must_be_trap: bool</code> but probably with an <code>enum</code> of some kind to be more descriptive.</p>\n</blockquote>",
        "id": 290526515,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504041
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4466#discussion_r927757680\">PR review comment</a>:</p>\n<blockquote>\n<p>Can this be folded into the preexisting trap initialization?</p>\n</blockquote>",
        "id": 290526517,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658504041
    }
]