[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>The code generation for (i) branches on booleans, and (ii) branches on integer values that come from compares but are not directly observable (e.g. in a different basic block), is suboptimal. We often see:</p>\n<ul>\n<li>Masking, like <code>AND reg, 1</code>, because we pessimistically assume that the upper bits of a boolean value are undefined;</li>\n<li><code>cmp</code>, <code>setcc</code> (x64) / <code>cset</code> (aarch64) into a register followed by a conditional branch sometime later;</li>\n<li>A combination of the above two.</li>\n</ul>\n<p>The root causes are:</p>\n<ul>\n<li>We do not pattern-match far enough back, in some cases, to fuse the <code>brz</code> and <code>icmp</code> at the Cranelift level, and this is exacerbated by GVN and LICM that hoist icmps earlier in the function;</li>\n<li>We do not have combination patterns that recognize when some producers of bools-as-integers will actually define the high bits.</li>\n</ul>\n<p>Some combination of more aggressive pattern matching and demanded-bits analysis could improve the codegen in these cases.</p>\n</blockquote>",
        "id": 281890685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652219282
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>The code generation for (i) branches on booleans, and (ii) branches on integer values that come from compares but are not directly observable (e.g. in a different basic block), is suboptimal. We often see:</p>\n<ul>\n<li>Masking, like <code>AND reg, 1</code>, because we pessimistically assume that the upper bits of a boolean value are undefined;</li>\n<li><code>cmp</code>, <code>setcc</code> (x64) / <code>cset</code> (aarch64) into a register followed by a conditional branch sometime later;</li>\n<li>A combination of the above two.</li>\n</ul>\n<p>The root causes are:</p>\n<ul>\n<li>We do not pattern-match far enough back, in some cases, to fuse the <code>brz</code> and <code>icmp</code> at the Cranelift level, and this is exacerbated by GVN and LICM that hoist icmps earlier in the function;</li>\n<li>We do not have combination patterns that recognize when some producers of bools-as-integers will actually define the high bits.</li>\n</ul>\n<p>Some combination of more aggressive pattern matching and demanded-bits analysis could improve the codegen in these cases.</p>\n</blockquote>",
        "id": 281890689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652219282
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>The code generation for (i) branches on booleans, and (ii) branches on integer values that come from compares but are not directly observable (e.g. in a different basic block), is suboptimal. We often see:</p>\n<ul>\n<li>Masking, like <code>AND reg, 1</code>, because we pessimistically assume that the upper bits of a boolean value are undefined;</li>\n<li><code>cmp</code>, <code>setcc</code> (x64) / <code>cset</code> (aarch64) into a register followed by a conditional branch sometime later;</li>\n<li>A combination of the above two.</li>\n</ul>\n<p>The root causes are:</p>\n<ul>\n<li>We do not pattern-match far enough back, in some cases, to fuse the <code>brz</code> and <code>icmp</code> at the Cranelift level, and this is exacerbated by GVN and LICM that hoist icmps earlier in the function;</li>\n<li>We do not have combination patterns that recognize when some producers of bools-as-integers will actually define the high bits.</li>\n</ul>\n<p>Some combination of more aggressive pattern matching and demanded-bits analysis could improve the codegen in these cases.</p>\n</blockquote>",
        "id": 281890691,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652219282
    },
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>The code generation for (i) branches on booleans, and (ii) branches on integer values that come from compares but are not directly observable (e.g. in a different basic block), is suboptimal. We often see:</p>\n<ul>\n<li>Masking, like <code>AND reg, 1</code>, because we pessimistically assume that the upper bits of a boolean value are undefined;</li>\n<li><code>cmp</code>, <code>setcc</code> (x64) / <code>cset</code> (aarch64) into a register followed by a conditional branch sometime later;</li>\n<li>A combination of the above two.</li>\n</ul>\n<p>The root causes are:</p>\n<ul>\n<li>We do not pattern-match far enough back, in some cases, to fuse the <code>brz</code> and <code>icmp</code> at the Cranelift level, and this is exacerbated by GVN and LICM that hoist icmps earlier in the function;</li>\n<li>We do not have combination patterns that recognize when some producers of bools-as-integers will actually define the high bits.</li>\n</ul>\n<p>Some combination of more aggressive pattern matching and demanded-bits analysis could improve the codegen in these cases.</p>\n</blockquote>",
        "id": 281890701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652219282
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123#issuecomment-1141929550\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>Would preventing the legalizing of <code>br_icmp</code> also help here? And possibly even do the opposite and combine <code>br</code> and <code>icmp</code>, when the <code>icmp</code> has single user?</p>\n</blockquote>",
        "id": 284452014,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653991245
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123#issuecomment-1142374228\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4123\">issue #4123</a>:</p>\n<blockquote>\n<p>Possibly... I'm a bit torn because our general principle is to decompose ops at the CLIF level, to allow for better optimization (this has certainly been our rule for SIMD for example). I could imagine a case where a <code>cset</code> produces a bool hoisted out of a loop, and the loop branches on that rather than a fresh compare, which reduces the loop-carried live set by one register. (This actually makes me think we might eventually want to have a notion of \"hoisted for perf reasons, do not re-merge\" feed from the mid-end into isel pattern matching, but that's a separate conversation!)</p>\n<p>An ad-hoc fusing pass is also somewhat brittle; imho it's better to have one place where we reason about macro-op matching (namely isel).</p>\n<p>I think we should be able to do OK with better pattern matching, at least to remove the masking to start; but this is still pretty open to investigation!</p>\n</blockquote>",
        "id": 284505156,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654015426
    }
]