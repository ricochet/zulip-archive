[
    {
        "content": "<p>kubkon opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 192406528,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585668993
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/iximeow\" title=\"https://github.com/iximeow\">iximeow</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a>.</p>",
        "id": 192406586,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585669018
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/sunfishcode\" title=\"https://github.com/sunfishcode\">sunfishcode</a> and <a href=\"https://github.com/iximeow\" title=\"https://github.com/iximeow\">iximeow</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a>.</p>",
        "id": 192406592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585669020
    },
    {
        "content": "<p>kubkon assigned <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> to alexcrichton.</p>",
        "id": 192406604,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585669024
    },
    {
        "content": "<p>kubkon unassigned <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> to alexcrichton.</p>",
        "id": 192406636,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585669043
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/sunfishcode\" title=\"https://github.com/sunfishcode\">sunfishcode</a> and <a href=\"https://github.com/iximeow\" title=\"https://github.com/iximeow\">iximeow</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a>.</p>",
        "id": 192406651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585669047
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 192418665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585674107
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 192489941,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585724819
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385823249\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385823249\">PR Review</a>.</p>",
        "id": 192568717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585764156
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385823249\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385823249\">PR Review</a>.</p>",
        "id": 192568719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585764156
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r401806326\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r401806326\">PR Review Comment</a>:</p>\n<blockquote>\n<p>left in some commented out debugs here and just below</p>\n</blockquote>",
        "id": 192568720,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585764156
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385967484\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-385967484\">PR Review</a>.</p>",
        "id": 192596125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585777024
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 193068624,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586191414
    },
    {
        "content": "<p>iximeow submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388557371\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388557371\">PR Review</a>.</p>",
        "id": 193105754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>iximeow submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388557371\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388557371\">PR Review</a>.</p>",
        "id": 193105762,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>iximeow created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404339339\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404339339\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Why the <code>+ 'static</code> here? My understanding of the interaction between lifetimes/trait objects is kind of fuzzy, but isn't <code>'static</code> the implied default? (I'm not sure why we'd want to forbid non-<code>'static</code>, either)</p>\n</blockquote>",
        "id": 193105764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>iximeow created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404341365\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404341365\">PR Review Comment</a>:</p>\n<blockquote>\n<p>What _is_ the <code>TODO</code> here? The <code>get_file_type() == Err</code> case?</p>\n</blockquote>",
        "id": 193105766,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>iximeow created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404352910\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404352910\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>update_from</code> on an <code>OsFile</code> that has a <code>dir</code> with <code>Some</code> would then have a stale <code>dir</code>. I'm not sure how much an issue this actually is, since we only <code>update_from</code> in <code>fdstat_set_flags</code>. Flags are on the referenced filesystem entry, not on the <code>fd</code>, right? So inconsistent flags aren't actually possible? Otherwise we might end up in a state where <code>dir</code> was populated can iterate when it shouldn't, or can't iterate when it should.</p>\n<p>At the very least, if this is sound (and I suspect it is), I think it'd be good to have a comment describing why alongside this impl.</p>\n</blockquote>",
        "id": 193105767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>iximeow created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404368063\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404368063\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>ReOpenFile</code> requires the file handle came from <code>CreateFile</code>, but the standard library will use <code>GetStdHandle</code> rather than <code>CreateFile(\"CONIN$\",...</code> or <code>CONOUT$</code>. If it works I'd be a little suspect of it mysteriously breaking one day. Judging by <a href=\"https://github.com/rust-lang/rust/issues/40490\" title=\"https://github.com/rust-lang/rust/issues/40490\">https://github.com/rust-lang/rust/issues/40490</a> (found when looking to confirm how stdlib deals with Windows stdio) it seems pretty suspect to retain a stdio handle in the first place?</p>\n<p>Nothing specific to add, just topical thought meandering, sorry <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n</blockquote>",
        "id": 193105769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586209322
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388645847\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-388645847\">PR Review</a>.</p>",
        "id": 193107191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586210095
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404412061\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r404412061\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That syntax threw me off when I learned it a week or two ago, it just means that the <code>Handle</code> concrete type cant have a lifetime.</p>\n</blockquote>",
        "id": 193107192,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586210095
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390215414\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390215414\">PR Review</a>.</p>",
        "id": 193357987,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586369619
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405719155\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405719155\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yep, exactly as @pchickey said. I can't foresee a situation where type that implements <code>Handle</code> wouldn't last for the entire duration of the program.</p>\n</blockquote>",
        "id": 193357988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586369620
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390216885\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390216885\">PR Review</a>.</p>",
        "id": 193358225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586369744
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405720439\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405720439\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh right, I forgot to remove it. Thanks for spotting this one!</p>\n</blockquote>",
        "id": 193358226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586369744
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405728863\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405728863\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That's an excellent observation, thanks! I think adding a comment to remember about this potential issue is the best thing to do here.</p>\n<p>On a related albeit somewhat different note, I'd still like to refactor how we store the <code>DIR</code> stream pointer on BSDes in <code>OsFile</code>. Having an embedded <code>Option</code> seems like a less than ideal solution to use here. I was actually thinking of splitting the type into two or possibly an enum, so that if we are dealing with a dir on BSD, we'd immediately store a valid <code>DIR</code> stream pointer. But this will be a subsequent PR :-)</p>\n</blockquote>",
        "id": 193359981,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586370599
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390227110\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390227110\">PR Review</a>.</p>",
        "id": 193359982,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586370599
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390232944\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#pullrequestreview-390232944\">PR Review</a>.</p>",
        "id": 193361110,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586371066
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405733556\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443#discussion_r405733556\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh good find, thanks! So if I understood it right, modifying stdio should error out on Windows since the handle was obtained from <code>GetStdHandle</code> and not <code>CreateFile</code>. I'm keen to leave some sort of TODO here anyway to investigate this further on Windows.</p>\n</blockquote>",
        "id": 193361112,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586371066
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 193361711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586371326
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a> from <code>yacc</code> to <code>master</code>:</p>\n<blockquote>\n<p>OK, so this PR is a bit of an experiment that came about somewhat itself<br>\nwhen I was looking at refactoring use of <code>Rc&lt;RefCell&lt;Descriptor&gt;&gt;</code> inside<br>\n<code>Entry</code> struct. I've noticed that since we've placed <code>VirtualFile</code> on the<br>\nsame level as <code>OsHandle</code> and <code>Stdin</code> etc., we've ended up necessiitating<br>\nchecks for different combinations such as \"is a real OS resource being mixed<br>\nup with a virtual resource?\", and if that was the case, we'd panic since<br>\nthis was clearly not allowed (e.g., symlinking, or worse renaming).<br>\nTherefore, it seemed natural for virtual file to be on the same level<br>\nas _any_ OS handle (regardless of whether it's an actual file, socket,<br>\nor stdio handle). In other words, we should ideally envision the following<br>\nhierarchy:</p>\n<div class=\"codehilite\"><pre><span></span>\\-- OsHandle \\-- OsFile\n              -- Stdio\n\\-- Virtual\n</pre></div>\n\n\n<p>This way, we can deal with the mix up at a level above which cleans up<br>\nour logic significantly.</p>\n<p>On the other hand, when looking through the <code>virtfs</code>, the trait approach<br>\nto some type that's a valid <code>Handle</code> grew on me, and I think this<br>\nis the way to go. And this is what this PR is proposing, a trait<br>\n<code>Handle</code> which features enough functionality to make both virtual and<br>\nOS ops to work. Now, inside <code>Entry</code> we can safely store something like<br>\n<code>Rc&lt;dyn Handle&gt;</code> where <code>Handle</code> can downcast to either <code>VirtualFile</code> or<br>\n<code>VirtualDir</code>, or <code>OsHandle</code> if its an actual OS resource. Note that<br>\nI've left <code>Handle</code> as one massive trait, but I reckon we could split<br>\nit up into several smaller traits, each dealing with some bit of WASI<br>\nfunctionality. I'm hoping this would perhaps make it easier to figure<br>\nout polyfilling between snapshots and the new upcoming ephemeral<br>\nsnapshot since a lot of boilerplate functionality is now done as part<br>\nof the <code>Handle</code> trait implementation.</p>\n<p>Next, I've redone the original <code>OsHandle</code> to be an <code>OsFile</code> which<br>\nnow stores a raw descriptor/handle (<code>RawFd</code>/<code>RawHandle</code>) inside a<br>\n<code>Cell</code> so that we can handle interior mutability in an easy (read,<br>\nnon-panicky) way. In order not to lose the perks of derefercing to<br>\n<code>std::fs::File</code>, I've added a convenience trait <code>AsFile</code> which<br>\nwill take <code>OsFile</code> by reference (or the stdio handles) and create<br>\na non-owned <code>ManuallyDrop&lt;File&gt;</code> resource which can be passed around<br>\nand acted upon the way we'd normally do on <code>&amp;File</code>. This change of<br>\ncourse implies that we now have to worry about properly closing all<br>\nOS resources stored as part of <code>OsFile</code>, thus this type now implements<br>\n<code>Drop</code> trait which essentially speaking moves the raw descriptor/handle<br>\ninto a <code>File</code> and drops it.</p>\n<p>Finally, I've redone setting time info on relative paths on *nix using<br>\nthe same approach as advocated in the virtual fs. Namely, we do an<br>\n<code>openat</code> followed by <code>filestat_set_times</code> on the obtained descriptor.<br>\nThis effectively removes the need for custom <code>filetime</code> module in<br>\n<code>yanix</code>. However, this does probably incur additional cost of at least<br>\none additional syscall, and I haven't checked whether this approach<br>\nperforms as expected on platforms such as NixOS which as far as I remember<br>\nhad some weirdness todo with linking <code>utimensat</code> symbols, etc. Still,<br>\nthis change is worth considering given that the implementation of<br>\n<code>path_filestat_set_times</code> cleans up a lot, albeit with some additional<br>\ncost.</p>\n<p>Anyhow, lemme y'all know what you think!</p>\n<p>PS, if anybody is wondering why the incoming branch is called <code>yacc</code>,<br>\nit stands for \"yet another cleanup cleanup\" simply because I was out<br>\nof ideas...</p>\n</blockquote>",
        "id": 193362813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586371848
    },
    {
        "content": "<p>kubkon merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1443\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1443\">PR #1443</a>.</p>",
        "id": 193503964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586463501
    }
]