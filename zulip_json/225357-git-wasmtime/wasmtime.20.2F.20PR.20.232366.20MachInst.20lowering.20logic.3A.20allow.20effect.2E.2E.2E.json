[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215680792,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604564119
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/julian-seward1\">julian-seward1</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a>.</p>",
        "id": 215680793,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604564119
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2366 </p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215680879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604564176
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215680905,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604564205
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215919929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604708095
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215920044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604708231
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 215920557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604708720
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216125123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604946603
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216161835,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604969696
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216165191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604973351
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216296337,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605056816
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> and <a href=\"https://github.com/julian-seward1\">julian-seward1</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a>.</p>",
        "id": 216414027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605140784
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531587169\">PR Review</a>.</p>",
        "id": 216915913,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553164
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531587169\">PR Review</a>.</p>",
        "id": 216915914,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553164
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524480577\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I feel like this could use a new name now: <code>NonRegInput</code>?</p>\n</blockquote>",
        "id": 216915915,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553164
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524489798\">PR Review Comment</a>:</p>\n<blockquote>\n<p>nitpick: it seems worth pulling this out into an <code>is_inst_sunk</code> helper method to clarify the meaning of this code without being forced to look at the details of the data structures and representation</p>\n</blockquote>",
        "id": 216915916,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553165
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524478661\">PR Review Comment</a>:</p>\n<blockquote>\n<p>doc nitpick for clarity:</p>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    /// Put the `idx`th input into a register and return the assigned register.\n</code></pre></div>\n</blockquote>",
        "id": 216915917,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553165
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524495075\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Can <code>inst</code> and <code>constant</code> ever <em>both</em> be <code>Some</code>? If not, then I think it makes more sense to define this as an <code>enum NonRegInput</code> and then methods that create this would return <code>Option&lt;NonRegInput&gt;</code> and use <code>None</code> instead of returning a struct that has empty components.</p>\n</blockquote>",
        "id": 216915918,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553165
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524490281\">PR Review Comment</a>:</p>\n<blockquote>\n<p>ditto for this bit. maybe we could have a <code>is_result_needed</code> helper</p>\n</blockquote>",
        "id": 216915919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553165
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524499043\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Returning <code>Option</code> would also make it so the naming could be a little more natural here, since the \"maybe\" would become redundant, and this could be named <code>fn get_input_as_non_reg(...) -&gt; Option&lt;NonRegInput&gt; {...}</code> which I think reads a lot better.</p>\n</blockquote>",
        "id": 216915920,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605553165
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531852854\">PR Review</a>.</p>",
        "id": 216944029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567009
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524703434\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The <code>inst</code> and <code>constant</code> fields can actually both be <code>Some</code>, and in fact some of the matching code relies on this -- it matches on the opcode implied by <code>inst</code> where one of the options is <code>Iconst</code>. In other words when we know a constant value for the input it's because we know its source instruction, and that source instruction is iconst/fconst/etc. Otherwise I agree this would have been a good simplification!</p>\n</blockquote>",
        "id": 216944030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567009
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531854617\">PR Review</a>.</p>",
        "id": 216944079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567065
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524704342\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I decided to remove <code>maybe_</code> as the returned struct is composed of <code>Option</code>s, so it's semantically pretty clear what's going on in any case.</p>\n</blockquote>",
        "id": 216944080,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567066
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216944110,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567093
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531855964\">PR Review</a>.</p>",
        "id": 216944116,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567105
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524705050\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 216944117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567106
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524705200\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done, thanks!</p>\n</blockquote>",
        "id": 216944129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567115
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531856237\">PR Review</a>.</p>",
        "id": 216944130,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567115
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531856607\">PR Review</a>.</p>",
        "id": 216944176,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567127
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524705379\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I like that name better, agreed.</p>\n</blockquote>",
        "id": 216944177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567127
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216944228,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567169
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#pullrequestreview-531859227\">PR Review</a>.</p>",
        "id": 216944266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567207
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366#discussion_r524706733\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 216944267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567207
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a> from <code>load-isel</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR updates the \"coloring\" scheme that accounts for side-effects in<br>\nthe MachInst lowering logic. As a result, the new backends will now be<br>\nable to merge effectful operations (such as memory loads) <em>into</em> other<br>\noperations; previously, only the other way (pure ops merged into<br>\neffectful ops) was possible. This will allow, for example, a load+ALU-op<br>\ncombination, as is common on x86. It should even allow a load + ALU-op +<br>\nstore sequence to merge into one lowered instruction.</p>\n<p>The scheme arose from many fruitful discussions with @julian-seward1<br>\n(thanks!); significant credit is due to him for the insights here.</p>\n<p>The first insight is that given the right basic conditions, i.e.  that<br>\nthe root instruction is the only use of an effectful instruction's<br>\nresult, all we need is that the \"color\" of the effectful instruction is<br>\n<em>one less</em> than the color of the current instruction. It's easier to<br>\nthink about colors on the program points between instructions: if the<br>\ncolor coming <em>out</em> of the first (effectful def) instruction and <em>in</em> to<br>\nthe second (effectful or effect-free use) instruction are the same, then<br>\nthey can merge. Basically the color denotes a version of global state;<br>\nif the same, then no other effectful ops happened in the meantime.</p>\n<p>The second insight is that we can keep state as we scan, tracking the<br>\n\"current color\", and <em>update</em> this when we sink (merge) an op. Hence<br>\nwhen we sink a load into another op, we effectively <em>re-color</em> every<br>\ninstruction it moved over; this may allow further sinks.</p>\n<p>Consider the example (and assume that we consider loads effectful in<br>\norder to conservatively ensure a strong memory model; otherwise, replace<br>\nwith other effectful value-producing insts):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Scanning from bottom to top, we first see the add producing <code>v3</code> and we<br>\ncan sink the load producing <code>v1</code> into it, producing a load + ALU-op<br>\nmachine instruction. This is legal because <code>v1</code> moves over only <code>v2</code>,<br>\nwhich is a pure instruction. Consider, though, <code>v2</code>: under a simple<br>\nscheme that has no other context, <code>v0</code> could not sink to <code>v2</code> because it<br>\nwould move over <code>v1</code>, another load. But because we already sunk <code>v1</code><br>\ndown to <code>v3</code>, we are free to sink <code>v0</code> to <code>v2</code>; the update of the<br>\n\"current color\" during the scan allows this.</p>\n<p>This PR also cleans up the <code>LowerCtx</code> interface a bit at the same time:<br>\nwhereas previously it always gave some subset of (constant, mergeable<br>\ninst, register) directly from <code>LowerCtx::get_input()</code>, it now returns<br>\nzero or more of (constant, mergable inst) from<br>\n<code>LowerCtx::maybe_get_input_as_source_or_const()</code>, and returns the<br>\nregister only from <code>LowerCtx::put_input_in_reg()</code>. This removes the need<br>\nto explicitly denote uses of the register, so it's a little safer.</p>\n<p>Note that this PR does not actually make use of the new ability to merge<br>\nloads into other ops; that will come in future PRs, especially to<br>\noptimize the <code>x64</code> backend by using direct-memory operands.</p>\n<p>Testing: existing filetests ensure the DCE-while-lowering and existing<br>\nmerging pattern-matches continue to work; merging of effectful ops<br>\nwill be verified in a subsequent PR with load+op pattern-matching.</p>\n<p>Fixes #2340.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 216944293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605567233
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2366\">PR #2366</a>.</p>",
        "id": 216947808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605569500
    }
]