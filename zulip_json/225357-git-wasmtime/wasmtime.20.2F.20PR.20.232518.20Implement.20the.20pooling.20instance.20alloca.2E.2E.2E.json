[
    {
        "content": "<p>peterhuene opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time and to reuse<br>\ncommitted memory pages wherever possible.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 220213105,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1608189333
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 220216003,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1608192593
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 223708443,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611353574
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 223708486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611353609
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 223711433,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611355262
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 224524696,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611950048
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225366709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612564156
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225367458,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612564630
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225368756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612565532
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225370517,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612566780
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225373665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612569471
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR is based on #2454 and only the most recent commit is new.</p>\n</blockquote>",
        "id": 225380021,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612576680
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 225947870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613017925
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 225950734,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613021824
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-588258590\">PR Review</a>.</p>",
        "id": 225950954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613022130
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r574261679\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This sure is pretty, <code>cargo-fmt</code>.</p>\n</blockquote>",
        "id": 225950955,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613022130
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r574261679\">PR Review Comment</a>.</p>",
        "id": 225951068,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613022362
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 225951121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613022423
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n<p>This PR depends on #2434.</p>\n</blockquote>",
        "id": 225951215,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613022563
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 225954754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613027077
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226041514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613070381
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226085890,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613096267
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226086101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613096498
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226101341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613109926
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226769683,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613628956
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226857008,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613673034
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226863129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613675291
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226866346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613676576
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226866523,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613676630
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226873047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613679287
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 226886290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1613684843
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 227985093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614370074
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 227989746,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614371936
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228009374,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614380306
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n</blockquote>",
        "id": 228025064,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614391967
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR implements the pooling instance allocator.</p>\n<p>The allocation strategy can be set with <code>Config::with_allocation_strategy</code>.</p>\n<p>The pooling strategy uses the pooling instance allocator to preallocate a<br>\ncontiguous region of memory for instantiating modules that adhere to various<br>\nlimits.</p>\n<p>The intention of the pooling instance allocator is to reserve as much of the<br>\nhost address space needed for instantiating modules ahead of time.</p>\n<p>This PR also implements the <code>uffd</code> feature in Wasmtime that enables<br>\nhandling page faults in user space; this can help to reduce kernel lock<br>\ncontention and thus increase throughput when many threads are<br>\ncontinually allocating and deallocating instances.</p>\n<p>See <a href=\"https://github.com/bytecodealliance/rfcs/pull/5\">the related RFC</a>.</p>\n</blockquote>",
        "id": 228025175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614392109
    },
    {
        "content": "<p><strong>peterhuene</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a>.</p>",
        "id": 228026656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614393761
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228026657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614393761
    },
    {
        "content": "<p><strong>peterhuene</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> and <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a>.</p>",
        "id": 228026658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614393763
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228283740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614624055
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-600897931\">PR Review</a>.</p>",
        "id": 228326618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-600897931\">PR Review</a>.</p>",
        "id": 228326619,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584840908\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Perhaps the tests here could conventionally have <code>uffd</code> in the name so we could just run <code>cargo test --features uffd -p ... -p ... uffd</code>?</p>\n</blockquote>",
        "id": 228326620,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584852110\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Is the reason that this is done here instead of module translation to defer the copying of the original wasm's data into a <code>Box&lt;[u8]&gt;</code> instead of borrowing it?</p>\n</blockquote>",
        "id": 228326621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584848872\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This returns a <code>Result</code> but never actually returns an error, would it be possible though to return an <code>Err</code> on the Windows side to avoid a panic?</p>\n</blockquote>",
        "id": 228326622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584855729\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We've generally tried to avoid reexporting inner types to avoid public crate dependencies and such. It's mostly to prevent developers from accidentally thinking they need to use the internal crates.</p>\n<p>Would it be ok to duplicate these definitions into this crate and using <code>match</code> to translate?</p>\n</blockquote>",
        "id": 228326624,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584864900\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The original design of <code>get_data</code> was intended to intentionally take a <code>fn</code> as the function parameter which explicitly cannot close over any state. The goal was to avoid computing data that didn't take into account something that should be hashed by enforcing that all input state was hashed.</p>\n<p>I saw that this changed from <code>fn</code> to <code>Fn</code>, and it's presumably to handle the <code>allocator</code> variable which I think is probably somewhat unreasonable to implement <code>Hash</code>.</p>\n<p>I was thinking about this and ways to possibly improve this, but I remembered that I think this needs to be refactored anyway? The <code>Module::deserialize</code> method is the other primary way to construct a module, which doesn't go through this path, so I think that method will need to also be validated against the instance allocator configured in the <code>Engine</code>? For that I think the <code>allocator</code> may need to switch to validating <code>CompiledModule</code> instances perhaps (or similar), and from there I think that this caching function can switch back to <code>fn</code>?</p>\n<p>Er, so basically:</p>\n<ul>\n<li>I don't think that this validation catches modules built with with <code>Module::deserialize</code></li>\n<li>By catching those modules I think we can switch the caching back to <code>fn</code> instead of <code>Fn</code></li>\n</ul>\n</blockquote>",
        "id": 228326625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584859578\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW if we wanted (and if it mattered, I'm not sure if it does), we could do away with this almost entirely. We might need to allocate more space for wasmtime to do its thing on the async stack (e.g. generate a backtrace after a trap), but we could have all host calls which are polling futures transition back to the main native stack. </p>\n<p>Although that would probably also lose the stack trace information with wasm frames if a host function generated a trap.</p>\n<p>Anyway not something for this PR naturally, just musing.</p>\n</blockquote>",
        "id": 228326626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584867138\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW I have a little red flag go off in my head whenever I see the <code>nix</code> dependency, it's historically I feel been a bit too much trying to be \"portable\" when it isn't actually. That said this is already a dependency of <code>lucet</code> and fastly folks look to be the ones managing this crate anyway, so this is something that could be updated later if necessary.</p>\n</blockquote>",
        "id": 228326627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584874430\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This check initially seemed odd to me because I thought \"what if the memory was larger?\" but in fact all memories here are defined memories which means that they'll all have the minimum size.</p>\n<p>Could the comment perhaps here be updated to reflect that? In theory if we have some future wasm feature to resize memory optionally before memory is initialized we'll need to update this, but that seems like a bit of a stretch.</p>\n</blockquote>",
        "id": 228326628,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584860782\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could the <code>new</code> function here perhaps return a native <code>anyhow::Error</code> to avoid this conversion?</p>\n</blockquote>",
        "id": 228326629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584876611\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I've only read this far up to this point, so I've definitely got more to go. That being said though while this representation makes sense in a vacuum I'm not sure why we'd pick it. Could this comment (or the one on <code>Paged</code>) be updated to point to somwhere which has rationale for why we'd structure memory initializers in this fashion?</p>\n</blockquote>",
        "id": 228326630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584882388\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I wonder, would it be possible to use some generics-fu and a helper function to make this lookup/<code>match</code> use shared logic between memory segments here and table segments above?</p>\n</blockquote>",
        "id": 228326631,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584879058\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think that some integration may be missing around this? It looks like this function is never actually called by <code>wasmtime</code>, so I think that maybe a change was missed when rebasing on the async changes? (it looks like <code>Store::on_fiber</code> still unconditionally calls <code>Fiber::new</code>)</p>\n</blockquote>",
        "id": 228326632,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584865868\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I was about to say that this is a really weighty dependency to pull in and realized that we already have this in our dependency graph, now there's just 2 ;_;</p>\n</blockquote>",
        "id": 228326633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584888203\">PR Review Comment</a>:</p>\n<blockquote>\n<p>One thing we could do to make this function a bit safer perhaps is to use <a href=\"https://doc.rust-lang.org/std/ptr/fn.slice_from_raw_parts_mut.html\"><code>ptr::slice_from_raw_parts_mut</code></a> perhaps?</p>\n</blockquote>",
        "id": 228326634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641880
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584883068\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this return <code>anyhow::Error</code>?</p>\n<p>(ideally we'd be pretty consistent about using that everywhere, although I don't know how successful we are up to this point)</p>\n</blockquote>",
        "id": 228326635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584886084\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Similar to other places, could this use <code>anyhow::Error</code> perhaps?</p>\n</blockquote>",
        "id": 228326636,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584884077\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Having only read this far (thanks github alphabetical sorting) and also not having a good grasp on uffd, I don't really have any idea what this field could be used for. Could this comment perhaps point to a different location which has a doc-block with a high-level overview of how uffd and wasmtime work?</p>\n</blockquote>",
        "id": 228326637,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584892898\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Piggy-backing on an earlier comment, this is one of the locations I stopped to think about overflow.</p>\n<p>I realize though this was copied from preexisting code so it wasn't introduced in this PR, but figured it'd be worth mentioning!</p>\n</blockquote>",
        "id": 228326638,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584890856\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm nott entirely certain if this is <em>the</em> place, but it seems like something should be done on overflow here. Either this should explicitly use a <code>wrapping_add</code> in the 32-bit index space, or it should use a <code>checked_add</code> and probably fail if overflow happens.</p>\n</blockquote>",
        "id": 228326639,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584889837\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I forget if we check this in various locations, but does this perhaps need to guard against overflow?</p>\n<p>I thought about this looking at a different part of this PR, but I would imagine that <em>something</em> should guard against overflow at some point, although I'm not sure precisely where that should happen.</p>\n</blockquote>",
        "id": 228326640,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584894014\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think that this may actually make us slightly non-spec-compliant. Spec-wise I think we need to process each data segment in-order and only trap when one is out of bounds, but all the previous data segments should be copied into memory. I think this should be easy to fix, though, by basically using Segmented when one of the segments is out of bounds?</p>\n<p>(and we could even optimize slightly and avoid storing any data for future data segments after the one that's known to trap)<br>\n</p>\n</blockquote>",
        "id": 228326641,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584892257\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I realize this is probably copied from earlier, but the <code>end</code> here is already computed above witth the <code>checked_add</code>, so perhaps a <code>match</code> could be used to bind the result and return early on failure?</p>\n</blockquote>",
        "id": 228326642,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584903070\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW if you're up for it I think this would be a good refactoring to implement for tables that a \"dynamic\" as well. I think we'd ideally have the same representation for both static and dynamic where everything is a <code>Vec&lt;usize&gt;</code> (or at least a contiguous array of pointer-sized things).</p>\n<p>That may help unify a few paths here and having so much difference between static/dynamic.</p>\n</blockquote>",
        "id": 228326643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584899633\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To avoid some extraneous casts here, could the <code>*mut Instance</code> be bound to a local variable and then it's got the <code>drop_in_place</code> and <code>dealloc</code> called on it?</p>\n</blockquote>",
        "id": 228326644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584909180\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This I think has interesting API implications where when using the pooling instance allocator you'll always have a maximum listed on tables even though no tables actually mention having a maximum. For example <code>Table::new</code> with a maximum size of <code>None</code> would come back to you and say it has a maximum size.</p>\n<p>I'm not sure if this is the right trade-off, though, since it means that the behavior of the <code>wasmtime</code> crate differs depending on the allocation strategy (which I don't think is intended)? </p>\n<p>Do you think it would be reasonable to have 2 maximums here? One for the wasm-defined maximum and one for the system-defined maximum. Growth beyond the wasm maximum would give a deterministic error message and growth beyond the system-defined maximum would return a different error message in theory.</p>\n</blockquote>",
        "id": 228326645,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584911808\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This bug predates your PR, but it might be good to actually go ahead and fix it here? Currently this <code>.unwrap()</code> will cause a panic if <code>TableElement</code> is of the wrong type:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">fill_wrong</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TableType</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ValType</span>::<span class=\"n\">FuncRef</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Limits</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Table</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Val</span>::<span class=\"n\">FuncRef</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">table</span><span class=\"p\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Val</span>::<span class=\"n\">ExternRef</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(using the <code>wasmtime</code> crate API)<br>\n</p>\n</blockquote>",
        "id": 228326646,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584895473\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Would it be possible to bake the assertions above into Rust's builtin bounds checks by calling <code>get_memory_slice</code> perhaps? That would also help improve safety from at least the Rust perspective where if we get the arguments wrong it panic</p>\n</blockquote>",
        "id": 228326647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584900210\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Would it be possible to inline the allocation that currently happens in the fiber crate to here instead? It'd be pretty nice actually if the fiber crate didn't deal with stack allocation at all and just unsafely assumed the given stack was valid</p>\n</blockquote>",
        "id": 228326648,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584916501\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Out of curiosity did we have tests already that required the check for forward/backward copy? If not, would you be ok adding a test or two that ensures we do the right direction of copy here?</p>\n</blockquote>",
        "id": 228326649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584919835\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I haven't read a ton of code related to this yet, but should this and <code>make_accessible</code> perhaps be methods on <code>Mmap</code>? If not methods on the structure itself perhaps associated functions?</p>\n<p>(would be good to consolidate all the various bits and pieces related to mmap and platform-specific-ness into one place</p>\n</blockquote>",
        "id": 228326650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584914992\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This isn't your bug (it predates this PR), but this suffers the same issue where it panics if the types of the tables mismatch:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">copy_wrong</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TableType</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ValType</span>::<span class=\"n\">FuncRef</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Limits</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">table1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Table</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Val</span>::<span class=\"n\">FuncRef</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TableType</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">ValType</span>::<span class=\"n\">ExternRef</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Limits</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">table2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Table</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Val</span>::<span class=\"n\">FuncRef</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Table</span>::<span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">table1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">table2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>while you're here, would you be ok fixing that?</p>\n</blockquote>",
        "id": 228326651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584924697\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok seeing the implementation of this I think that it might be best to change this signature to at least take a <code>Module</code> instead of <code>ModuleTranslation</code>.</p>\n<p>As for the other comment I had elsewhere about doing this after compilation instead of before, I realize that'll have the impact of some modules will take time to compile and then fail (whereas they could have failed faster), but perhaps we can leave that as an open issue to fix for later?</p>\n</blockquote>",
        "id": 228326652,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584918327\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Given that we already have a trait here for what linear memory looks like, could we continue to use that instead of having a static variant? Or were you trying to also avoid the allocation overhead of the trait object itself?</p>\n</blockquote>",
        "id": 228326653,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584914454\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think that this, and the functions below, may not need to be <code>unsafe</code>?</p>\n</blockquote>",
        "id": 228326654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584925558\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We may want to update the documentation for enabling the pooling allocator to indicate that these fields are automatically configured and any provided values with <code>Config</code> are ignored?</p>\n</blockquote>",
        "id": 228326655,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584951466\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could these numbers be decomposed a bit into a more readable form, e.g. <code>10 * MB</code> or <code>10 * (1 &lt;&lt; 20)</code> or something like that?</p>\n</blockquote>",
        "id": 228326656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584921629\">PR Review Comment</a>:</p>\n<blockquote>\n<p>How come this uses the default instance allocator instead of the configured instance allocator?</p>\n</blockquote>",
        "id": 228326657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584952375\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Is this intended to be used beyond tests? If so it may be better to have the rng as a parameter somehow to avoid hardcoding <code>thread_rng</code> which may not always be the most performant.</p>\n</blockquote>",
        "id": 228326658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584962698\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this <code>clear()</code> happen as part of <code>deallocate</code> and this could become a <code>debug_assert</code> that it's already empty?</p>\n</blockquote>",
        "id": 228326659,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584958464\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It's ok to skip the extra block here since the <code>lock()</code> will get freed at the end of the expression anyway</p>\n</blockquote>",
        "id": 228326660,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584953246\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This might be a bit more terse as:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">base_pointer_iter</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">num</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 228326661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584971805\">PR Review Comment</a>:</p>\n<blockquote>\n<p>In theory the <code>InstancePool</code>, <code>MemoryPool</code>, and <code>TablePool</code> structures are all along the lines of <code>MmapBackedPool&lt;T&gt;</code> and have pretty similar code for allocation/etc. Do you think it'd be possible to make something that's literally generic like that? Or perhaps runtime-bounded where you pass in a runtime size and a runtime count.</p>\n</blockquote>",
        "id": 228326662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584970161\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It looks like the index of the instance in the pool is the same as the index of the memory/table used in the pool, but could we perhaps make that more flexible? Could the memory/table pool indices be in separate spaces to allow for more flexible memory/table allocation?</p>\n<p>I don't think this helps a ton of use cases today but could in theory help with something where if you allowed up to 2 memories but you expected almost all modules to use only one memory you wouldn't have to allocate 2x the virtual memory space in case all instances allocated 2 (or something like that).</p>\n<p>I imagine this may be more of a problem for tables in the near future since multiple tables may be used more regularly than multiple memories.</p>\n</blockquote>",
        "id": 228326663,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585053319\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This I think is a good place where using <code>anyhow</code> would clean this up a bit where <code>with_context</code> wouldn't have to worry about including the original error in the message here, it'd be done automatically.</p>\n</blockquote>",
        "id": 228326664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584956963\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This looks like it's at least used in <code>allocate</code> below as well, so perhaps a helper method could be added along the lines of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">instance_ptr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">Instance</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 228326665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584959075\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this have a debug assertions that the memory (and table below) are \"static\" and managed by the pooling allocator?</p>\n</blockquote>",
        "id": 228326666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585054176\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this have a doc comment indicating that the helper thread should automatically exit when all regions are unmapped, so this doesn't need to do anything like send a signal for the thread to exit?</p>\n</blockquote>",
        "id": 228326667,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641881
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585056536\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Should this perhaps panic since the documentation seems to indicate that it's only used in non-blocking situations where an event wasn't available.</p>\n</blockquote>",
        "id": 228326668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641882
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585105203\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To confirm my understanding, the fault is on an unmapped region of memory, one with zero backed pages. This is just switching it to a confirmed mapped, but no protection region? </p>\n<p>I'm not actually sure how <code>PROT_NONE</code> affects the default regions vs not...</p>\n</blockquote>",
        "id": 228326695,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585103870\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is actually pretty interesting, while true I don't think that this has been assumed before (well before this PR we didn't assume raw initialization of tables anyway). Could you drop a comment in the <code>Table</code> implementation about this? It'll be a hard requirement that tables can be initialized with all-zeros as their representation.</p>\n</blockquote>",
        "id": 228326697,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585109393\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm not sure I understand the semantics of <code>MAP_NORESERVE</code> here. This is creating a mapping for the full <code>mapping_size</code>, which seems like it's creating a read/write mapping for the 1000 * 1 * 6GB default (6TB?), but that surely isn't what's happening. Does <code>NORESERVE</code> here mean that page tables aren't edited at all? Does read/write unconditionally segfault and get routed to uffd with this flag?</p>\n<p>I tried reading man pages but they weren't the most illuminating for this...</p>\n</blockquote>",
        "id": 228326698,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585105664\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW I personally have 0 uffd experience. Would you be up for writing a longer-form doc comment explaining some high-level pieces about how uffd works and how it is used here? I think it'd be nice to read a module-doc comment and get a high-level overview of what primitives uffd offers and how they're used in wasmtime.</p>\n</blockquote>",
        "id": 228326699,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585102820\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this handling be broken out into the main body of the loop or a separate function to avoid the rightward-drift here?</p>\n</blockquote>",
        "id": 228326700,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585112870\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Should this perhaps be wired up as <code>DefinedMemoryIndex</code>?</p>\n</blockquote>",
        "id": 228326703,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585114695\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hm I see now about my comment earlier having different index spaces for tables/memories will not work because of this. I can't really think of an alternative, so seems fine!</p>\n</blockquote>",
        "id": 228326704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585115282\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll admit I'm a bit lost and confused with the native os page size and the wasm page size. Why does the page address of the wasm page matter here?</p>\n</blockquote>",
        "id": 228326707,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585115726\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sort of similar to above, how come a length of wasm page size is assumed? I would naively assume that the wasm page size wouldn't factor into anything in this module, only perhaps as a multiplier to by default initialize more than one page at a time if one faults.</p>\n</blockquote>",
        "id": 228326708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585121015\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this have a comment that <code>Some(None)</code> means that we just didn't have a data initializer for this page in memory but we did have an initializer for a later page, and then <code>None</code> means that we didn't have an initializer for this page or anything afterwards.</p>\n</blockquote>",
        "id": 228326711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585117289\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is one part where the native page size and wasm page size sent me spinning for a bit. It looks like the inputs to this function are wasm page size indices and multiples, but the <code>map</code> that we're loading from is stored with native page sizes aligned. How come that's the case? Should the <code>map</code> have wasm page sizes instead? (or should this function take native page size multiples/indices?)</p>\n</blockquote>",
        "id": 228326712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585116339\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll admit I unfortunately have no idea what the purpose of this function nor why this (presumably <code>mprotect</code>?) call does what it needs to do. Could you explain a bit more what's going on with this side table of guard pages?</p>\n</blockquote>",
        "id": 228326714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585121620\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW I find the error-handling boilerplate here to take up a lot of screen real-estate, it'd be nice to use perhaps a helper function to create these messages to make the <code>map_err</code> format onto a single line if possible.</p>\n</blockquote>",
        "id": 228326715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585130710\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Why is this called here? </p>\n</blockquote>",
        "id": 228326717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585124947\">PR Review Comment</a>:</p>\n<blockquote>\n<p>If I understand this correctly, when uffd is enabled, this I think has somewhat weirder performance? During this standard initialization what will happen is that we'll fault as we write in each byte, but the uffd handler fills in zeros, and then we proceed to the next page. </p>\n<p>For this sort of initialization would it be better to go ahead and make the pages backed by real memory before we initialize the memories of the instance?</p>\n</blockquote>",
        "id": 228326718,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585121260\">PR Review Comment</a>:</p>\n<blockquote>\n<p>While obvious in retrospect, could this be commented to indicate that it's only called with requests which are known to be valid wasm pages that must either have data copied in or data zeroed?</p>\n</blockquote>",
        "id": 228326719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585128847\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm not sure I saw this, but could you add a test where async code hits the guard page in native code?</p>\n<p>I think it'll need to be a new test executable that executes itself similar to <code>tests/host_segfault.rs</code> (although this could modify that too)</p>\n</blockquote>",
        "id": 228326721,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585130048\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I got lost a little trying to find what this <code>AtomicBool</code> was being threaded around for. I don't think that we need to have this, though, since if anything hits the guard page then it should abort the whole process (we don't recover from those at all). Basically I think that this could work, but given that the signal handler never handles this SIGSEGV I think that it's not necessary to try to recover and this can simply <code>wake_guard_page_access</code></p>\n</blockquote>",
        "id": 228326722,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585125485\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm having a bit of trouble imagining where this case is hit. Is this used for things like <code>Memory::new</code> explicit constructors?</p>\n<p>It seems like this also gets triggered perhaps when uffd is used but pages are not initialized with the paging above?</p>\n<p>I feel like ideally we would assert that this case was never hit, but I'm not sure if that makes sense within the realm of performance that uffd is targeting.</p>\n</blockquote>",
        "id": 228326723,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584961413\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hm ok as I read more and see that this is named in a few locations this may not be that applicable.</p>\n</blockquote>",
        "id": 228326725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r584896738\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Also, another thing I'm thinking at this point. I still haven't yet read to the point where the <code>Paged</code> variant here is motivated (probably uffd related I'm assuming), but wouldn't this initialization strategy be slower for modules not using the uffd allocator? Previously what was one large memcpy is now a lot of page-sized memcpys, which seems like it might be a bit slower but I also suspect probably not really all that perceptibly slower.</p>\n</blockquote>",
        "id": 228326726,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585119069\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ok maybe I'm just confused how uffd works.</p>\n<p>It looks like a uffd backed page is one with read/write permissions, but not physical memory backed? By using NONE here we're asking the kernel to specifically bypass uffd? Then the <code>reset_guard_page</code> switches it back to read/write to get faults routed to uffd?</p>\n</blockquote>",
        "id": 228326727,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585131102\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Or, well, put another way, I couldn't figure out what was going on with recording all these faults.</p>\n<p>Could you write up a doc comment about what's going on with this record of guard pages and how it's used/applied with uffd?</p>\n</blockquote>",
        "id": 228326728,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614641884
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601285677\">PR Review</a>.</p>",
        "id": 228330319,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643659
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585144615\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We could do it that way, although right now the desire is to run the default pooling allocator tests but with uffd feature enabled as well (i.e. same tests, but use user fault handling).</p>\n<p>Is there a good way to do that without duplicating the tests?</p>\n</blockquote>",
        "id": 228330320,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643659
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601286294\">PR Review</a>.</p>",
        "id": 228330386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643684
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585144803\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sure thing, I'll fix that.</p>\n</blockquote>",
        "id": 228330393,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643685
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601287313\">PR Review</a>.</p>",
        "id": 228330576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643776
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585146033\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll redefine these in the <code>wasmtime</code> crate with a mapping.</p>\n</blockquote>",
        "id": 228330577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643776
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601288432\">PR Review</a>.</p>",
        "id": 228330850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643913
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585146902\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I believe that was the intention behind doing this post-translation originally because the data was stored on <code>CompiledModule</code> vs <code>Module</code>, but the uffd implementation needs the initialization data on <code>Module</code> to access it via <code>Instance</code> at runtime (<code>Instance</code> currently only references the <code>Module</code>).</p>\n<p>I would be fine doing it on module translation (make sense to give back a fully-formed <code>Module</code>), but I wasn't sure if it was the right thing to do in terms of boxing the initialization data.</p>\n</blockquote>",
        "id": 228330854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614643913
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601301336\">PR Review</a>.</p>",
        "id": 228333247,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645230
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585157250\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'd like to address this in a future PR to behave more like how Lucet functions for execution stacks.</p>\n<p>Ideally all the platforms would be able to walk through the \"fiber stack\" frames, so hopefully at some point that isn't a problem (it may mean some patches to <code>backtrace</code> to make work especially with the weirdness you saw on Windows fibers with the async work).</p>\n<p>The approach I would favor, if possible, is that each store allocates a single fiber stack when it is created and the first entry to Wasm (async and sync) switches to that stack.  We only switch back if yielded (async) or the entry wasm call returns (sync). This means we do check that the host has enough \"guaranteed\" stack space (ala Lucet) when a host function is called.  We'd remove the prologue stack overflow check in favor of a guard page signal as we'd know exactly where the guard page is so the trap handler can tell if the fault is on a stack guard page.</p>\n<p>To that end, I think there would be a setting that controls the size of the fiber stack allocated and a setting for controlling the size reserved for host calls.  This only matters at host entry; the wasm code can have the full stack to itself provided it doesn't call the host past the reservation size.</p>\n<p>Doing it this way give us a consistent stack story across platforms (perhaps excluding Windows?) for sync/async (i.e. \"WebAssembly code gets exactly XX of stack space, but must have at least YY of space left to call the host\") and it'd reduce the prologue branching + extra recorded trap (when not interruptible), etc.</p>\n<p>A design for another time, perhaps.</p>\n</blockquote>",
        "id": 228333248,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645231
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601302696\">PR Review</a>.</p>",
        "id": 228333617,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645423
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585158446\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That'd mean a new dependency on <code>anyhow</code> from the runtime crate, which I'm personally fine with.  Worth it?</p>\n</blockquote>",
        "id": 228333618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645423
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601304952\">PR Review</a>.</p>",
        "id": 228334116,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645729
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585160422\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That's an excellent point about validating deserialized modules.</p>\n<p>I'll switch to validating with <code>CompiledModule</code> and handle the validation after the data is returned from the cache, which should revert this back to <code>fn</code>.</p>\n</blockquote>",
        "id": 228334117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645729
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585160671\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll update the comment.</p>\n</blockquote>",
        "id": 228334161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645773
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601305263\">PR Review</a>.</p>",
        "id": 228334162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645773
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601305732\">PR Review</a>.</p>",
        "id": 228334224,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645840
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585161070\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll update the comment on why \"paged\" initialization is necessary, which is primarily for the uffd feature so that no work has to be performed in the user fault handler to initialize the page (we just tell the kernel \"here's a page you can copy to the page being accessed\").</p>\n</blockquote>",
        "id": 228334225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645840
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601306039\">PR Review</a>.</p>",
        "id": 228334313,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645888
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585161332\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Thanks for catching this; it was a bad rebase merge after I pulled in your final async changes.</p>\n<p>I've pushed up the fix.</p>\n</blockquote>",
        "id": 228334314,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645888
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601306374\">PR Review</a>.</p>",
        "id": 228334380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645934
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585161672\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Same comment as above as we don't currently have a dependency on <code>anyhow</code> for the runtime crate; I'm not opposed to adding one, however.</p>\n</blockquote>",
        "id": 228334381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614645934
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601312440\">PR Review</a>.</p>",
        "id": 228335676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614646758
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585167069\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can expand the comment to point at higher-level overview documentation on how uffd works.</p>\n<p>Specifically this is a workaround to an issue we were seeing in Lucet on more recent Linux kernels: previously waking a faulting thread without zeroing or copying the page data resulted in a <code>SIGBUS</code>, which Lucet relied on to signal an out-of-bounds memory access and thus trapped accordingly.</p>\n<p>Newer Linux kernels (5.7+) now retry the fault ad infinitum, resulting in a busy hang in Lucet when uffd is used.</p>\n<p>To fix this when implementing uffd in Wasmtime, Wasmtime records faults to current \"guard\" pages (i.e. pages that <em>should not</em> be accessible, but with uffd the entire memory region is read/write) when faulted and then explicitly changes the protection level of the page to <code>NONE</code> to induce a <code>SIGSEGV</code> when the kernel retries the fault, ultimately resulting in a trap as if the page were <code>NONE</code> the whole time.</p>\n<p>As an instance may continue to be used after a trap or (with the pooling allocator) the same virtual memory pages reused for a new instance, we have to reset the protection level of these \"none\" pages back to read-write because they might actually be accessible pages in the future if a memory grows (this should probably check to see if the page is beyond the limit of addressable pages and skip recording it if so, though; I'll fix that).</p>\n<p>The ultimate goal of the <code>uffd</code> feature is to (almost) never change memory protection levels as doing so requires taking kernel locks.</p>\n</blockquote>",
        "id": 228335677,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614646758
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601314372\">PR Review</a>.</p>",
        "id": 228336129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647001
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585168742\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Will change if we think runtime should depend on <code>anyhow</code>.</p>\n</blockquote>",
        "id": 228336130,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647001
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601315690\">PR Review</a>.</p>",
        "id": 228336371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647161
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585169879\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll see what I can come up with.</p>\n</blockquote>",
        "id": 228336372,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647161
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601317789\">PR Review</a>.</p>",
        "id": 228336711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647352
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585171551\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is old code refactored out from <code>instance.rs</code>, but I'm happy to change it.</p>\n</blockquote>",
        "id": 228336713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647352
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601319537\">PR Review</a>.</p>",
        "id": 228337104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647571
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585172838\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I feel like perhaps this belongs in the module translator such that we never call <code>declare_data_initialization</code> or <code>declare_table_elements</code> with offsets + lengths that would overflow.</p>\n</blockquote>",
        "id": 228337105,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647572
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585173678\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is also old code refactored out of <code>instance.rs</code>, but I agree this should be checking that the global doesn't introduce an overflow (assuming we're checking for the static offset in module translation).</p>\n</blockquote>",
        "id": 228337304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647714
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601320565\">PR Review</a>.</p>",
        "id": 228337305,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647715
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585173678\">PR Review Comment</a>.</p>",
        "id": 228337356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647754
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601321709\">PR Review</a>.</p>",
        "id": 228337482,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647841
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585174598\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed, this should calculate the end once (also existing code out of <code>instance.rs</code>).  I'll fix.</p>\n</blockquote>",
        "id": 228337483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647841
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585173678\">PR Review Comment</a>.</p>",
        "id": 228337489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647852
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585174963\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It can't hurt to address this one as well in this PR.  I'll fix.</p>\n</blockquote>",
        "id": 228337569,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647895
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601322395\">PR Review</a>.</p>",
        "id": 228337570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614647895
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601323516\">PR Review</a>.</p>",
        "id": 228337766,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648027
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585176646\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This condition (i.e. <code>MemoryInitialization::OutOfBounds</code>) only occurs when <em>all</em> the memories being initialized are defined (i.e. no imported memories).</p>\n<p>As such, there can't be any visible side-effects to the initialization because the module never successfully instantiates and no linear memory is being written to that existed prior to instantiation.</p>\n</blockquote>",
        "id": 228337767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648027
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585176646\">PR Review Comment</a>.</p>",
        "id": 228337785,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648039
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601324954\">PR Review</a>.</p>",
        "id": 228338019,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648223
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585177833\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I totally agree that using paged initialization might have a performance impact when not using uffd (which requires it so that we can quickly tell the kernel \"copy this page exactly and wake the faulting thread\").</p>\n<p>I'd be totally fine with defaulting to segmented initialization always unless the uffd feature is enabled.  What's your thoughts on that?</p>\n</blockquote>",
        "id": 228338020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648223
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601326148\">PR Review</a>.</p>",
        "id": 228338301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648392
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585178888\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll fix as the way you describe it is how the code currently works in <code>InstanceHandle::dealloc</code>; this is probably a holdover from something that made sense 30 commits ago in this work <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> </p>\n</blockquote>",
        "id": 228338302,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648392
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601328204\">PR Review</a>.</p>",
        "id": 228338710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648674
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585180735\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think we can make that work; the Windows implementation would differ from the other platforms in that the \"top of stack\" pointer given back is actually a fiber address to use with the Windows API.</p>\n<p>I'm on board with that and will make that change.</p>\n</blockquote>",
        "id": 228338711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648674
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601328912\">PR Review</a>.</p>",
        "id": 228338868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648779
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585181355\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll fix that.</p>\n</blockquote>",
        "id": 228338870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614648779
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601330867\">PR Review</a>.</p>",
        "id": 228339263,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649065
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585183299\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>Table::new</code> should not have any limits placed on it as instances for all host-defined objects use the default (on demand) allocator.</p>\n<p>Only module-defined tables and memories should have an implicit upper-bound via the pooling allocator's limits.</p>\n</blockquote>",
        "id": 228339265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649065
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585183299\">PR Review Comment</a>.</p>",
        "id": 228339416,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649197
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585183299\">PR Review Comment</a>.</p>",
        "id": 228339476,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649214
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601332080\">PR Review</a>.</p>",
        "id": 228339512,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649252
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585184456\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll fix.</p>\n</blockquote>",
        "id": 228339513,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649252
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601333352\">PR Review</a>.</p>",
        "id": 228339738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649445
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585185620\">PR Review Comment</a>:</p>\n<blockquote>\n<p>These do call <code>slice::from_raw_parts</code> for the static case as we just have a base pointer and size and the unified representation between static and dynamic is <code>&amp;[T]</code>.</p>\n</blockquote>",
        "id": 228339739,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649445
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601333489\">PR Review</a>.</p>",
        "id": 228339772,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649467
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585185746\">PR Review Comment</a>:</p>\n<blockquote>\n<p>But I can better scope the <code>unsafe</code> so the function itself isn't <code>unsafe</code>.</p>\n</blockquote>",
        "id": 228339773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649467
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585185746\">PR Review Comment</a>.</p>",
        "id": 228339782,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614649481
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601338255\">PR Review</a>.</p>",
        "id": 228340714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650193
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585190076\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It appears that bulk memory spec suite covers both directions (i.e. some are <code>dst &gt; src</code> and some are <code>dst &lt;= src</code>).</p>\n<p>Do you think that's sufficient?</p>\n</blockquote>",
        "id": 228340715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650194
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601339203\">PR Review</a>.</p>",
        "id": 228340868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650341
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585190985\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I was looking to avoid allocating a trait object for the static case, but I'm not opposed to putting this behind the trait to simplify the code here.</p>\n<p>Perhaps I was a little overzealous on trying to get the pooling allocator to heap allocate as little as possible to service a module instantiation request.</p>\n</blockquote>",
        "id": 228340869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650341
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601340235\">PR Review</a>.</p>",
        "id": 228341069,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650486
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585191869\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm fine with doing that.</p>\n<p>With <code>uffd</code> enabled, perhaps we just won't call these functions rather than stubbing them out (<code>decommit</code> for uffd is very similar, except it doesn't modify any protection levels).</p>\n</blockquote>",
        "id": 228341070,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614650487
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601345495\">PR Review</a>.</p>",
        "id": 228342078,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651243
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585196307\">PR Review Comment</a>:</p>\n<blockquote>\n<p>As commented in a previous response, I viewed the \"pooling instance allocator\" as relating to <em>module</em> instantiations and it's not used for creating host objects because I didn't want them to count towards the allocator's limits (from the runtime's perspective, a host object instance and a module instance is basically indistinguishable).</p>\n<p>Personally, I think this part of the design (specifically the notion of the \"default instance allocator\") is a bit wonky and I'd be happy to revisit it.</p>\n<p>What I don't want, however, is users to define a <code>Wasi</code> instance and, unbeknownst to them, the availability in the pool has been reduced by many dozens of instances, especially when none of those instances defined any memories or tables (and thus the pool's memory is underutilized).  I view the way we instantiate host objects to be an implementation detail of Wasmtime and not one I really want to expose users to when thinking about \"instances\".</p>\n<p>Doing it this way also means host objects are not restricted by any limits placed on the pooling allocator.</p>\n<p>That said, I'm totally open to better ways of doing this.</p>\n</blockquote>",
        "id": 228342080,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651243
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601347213\">PR Review</a>.</p>",
        "id": 228342405,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651498
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585197738\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed, this should take <code>Module</code> and happen after translation.</p>\n<p>I also doubt failing faster will be necessary, as scenarios in which the pooling allocator is most likely to be utilized, services would validate the module against its known limits once and long before instantiation.</p>\n</blockquote>",
        "id": 228342407,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651498
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601347858\">PR Review</a>.</p>",
        "id": 228342496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651582
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585198229\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Absolutely will do.</p>\n</blockquote>",
        "id": 228342498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651582
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601350448\">PR Review</a>.</p>",
        "id": 228343018,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651976
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585200376\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can do that.</p>\n<p>I've also been toying with removing the <code>memory_reservation_size</code> knob in the pooling instance allocator limits and instead relying on <code>static_memory_bound</code> when creating the pooling instance allocator.  A static memory bound of zero would be an error when using the pooling instance allocator and it would still be treated as the upper bound for all memories (and thus are static).</p>\n<p>This would mean the same sort of checks done in <code>Config::async_stack_size</code> to see if the strategy was already configured when setting <code>static_memory_bound</code> would need to be performed, but that's relatively minor.</p>\n</blockquote>",
        "id": 228343019,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614651976
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601351554\">PR Review</a>.</p>",
        "id": 228343194,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652149
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585201387\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Except now I just remembered why I quashed that idea: the 32-bit default for <code>static_memory_bound</code> is way too large to accommodate the pooling instance allocator (1 GiB vs 10 MiB).</p>\n</blockquote>",
        "id": 228343195,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652149
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601353778\">PR Review</a>.</p>",
        "id": 228343608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652489
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585203214\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This is intended to be used in production environments to make it harder for attackers to predict linear memory addresses (linear memory ASLR, if you will).</p>\n<p>In Lucet, there's <code>Linear</code> (which I'm calling <code>NextAvailable</code> here), <code>Random</code> (same implementation as here), and <code>CustomRandom(Arc&lt;Mutex&lt;dyn RngCore&gt;&gt;)</code> which is used in testing to simulate randomness (not implemented in this PR).</p>\n<p>Perhaps we could include <code>CustomRandom</code> just in case a different rng is desired?  Thread-local variants would definitely be preferred, though, as the only locks taken in the pooling allocator currently are for modifying the free lists.</p>\n</blockquote>",
        "id": 228343610,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652489
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585203214\">PR Review Comment</a>.</p>",
        "id": 228343678,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652563
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601355278\">PR Review</a>.</p>",
        "id": 228343853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652726
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585204644\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll remove this in favor of a simple generator.</p>\n</blockquote>",
        "id": 228343854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652726
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601355413\">PR Review</a>.</p>",
        "id": 228343878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652749
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585204747\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll add that.</p>\n</blockquote>",
        "id": 228343879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652749
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601356479\">PR Review</a>.</p>",
        "id": 228344045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652902
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585205625\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll remove.  I think originally this had a named scope guard rather than having the single statement, so it was explicitly done to denote a lock in play.</p>\n</blockquote>",
        "id": 228344046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652902
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601356583\">PR Review</a>.</p>",
        "id": 228344055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652918
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585205706\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll add that.</p>\n</blockquote>",
        "id": 228344056,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652918
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601356813\">PR Review</a>.</p>",
        "id": 228344128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652958
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585205886\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That sounds good to me.  I'll change.</p>\n</blockquote>",
        "id": 228344129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614652958
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585210232\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The reason the memory and table pools don't maintain their own free lists is that the uffd implementation can very quickly go from faulting address to the owning instance based on some simple arithmetic without any extra bookkeeping; but I don't think that's a strong enough reason to not be more flexible in this implementation.</p>\n<p>We'd need a table that maps between memory/table pool index to instance that it was allocated for, which isn't that big a deal to maintain.</p>\n<p>I'll see about addressing this.</p>\n</blockquote>",
        "id": 228344995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653718
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601361720\">PR Review</a>.</p>",
        "id": 228344996,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653718
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601362723\">PR Review</a>.</p>",
        "id": 228345135,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653868
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585211200\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think it would make sense to make this more generic especially if more free lists are maintained per my last comment.</p>\n<p>The mutex would probably then surround the instance pool itself rather than its free list, as we only want one lock to be able to modify three different free lists (instance, memory, and table).</p>\n</blockquote>",
        "id": 228345136,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653869
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601363177\">PR Review</a>.</p>",
        "id": 228345225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653940
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585211592\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed.  If we decide to add the <code>anyhow</code> dependency to runtime, then I'll make this change.</p>\n</blockquote>",
        "id": 228345227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653940
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601363261\">PR Review</a>.</p>",
        "id": 228345251,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653954
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585211671\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll add that comment.</p>\n</blockquote>",
        "id": 228345252,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653954
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585211745\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Panicking here makes sense to me.  I'll add that.</p>\n</blockquote>",
        "id": 228345266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653971
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601363364\">PR Review</a>.</p>",
        "id": 228345267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614653971
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601363767\">PR Review</a>.</p>",
        "id": 228345380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654030
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585212087\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Definitely.  I'll factor this out.</p>\n</blockquote>",
        "id": 228345381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654031
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601365813\">PR Review</a>.</p>",
        "id": 228345831,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654365
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585213852\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this comment might be a little confusing.</p>\n<p>It's not that the table's memory can be zero for element representation, just that tables aren't lazy initialized like memories are with uffd.</p>\n<p>This is simply zeroing the page prior to the initialization performed during module instantiation (what the representation of accessible elements are is then up to that initialization).</p>\n</blockquote>",
        "id": 228345832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654365
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585213852\">PR Review Comment</a>.</p>",
        "id": 228345871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654396
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601368181\">PR Review</a>.</p>",
        "id": 228346155,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654633
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585215424\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think I now see what you meant.</p>\n<p><code>Table::new_dynamic</code> (previously <code>Table::new</code>) is explicitly using <code>ptr::null_mut</code> and <code>None</code> (which is an <code>Option&lt;NotNull&lt;T&gt;&gt;</code>) for \"uninitialized\" elements, and this will assume those are equivalent to a zeroed page when uffd is in play.</p>\n<p>I'll add comments in <code>Table</code> that says there's an assumption being made here that uninitialized elements are assumed to be represented with all zeroes.</p>\n</blockquote>",
        "id": 228346156,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614654634
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601374219\">PR Review</a>.</p>",
        "id": 228347125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614655491
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585220206\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I left a previous comment that explains this a little bit and I'm happy to codify this better in the uffd module's comments.</p>\n<p>One of the big selling points of uffd is that we don't have to explicitly change the kernel's memory protection levels when instances are allocated/deallocated or when tables/memories grow (or for reused fiber stacks either).</p>\n<p>It keeps the regions as entirely read/write and initially the entire memory range is mapped but \"missing\" (i.e. normally the kernel would service a fault as if the page were all zeroes). When a fault occurs in the region, we can detect if the access was semantically to a \"guard\" page even though it has read/write access.</p>\n<p>The older kernels allowed us to simply wake the faulting thread without servicing the fault and, instead of retrying the fault, it would <code>SIGBUS</code> the access (this is behavior Lucet relies on currently to translate the access to a trap).</p>\n<p>Newer kernels will retry the fault indefinitely, meaning we <em>must</em> service it with either zeroing the page or copying the page from some other VA.  However, we don't want to service it because the access was to a guard page in this case.</p>\n<p>So what this does is record the fact a guard page was hit, \"temporarily\" set the protection to <code>NONE</code> to induce a <code>SIGSEGV</code> when the kernel retries the fault, and then later on \"reset\" the protection level back to read/write as some point in the future the page might actually be accessible.  Granted, this implementation could be a little smarter in identifying pages that will <em>never</em> become accessible and thus leave them forever with a <code>NONE</code> protection level (something I will try to address).</p>\n<p>This means we only ever change protection levels on guard page access.  This isn't ideal as malicious modules might intentionally hit guard pages, but there's other mitigations services could do to prevent abuse (i.e. \"your module has to sit in the naughty corner because it trapped out of bounds to much\").</p>\n</blockquote>",
        "id": 228347126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614655491
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585220206\">PR Review Comment</a>.</p>",
        "id": 228347140,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614655509
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601375108\">PR Review</a>.</p>",
        "id": 228347300,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614655632
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585220996\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I will definitely expand upon this documentation to make this more clear.</p>\n</blockquote>",
        "id": 228347302,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614655632
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601381493\">PR Review</a>.</p>",
        "id": 228348556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614656750
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585226423\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Here's my understanding of <a href=\"https://www.kernel.org/doc/Documentation/vm/overcommit-accounting\">over-committing memory on Linux</a>:</p>\n<p>A lot of distros use the default of <code>0</code> for <code>vm.overcommit_memory</code>.  This causes the kernel to apply a heuristic to see if it can likely satisfy a request to physically back all the requested accessible pages in the future.  If the kernel thinks it won't be able to physically back the allocation, it fails.</p>\n<p><code>MAP_NORESERVE</code> effectively tells a kernel using this over-commit strategy to forgo this check.  In this case, we're pretty much guaranteed that the kernel will not be able to physically back such a gigantic VM allocation.  However, only a fraction of the pages will ever need backing, so <code>MAP_NORESERVE</code> is our way of telling the kernel we know better than it does.</p>\n<p>I believe that a setting of <code>1</code> for <code>vm.overcommit_memory</code> is the same as every allocation being <code>MAP_NORESERVE</code>.</p>\n<p>A setting of <code>2</code> will always cause the pooling allocator to fail its allocation.  In this case, <code>MAP_NORESERVE</code> has no meaning.</p>\n<p>Ultimately this means we're at risk of random <code>SIGSEGV</code> for accesses to otherwise accessible pages in OOM conditions because we told the kernel to give us no guarantees that the page can be backed (I believe it might also sidestep the OOM killer for such pages, so the kernel won't bother killing other processes to give you backing space).</p>\n</blockquote>",
        "id": 228348557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614656750
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585226423\">PR Review Comment</a>.</p>",
        "id": 228348643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614656809
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585157250\">PR Review Comment</a>.</p>",
        "id": 228353007,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660373
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601408907\">PR Review</a>.</p>",
        "id": 228353036,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660413
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585248202\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can remove this.</p>\n<p>I was being a little to forward thinking that we might eventually want to utilize the stack guard pages to trap for stack overflow rather than relying on prologue checks like we do now (see comment made much earlier today), but we can always put this back in if that ever becomes a reality.</p>\n<p>No sense cluttering the code unnecessarily.</p>\n</blockquote>",
        "id": 228353037,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660413
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601409133\">PR Review</a>.</p>",
        "id": 228353092,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660454
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585248397\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sure, that conveys the intention better.  I'll fix.</p>\n</blockquote>",
        "id": 228353093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660454
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601409343\">PR Review</a>.</p>",
        "id": 228353161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660492
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585248623\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I have some ideas around making this work so I'll see what I can do.</p>\n</blockquote>",
        "id": 228353162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660492
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601410145\">PR Review</a>.</p>",
        "id": 228353286,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660618
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585249303\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So Lucet's uffd implementation has two ways of delay-initializing linear memories: by OS page and by Wasm page.  The latter seems more commonly used in production, which is why this implementation simply informs the handler thread which Wasm page was faulted and it initializes per Wasm page.</p>\n</blockquote>",
        "id": 228353287,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660618
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601410469\">PR Review</a>.</p>",
        "id": 228353335,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660673
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585249550\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The uffd handler initializes per Wasm page rather than handling a fault per OS page when faulting on linear memories.</p>\n<p>See above comment too.</p>\n</blockquote>",
        "id": 228353336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660674
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601412509\">PR Review</a>.</p>",
        "id": 228353671,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660991
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585251119\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This resets the previously faulted guard pages to the expected read/write permission; the entire range of pages monitored by the user fault handler is read/write so a fault can occur anywhere in that range and the kernel will pass it to us.</p>\n<p>This call to <code>mprotect</code> only ever occurs when a guard page has faulted; if a memory access is never out of bounds, then the memory managed by the pooling allocator will never have its protection level changed while still providing the correct semantics for Wasm.</p>\n</blockquote>",
        "id": 228353673,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614660991
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601416553\">PR Review</a>.</p>",
        "id": 228354457,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661656
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585254457\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The reason the map stores OS pages while the uffd initialization is Wasm-page sized is that I was concerned over how much we might potentially allocate as part of module compilation to represent potentially sparse and disjointed data segments.</p>\n<p>I think if we changed the implementation such that we only ever use the \"paged\" initialization when on Linux with uffd enabled, then I think we should change the map to be Wasm-page sized and give the kernel a single call to copy the page when handling the fault here.</p>\n</blockquote>",
        "id": 228354458,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661656
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601417173\">PR Review</a>.</p>",
        "id": 228354576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661741
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585255034\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll add that.</p>\n</blockquote>",
        "id": 228354577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661741
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601417252\">PR Review</a>.</p>",
        "id": 228354594,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661755
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585255099\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can add that comment.</p>\n</blockquote>",
        "id": 228354595,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614661755
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601445630\">PR Review</a>.</p>",
        "id": 228357083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614663889
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585277845\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I can do that or instead make use of <code>anyhow</code>.</p>\n</blockquote>",
        "id": 228357084,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614663889
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601502273\">PR Review</a>.</p>",
        "id": 228366057,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614670483
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585322817\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For some context, here's my understanding of how linear memories are created and initialized in Wasmtime (on Linux) with these changes:</p>\n<ul>\n<li>\n<p>On-demand allocator: by default we create a 6 GiB anonymous, private mapping with a <code>none</code> protection for the entire range.  We then mark the pages that are part of the \"minimal\" initial set for the linear memory as <code>read+write</code>.  We then iterate the data segments and they instruct us to write to one of those initial pages; but the page is not yet backed, so this causes a minor page fault and the kernel's memory manager handles it by backing the page with a single, shared CoW-marked zero-filled page. The write causes a copy of the page and thus a new page is physically backed for the process and subsequently filled with segment's data.  When the instance is deallocated, the entire mapping of the linear memory is freed.</p>\n</li>\n<li>\n<p>Pooling allocator: we allocate the same 6 GiB anonymous, private mapping with a <code>none</code> protection, but upfront and part of a pool of linear memories.  This is otherwise identical to the on-demand case: we still change the protection when creating/growing the memory and expect the kernel to handle missing backings with a zeroed page. Unlike the on-demand allocator, we may reuse the linear memory's mapping for a new instance; we effectively clear any backing for the linear memory's pages with <code>MADV_DONTNEED</code> when the instance is freed, thus guaranteeing the same initially-zero page the next time it is accessed (causing another minor fault).</p>\n</li>\n<li>\n<p>Pooling allocator with <code>uffd</code> enabled: same as without the <code>uffd</code> feature, except the entire region is protected as <code>read+write</code> instead of <code>none</code>.  This means we don't have to call <code>mprotect</code> to grow memories or when we reuse the linear memory's space for a new instance. Instead, we instruct the kernel to pass us any faults in this region and if we determine the access is out of bounds, we'll change the protection (temporarily) to <code>none</code> as-needed to induce a <code>SIGSEGV</code>.  We have two ways to handle the fault to an accessible page: zero the page or copy from another page.  As we're able to handle the faults ourselves, we can skip any initialization of defined linear memories at instantiation time and just do it when the page is first accessed. </p>\n</li>\n</ul>\n<p>The trade-off for uffd is that handling page faults in user space is slower than letting the kernel handle the faults, but we can skip any data segment initialization until actually accessed (a win if there are large data segments that aren't fully utilized). But more importantly, without all those <code>mprotect</code> calls, we're reducing kernel lock contention, page table modifications, and (possibly?) TLB shootdowns.  Access to guard pages notwithstanding, the page table entries only get modified when an instance is freed with the <code>uffd</code> feature.</p>\n<p>In theory, the penalty of handling the faults in user space is outweighed by the improved concurrency.</p>\n</blockquote>",
        "id": 228366058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614670484
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601509549\">PR Review</a>.</p>",
        "id": 228367046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671171
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585328847\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So this happens when the data segments either initialize imported memories or use a global base (this is treated as \"segmented\" initialization instead of \"paged\").</p>\n<p>For the bulk memory proposal, initializing an imported memory should have visible side effects if the module fails to instantiate, so we can't delay-initialize the pages.  Thus we handle the fault by zeroing the page; the fault is actually caused by Wasmtime during module instantiation, so the next thing that's happening when we wake the thread is that it's copying the segment data into the page. </p>\n<p>I just realized we <em>can</em> actually delay-initialize when a global base is used (for defined memories) because it's required to be an immutable global, so the value cannot change from the time the module instantiates to the time the page is accessed.  I'll fix that.</p>\n</blockquote>",
        "id": 228367047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671171
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601510641\">PR Review</a>.</p>",
        "id": 228367190,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671266
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585329783\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll see about adding this test case.</p>\n</blockquote>",
        "id": 228367191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671266
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585248202\">PR Review Comment</a>.</p>",
        "id": 228367204,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671280
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601511387\">PR Review</a>.</p>",
        "id": 228367305,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671330
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585330361\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'll update these methods will more comments to make it clearer as to why this is necessary and how it works.</p>\n</blockquote>",
        "id": 228367306,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671330
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585330361\">PR Review Comment</a>.</p>",
        "id": 228367316,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671337
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585328847\">PR Review Comment</a>.</p>",
        "id": 228368104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614671818
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585322817\">PR Review Comment</a>.</p>",
        "id": 228370651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614673215
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601965815\">PR Review</a>.</p>",
        "id": 228431492,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614699903
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585677444\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh nah that makes sense, seems fine to leave this as-is then.</p>\n</blockquote>",
        "id": 228431493,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614699903
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601967374\">PR Review</a>.</p>",
        "id": 228431739,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614699982
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585678655\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think it was originally intended to be a bit more flexible than it is now, but nowadays I think it's best to avoid the <code>Option</code> here to be in weird situations where you have to handle both <code>Some</code> and <code>None</code> somehow. Basically I think it's fine to go ahead and box up the data during module translation. If this is ever a problem in the future we can tackle it then.</p>\n</blockquote>",
        "id": 228431740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614699982
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601967764\">PR Review</a>.</p>",
        "id": 228431777,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700004
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585678979\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Nah yeah definitely something for a future PR, no need to handle this here!</p>\n</blockquote>",
        "id": 228431778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700004
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601968557\">PR Review</a>.</p>",
        "id": 228431908,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700043
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585679632\">PR Review Comment</a>:</p>\n<blockquote>\n<p>If not no worries, just something I figured may help make this slightly easier to read</p>\n</blockquote>",
        "id": 228431910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700043
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601969417\">PR Review</a>.</p>",
        "id": 228432061,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700087
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585680331\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Personally I think it's ok to add <code>anyhow</code> as a dependency. The alternative is something like <code>thiserror</code> but for our purposes I think <code>anyhow</code> is easier and works just fine.</p>\n</blockquote>",
        "id": 228432066,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700087
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601973919\">PR Review</a>.</p>",
        "id": 228432815,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585683756\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Makes sense to me!</p>\n</blockquote>",
        "id": 228432817,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700324
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601980555\">PR Review</a>.</p>",
        "id": 228433780,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700641
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585688520\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah I forgot yeah that this only happens when all memories are being defined. That being said I think weird spec corner cases will require us to still perform in-order initialization.</p>\n<p>According to <a href=\"https://webassembly.github.io/bulk-memory-operations/core/exec/modules.html#instantiation\">https://webassembly.github.io/bulk-memory-operations/core/exec/modules.html#instantiation</a> the 10th step is table initialization and the 11th step is data segment initialization. That means that we could initialize imported tables with functions this module defines (which close over defined memories). I believe that means that the module's internal memory can be exposed via those functions, so we'll still need to perform partial initialization.</p>\n<p>This is actually also a slight bug I think with the pooling allocator which I think calls <code>set_instance_memories</code> first before <code>set_instance_tables</code>, but should be an easy fix to swap them.</p>\n<p>I also feel like that while it's interesting-ish to think about this it's probably not really worth a complicated test to ensure the letter-of-the-law is followed in this respect.</p>\n</blockquote>",
        "id": 228433781,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700641
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601981827\">PR Review</a>.</p>",
        "id": 228433948,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700692
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585689317\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah I think that sounds reasonable to me! We should have semi-comprehensive tests for uffd anyway which I think should cover our bases in ensuring all branches are covered effectively.</p>\n</blockquote>",
        "id": 228433949,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700692
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585690068\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It's ok to defer this to a future PR as well, should in theory be a relatively easy cleanup. I also wouldn't bend over too far backwards to get windows/unix to work, if it's too much we can just leave fibers as they are right now.</p>\n</blockquote>",
        "id": 228434073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700740
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601982942\">PR Review</a>.</p>",
        "id": 228434074,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700740
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601985188\">PR Review</a>.</p>",
        "id": 228434416,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700847
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585691698\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh that's a good point about <code>Table::new</code>, but I also feel like this is a bit interesting wrt defined tables in wasm modules. This means that the pooling allocator will change the reported limits on memories/tables from instantiated modules relative to the on-demand allocator. That to me feels a bit odd because I figured the limits would reflect the in-wasm limits rather than the system-imposed limits.</p>\n</blockquote>",
        "id": 228434418,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700848
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585692054\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Indeed I think that is sufficient!</p>\n</blockquote>",
        "id": 228434504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700875
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601985739\">PR Review</a>.</p>",
        "id": 228434505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700875
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601987950\">PR Review</a>.</p>",
        "id": 228434870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700981
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585693469\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'd be ok either way myself, I figured it was slightly odd that we have a trait but then we also have an enum to do roughly the same thing.</p>\n<p>FWIW I was curious if we could make a test where we use a custom <code>#[global_allocator]</code> to do something like count the number of allocations that happens during <code>Instance::new</code> while using a pooling allocator, and we could have the test clamp with something like \"we perform 10 allocations today and that number must not go up\" so we can catch additional allocations (and even update the test as we remove allocations in theory). Felt like a little-bit overkill though too.</p>\n</blockquote>",
        "id": 228434871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614700981
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601989463\">PR Review</a>.</p>",
        "id": 228435167,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701060
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585694561\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Eh either way is fine by me, I'm mostly just looking to consolidate platform-specific memory manipulation. The <code>Mmap</code> type already is a bit odd I think in that it's kinda using an upstream crate kinda not, and it may be best if we just make our own module nowadays. Anyway that can be a refactoring for another day.</p>\n</blockquote>",
        "id": 228435169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701060
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601990386\">PR Review</a>.</p>",
        "id": 228435316,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701110
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585695215\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok that makes sense, and I agree that this seems like the best way to handle this. Agreed that creating a <code>Func</code> shouldn't accidentally reserve 6GB of address space because you're using a pooling allocator.</p>\n<p>Could the comment here be expanded with some of this too?</p>\n</blockquote>",
        "id": 228435317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701110
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601992201\">PR Review</a>.</p>",
        "id": 228435621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701207
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585696680\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah I don't think we need to be super elegant with these knobs, they're quite advanced and will likely rarely get tweaked by folks other than us anyway. I think it's good to have notes about the effects but no need to make them the most ergonomic.</p>\n</blockquote>",
        "id": 228435622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701208
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601992962\">PR Review</a>.</p>",
        "id": 228435724,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701246
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585697338\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok makes sense, let's stick with just using <code>thread_rng</code> for now (no need I think yet to start using a custom rng unless necessary), and if that's a problem in the future we can fix it then.</p>\n</blockquote>",
        "id": 228435726,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701246
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601995924\">PR Review</a>.</p>",
        "id": 228436167,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701400
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585699695\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm waffling on this a bit over time myself. I'm not actually sure that this is a good idea, because if you want to <em>guarantee</em> that each instance can have a memory (or two memories) then you have to do what your implementation does today anyway (basically pre-assign memories per instance). Having a few extra memories so some modules can have 2 memories and most others can have one only works when everything is cooperative.</p>\n<p>I feel like the cooperative case doesn't really happen that much if you're using the pooling allocator?</p>\n<p>I think this should probably actually stay as-is where the limits are guaranteed to be available for each instance, and we can always revisit this in the future if necessary.</p>\n</blockquote>",
        "id": 228436168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701400
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-601997030\">PR Review</a>.</p>",
        "id": 228436353,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701457
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585700524\">PR Review Comment</a>:</p>\n<blockquote>\n<p>And yeah I wouldn't really go out of your way to try to make this generic and wrapped up nicely, only if it makes sense. Just something I noticed while reading!</p>\n</blockquote>",
        "id": 228436355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701457
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602002594\">PR Review</a>.</p>",
        "id": 228437120,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701757
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585704706\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ok that all definitely makes sense, thanks for explaining!</p>\n<blockquote>\n<p>One of the big selling points of uffd is that we don't have to explicitly change the kernel's memory protection levels when instances are allocated/deallocated or when tables/memories grow (or for reused fiber stacks either).</p>\n</blockquote>\n<p>Ah right yes, it's all about avoiding those IPIs with cross-cpu TLB flushes?</p>\n<p>We do, however, routinely change the page tables but only insofar as adding allocated pages for regions? e.g. filling something in with zeros or from another page.</p>\n<blockquote>\n<p>Granted, this implementation could be a little smarter in identifying pages that will never become accessible and thus leave them forever with a NONE protection level (something I will try to address).</p>\n</blockquote>\n<p>Ah yeah this is also something I was wondering about. Presumably the guard page for all async stacks and the 2GB guard region for each memory could always be mapped as <code>NONE</code>? </p>\n</blockquote>",
        "id": 228437121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701757
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602004964\">PR Review</a>.</p>",
        "id": 228437502,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701883
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585706477\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So if you set <code>vm.overcommit_memory</code> to 2, wasmtime with uffd (or I guess the pooling allocator in general?) is inoperable.</p>\n<p>Otherwise this business about a random <code>SIGSEGV</code>, how does that play out with uffd? We're the ones who ask  the kernel \"please allocate a zero page for that spot\" or copy from somewhere else. Does that request for a page fail with an error we can handle? Or does it \"succeed\" and/or kill our process right there?</p>\n</blockquote>",
        "id": 228437504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701883
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602005920\">PR Review</a>.</p>",
        "id": 228437813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701935
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585707232\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok, could this perhaps be something like a constant which says \"default number of OS pages to initialize on a wasm fault\", and we update that as necessary?</p>\n</blockquote>",
        "id": 228437814,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614701935
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602007925\">PR Review</a>.</p>",
        "id": 228438264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702045
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585708789\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So to make sure I understand</p>\n<ul>\n<li>Guard pages <em>never</em> have physical memory backing them (e.g. <code>NORESERVE</code>)</li>\n<li>If permission is read/write, faults get routed to our uffd</li>\n<li>If permission is <code>NONE</code>, faults get routed to the signal handler</li>\n</ul>\n<p>So this reset needs to happen so future faults go to uffd?</p>\n</blockquote>",
        "id": 228438265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702045
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602014196\">PR Review</a>.</p>",
        "id": 228439226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702386
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585713564\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ok that all makes sense, thanks for explaining!</p>\n<p>So basically uffd or not, the same thing happens in this case where we manually initialize all data segments, which is that the first fault on each page <em>someone</em> puts a page of zeros there and then we overwrite it.</p>\n<p>My pondering here was mostly around how we know how big our memcpy is and which pages need to be resident, so I figured we could skip the uffd handler entirely and just tell the kernel \"put a bunch of pages there\", but that's probably overkill and not actually really needed for any situation today in terms of being a bottleneck.</p>\n</blockquote>",
        "id": 228439227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702386
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602015907\">PR Review</a>.</p>",
        "id": 228439422,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702477
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585714938\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ok cool makes sense, could you add some comments to that effect here of when this case will be hit?</p>\n</blockquote>",
        "id": 228439423,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614702477
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602178948\">PR Review</a>.</p>",
        "id": 228469049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712854
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585841824\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed, and compilation will happen in a different process.</p>\n</blockquote>",
        "id": 228469050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712854
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585841824\">PR Review Comment</a>.</p>",
        "id": 228469125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712874
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585841824\">PR Review Comment</a>.</p>",
        "id": 228469197,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712912
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585842532\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Isn't populating an imported table with functions from a module that failed to instantiate...problematic? The function might (transitively) reference a defined memory that wasn't initialized properly because the data segment never got copied because a previous segment was out of bounds:</p>\n<blockquote>\n<p>Each active segment is initialized in module-definition order. For each segment, if reading the source or writing the destination would go out of bounds, then instantiation fails at that point. Data that had already been written for previous (in-bounds) segments stays written.</p>\n</blockquote>\n<p>I'm not exactly sure why the bulk memory proposal did away with the upfront bounds checking on the segments at initialization time and explicitly allowed for these side effects to occur; of which there is no reasonable recovery other than completely throwing out any table or memory that was imported to the module that failed to instantiate as they are now in indeterminate states.</p>\n</blockquote>",
        "id": 228469255,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712924
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602179873\">PR Review</a>.</p>",
        "id": 228469256,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614712924
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585842532\">PR Review Comment</a>.</p>",
        "id": 228470139,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713268
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585842532\">PR Review Comment</a>.</p>",
        "id": 228470306,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713329
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585842532\">PR Review Comment</a>.</p>",
        "id": 228470401,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713376
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602187580\">PR Review</a>.</p>",
        "id": 228470685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713472
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585848469\">PR Review Comment</a>:</p>\n<blockquote>\n<p>In Lucet we implemented both strategies and benchmarked each under production loads. It turned out that initializing a Wasm page on each fault was more efficient than a single OS page. We didn't experiment with intermediate points in that design space but it makes sense to define a constant and we could try it!</p>\n</blockquote>",
        "id": 228470686,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713472
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602189495\">PR Review</a>.</p>",
        "id": 228471013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713608
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585849892\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Re: the order of <code>set_instance_memories</code> and <code>set_instance_tables</code>, these are setting up the <code>Instance</code>'s fields and both done prior to initialization, so the order doesn't matter.</p>\n<p>The order matters in <code>initialize_instance</code>, where <code>initialize_tables</code> is called before <code>initialize_memories</code> (with uffd enabled, <code>initialize_memories</code> isn't called so that the page fault handler can on-demand init the pages).</p>\n</blockquote>",
        "id": 228471015,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713608
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585849892\">PR Review Comment</a>.</p>",
        "id": 228471043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614713620
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602196725\">PR Review</a>.</p>",
        "id": 228472326,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714100
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585855435\">PR Review Comment</a>:</p>\n<blockquote>\n<p>we used to panic in the case where no event was available (<a href=\"https://github.com/bytecodealliance/lucet/blob/main/lucet-runtime/lucet-runtime-internals/src/region/uffd.rs#L203\">https://github.com/bytecodealliance/lucet/blob/main/lucet-runtime/lucet-runtime-internals/src/region/uffd.rs#L203</a>), but in our private production fork (ask me on slack) we no longer panic in this case, and instead log at the <code>warn</code> level and <code>break</code>. Despite lots of debugging we cannot determine why this behavior occurs, but it does not appear to cause any real problems. I recommend we do the same thing here, and if we never see the warning after we get some production time on it, we can change it back to a panic.</p>\n</blockquote>",
        "id": 228472327,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714100
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585842532\">PR Review Comment</a>.</p>",
        "id": 228472427,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714133
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585862658\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This thread just loops on a blocking read on uffd, which doesn't leave any mechanism to tear it down. With the change I suggested above, this is unreachable.</p>\n</blockquote>",
        "id": 228473847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714667
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602204975\">PR Review</a>.</p>",
        "id": 228473848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714667
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585862658\">PR Review Comment</a>.</p>",
        "id": 228473952,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614714715
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602210354\">PR Review</a>.</p>",
        "id": 228474791,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715049
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585866755\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I believe the instance's type (i.e. the fact that an exported table/memory's maximum would be unbounded vs. artificially constrained by the pooling allocator) is based on the table/memory plan from the <code>Module</code> and not from the runtime table/memory.  So Wasmtime API users would see the same limits as reported by the module for any exported tables or memories when using the on-demand allocator vs. the pooling allocator.</p>\n<p>This function, <code>Table::maximum</code> is only be called when attempting to grow the table.  Thus this is accurately reporting how far the runtime representation of the table can grow before it fails, which to me makes sense for the runtime's representation to report as constrained by the pooling allocator.</p>\n</blockquote>",
        "id": 228474792,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715049
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585866755\">PR Review Comment</a>.</p>",
        "id": 228475202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715189
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585866755\">PR Review Comment</a>.</p>",
        "id": 228475339,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715217
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602220688\">PR Review</a>.</p>",
        "id": 228476986,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715811
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585874814\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Random faults that would otherwise signal a <code>SIGSEGV</code> aren't sent to our fault handler as we only monitor specific regions of address space and they are protected in such a way (i.e .<code>read+write</code>) that the kernel should never signal a <code>SIGSEGV</code> normally itself (other than, perhaps as a failure to back one of our pages given we're massively over-committing the address space reservation).</p>\n</blockquote>",
        "id": 228476988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614715811
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602224350\">PR Review</a>.</p>",
        "id": 228477755,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716095
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585877709\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Your summary is correct.</p>\n<p>If we limit the recording of resettable guard page to only pages that could potentially be accessible in the future, the reset is basically telling the kernel memory manager that we want to start receiving the faults again for that page.  Upon the next fault we then get to decide to back the page or treat it once against as a guard page.</p>\n</blockquote>",
        "id": 228477756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716095
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602224554\">PR Review</a>.</p>",
        "id": 228477792,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716109
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585877851\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The usage of <code>nix</code> in <code>userfaultfd</code> is just to call ioctls and <code>read</code>. I don't think we've run into the funny spots of nix there but I understand your apprehension.</p>\n</blockquote>",
        "id": 228477793,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716109
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585877709\">PR Review Comment</a>.</p>",
        "id": 228477830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716124
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602228040\">PR Review</a>.</p>",
        "id": 228478411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716378
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585880645\">PR Review Comment</a>:</p>\n<blockquote>\n<p>With wizer (I believe) organizing initialized memories on page boundaries, I think an implementation that mmaps these pages CoW directly from the file might definitely be something to investigate for the future.  We could do the same for our cached compiled modules too.</p>\n<p>Granted the whole bulk memory side-effects thing might throw this stuff for a loop).</p>\n</blockquote>",
        "id": 228478413,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716378
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585880645\">PR Review Comment</a>.</p>",
        "id": 228478427,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716383
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602232327\">PR Review</a>.</p>",
        "id": 228478998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716609
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585882872\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>With wizer (I believe) organizing initialized memories on page boundaries</p>\n</blockquote>\n<p>Correct.</p>\n<p>It is also perhaps worth doing this kind of pre-processing of all modules' data segments when we compile them, so that we could hit this optimization unconditionally.</p>\n</blockquote>",
        "id": 228478999,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716609
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602239079\">PR Review</a>.</p>",
        "id": 228479577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716845
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585885371\">PR Review Comment</a>:</p>\n<blockquote>\n<p>As discussed in Slack, the fault handler will monitor for the regions being unmapped and when the count of regions being monitored hits zero, it should gracefully terminate.  This does require a slightly newer kernel version (4.11) compare to Lucet's uffd implementation, however.</p>\n<p>The hope with doing it this way is that we get around the weird \"POLLIN but can't read\" issue we're seeing from Lucet's non-blocking implementation by having blocking reads <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span> </p>\n</blockquote>",
        "id": 228479578,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716845
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585849892\">PR Review Comment</a>.</p>",
        "id": 228479960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614716998
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585874814\">PR Review Comment</a>.</p>",
        "id": 228481073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614717383
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602346858\">PR Review</a>.</p>",
        "id": 228501414,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614725462
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585969979\">PR Review Comment</a>:</p>\n<blockquote>\n<p>IIRC the bulk memory change was to spec memory initialization as <code>memory.init</code> instructions to make the spec a bit simpler, but I won't pretend to know all the intricacies there. I do believe, though, that it was acknowledged that functions could be put into tables which could reference not-fully-initialized memories at the time.</p>\n<p>For the ordering ah yeah good point, I think you're right in that a swap isn't necessary.</p>\n</blockquote>",
        "id": 228501415,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614725462
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602347890\">PR Review</a>.</p>",
        "id": 228501622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614725566
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585970758\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Aha ok then this already has the semantics I was hoping for, which is that the <code>Limits</code> as reported by wasmtime are always those written in the wasm module.</p>\n</blockquote>",
        "id": 228501623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614725566
    },
    {
        "content": "<p>tschneidereit submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-602837671\">PR Review</a>.</p>",
        "id": 228582370,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614774348
    },
    {
        "content": "<p>tschneidereit created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r586374254\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Granted the whole bulk memory side-effects thing might throw this stuff for a loop.</p>\n</blockquote>\n<p>Should this turn out to really throw a wrench in the works here, I wonder if that might be a reason to revisit this at the spec level? I know that bulk memory is stable, but this seems like a corner-case-y enough thing that perhaps there's some wiggle room?</p>\n</blockquote>",
        "id": 228582371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614774348
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-603253050\">PR Review</a>.</p>",
        "id": 228649187,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614798619
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r586705629\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think we can still do the preprocessing, similar to what this PR is doing in-memory, but due to the bulk memory spec's relaxation of the upfront bounds checking at initialization time, we'll have to enforce certain requirements to initialize memory this way:</p>\n<ul>\n<li>If any data segment references an imported table, use the existing memory initialization implementation (i.e. iterate the segments directly).</li>\n<li>If any data segment uses a global base, use the existing implementation (global bases, while immutable, are always an import).</li>\n<li>If neither of those are true, then we can organize the data segments into pages at compilation time; if a data segment is out of bounds, we stop the organization and set a flag indicating a segment went out of bounds.</li>\n</ul>\n<p>When initializing the instance, we would initialize tables first per the spec; an out of bounds element segment would fail the instantiation and memories wouldn't be initialized at all.</p>\n<p>When initializing the memories, if we're using the existing initialization strategy, we iterate the segments and copy the data, stopping if the segment was out of bounds and thus failing the instantiation.</p>\n<p>If we're using \"paged\" initialization, we copy (delayed for uffd) or, potentially, mmap all of the pages in the organized data and then check the flag to see if there was an out of bounds segment, returning failure to instantiate if that's the case.  This should maintain the \"partially initialized\" side effects allowed for in the bulk memory proposal, I think.</p>\n</blockquote>",
        "id": 228649188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614798620
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r586705629\">PR Review Comment</a>.</p>",
        "id": 228649327,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614798683
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r586705629\">PR Review Comment</a>.</p>",
        "id": 228649969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614798889
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-603478458\">PR Review</a>.</p>",
        "id": 228690935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614815794
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r586903291\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So I am correcting this to not treat \"out of bounds\" and \"paged\" initialization as two different variants; the \"paged\" initialization now records if an out of bounds segment was observed in addition to the pages that, up until that point, were initialized.</p>\n<p>The memory initialization process now first copies the \"successfully initialized up until the out of bounds access\" pages (or let's the uffd handler fill the pages as needed) before a trap is returned.  This should maintain the observable side-effects required by the bulk memory proposal.</p>\n</blockquote>",
        "id": 228690937,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614815794
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604572320\">PR Review</a>.</p>",
        "id": 228852650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614892935
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587834645\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So I've refactored this a little in a forthcoming push that makes <code>make_accessible</code> less generic sounding and explicitly related to protecting pages for linear memories (this also makes the semantics clearer when uffd is used).  <code>decommit</code> remains, but I don't think belongs on <code>Mmap</code> as the pages to decommit are rarely the entire mapping (the pooling alloctor tries to release the backing of a pages that were \"used\" for the instance, ensuring that new zero pages are mapped back in for the next instance).</p>\n<p>As such, I don't think there's much to do for this comment and I'm resolving it.</p>\n</blockquote>",
        "id": 228852651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614892935
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604586453\">PR Review</a>.</p>",
        "id": 228855072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614893954
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587845328\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So I'm going to push a change that removes the use of <code>MAP_NORESERVE</code>.  This was previously needed because the memory pool was being protected as <code>READ_WRITE</code> for the entire mapping (which is multiple TiB by default for 64-bit hosts).</p>\n<p>We now map the entire memory pool with protection <code>NONE</code>, which doesn't count towards overcommitlimits.</p>\n<p>When <code>uffd</code> is enabled, it marks <em>only</em> the pages that could potentially be accessible as <code>READ_WRITE</code> (and thus only this does count towards the overcommit limits).  This also means the user fault handler now <em>only</em> gets faults for pages that might be accessible depending on the linear memory's current size.</p>\n<p>This has the benefit of failing fast (when the pooling strategy is set in the <code>Config</code>) if the kernel doesn't think it can reserve <em>all</em> the backing space needed for the accessible pages; compared to receiving random <code>SIGSEGV</code> with <code>MAP_NORESERVE</code>, I think this is desirable.</p>\n<p>Resolving this conversation for now.</p>\n</blockquote>",
        "id": 228855073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614893954
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604590936\">PR Review</a>.</p>",
        "id": 228855972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614894325
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587848718\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm going to keep this current design rather than implementing free lists for the memory and table pools as I think it's desirable that the module limits guarantees <code>N</code> number of instances can be created, provided the modules being instantiated conform to the limits, rather than allow for memory or table pool exhaustion causing instantiation failures.</p>\n<p>I think this is easier for users to reason about.  Resolving this conversation for now.</p>\n</blockquote>",
        "id": 228855974,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614894325
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228885317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910150
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604740862\">PR Review</a>.</p>",
        "id": 228885590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910316
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587974682\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Resolving as we're going to keep the current design where we guarantee an instance can allocate provided 1) the module conforms to the module limits and 2) the maximum number of instances hasn't been reached.</p>\n<p>We can address this in the future if this needs to change.</p>\n</blockquote>",
        "id": 228885591,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910317
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587975248\">PR Review Comment</a>:</p>\n<blockquote>\n<p>While <code>MemoryPool</code> and <code>TablePool</code> have a lot of overlap, they differ a bit from <code>InstancePool</code> and <code>StackPool</code> to be entirely generic.</p>\n<p>Consolidating <code>MemoryPool</code> and <code>TablePool</code> probably isn't worth it as the impls are pretty small.</p>\n<p>Resolving this as \"won't fix\" since we're not changing <code>MemoryPool</code> and <code>TablePool</code> to maintain their own free lists.</p>\n</blockquote>",
        "id": 228885739,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910414
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604741965\">PR Review</a>.</p>",
        "id": 228885740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910414
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228886205,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910704
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228886303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614910795
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604750516\">PR Review</a>.</p>",
        "id": 228887369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911554
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587981452\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm going to land this PR without lifting the fiber creation implementation in <code>wasmtime-fiber</code>.  I've opened #2708 to track the follow-up work.</p>\n</blockquote>",
        "id": 228887370,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911554
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r585220206\">PR Review Comment</a>.</p>",
        "id": 228887490,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911636
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604754486\">PR Review</a>.</p>",
        "id": 228887676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911739
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587982997\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The pooling instance allocator now protects statically known guard pages as <code>NONE</code> and will only change protections on pages that could potentially be accessible in the future.</p>\n<p>The uffd implementation now only receives the faults for the potentially accessible pages as well.</p>\n</blockquote>",
        "id": 228887678,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911739
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604755556\">PR Review</a>.</p>",
        "id": 228887920,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911916
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587985916\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This code has been eliminated and we now just set the protection on the stack guard page to <code>NONE</code> without relying on the page fault handler to treat it as a guard page access (it'll never receive the fault event for the stack guard page).</p>\n<p>I still think we should have an async feature test that will hit the guard page and crash to verify both the <code>wasmtime-fiber</code> implementation and the pooling allocator implementation.</p>\n</blockquote>",
        "id": 228887921,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911916
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r587985916\">PR Review Comment</a>.</p>",
        "id": 228887940,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614911942
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228895409,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614917710
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604904839\">PR Review</a>.</p>",
        "id": 228913830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614932910
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588114791\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Fixed this in the <code>wasmtime</code> crate as returning a \"table out of bounds\" trap (the only trap code that would make sense to return from this runtime function) here for mismatched type seems wrong; this is an API bug anyway since mismatched type shouldn't pass module validation.</p>\n</blockquote>",
        "id": 228913831,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614932910
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-604905177\">PR Review</a>.</p>",
        "id": 228913871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614932940
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588115099\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Fixed this in the <code>wasmtime</code> crate as returning a \"table out of bounds\" trap (the only trap code that would make sense to return from this runtime function) here for mismatched table types seems wrong; this is an API bug anyway since mismatched table types shouldn't pass module validation.</p>\n</blockquote>",
        "id": 228913872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614932940
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 228917149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614934294
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229052881,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614994762
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-605713093\">PR Review</a>.</p>",
        "id": 229053043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614994919
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588811382\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>Table</code> now stores by raw pointers for both \"static\" and \"dynamic\" storage, so these assumptions are now being enforced via <code>TableElement</code>.</p>\n</blockquote>",
        "id": 229053044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614994919
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-605713235\">PR Review</a>.</p>",
        "id": 229053140,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614994962
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588811528\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm going to punt on this test for now as it isn't specific to the pooling allocator and add it as part of #2708. </p>\n</blockquote>",
        "id": 229053141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614994962
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-605716723\">PR Review</a>.</p>",
        "id": 229055273,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614996639
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588816005\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm leaning towards just leaving this as-is and not boxing a trait-object in the static case; I'm of the opinion that the <code>MemoryStorage</code> enum doesn't complicate it all <em>that</em> much (it's a pretty small amount of code) and not having to box a trait object will be desirable for Lucet-like use cases.  Marking this as resolved.</p>\n</blockquote>",
        "id": 229055274,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614996639
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229056833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1614998201
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229065576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615006599
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229068101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615008522
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229068150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615008586
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229070126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615010461
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229071773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615012143
    },
    {
        "content": "<p><strong>peterhuene</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> and <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a>.</p>",
        "id": 229073899,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615014315
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-605442843\">PR Review</a>.</p>",
        "id": 229323708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-605442843\">PR Review</a>.</p>",
        "id": 229323709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589512555\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I've been thinking about this storage here and have been waffling a bit on what to do about this. I think that this works today, but only just. The thing I'm worried about is that a memory doesn't really \"belong\" to an instance after creation because it can be used in any number of other instances/locations. (or directly from the wasmtime API itself)</p>\n<p>I was originally worried that if a different instance than the defining instance faulted the memory that the guard page recording would go to the wrong place. Since it's done by the instance's index in the pooling allocator, though, that should be fine. I was then worried about the wasmtime <code>Memory::grow</code> API, but that also turned out to be ok because it's routed through <code>Instance::memory_grow</code> (which I forgot).</p>\n<p>It does sort of feel like we're close to the edge, though, and perhaps it'd be best to store this in the <code>Memory</code> itself rather than in the instance?</p>\n</blockquote>",
        "id": 229323710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589504543\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think that we need to be careful here since running the dtor of the <code>VMExternRef</code> could run arbitrary code. I think that this should swap the pointers first, and then destroy the previous pointer to ensure if the dtor accesses/aliases the table it can't alias itself (and the table is in a valid state)</p>\n</blockquote>",
        "id": 229323711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r588497470\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To avoid the extra <code>cfg_if!</code> here I think this could implement the new parameter as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">USE_PAGED_MEM_INIT</span>: <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">cfg!</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"uffd\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"fm\">cfg!</span><span class=\"p\">(</span><span class=\"n\">target_os</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"linux\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and that I think means that the overall structure here could remain the same?</p>\n</blockquote>",
        "id": 229323712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589522219\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this update the <code>Resource</code> variant to store an <code>anyhow::Error</code>? Otherwise this I think is losing the original source of the error by calling <code>.to_string()</code></p>\n</blockquote>",
        "id": 229323713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589528420\">PR Review Comment</a>:</p>\n<blockquote>\n<p>To confirm, by calling <code>mmap</code> here the kernel basically just zeros out the pages if read/write is requested? I wasn't actually aware of that behavior of mmap, could that be added as a small comment here?</p>\n</blockquote>",
        "id": 229323714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589529732\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Cut off sentence?</p>\n</blockquote>",
        "id": 229323716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589537893\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think this comment may want to be updated from the other comment that looks like this as well. By my reading it's not enough to just zero the pages, but we also need to guarantee that all future faults to these pages to through to uffd, right? So this is technically both zero-ing and ensuring that faults get routed right?</p>\n</blockquote>",
        "id": 229323718,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589530802\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Shouldn't <code>max_memories</code> play into this computation somewhere as well?</p>\n</blockquote>",
        "id": 229323719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615219558
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-606496009\">PR Review</a>.</p>",
        "id": 229333832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222294
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589580501\">PR Review Comment</a>:</p>\n<blockquote>\n<p>As this is a fixed mapping at the same address, it effectively discards the existing pages and remaps them to the CoW zero page (because of being both private and <code>PROT_READ</code>|<code>PROT_WRITE</code>).</p>\n</blockquote>",
        "id": 229333833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222294
    },
    {
        "content": "<p>peterhuene edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589580501\">PR Review Comment</a>.</p>",
        "id": 229333856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222304
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-606497317\">PR Review</a>.</p>",
        "id": 229334067,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222372
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589581654\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It does in <code>MemoryPool::get</code>.</p>\n<p>This loop is to get the base address of every memory in the pool.</p>\n</blockquote>",
        "id": 229334068,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222372
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-606499854\">PR Review</a>.</p>",
        "id": 229334555,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222528
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589584154\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh clever I missed that! Even though the <code>for</code> was staring at me in the face...</p>\n</blockquote>",
        "id": 229334557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222528
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#pullrequestreview-606503391\">PR Review</a>.</p>",
        "id": 229335179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222743
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518#discussion_r589587158\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed that this probably makes more sense in <code>Memory</code>.  I'll move it there.</p>\n</blockquote>",
        "id": 229335181,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615222743
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229340861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615224690
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229342026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615225135
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229342937,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615225503
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229358405,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615231251
    },
    {
        "content": "<p>peterhuene updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a> from <code>add-allocator</code> to <code>main</code>.</p>",
        "id": 229359496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615231657
    },
    {
        "content": "<p>peterhuene merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2518\">PR #2518</a>.</p>",
        "id": 229367478,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615234919
    }
]