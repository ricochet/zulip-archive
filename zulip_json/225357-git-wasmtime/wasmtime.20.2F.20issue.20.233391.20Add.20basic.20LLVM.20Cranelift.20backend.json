[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-928237139\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>Hi @bjorn3 -- thanks for the PR; a few questions and thoughts:</p>\n<ul>\n<li>\n<p>Can you say more about your intended use-case for this? Did this approach arise to solve a specific problem or are you wanting to expand the array of backends in general?</p>\n</li>\n<li>\n<p>The maintenance burden of adding a new backend is nontrivial; in this case, both when CLIF changes, on the input side of this translator, and when LLVM's API changes, on the output side of this translator. It is also another translation layer to test in some way, and another potential source of bugs. With that in mind, I'm somewhat concerned about the prospect of accepting this, unless or until a compelling use-case arises for which we don't have a better answer.</p>\n</li>\n<li>\n<p>This potentially also spawns some conversations about our goals and vision w.r.t. compiler backends. We've been gradually steering in a direction to where we have a focus in Cranelift on correctness (especially with recent efforts on different kinds of fuzzing, and with allowance for verification efforts in ISLE), while maintaining a reasonable level of speed, and in general adding multiple compiler frameworks might diffuse the efforts toward those goals. This point definitely deserves further discussion, but at least right now I would prefer to try to solve issues and needs by addressing them within the main Cranelift infrastructure, unless there is clearly a very different use-case that can't work that way.</p>\n</li>\n<li>\n<p>Given the above, would it be a possibility for this translator to be maintained in a separate repository? It looks to me like this crate basically consumes the public CLIF definitions in order to translate CLIF, so I suspect nothing would technically prevent this. There is of course the overhead of tracking changes, and we don't guarantee the stability of Cranelift APIs (only Wasmtime APIs) in this repo, but as mentioned above this work has to happen either way; the question is just where the management burden lies.</p>\n</li>\n</ul>\n<p>Thoughts? I'm interested to hear what others think as well!</p>\n</blockquote>",
        "id": 255113257,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632773830
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-928237139\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>Hi @bjorn3 -- thanks for the PR; a few questions and thoughts:</p>\n<ul>\n<li>\n<p>Can you say more about your intended use-case for this? Did this approach arise to solve a specific problem or are you wanting to expand the array of backends in general?</p>\n</li>\n<li>\n<p>The maintenance burden of adding a new backend is nontrivial; in this case, both when CLIF changes, on the input side of this translator, and when LLVM's API changes, on the output side of this translator. It is also another translation layer to test in some way, and another potential source of bugs. With that in mind, I'm somewhat concerned about the prospect of accepting this, unless or until a compelling use-case arises for which we don't have a better answer.</p>\n</li>\n<li>\n<p>This potentially also spawns some conversations about our goals and vision w.r.t. compiler backends. We've been gradually steering in a direction to where we have a focus in Cranelift on correctness (especially with recent efforts on different kinds of fuzzing, and with allowance for verification efforts in ISLE), while maintaining a reasonable level of speed, and in general adding multiple compiler frameworks might diffuse the efforts toward those goals. This point definitely deserves further discussion, but at least right now I would prefer to try to solve issues and needs by addressing them within the main Cranelift infrastructure, unless there is clearly a very different use-case that can't work that way.</p>\n</li>\n<li>\n<p>Given the above, would it be a possibility for this translator to be maintained in a separate repository? It looks to me like this crate basically consumes the public CLIF definitions in order to translate CLIF, so I suspect nothing would technically prevent this. There is of course the overhead of tracking changes, and we don't guarantee the stability of Cranelift APIs (only Wasmtime APIs) in this repo, but as mentioned above this work has to happen either way; the question is just where the maintenance burden lies.</p>\n</li>\n</ul>\n<p>Thoughts? I'm interested to hear what others think as well!</p>\n</blockquote>",
        "id": 255113692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632774018
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-928248450\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<blockquote>\n<p>Can you say more about your intended use-case for this? Did this approach arise to solve a specific problem or are you wanting to expand the array of backends in general?</p>\n</blockquote>\n<p>A combination of because I can, because it helps with detecting cases where I depend on the fact that Cranelift doesn't optimize a lot (I already found two in cg_clif: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/issues/1199\">https://github.com/bjorn3/rustc_codegen_cranelift/issues/1199</a> I am curious how much breaks in cg_clif when enabling more optimizations.) and because it could be useful when you want high runtime performance without duplicating a backend for fast unoptimized compilation. It could also be used to prototype clif ir changes for new features before the regular cranelift backends gain support for it to eg see if the changes don't put undue burden on clif ir producers. It also seems that cg_clif + this backend produces faster code than cg_llvm in debug mode despite cg_llvm using more optimization passes. Didn't benchmark compilation times though.</p>\n<blockquote>\n<p>The maintenance burden of adding a new backend is nontrivial</p>\n</blockquote>\n<p>I see</p>\n<blockquote>\n<p>Given the above, would it be a possibility for this translator to be maintained in a separate repository?</p>\n</blockquote>\n<p>That would be an option.</p>\n</blockquote>",
        "id": 255114919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632774574
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-928252116\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<blockquote>\n<p>because it helps with detecting cases where I depend on the fact that Cranelift doesn't optimize a lot (I already found two in cg_clif: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/issues/1199\">bjorn3/rustc_codegen_cranelift#1199</a> I am curious how much breaks in cg_clif when enabling more optimizations.)</p>\n</blockquote>\n<p>This may actually help with the correctness goal of Cranelift by finding inaccuracies between the documented semantics of clif ir around for example the memory model and the actual implementation in the backends. As we don't have a lot of optimizations yet it is very easy for violations of the memory model to compile to something that works anyway. The memory model of clif ir includes flags like readonly, notrap and aligned.</p>\n</blockquote>",
        "id": 255115449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632774809
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-929606455\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>@bjorn3 Interesting -- thanks for elaborating on the uses a bit here! While the differential testing possibilities that this could allow may be nice in some ways, I think overall the maintenance overhead (and the overhead of testing the translator itself) tips the balance toward keeping this outside the tree, in its own repository, for now. In the future if it becomes a very useful or popular option then of course this can be reconsidered but maybe not today, with our existing resources. Does that seem reasonable to you?</p>\n</blockquote>",
        "id": 255295067,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632861441
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-929612731\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>Sure, that is reasonable.</p>\n</blockquote>",
        "id": 255296467,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632862022
    },
    {
        "content": "<p>Anutrix <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-1585872228\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>Was this ever moved to a separate repository?</p>\n</blockquote>",
        "id": 365213960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686443121
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391#issuecomment-1586043119\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3391\">issue #3391</a>:</p>\n<blockquote>\n<p>No it was not, but I intentionally didn't delete the branch of this PR to ensure it can be picked up again.</p>\n</blockquote>",
        "id": 365247136,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686466156
    }
]