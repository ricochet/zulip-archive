[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4167\">issue #4167</a>:</p>\n<blockquote>\n<p>In #4163, we have an alias analysis that right now we will use to eliminate redundant loads.</p>\n<p>However, in principle we could also eliminate dead stores -- stores that are not observed and that are known to be overwritten by some other store, hence completely invisible.</p>\n<p>This is quite a bit more complicated in a world where traps exist and precise state must be observed at the trap point (and where the store itself can trap); so we should carefully evaluate whether this is actually worth it, and whether much opportunity exists under these constraints. But it may still be worthwhile.</p>\n<p>We will at least need to ensure that:</p>\n<ul>\n<li>The store can be proved not to trap (e.g., another access to the same memory category dominates this store, with the same or a greater address/offset);</li>\n<li>There is another store to the same address that postdominates this store (all paths from this store go through the postdominating aliasing store eventually);</li>\n<li>No loads observe, or even may observe, the store (no loads in the same memory category);</li>\n<li>No trapping instructions, calls, or fences/atomics between the store and the shadowing store.</li>\n</ul>\n</blockquote>",
        "id": 283005073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653002552
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4167\">issue #4167</a>:</p>\n<blockquote>\n<p>In #4163, we have an alias analysis that right now we will use to eliminate redundant loads.</p>\n<p>However, in principle we could also eliminate dead stores -- stores that are not observed and that are known to be overwritten by some other store, hence completely invisible.</p>\n<p>This is quite a bit more complicated in a world where traps exist and precise state must be observed at the trap point (and where the store itself can trap); so we should carefully evaluate whether this is actually worth it, and whether much opportunity exists under these constraints. But it may still be worthwhile.</p>\n<p>We will at least need to ensure that:</p>\n<ul>\n<li>The store can be proved not to trap (e.g., another access to the same memory category dominates this store, with the same or a greater address/offset);</li>\n<li>There is another store to the same address that postdominates this store (all paths from this store go through the postdominating aliasing store eventually);</li>\n<li>No loads observe, or even may observe, the store (no loads in the same memory category);</li>\n<li>No trapping instructions, calls, or fences/atomics between the store and the shadowing store.</li>\n</ul>\n</blockquote>",
        "id": 283005088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653002564
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4167\">issue #4167</a>:</p>\n<blockquote>\n<p>In #4163, we have an alias analysis that right now we will use to eliminate redundant loads.</p>\n<p>However, in principle we could also eliminate dead stores -- stores that are not observed and that are known to be overwritten by some other store, hence completely invisible.</p>\n<p>This is quite a bit more complicated in a world where traps exist and precise state must be observed at the trap point (and where the store itself can trap); so we should carefully evaluate whether this is actually worth it, and whether much opportunity exists under these constraints. But it may still be worthwhile.</p>\n<p>We will at least need to ensure that:</p>\n<ul>\n<li>The store can be proved not to trap (e.g., another access to the same memory category dominates this store, with the same or a greater address/offset);</li>\n<li>There is another store to the same address that postdominates this store (all paths from this store go through the postdominating aliasing store eventually);</li>\n<li>No loads observe, or even may observe, the store (no loads in the same memory category);</li>\n<li>No trapping instructions, calls, or fences/atomics between the store and the shadowing store.</li>\n</ul>\n</blockquote>",
        "id": 283005090,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653002567
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4167\">issue #4167</a>:</p>\n<blockquote>\n<p>In #4163, we have an alias analysis that right now we will use to eliminate redundant loads.</p>\n<p>However, in principle we could also eliminate dead stores -- stores that are not observed and that are known to be overwritten by some other store, hence completely invisible.</p>\n<p>This is quite a bit more complicated in a world where traps exist and precise state must be observed at the trap point (and where the store itself can trap); so we should carefully evaluate whether this is actually worth it, and whether much opportunity exists under these constraints. But it may still be worthwhile.</p>\n<p>We will at least need to ensure that:</p>\n<ul>\n<li>The store can be proved not to trap (e.g., another access to the same memory category dominates this store, with the same or a greater address/offset);</li>\n<li>There is another store to the same address that postdominates this store (all paths from this store go through the postdominating aliasing store eventually);</li>\n<li>No loads observe, or even may observe, the store (no loads in the same memory category);</li>\n<li>No trapping instructions, calls, or fences/atomics between the store and the shadowing store.</li>\n</ul>\n</blockquote>",
        "id": 283005095,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653002571
    }
]