[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5686\">issue #5686</a>:</p>\n<blockquote>\n<p>It's a footgun: they will always succeed (should be using <code>if-let</code> to match on the result of the value, not <code>if</code> on whether anything is matchable).</p>\n<p>See #5684 where this bit us (me) in practice.</p>\n</blockquote>",
        "id": 325263674,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675284064
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5686\">issue #5686</a>:</p>\n<blockquote>\n<p>It's a footgun: they will always succeed (should be using <code>if-let</code> to match on the result of the value, not <code>if</code> on whether anything is matchable).</p>\n<p>See #5684 where this bit us (me) in practice.</p>\n</blockquote>",
        "id": 325263676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675284065
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5686#issuecomment-1412788447\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5686\">issue #5686</a>:</p>\n<blockquote>\n<p>I thought this would be something I could hack together between meetings, but it's trickier than I thought.</p>\n<p>First off, I believe we can't do this during parsing/AST construction. We don't necessarily know whether a term is partial at that point since we may not have parsed its declaration yet.</p>\n<p>During semantic analysis, we've already rewritten <code>(if foo)</code> into <code>(if-let _ foo)</code>, so we can't reject total terms only when they're inside an <code>if</code> construct. That's not a bad thing though, because really we shouldn't allow infallible <code>if-let</code> either.</p>\n<p>An infallible <code>if-let</code> occurs if both the left-hand pattern and the right-hand expression are infallible/non-partial. That's not completely trivial to determine, in that we can't just check the top-level of either. We have to recurse through the whole subtree and reason about how, for example, and-patterns or let-binding expressions interact with match failures. Not a huge deal, but not \"hack together between meetings\" material.</p>\n<p>There are some complicated cases. For one, <code>(if-let x (...))</code> may be infallible, in which case it's almost equivalent to a let-binding expression. However that might be useful as the only way to let-bind an expression for use in multiple <code>if-let</code>s. And <code>(if-let (extractor x) (...))</code> is the only way to call an extractor on an arbitrary expression, so even if the extractor is infallible this pattern could be necessary.</p>\n<p>We could add a <code>(let)</code> construct for the left-hand side of a rule: functionally it would be identical to <code>if-let</code> but would suppress this infallible-if check and capture the rule-author's intent better.</p>\n<p>I wondered if this would be any easier to check on the <code>trie_again</code> representation, after semantic analysis. This bug would show up as an unused binding-site. However, right now we generate unused binding sites in other ways that are harmless. Also, this is a property of a single rule, but we only build that representation on the combined set of all rules for a term, so determining where a binding site is \"used\" is non-trivial. So I think this is best done in semantic analysis.</p>\n<p>Independent of this current issue, we should also consider checking for unused variable bindings, and checking that let-bindings only bind <code>_</code> for impure expressions.</p>\n</blockquote>",
        "id": 325275871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675288541
    }
]