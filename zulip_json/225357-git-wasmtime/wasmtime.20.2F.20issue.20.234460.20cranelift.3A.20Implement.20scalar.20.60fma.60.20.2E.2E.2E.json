[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1186230721\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"cranelift:area:aarch64\", \"cranelift:area:machinst\", \"cranelift:area:x64\", \"cranelift:module\", \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 289835420,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657988371
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1190894891\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>I keep trying to review this but finding too many things I don't understand about Cranelift yet. So I'll ask some questions instead. I think there are three main things happening in this PR:</p>\n<ol>\n<li>\n<p>You've moved <code>make_libcall_sig</code> from <code>isa::x64::lower</code> to <code>ir::libcall</code> and renamed it to <code>Libcall::signature</code>. This seems related to a nearby comment in the existing code: \"TODO avoid recreating signatures for every single Libcall function.\" But in doing so you lose access to the <code>ir::Inst</code> that the libcall came from, so you have to list the input and output types for every libcall in the <code>signature</code> method.</p>\n</li>\n<li>\n<p>You've plumbed a <code>target_lexicon::Triple</code> through a bunch of functions. I think this is because <code>libcall_3_ret_1</code> needs it to call <code>emit_vm_call</code> but only has access to the x64 <code>IsleContext</code>, so you have to thread the triple through to <code>lower_common</code> in order to stash it there.</p>\n</li>\n<li>\n<p>You're exposing x64's <code>emit_vm_call</code> to ISLE via a new <code>libcall_3_ret_1</code> helper, and using that to write lowering rules for <code>fma</code>.</p>\n</li>\n</ol>\n<p>Does that cover everything you did in this PR?</p>\n<p>I would find this easier to review without change (1), or if you pass the <code>ir::Inst</code> to <code>Libcall::signature</code> so its implementation is identical to <code>make_libcall_sig</code>. But I'm guessing the way you have it now is better because it means this function can be reused by other target backends, right?</p>\n<p>I'm curious if the target triple is reachable through one of the other fields that's already in the <code>IsleContext</code>, or if there's a way to get the right libcall calling convention in <code>emit_vm_call</code> without using the triple. I'm guessing no, or you probably would have used it, but it may be worth double-checking. If it's possible to get rid of the tedious changes for (2), that would make this patch a lot more readable.</p>\n<p>Step (3) seems like it's simple enough that it can't be wrong, but I haven't read up on the details of ISLE yet.</p>\n<p>The other thing I'd like to know is whether anybody is using the <code>fma</code> CLIF instruction. It looks to me like wasmtime does not use it, so I assume it's here for use by one of the other frontends, but it would be nice to verify that.</p>\n<p>I think @cfallin or @fitzgen will need to review this but I hope my notes can at least help guide that review.</p>\n</blockquote>",
        "id": 290317035,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658362493
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1191157605\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I keep trying to review this but finding too many things I don't understand about Cranelift yet.</p>\n</blockquote>\n<p>Thanks for reviewing either way!</p>\n<blockquote>\n<p>You've moved make_libcall_sig from isa::x64::lower to ir::libcall and renamed it to Libcall::signature. This seems related to a nearby comment in the existing code: \"TODO avoid recreating signatures for every single Libcall function.\" But in doing so you lose access to the ir::Inst that the libcall came from, so you have to list the input and output types for every libcall in the signature method.</p>\n</blockquote>\n<p>I think that comment still applies, we are still creating a new signature every time we lower <code>fma</code> even if we could cache (or precompute) that, since the signature isn't going to change.</p>\n<p>Losing the <code>Inst</code> is a bit more deliberate, the previous code was essentially just copying the <code>Inst</code> signature into a <code>LibCall</code> signature, which doesen't seem very correct to me. I've centralized the signatures in <code>LibCall</code> since they should be pretty much equal across arches, but this may be wrong as well.</p>\n<p>I think using <code>Inst</code> can also lead to a situation where we put a libcall in a rule, and use it in a different instruction lowering and then copy the wrong signature. An example would be calling <code>nearest</code> in the <code>div</code> instruction lowering and use the signature from <code>div</code> when emitting the libcall for <code>nearest</code></p>\n<blockquote>\n<p>I'm curious if the target triple is reachable through one of the other fields that's already in the IsleContext, or if there's a way to get the right libcall calling convention in emit_vm_call without using the triple. I'm guessing no, or you probably would have used it, but it may be worth double-checking. If it's possible to get rid of the tedious changes for (2), that would make this patch a lot more readable.</p>\n</blockquote>\n<p>Yeah, I couldn't find it, but would appreciate a double check on that.</p>\n<blockquote>\n<p>Does that cover everything you did in this PR?</p>\n</blockquote>\n<p>Yeah pretty much.</p>\n<blockquote>\n<p>The other thing I'd like to know is whether anybody is using the fma CLIF instruction. It looks to me like wasmtime does not use it, so I assume it's here for use by one of the other frontends, but it would be nice to verify that.</p>\n</blockquote>\n<p>I don't think so, since it is not implemented right now, but at least <code>rustc_codegen_cranelift</code> side steps the issue by calling the libcall directly both for <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/11007c02f70130cdc70b98f0909e5c150a2751a6/src/intrinsics/simd.rs#L336-L337\">SIMD</a> and the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/a298c6908e443fc689c474750df26d82301fd74f/src/intrinsics/mod.rs#L297-L298\">scalar</a> version of this instruction.</p>\n<p>Thanks!<br>\n</p>\n</blockquote>",
        "id": 290343850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658389598
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1201711532\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>@cfallin Would it be possible to review this? The Fma op isn't that important (we have a better implementation on #4539), but the libcall mechanism is something that we need to lower other i128 ops and this is sort of blocking that.</p>\n<p>Changes since @jameysharp 's review:</p>\n<ul>\n<li>Renamed <code>libcall_3_ret_1</code> to <code>libcall_3</code></li>\n<li>Enabled FMA on fuzzer</li>\n</ul>\n</blockquote>",
        "id": 291632577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659387375
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for FMA. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports these relocations, so we should also be good there.</p>\n<p>And #4453 allows us to test them with runtests.</p>\n</blockquote>",
        "id": 291742071,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659461645
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for FMA. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports these relocations, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests.</p>\n</blockquote>",
        "id": 291742301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659461774
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for FMA. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports these relocations, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests. This does cause a panic if no relocations are performed which is the state of the current runtest suite (and why we don't add tests in this PR)</p>\n</blockquote>",
        "id": 291742423,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659461865
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for <code>fma</code>. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports these relocations, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests. This does cause a panic if no relocations are performed which is the state of the current runtest suite (and why we don't enable the <code>fma</code> tests in this PR)</p>\n</blockquote>",
        "id": 291742450,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659461882
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for <code>fma</code>. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports these relocations, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests. This does cause a panic if no relocations are performed which is the state of the current runtest suite (and why we don't enable the <code>fma</code> tests in this PR).</p>\n</blockquote>",
        "id": 291742538,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659461909
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for <code>fma</code>. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports handling relocations for these functions, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests. This does cause a panic if no relocations are performed which is the state of the current runtest suite (and why we don't enable the <code>fma</code> tests in this PR).</p>\n</blockquote>",
        "id": 291743063,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462195
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203022435\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't see an actual libcall implementation here -- I guess it will result in a panic if used today in e.g. the Wasmtime embedding (but that's fine since the cranelift-wasm frontend won't use the opcode)? Or is it already implemented in cranelift-jit?</p>\n</blockquote>\n<p>Sorry, I don't quite understand understand.</p>\n<p>We implement a libcall lowering for <code>fma</code>. We already have libcall's in the x86 backend, but not in isle yet (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c77bec4dcb33973a386d924474d95bab6b23e263/cranelift/codegen/src/isa/x64/lower.rs#L1970-L1975\"><code>ceil</code> lowering without SSE42</a>).</p>\n<p>So this is already reachable from wasmtime (from the <code>ceil</code> instruction). <code>cranelift-jit</code> already supports handling relocations for these functions, so we should also be good there. And I assume that those instructions already work in wasmtime (without SSE42).</p>\n<p>And #4453 allows us to test them with runtests. This does cause a Illegal Instruction if no relocations are performed which is the state of the current runtest suite (and why we don't enable the <code>fma</code> tests in this PR).</p>\n</blockquote>",
        "id": 291743162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462242
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203034723\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>I guess I meant specifically for <code>fma</code> -- this PR adds two new libcalls, <code>FmaF32</code> and <code>FmaF64</code>, and I didn't see implementations of them. I was wondering if these implementations were coming later, or in general what the plan for them is? (Or perhaps I've missed them somewhere, but grepping for <code>FmaF32</code> in the existing tree isn't showing anything.)</p>\n</blockquote>",
        "id": 291743516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462445
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203039565\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>We don't implement them, in <code>cranelift-jit</code> we expect them to be provided when linking. We translate the <code>FmaF{32,64}</code> enum to the <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460/files#diff-bf8e49ed20f8a7f2357e0f61e6628747405c1ca78cb68a0c564e3768ad1c8e03R73-R74\">libcall name (<code>fmaf</code> and <code>fma</code>) in <code>cranelift-module</code></a> and from there the linker finds those functions for us. We search libc / msvcrt / whatever native runtime by default in <code>cranelift-jit</code>.</p>\n<p>I don't know how this works in Wasmtime, if we always need to provide those functions or if we also get them from the system.</p>\n</blockquote>",
        "id": 291744161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462770
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203039565\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>We don't implement them. In <code>cranelift-jit</code> we expect them to be provided when linking. We translate the <code>FmaF{32,64}</code> enum to the <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460/files#diff-bf8e49ed20f8a7f2357e0f61e6628747405c1ca78cb68a0c564e3768ad1c8e03R73-R74\">libcall name (<code>fmaf</code> and <code>fma</code>) in <code>cranelift-module</code></a> and from there the linker finds those functions for us. We search libc / msvcrt / whatever native runtime by default in <code>cranelift-jit</code>.</p>\n<p>I don't know how this works in Wasmtime, if we always need to provide those functions or if we also get them from the system.</p>\n</blockquote>",
        "id": 291744253,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462816
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460#issuecomment-1203042095\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4460\">issue #4460</a>:</p>\n<blockquote>\n<p>OK, that seems fine to me; just want to confirm that I wasn't missing something! It is at least a loud failure if someone tries to use the lowering in their own embedding and finds that the libcall isn't provided/implemented, so this shouldn't be a problem.</p>\n</blockquote>",
        "id": 291744541,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659462946
    }
]