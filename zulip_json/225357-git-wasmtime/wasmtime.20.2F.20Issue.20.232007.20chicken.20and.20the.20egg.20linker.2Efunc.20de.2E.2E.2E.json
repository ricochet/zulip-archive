[
    {
        "content": "<p>softprops opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>I'm running into a problem with the current <a href=\"https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Linker.html#method.func\"><code>Linker.func</code></a> api as it relates to the wiring of a wasm runtime.</p>\n<p>The following illustrates a problem I'm having where in order to instantiate a <code>Module</code>, one must configure a linker's functions. In my case this runtime is expected to provide a an implementation of a number of module functions. When they are not defined wasi's call to  instantiate a <code>Module</code> fails with very useful error reporting describing the missing implementation and its type signature. However in order to define those linker functions I would require the instantiated modules <code>Memory</code> reference if I understand this system currently.</p>\n<p>I'm new to wasm so I may be missing something here but presumably the example below is a more helpful and fill the gaps I'm not sure how to describe yet.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasmtime_wasi</span>::<span class=\"p\">{</span><span class=\"n\">Wasi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">WasiCtxBuilder</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">byteorder</span>::<span class=\"n\">ByteOrder</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">engine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Engine</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Linker</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wasi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wasi</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">WasiCtxBuilder</span>::<span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">inherit_stdout</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">inherit_stderr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">wasi</span><span class=\"p\">.</span><span class=\"n\">add_to_linker</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// the egg exists here. The egg needs the a reference chicken&#39;s memory</span>\n<span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"s\">&quot;mod_name&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"s\">&quot;fn_name&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">|</span><span class=\"n\">offset_arg0</span>: <span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"c1\">// performs some computation then updates the instances Memory</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">some_computed_result</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">byteorder</span>::<span class=\"n\">LittleEndian</span>::<span class=\"n\">write_u32</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">data_unchecked_mut</span><span class=\"p\">()[</span><span class=\"n\">offset_arg0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"o\">..</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">some_computed_result</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// the chicken is born here the chicken can not be born without the linker being defining the implementation</span>\n<span class=\"c1\">// of `mod_name::fn_name`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Module</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"s\">&quot;path/to/app.wasm&quot;</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">get_memory</span><span class=\"p\">(</span><span class=\"s\">&quot;memory&quot;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">&quot;all instances should have memory. this one does not&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I'm basing this Rust application off of an implementation in go-wasmtime which orchestrates this all in the the setup of of a structs <code>NewFoo</code> func where the reference to memory can be <code>nil</code> at the time of link definition. This is made slightly more challenging with rusts memory module and references to \"self\" and/or any external closure references inside <code>linker.func()</code> </p>\n<p>I can fill in more concrete details if needed but I'm wondering if it's clear I'm missing something very fundamental right out of the gate with wasmtime's expected api usage.</p>\n</blockquote>",
        "id": 203502262,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594385374
    },
    {
        "content": "<p>Rochet2 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007#issuecomment-656676636\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>Only one memory is allowed. Both modules would point to same memory if one creates the memory and the other imports it for example.</p>\n<p>From what I understand, a host function can have <code>caller: Caller</code> as parameter. This is shown in the <a href=\"https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Linker.html#examples-3\">examples</a>. The <code>Caller</code> allows you to <a href=\"https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Caller.html#method.get_export\">get an export</a>, for example if the module exports memory you can access it.</p>\n<p>I guess one issue I see here might be that you would always need to export the memory in the module if you want the host to be able to access it with this method.</p>\n</blockquote>",
        "id": 203506044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594387672
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007#issuecomment-656704752\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>Yes currently this is a limitation of WebAssembly. All instances must be instantiated in a DAG to ensure there's no cycle for instantiation. As @Rochet2 mentions, however, the <code>Caller</code> type in Wasmtime is intended to help solve this issue about memories specifically (there's a longer example <a href=\"https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Func.html#examples-1\">on <code>Func</code> too</a>).</p>\n<p>Overall there's a few ways you can solve this:</p>\n<ul>\n<li>The module could import memory instead so you, as the host, can create memory early.</li>\n<li>Your closures can use <code>Caller</code> to access the caller's memory</li>\n<li>You can use a combination of <code>Rc</code> and <code>RefCell</code> in Rust to communicate the memory back to the imports after instantiation (it means imports won't work during instantiation, however)</li>\n<li>Eventually the interface types proposal is intended to make this much easier where communication of types in memories will automatically be handled by the host.</li>\n</ul>\n</blockquote>",
        "id": 203512569,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594391222
    },
    {
        "content": "<p>softprops <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007#issuecomment-656916070\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>Thanks for the fast feedback folks. These were very helpful insights.</p>\n<p>I don't have control over changing the wasm apps contact api with it's host environment but a few of the options above sound like tenable experiments.</p>\n<p>The caller example looks to be precisely what I need to get a handle on the instances memory.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">log_str</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Func</span>::<span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">caller</span>: <span class=\"nc\">Caller</span><span class=\"o\">&lt;</span><span class=\"nb\">&#39;_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span>: <span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">&quot;memory&quot;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span>::<span class=\"n\">Memory</span><span class=\"p\">(</span><span class=\"n\">mem</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">Trap</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"s\">&quot;failed to find host memory&quot;</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>It can't be said enough but the quality of docs in these projects are superb</p>\n</blockquote>",
        "id": 203563338,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594419072
    },
    {
        "content": "<p>softprops <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007#issuecomment-656965634\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>Closing this for now since I have what I need to move forward.</p>\n<p>Thanks for an amazing project!</p>\n</blockquote>",
        "id": 203574957,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594432490
    },
    {
        "content": "<p>softprops closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2007\">Issue #2007</a>:</p>\n<blockquote>\n<p>I'm running into a problem with the current <a href=\"https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Linker.html#method.func\"><code>Linker.func</code></a> api as it relates to the wiring of a wasm runtime.</p>\n<p>The following illustrates a problem I'm having where in order to instantiate a <code>Module</code>, one must configure a linker's functions. In my case this runtime is expected to provide a an implementation of a number of module functions. When they are not defined wasi's call to  instantiate a <code>Module</code> fails with very useful error reporting describing the missing implementation and its type signature. However in order to define those linker functions I would require the instantiated modules <code>Memory</code> reference if I understand this system currently.</p>\n<p>I'm new to wasm so I may be missing something here but presumably the example below is a more helpful and fill the gaps I'm not sure how to describe yet.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasmtime_wasi</span>::<span class=\"p\">{</span><span class=\"n\">Wasi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">WasiCtxBuilder</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">byteorder</span>::<span class=\"n\">ByteOrder</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">engine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Engine</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Linker</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wasi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wasi</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">WasiCtxBuilder</span>::<span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">inherit_stdout</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">inherit_stderr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">wasi</span><span class=\"p\">.</span><span class=\"n\">add_to_linker</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// the egg exists here. The egg needs the a reference chicken&#39;s memory</span>\n<span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"s\">&quot;mod_name&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"s\">&quot;fn_name&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">|</span><span class=\"n\">offset_arg0</span>: <span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"c1\">// performs some computation then updates the instances Memory</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">some_computed_result</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">byteorder</span>::<span class=\"n\">LittleEndian</span>::<span class=\"n\">write_u32</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">data_unchecked_mut</span><span class=\"p\">()[</span><span class=\"n\">offset_arg0</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"o\">..</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">some_computed_result</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\"> </span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// the chicken is born here the chicken can not be born without the linker being defining the implementation</span>\n<span class=\"c1\">// of `mod_name::fn_name`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Module</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"s\">&quot;path/to/app.wasm&quot;</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">get_memory</span><span class=\"p\">(</span><span class=\"s\">&quot;memory&quot;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">&quot;all instances should have memory. this one does not&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I'm basing this Rust application off of an implementation in go-wasmtime which orchestrates this all in the the setup of of a structs <code>NewFoo</code> func where the reference to memory can be <code>nil</code> at the time of link definition. This is made slightly more challenging with rusts memory module and references to \"self\" and/or any external closure references inside <code>linker.func()</code> </p>\n<p>I can fill in more concrete details if needed but I'm wondering if it's clear I'm missing something very fundamental right out of the gate with wasmtime's expected api usage.</p>\n</blockquote>",
        "id": 203574960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594432491
    }
]