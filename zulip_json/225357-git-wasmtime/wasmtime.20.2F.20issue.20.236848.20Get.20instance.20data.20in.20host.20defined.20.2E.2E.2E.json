[
    {
        "content": "<p>bobogei81123 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Provide instance (<code>Instance</code> struct) or instance data to host defined functions in component model.</p>\n<h4>Benefit</h4>\n<p>In #2491, it is suggested to bind the instance data to the closure passed to <code>Func::wrap</code> to store per-instance data. However, this will not work for instances in component model because to bind a function (let host export a function to be called by guests), one need to configure <a href=\"https://docs.wasmtime.dev/api/wasmtime/component/struct.LinkerInstance.html\"><code>LinkerInstance</code></a> (e.g., use <a href=\"https://docs.wasmtime.dev/api/wasmtime/component/struct.LinkerInstance.html#method.func_wrap\"><code>LinkerInstance::func_wrap</code></a> or similar methods). Yet, there is only a single linker set up for instantiating all the instances in a store, so there is no way to configure per-instance data.</p>\n<p>Providing host function instance and instance data will let host function able to get data tied to the instance that calls the function, or let host perform a nested call to a guest function, etc. </p>\n<h4>Implementation</h4>\n<p>I think a possible implementation is to let the function passed to <a href=\"https://docs.wasmtime.dev/api/wasmtime/component/struct.LinkerInstance.html#method.func_wrap\"><code>LinkerInstance::func_wrap</code></a> to be able to take <code>Caller</code> instead of <code>StoreContextMut</code>. The non-component model counterpart <a href=\"https://docs.wasmtime.dev/api/wasmtime/struct.Func.html#method.wrap\"><code>Func::wrap</code></a> takes <code>AsContextMut</code> to achieve this, and I'm not sure why <code>func_wrap</code> takes <code>StoreContextMut</code> instead. Then, we can expose the instance stored in the <code>Caller</code> struct. Of course, this all rely on the assumption that <code>Caller</code> can be retrieve in calls to component host.<br>\n</p>\n</blockquote>",
        "id": 385041441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692088221
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-1684056351\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>You mention that a single linker is used for a store, but that's not quite accurate because you can use any number of linkers to instantiate within a <code>Store</code>. In that sense you can still provide per-function state within the <code>Linker</code>. Otherwise though I'll also note that the question there was in reference to the C API and the Rust API is a bit different. In Rust the closures in <code>Linker</code> are <code>Fn</code> meaning you don't get mutable access to closed-over-state. Instead that sort of information typically goes within the <code>T</code> of a <code>Store&lt;T&gt;</code> which you do get mutable access to.</p>\n<p>So, if possible, the recommendation is to store per-instance information into a <code>T</code> in <code>Store&lt;T&gt;</code> and only if necessary store per-instance information within the closures passed to a <code>Linker</code>. Does that work for you?</p>\n</blockquote>",
        "id": 385938292,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692371234
    },
    {
        "content": "<p>bobogei81123 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-1685883827\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'll also note that the question there was in reference to the C API and the Rust API is a bit different.</p>\n</blockquote>\n<p>Sorry for not stating the question clearly. I'm using the rust API. Otherwise</p>\n<blockquote>\n<p>So, if possible, the recommendation is to store per-instance information into a T in Store&lt;T&gt; and only if necessary store per-instance information within the closures passed to a Linker. Does that work for you?</p>\n</blockquote>\n<p>I'm a little bit confused here because I thought there can be multiple <strong>instances</strong> inside a single store.  My setup is as follows:<br>\nFirst I create a global <code>Engine</code> and <code>Store</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">engine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Engine</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span>\n<span class=\"w\">  </span><span class=\"n\">linker</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Linker</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">MyWasmWorld</span>::<span class=\"n\">add_to_linker</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Then, when a plugin (guest program) is loaded, I load the wasm file and instantiate the component</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">load_plugin_from_path</span><span class=\"p\">(</span><span class=\"n\">file_path</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Component</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">file_path</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MyWasmWorld</span>::<span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">component</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>My understanding is that <code>load_plugin_from_path</code> can be called multiple time to instantiate multiple plugins in the same store, so I'll need a way to identify which instance is calling the host function.</p>\n<p>Or should I use multiple stores for different plugins? But even then, I still need to get the <code>Instance</code> handle to get its exports so I cn call guest functions or inspect its memory, is that correct?<br>\n</p>\n</blockquote>",
        "id": 386333121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692606471
    },
    {
        "content": "<p>bobogei81123 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-1685890667\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>Oh, I think I get what you are suggesting, I can create one linker each time I instantiate a plugin. Let me try if that works.</p>\n</blockquote>",
        "id": 386334169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692606745
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-1686515307\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>Ah yes it's possible to put lots of instances in the same store. The downside of that approach is that you can't incrementally delete instances within the store, it's an all-or-nothing operation (e.g. you can't unload just one plugin, you'd have to unload all of them).</p>\n<p>If possible I'd recommend having a <code>Store</code>-per-plugin. With the component abstraction it's not actually necessary to have everything in one store as that's primarily there for core wasm instance linking and shared memory, which the component model doesn't support.</p>\n<p>Storing state per-linker would still work, however, if that works for you!</p>\n</blockquote>",
        "id": 386414939,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1692630596
    },
    {
        "content": "<p>richardpringle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-2447900164\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>@alexcrichton, not sure if this is the best place to ask the question, but is there a clean way to call guest functions from without a host function? (I'm not currently using the component model, if that makes a difference). </p>\n<p>I have a bunch of host functions that allocate their results. To do so, they rely on an <code>allocate</code> function exported from the wasm-module. I know I can dynamically get the export and do all the checking, but is there a way to do this at link-time? </p>\n<p>It would be nice if there was a way for <code>Linker::instantiate</code> to check for exports in addition to imports in a way that would enable me to make safe static calls back into the module. </p>\n<p>Should I be thinking about allocation differently? Is there another way to do this? Please advise if there's a better place to post too.</p>\n</blockquote>",
        "id": 479733435,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730309755
    },
    {
        "content": "<p>richardpringle edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-2447900164\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>@alexcrichton, not sure if this is the best place to ask the question, but is there a clean way to call guest functions from without a host function? (I'm not currently using the component model, if that makes a difference). </p>\n<p>I have a bunch of host functions that allocate their results. To do so, they rely on an <code>allocate</code> function exported from the wasm-module. I know I can dynamically get the export and do all the checking, but is there a way to do this at link-time? </p>\n<p>It would be nice if there was a way for <code>Linker::instantiate</code> to check for exports in addition to imports in a way that would enable me to make safe static calls back into the module. </p>\n<p>Or maybe I just want to expose <code>Instance::get_module_export</code> off of <code>Caller</code> so I don't have to do a lookup by name every time and put the <code>ModuleExport</code> in the <code>Store</code>-data? </p>\n<p>Should I be thinking about allocation differently? Is there another way to do this? Please advise if there's a better place to post too.</p>\n</blockquote>",
        "id": 479734165,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730310040
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848#issuecomment-2450595365\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6848\">issue #6848</a>:</p>\n<blockquote>\n<p>I'll follow up on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9525\">https://github.com/bytecodealliance/wasmtime/pull/9525</a> as this probably isn't the best place to continue this discussion (but no worries!)</p>\n</blockquote>",
        "id": 479940439,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730400425
    }
]