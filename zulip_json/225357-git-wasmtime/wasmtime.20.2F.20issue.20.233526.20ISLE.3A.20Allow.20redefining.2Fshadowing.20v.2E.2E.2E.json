[
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526\">issue #3526</a>:</p>\n<blockquote>\n<p>Originally <a href=\"https://github.com/cfallin/isle/issues/9\">https://github.com/cfallin/isle/issues/9</a></p>\n<blockquote>\n<p>This example redefines <code>carry</code> and <code>hi_shifted</code>:</p>\n<p><code>lisp\n(decl shl_i128 (ValueRegs Reg) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Reg (value_regs_get src 0))\n            (src_hi Reg (value_regs_get src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Reg (shl $I64 src_lo (Imm8Reg.Reg amt)))\n            (hi_shifted Reg (shl $I64 src_hi (Imm8Reg.Reg amt)))\n            ;; `src_lo &gt;&gt; (64 - shift)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Reg (shr $I64 src_lo (Imm8Reg.Reg (sub $I64 (imm $I64 64) (RegMemImm.Reg amt)))))\n            (zero Reg (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry Reg (with_flags_1 (test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                     (cmove $I64 (CC.Z) (RegMem.Reg zero) carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted Reg (or $I64 carry (RegMemImm.Reg hi_shifted))))\n        ;; Combine the two shifted halves. However, if we are shifting by 64,\n        ;; then the low bits are zero and the high bits are our low bits.\n        (with_flags_2 (test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                      (cmove $I64 (CC.Z) (RegMem.Reg lo_shifted) zero)\n                      (cmove $I64 (CC.Z) (RegMem.Reg hi_shifted) lo_shifted))))\n</code></p>\n<p>Without the ability to redefine, we have to use names like <code>carry2</code> and <code>hi_shifted2</code> or something, like Erlang.</p>\n</blockquote>\n</blockquote>",
        "id": 261577303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637019766
    },
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526\">issue #3526</a>:</p>\n<blockquote>\n<p>Originally <a href=\"https://github.com/cfallin/isle/issues/9\">https://github.com/cfallin/isle/issues/9</a></p>\n<blockquote>\n<p>This example redefines <code>carry</code> and <code>hi_shifted</code>:</p>\n<p><code>lisp\n(decl shl_i128 (ValueRegs Reg) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Reg (value_regs_get src 0))\n            (src_hi Reg (value_regs_get src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Reg (shl $I64 src_lo (Imm8Reg.Reg amt)))\n            (hi_shifted Reg (shl $I64 src_hi (Imm8Reg.Reg amt)))\n            ;; `src_lo &gt;&gt; (64 - shift)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Reg (shr $I64 src_lo (Imm8Reg.Reg (sub $I64 (imm $I64 64) (RegMemImm.Reg amt)))))\n            (zero Reg (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry Reg (with_flags_1 (test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                     (cmove $I64 (CC.Z) (RegMem.Reg zero) carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted Reg (or $I64 carry (RegMemImm.Reg hi_shifted))))\n        ;; Combine the two shifted halves. However, if we are shifting by 64,\n        ;; then the low bits are zero and the high bits are our low bits.\n        (with_flags_2 (test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                      (cmove $I64 (CC.Z) (RegMem.Reg lo_shifted) zero)\n                      (cmove $I64 (CC.Z) (RegMem.Reg hi_shifted) lo_shifted))))\n</code></p>\n<p>Without the ability to redefine, we have to use names like <code>carry2</code> and <code>hi_shifted2</code> or something, like Erlang.</p>\n</blockquote>\n</blockquote>",
        "id": 261577304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637019766
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526\">issue #3526</a>:</p>\n<blockquote>\n<p>Originally <a href=\"https://github.com/cfallin/isle/issues/9\">https://github.com/cfallin/isle/issues/9</a></p>\n<blockquote>\n<p>This example redefines <code>carry</code> and <code>hi_shifted</code>:</p>\n<p><code>lisp\n(decl shl_i128 (ValueRegs Reg) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Reg (value_regs_get src 0))\n            (src_hi Reg (value_regs_get src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Reg (shl $I64 src_lo (Imm8Reg.Reg amt)))\n            (hi_shifted Reg (shl $I64 src_hi (Imm8Reg.Reg amt)))\n            ;; `src_lo &gt;&gt; (64 - shift)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Reg (shr $I64 src_lo (Imm8Reg.Reg (sub $I64 (imm $I64 64) (RegMemImm.Reg amt)))))\n            (zero Reg (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry Reg (with_flags_1 (test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                     (cmove $I64 (CC.Z) (RegMem.Reg zero) carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted Reg (or $I64 carry (RegMemImm.Reg hi_shifted))))\n        ;; Combine the two shifted halves. However, if we are shifting by 64,\n        ;; then the low bits are zero and the high bits are our low bits.\n        (with_flags_2 (test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                      (cmove $I64 (CC.Z) (RegMem.Reg lo_shifted) zero)\n                      (cmove $I64 (CC.Z) (RegMem.Reg hi_shifted) lo_shifted))))\n</code></p>\n<p>Without the ability to redefine, we have to use names like <code>carry2</code> and <code>hi_shifted2</code> or something, like Erlang.</p>\n</blockquote>\n</blockquote>",
        "id": 281212108,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694561
    },
    {
        "content": "<p>elliottt <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526#issuecomment-1201728699\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526\">issue #3526</a>:</p>\n<blockquote>\n<p>Fixed in #4562 </p>\n</blockquote>",
        "id": 291634558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659388477
    },
    {
        "content": "<p>elliottt closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3526\">issue #3526</a>:</p>\n<blockquote>\n<p>Originally <a href=\"https://github.com/cfallin/isle/issues/9\">https://github.com/cfallin/isle/issues/9</a></p>\n<blockquote>\n<p>This example redefines <code>carry</code> and <code>hi_shifted</code>:</p>\n<p><code>lisp\n(decl shl_i128 (ValueRegs Reg) ValueRegs)\n(rule (shl_i128 src amt)\n      ;; Unpack the registers that make up the 128-bit value being shifted.\n      (let ((src_lo Reg (value_regs_get src 0))\n            (src_hi Reg (value_regs_get src 1))\n            ;; Do two 64-bit shifts.\n            (lo_shifted Reg (shl $I64 src_lo (Imm8Reg.Reg amt)))\n            (hi_shifted Reg (shl $I64 src_hi (Imm8Reg.Reg amt)))\n            ;; `src_lo &gt;&gt; (64 - shift)` are the bits to carry over from the lo\n            ;; into the hi.\n            (carry Reg (shr $I64 src_lo (Imm8Reg.Reg (sub $I64 (imm $I64 64) (RegMemImm.Reg amt)))))\n            (zero Reg (imm $I64 0))\n            ;; Nullify the carry if we are shifting in by a multiple of 128.\n            (carry Reg (with_flags_1 (test (OperandSize.Size64) (RegMemImm.Imm 127) amt)\n                                     (cmove $I64 (CC.Z) (RegMem.Reg zero) carry)))\n            ;; Add the carry into the high half.\n            (hi_shifted Reg (or $I64 carry (RegMemImm.Reg hi_shifted))))\n        ;; Combine the two shifted halves. However, if we are shifting by 64,\n        ;; then the low bits are zero and the high bits are our low bits.\n        (with_flags_2 (test (OperandSize.Size64) (RegMemImm.Imm 64) amt)\n                      (cmove $I64 (CC.Z) (RegMem.Reg lo_shifted) zero)\n                      (cmove $I64 (CC.Z) (RegMem.Reg hi_shifted) lo_shifted))))\n</code></p>\n<p>Without the ability to redefine, we have to use names like <code>carry2</code> and <code>hi_shifted2</code> or something, like Erlang.</p>\n</blockquote>\n</blockquote>",
        "id": 291634559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659388477
    }
]