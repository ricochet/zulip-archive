[
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>There is a lot of <code>(RegMem.Reg my_reg)</code> expressions in the x64 backend that convert a <code>Reg</code> into a <code>RegMem</code> when passing a <code>Reg</code> as an operand to an instruction that can also take a memory operand. Even more of this kind of boring conversion will be littered about with the introduction of newtypes for GPRs and XMMs in #3752 where we have to do <code>(xmm_to_xmm_mem my_xmm)</code>.</p>\n<p>If we were writing these APIs in Rust, we would take an <code>reg_mem: impl Into&lt;RegMem&gt;</code> param for the first example and \"hide\" the type conversion inside the API so that the noise is hidden from callers and the API feels nicer and more flexible. The second example would have <code>xmm_mem: impl Into&lt;XmmMem&gt;</code>. We don't have that mechanism in ISLE and the result is that certain bits of code are painfully noisy to the point where it is distracting from what instructions we are actually lowering into.</p>\n<p>This issue is proposing that we add something similar to <code>impl Into&lt;T&gt;</code> to ISLE, to fulfill those same API ergonomics/niceties, but much simpler and without introducing a whole traits system.</p>\n<p>First off, a big constraint: we want to maintain that there is only one expected type for every expression. This keeps type checking a single, simple pass. We don't need to do any kind of type constraint collection/solving/inference or anything like that.</p>\n<p>Straw person proposal (feel free to bikeshed on syntax):</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"c1\">;; A plain decl+constructor that happens to take a `Reg` and return a `RegMem`.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">reg_to_reg_mem</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span><span class=\"p\">)</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">r</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">RegMem.Reg</span> <span class=\"nv\">r</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; Declare that we can convert a `Reg` into a `RegMem` with the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor.</span>\n<span class=\"c1\">;;</span>\n<span class=\"c1\">;; Note that this is unidirectional and does *not* imply you can</span>\n<span class=\"c1\">;; convert a `RegMem` into a `Reg`!</span>\n<span class=\"p\">(</span><span class=\"nv\">converts</span> <span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span> <span class=\"nv\">reg_to_reg_mem</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; The x64 add instruction takes two operands: a register operand and</span>\n<span class=\"c1\">;; a register-or-memory operand.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">x64_add</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span> <span class=\"nv\">Reg</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">src1</span> <span class=\"nv\">src2</span><span class=\"p\">)</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; We can pass a `Reg` as the second register-or-memory operand to</span>\n<span class=\"c1\">;; `x64_add`, without explicitly writing any type conversions, and</span>\n<span class=\"c1\">;; the ISLE compiler will automatically insert a call to the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor for us.</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"nv\">b</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; That is, the above is equivalent to this:</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">b</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>How do we implement this? Well when you try to compile the above example with ISLE today, it gives you a type error saying that it expected a <code>RegMem</code> but got a <code>Reg</code>. It already knows the expected and actual types, so it can just look up and see if an implicit type conversion between the two is already registered. If so, then insert the conversion call. If not, then report the error.</p>\n<p>Thoughts?</p>\n<p>(cc @cfallin @abrown @uweigand)</p>\n</blockquote>",
        "id": 270274125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745039
    },
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>There is a lot of <code>(RegMem.Reg my_reg)</code> expressions in the x64 backend that convert a <code>Reg</code> into a <code>RegMem</code> when passing a <code>Reg</code> as an operand to an instruction that can also take a memory operand. Even more of this kind of boring conversion will be littered about with the introduction of newtypes for GPRs and XMMs in #3752 where we have to do <code>(xmm_to_xmm_mem my_xmm)</code>.</p>\n<p>If we were writing these APIs in Rust, we would take an <code>reg_mem: impl Into&lt;RegMem&gt;</code> param for the first example and \"hide\" the type conversion inside the API so that the noise is hidden from callers and the API feels nicer and more flexible. The second example would have <code>xmm_mem: impl Into&lt;XmmMem&gt;</code>. We don't have that mechanism in ISLE and the result is that certain bits of code are painfully noisy to the point where it is distracting from what instructions we are actually lowering into.</p>\n<p>This issue is proposing that we add something similar to <code>impl Into&lt;T&gt;</code> to ISLE, to fulfill those same API ergonomics/niceties, but much simpler and without introducing a whole traits system.</p>\n<p>First off, a big constraint: we want to maintain that there is only one expected type for every expression. This keeps type checking a single, simple pass. We don't need to do any kind of type constraint collection/solving/inference or anything like that.</p>\n<p>Straw person proposal (feel free to bikeshed on syntax):</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"c1\">;; A plain decl+constructor that happens to take a `Reg` and return a `RegMem`.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">reg_to_reg_mem</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span><span class=\"p\">)</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">r</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">RegMem.Reg</span> <span class=\"nv\">r</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; Declare that we can convert a `Reg` into a `RegMem` with the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor.</span>\n<span class=\"c1\">;;</span>\n<span class=\"c1\">;; Note that this is unidirectional and does *not* imply you can</span>\n<span class=\"c1\">;; convert a `RegMem` into a `Reg`!</span>\n<span class=\"p\">(</span><span class=\"nv\">converts</span> <span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span> <span class=\"nv\">reg_to_reg_mem</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; The x64 add instruction takes two operands: a register operand and</span>\n<span class=\"c1\">;; a register-or-memory operand.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">x64_add</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span> <span class=\"nv\">Reg</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">src1</span> <span class=\"nv\">src2</span><span class=\"p\">)</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; We can pass a `Reg` as the second register-or-memory operand to</span>\n<span class=\"c1\">;; `x64_add`, without explicitly writing any type conversions, and</span>\n<span class=\"c1\">;; the ISLE compiler will automatically insert a call to the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor for us.</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"nv\">b</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; That is, the above is equivalent to this:</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">b</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>How do we implement this? Well when you try to compile the above example with ISLE today, it gives you a type error saying that it expected a <code>RegMem</code> but got a <code>Reg</code>. It already knows the expected and actual types, so it can just look up and see if an implicit type conversion between the two is already registered. If so, then insert the conversion call. If not, then report the error.</p>\n<p>Thoughts?</p>\n<p>(cc @cfallin @abrown @uweigand)</p>\n</blockquote>",
        "id": 270274126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745039
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027225681\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 270274161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745053
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027230521\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>+1, I think this makes a ton of sense, and as we discussed it could make a lot of the tedium in the rules today (<code>value_regs</code>, <code>def_inst</code>) go away if we define right implicit conversions. So we finally reach the ultimate goal of something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">imul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"p\">(</span><span class=\"n\">madd</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The main downside is the increased implicitness. An idea: perhaps we could have a mode where the compiler expands implicit conversions and dumps the AST? (Something like <code>cargo expand</code> in principle)</p>\n</blockquote>",
        "id": 270275288,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745448
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027230521\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>+1, I think this makes a ton of sense, and as we discussed it could make a lot of the tedium in the rules today (<code>value_regs</code>, <code>def_inst</code>) go away if we define right implicit conversions. So we finally reach the ultimate goal of something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">lower</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">imul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">madd</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The main downside is the increased implicitness. An idea: perhaps we could have a mode where the compiler expands implicit conversions and dumps the AST? (Something like <code>cargo expand</code> in principle)</p>\n</blockquote>",
        "id": 270275348,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745477
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027235171\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p><code>def_inst</code> is actually an interesting thing to bring up because I've only thought about constructors thus far. I think we might want to have separate sets of conversions for constructors vs extractors.</p>\n</blockquote>",
        "id": 270276137,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643745774
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027241230\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>Yep, that makes sense to me, since they're different semantic contexts (pattern vs expr). <code>implicit_etor</code> or <code>etor_convert</code> and <code>implicit_ctor</code> or <code>ctor_convert</code> perhaps?</p>\n</blockquote>",
        "id": 270277201,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643746155
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027243293\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>I think I would prefer <code>constructor</code> to <code>ctor</code> and <code>extractor</code> to <code>etor</code>.</p>\n</blockquote>",
        "id": 270277563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643746302
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1027800998\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>Makes sense to me as well!</p>\n</blockquote>",
        "id": 270363869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643798344
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753#issuecomment-1049230200\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>Implemented in #3807.</p>\n</blockquote>",
        "id": 273013373,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645651519
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3753\">issue #3753</a>:</p>\n<blockquote>\n<p>There is a lot of <code>(RegMem.Reg my_reg)</code> expressions in the x64 backend that convert a <code>Reg</code> into a <code>RegMem</code> when passing a <code>Reg</code> as an operand to an instruction that can also take a memory operand. Even more of this kind of boring conversion will be littered about with the introduction of newtypes for GPRs and XMMs in #3752 where we have to do <code>(xmm_to_xmm_mem my_xmm)</code>.</p>\n<p>If we were writing these APIs in Rust, we would take an <code>reg_mem: impl Into&lt;RegMem&gt;</code> param for the first example and \"hide\" the type conversion inside the API so that the noise is hidden from callers and the API feels nicer and more flexible. The second example would have <code>xmm_mem: impl Into&lt;XmmMem&gt;</code>. We don't have that mechanism in ISLE and the result is that certain bits of code are painfully noisy to the point where it is distracting from what instructions we are actually lowering into.</p>\n<p>This issue is proposing that we add something similar to <code>impl Into&lt;T&gt;</code> to ISLE, to fulfill those same API ergonomics/niceties, but much simpler and without introducing a whole traits system.</p>\n<p>First off, a big constraint: we want to maintain that there is only one expected type for every expression. This keeps type checking a single, simple pass. We don't need to do any kind of type constraint collection/solving/inference or anything like that.</p>\n<p>Straw person proposal (feel free to bikeshed on syntax):</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"c1\">;; A plain decl+constructor that happens to take a `Reg` and return a `RegMem`.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">reg_to_reg_mem</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span><span class=\"p\">)</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">r</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">RegMem.Reg</span> <span class=\"nv\">r</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; Declare that we can convert a `Reg` into a `RegMem` with the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor.</span>\n<span class=\"c1\">;;</span>\n<span class=\"c1\">;; Note that this is unidirectional and does *not* imply you can</span>\n<span class=\"c1\">;; convert a `RegMem` into a `Reg`!</span>\n<span class=\"p\">(</span><span class=\"nv\">converts</span> <span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span> <span class=\"nv\">reg_to_reg_mem</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; The x64 add instruction takes two operands: a register operand and</span>\n<span class=\"c1\">;; a register-or-memory operand.</span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">x64_add</span> <span class=\"p\">(</span><span class=\"nv\">Reg</span> <span class=\"nv\">RegMem</span><span class=\"p\">)</span> <span class=\"nv\">Reg</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">rule</span> <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">src1</span> <span class=\"nv\">src2</span><span class=\"p\">)</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; We can pass a `Reg` as the second register-or-memory operand to</span>\n<span class=\"c1\">;; `x64_add`, without explicitly writing any type conversions, and</span>\n<span class=\"c1\">;; the ISLE compiler will automatically insert a call to the</span>\n<span class=\"c1\">;; `reg_to_reg_mem` constructor for us.</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"nv\">b</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; That is, the above is equivalent to this:</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">a</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">b</span> <span class=\"nv\">Reg</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">x64_add</span> <span class=\"nv\">a</span> <span class=\"p\">(</span><span class=\"nv\">reg_to_reg_mem</span> <span class=\"nv\">b</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>How do we implement this? Well when you try to compile the above example with ISLE today, it gives you a type error saying that it expected a <code>RegMem</code> but got a <code>Reg</code>. It already knows the expected and actual types, so it can just look up and see if an implicit type conversion between the two is already registered. If so, then insert the conversion call. If not, then report the error.</p>\n<p>Thoughts?</p>\n<p>(cc @cfallin @abrown @uweigand)</p>\n</blockquote>",
        "id": 273013374,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645651519
    }
]