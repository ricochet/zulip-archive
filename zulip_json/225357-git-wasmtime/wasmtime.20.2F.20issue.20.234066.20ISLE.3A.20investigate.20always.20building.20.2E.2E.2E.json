[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>In our most recent Cranelift meeting, we discussed the question of whether we want to continue to rely on checked-in, pre-generated ISLE DSL compiler output, or else move back to a build strategy that always builds from the DSL.</p>\n<p>The two main advantages of the current situation are:</p>\n<ul>\n<li>The build time of <code>cranelift-codegen</code> is low: there is only a little bit of <code>build.rs</code> work (the <code>meta</code>) crate, but we don't need to build the ISLE compiler every time.</li>\n<li>The generated source is present in the main tree and can be examined and debugged easily, to see why rules are or are not matching.</li>\n</ul>\n<p>On the other hand, I believe that the following downsides are becoming more relevant:</p>\n<ul>\n<li>The workflow in general is very awkward. If we want to be friendly to newcomers who might want to tweak some instruction lowerings -- one of the main goals of ISLE, long-term -- then consider what understanding we assume:<ul>\n<li>We require the developer to build a mental model of the complex multi-step build with checked-in artifacts, which is unusual and unidiomatic in the Rust world;</li>\n<li>We require a special Cargo flag to force a generated-source rebuild;</li>\n<li>If there is ever more than one PR outstanding at a time to the ISLE DSL source, all but the first to merge will need to regenerate and rebase (most of us probably take understanding <code>git</code> for granted but this is a nontrivial speedbump for many);</li>\n<li>The diffs that one sees on GitHub are cluttered with generated-source changes, which I have mostly learned to subconsciously ignore when reviewing but are potentially pretty confusing for onlookers.</li>\n</ul>\n</li>\n</ul>\n<p>The above factors are a mix of friction for newcomers (required understanding and complexity) and regular contributors (rebase pain). If the goal of the DSL is to make modifying the compiler easy, then the above factors I think are working against the goal of the DSL.</p>\n<p>A quick survey of some other compilers and their build systems: of LLVM, SpiderMonkey and Golang, all of which have some meta-build steps, only Golang checks in generated source (and in the Go community this seems to be a bit more idiomatic).</p>\n<p>So, to me, the question becomes how to support the needs above (build time, debugging) in a different way, if we can. I'd like to see if we can:</p>\n<ul>\n<li>Find a way to reduce the dependencies of <code>cranelift-isle</code> so it can be built in a few seconds at most. We use <code>miette</code> and <code>thiserror</code> (all for good reasons, to be clear!) and these pull in a bunch of (i) derive-macro stuff and (ii) fancy terminal stuff for <code>miette</code>. The latter can be removed when not in a \"developer mode\" but the derive-macros seem to go pretty deep. I don't think we should get rid of <code>miette</code> -- its errors are fantastic -- but could we refactor its use out to <code>islec</code>, propagating a more generic and minimal error-plus-span type out of <code>isle</code>? Ideally the crate tree used by <code>build.rs</code> should have just <code>cranelift-isle</code> and its one other dep <code>log</code>.</li>\n<li>Add a means to print \"tracing\" messages (off by default) in generated code, to ease debugging of why rules did or did not match.</li>\n</ul>\n<p>Thoughts? cc @abrown @fitzgen </p>\n</blockquote>",
        "id": 279783075,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650607507
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>In our most recent Cranelift meeting, we discussed the question of whether we want to continue to rely on checked-in, pre-generated ISLE DSL compiler output, or else move back to a build strategy that always builds from the DSL.</p>\n<p>The two main advantages of the current situation are:</p>\n<ul>\n<li>The build time of <code>cranelift-codegen</code> is low: there is only a little bit of <code>build.rs</code> work (the <code>meta</code>) crate, but we don't need to build the ISLE compiler every time.</li>\n<li>The generated source is present in the main tree and can be examined and debugged easily, to see why rules are or are not matching.</li>\n</ul>\n<p>On the other hand, I believe that the following downsides are becoming more relevant:</p>\n<ul>\n<li>The workflow in general is very awkward. If we want to be friendly to newcomers who might want to tweak some instruction lowerings -- one of the main goals of ISLE, long-term -- then consider what understanding we assume:<ul>\n<li>We require the developer to build a mental model of the complex multi-step build with checked-in artifacts, which is unusual and unidiomatic in the Rust world;</li>\n<li>We require a special Cargo flag to force a generated-source rebuild;</li>\n<li>If there is ever more than one PR outstanding at a time to the ISLE DSL source, all but the first to merge will need to regenerate and rebase (most of us probably take understanding <code>git</code> for granted but this is a nontrivial speedbump for many);</li>\n<li>The diffs that one sees on GitHub are cluttered with generated-source changes, which I have mostly learned to subconsciously ignore when reviewing but are potentially pretty confusing for onlookers.</li>\n</ul>\n</li>\n</ul>\n<p>The above factors are a mix of friction for newcomers (required understanding and complexity) and regular contributors (rebase pain). If the goal of the DSL is to make modifying the compiler easy, then the above factors I think are working against the goal of the DSL.</p>\n<p>A quick survey of some other compilers and their build systems: of LLVM, SpiderMonkey and Golang, all of which have some meta-build steps, only Golang checks in generated source (and in the Go community this seems to be a bit more idiomatic).</p>\n<p>So, to me, the question becomes how to support the needs above (build time, debugging) in a different way, if we can. I'd like to see if we can:</p>\n<ul>\n<li>Find a way to reduce the dependencies of <code>cranelift-isle</code> so it can be built in a few seconds at most. We use <code>miette</code> and <code>thiserror</code> (all for good reasons, to be clear!) and these pull in a bunch of (i) derive-macro stuff and (ii) fancy terminal stuff for <code>miette</code>. The latter can be removed when not in a \"developer mode\" but the derive-macros seem to go pretty deep. I don't think we should get rid of <code>miette</code> -- its errors are fantastic -- but could we refactor its use out to <code>islec</code>, propagating a more generic and minimal error-plus-span type out of <code>isle</code>? Ideally the crate tree used by <code>build.rs</code> should have just <code>cranelift-isle</code> and its one other dep <code>log</code>.</li>\n<li>Add a means to print \"tracing\" messages (off by default) in generated code, to ease debugging of why rules did or did not match.</li>\n</ul>\n<p>Thoughts? cc @abrown @fitzgen </p>\n</blockquote>",
        "id": 279857964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650099
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106737040\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 279858047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650148
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106737121\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>The diffs that one sees on GitHub are cluttered with generated-source changes, which I have mostly learned to subconsciously ignore when reviewing but are potentially pretty confusing for onlookers.</li>\n</ul>\n</blockquote>\n<p>Nitpick: this isn't 100% true, since we tell github to automatically hide diffs for these files. You have to expand it yourself if you want to see the clutter.</p>\n</blockquote>",
        "id": 279858060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650155
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106738786\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<p>A quick survey of some other compilers and their build systems: of LLVM, SpiderMonkey and Golang, all of which have some meta-build steps, only Golang checks in generated source (and in the Go community this seems to be a bit more idiomatic).</p>\n</blockquote>\n<p>The difference is that most people using those compilers will be downloading pre-built <code>.so</code>s and aren't generally building from source and dealing with compile times themselves. With Rust and <code>cargo</code>, every embedder of Cranelift and Wasmtime is building this stuff from source themselves.</p>\n</blockquote>",
        "id": 279858339,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650307
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106740355\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>The latter can be removed when not in a \"developer mode\"</li>\n</ul>\n</blockquote>\n<p>If we have a \"developer mode\", I'm assuming this would be a new <code>cargo</code> feature? But isn't that the same state of developer experience we are currently in, that you list as a downside earlier, where developers have to know to enable a <code>cargo</code> feature when hacking on ISLE?</p>\n</blockquote>",
        "id": 279858673,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650454
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106740719\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<p>Add a means to print \"tracing\" messages (off by default) in generated code, to ease debugging of why rules did or did not match.</p>\n</blockquote>\n<p>I think this is a good idea either way. Probably means yet another <code>cargo</code> feature, though.</p>\n</blockquote>",
        "id": 279858735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650482
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106745902\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<p>The difference is that most people using those compilers will be downloading pre-built .sos and aren't generally building from source and dealing with compile times themselves. With Rust and cargo, every embedder of Cranelift and Wasmtime is building this stuff from source themselves.</p>\n</blockquote>\n<p>That's certainly true! This is why I think we can only really do this if we can cut down the build time of <code>cranelift-isle</code>. At least when initially developing it though, I found it to be really fast to build -- it didn't yet have deps on <code>thiserror</code> or <code>miette</code>, so the only external dep was <code>log</code> -- and I think that would be viable.</p>\n<blockquote>\n<p>If we have a \"developer mode\", I'm assuming this would be a new cargo feature? But isn't that the same state of developer experience we are currently in, that you list as a downside earlier, where developers have to know to enable a cargo feature when hacking on ISLE?</p>\n</blockquote>\n<p>Yeah, I'm going back and forth on this one, maybe we just don't need a special mode here.</p>\n<hr>\n<p>Overall I think the strongest argument in favor of this is the rebase pain. I feel quite strongly actually that this is a speedbump that will turn people away, and it is not a process that will scale up if we want to scale up to more contributors. Checking in generated artifacts to source control is <em>in general</em> an antipattern that should be avoided unless the other advantages are really really compelling; so in my mind if we can cut down the build time delta then the main reason to do so evaporates.</p>\n<p>Another argument I hadn't realized until today: there is a security/trust argument to be made against checked-in source. RIght now, the code that everyone builds with is generated by whoever last updated the ISLE, on their local machine. Since we don't review the generated source deltas, nothing is stopping a malicious user from tweaking something after making some other innocuous change to ISLE that forces a regenerate step. This alone is IMHO a reason why the current situation needs to change.</p>\n</blockquote>",
        "id": 279859661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650650932
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106746705\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Ultimately, I agree that the pains you've listed are real and painful.</p>\n<p>However, I'm not convinced that the proposed changes will ultimately lead to better outcomes. I'm especially wary of making changes that make the developer experience a little better for Cranelift developers at the cost of the developer experience for Cranelift embedders, since it will be pain we aren't feeling directly and therefore will be easy to unintentionally ignore, and we won't feel pressure to improve.</p>\n<p>That said, we can remove <code>thiserror</code> from ISLE by copying in its <code>cargo expand</code> output and then removing the dependency. Not sure if <code>miette</code> also pulls in derive macro goop. I wanted to start using actual spans all over the place in ISLE rather than the stubbed, single-character spans we have now. My plan was to use <code>miette</code> everywhere for this. We could define our own thing, and hopefully it would do less than <code>miette</code> and have less code and get faster compiles as a result. That might work out.</p>\n<p>But before we get into any of that, I think we should define what an acceptable build time hit to Cranelift would be acceptable, if we are going to seriously pursue this. I think &lt;5% might be reasonable.</p>\n</blockquote>",
        "id": 279859745,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650651001
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106749194\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<p>However, I'm not convinced that the proposed changes will ultimately lead to better outcomes. I'm especially wary of making changes that make the developer experience a little better for Cranelift developers at the cost of the developer experience for Cranelift embedders, since it will be pain we aren't feeling directly and therefore will be easy to unintentionally ignore, and we won't feel pressure to improve.</p>\n</blockquote>\n<p>So here I think it's a bit of a subjective call, but the way I see it is:</p>\n<ul>\n<li>First, we should cut down the cost of rebuilding always; the more we can do this, the more the \"pain to Cranelift embedders\" side of the balance goes away, and it's an unambiguous win;</li>\n<li>Second, they are different kinds of pains. Several seconds of build time is real, for sure. But process friction, and need for human effort and managing complexity, is a whole different kind of pain. \"Machines are cheap, humans are expensive\"; if we make developing Cranelift harder, then we will have fewer people developing Cranelift, and in the end we'll have a worse compiler.</li>\n</ul>\n</blockquote>",
        "id": 279860148,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650651211
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106762088\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Addendum to above: not just \"rebase pain\", but the \"how to add an instruction lowering for a newcomer\" pain in general. If we have a convoluted process for all of this then it will be seen as arcane and inaccessible to someone who just wants to make a tweak. If the cost of making us friendlier to new contributors is ~5s of build time (let's predicate all of this on the assumption we can get there), then IMHO it's worth it. Consider what a newcomer goes through now:</p>\n<ul>\n<li>There's a pattern-matching DSL; cool, I can add a new pattern for my \"multiply by pi with this one cute bit-twiddling trick\" lowering</li>\n<li><code>cargo test</code>; huh, I see an error message. I have to add a Cargo feature? OK, copy/paste that command</li>\n<li>It works, cool, let's create a PR. <code>git add .../lower.isle; git commit</code></li>\n<li>Huh, that's weird, CI turns red. Oh, do I need to add the generated source too?</li>\n<li>commit that too, push</li>\n<li>In the meantime, this jerk @cfallin comes along and makes a change to unrelated lowerings, gets a review, merges it</li>\n<li>Now there's a merge conflict. Do I need to go through and fix the source somehow?</li>\n<li>No, OK, now I need to <code>git fetch upstream</code>, merge, see the message about merge conflicts, ignore it (we'll be regenerating that source anyway), remember how to regenerate source again (I don't get a nice error message telling me <code>--features rebuild-isle</code> here), do that, commit</li>\n<li>OK, finally, I can push, someone reviews, I merge</li>\n</ul>\n<p>Contrast to:</p>\n<ul>\n<li>Change the ISLE DSL code, commit, create PR</li>\n<li>Someone reviews</li>\n<li>I can merge as long as there are no conflicts in the <code>.isle</code> file itself</li>\n</ul>\n<p>That's the experience I worry about above! We should be blind to adding 5 seconds to build time in our embedders, sure; but we should also not be blind to how friendly we are in our processes.</p>\n</blockquote>",
        "id": 279862602,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650652388
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106762088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Addendum to above: not just \"rebase pain\", but the \"how to add an instruction lowering for a newcomer\" pain in general. If we have a convoluted process for all of this then it will be seen as arcane and inaccessible to someone who just wants to make a tweak. If the cost of making us friendlier to new contributors is ~5s of build time (let's predicate all of this on the assumption we can get there), then IMHO it's worth it. Consider what a newcomer goes through now:</p>\n<ul>\n<li>There's a pattern-matching DSL; cool, I can add a new pattern for my \"multiply by pi with this one cute bit-twiddling trick\" lowering</li>\n<li><code>cargo test</code>; huh, I see an error message. I have to add a Cargo feature? OK, copy/paste that command</li>\n<li>It works, cool, let's create a PR. <code>git add .../lower.isle; git commit</code></li>\n<li>Huh, that's weird, CI turns red. Oh, do I need to add the generated source too?</li>\n<li>commit that too, push</li>\n<li>In the meantime, this jerk @cfallin comes along and makes a change to unrelated lowerings, gets a review, merges it</li>\n<li>Now there's a merge conflict. Do I need to go through and fix the source somehow?</li>\n<li>No, OK, now I need to <code>git fetch upstream</code>, merge, see the message about merge conflicts, ignore it (we'll be regenerating that source anyway), remember how to regenerate source again (I don't get a nice error message telling me <code>--features rebuild-isle</code> here), do that, commit</li>\n<li>OK, finally, I can push, someone reviews, I merge</li>\n</ul>\n<p>Contrast to:</p>\n<ul>\n<li>Change the ISLE DSL code, commit, create PR</li>\n<li>Someone reviews</li>\n<li>I can merge as long as there are no conflicts in the <code>.isle</code> file itself</li>\n</ul>\n<p>That's the experience I worry about above! We should not be blind to adding 5 seconds to build time in our embedders, sure; but we should also not be blind to how friendly we are in our processes.</p>\n</blockquote>",
        "id": 279862859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650652525
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106764230\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Can we check in sources for releases and not for the main branch?</p>\n</blockquote>",
        "id": 279862995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650652590
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106767249\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>@bjorn3 I appreciate the intent behind the suggestion but IMHO that's probably the worst of both worlds: we would retain the complexity of the current situation (because it's needed in some cases) and compound it with \"something different happens in different builds\". I'd prefer we develop and test with the same thing that end-users get, if we can make that viable.</p>\n</blockquote>",
        "id": 279863559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650652878
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106803631\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<blockquote>\n<p>Another argument I hadn't realized until today: there is a security/trust argument to be made against checked-in source. RIght now, the code that everyone builds with is generated by whoever last updated the ISLE, on their local machine. Since we don't review the generated source deltas, nothing is stopping a malicious user from tweaking something after making some other innocuous change to ISLE that forces a regenerate step. This alone is IMHO a reason why the current situation needs to change.</p>\n</blockquote>\n<p>Without taking a position on any of the other arguments here: I remember that at some point we talked about explicitly checking this in CI: we'd rebuild the source and verify that it's identical to what's checked in. If we do end up keeping checked in generated code, we absolutely should add this kind of check if we don't have it right now.</p>\n</blockquote>",
        "id": 279869437,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650656277
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1106971403\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>@tschneidereit, if I understand you correctly, I'm pretty sure that check exists today:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/6a36a1d15df303f533fc0dddc89012b1358b52d7/.github/workflows/main.yml#L199-L204\">https://github.com/bytecodealliance/wasmtime/blob/6a36a1d15df303f533fc0dddc89012b1358b52d7/.github/workflows/main.yml#L199-L204</a></p>\n<p>Catching up on this thread, I am actually torn: I don't really like the current rebase pain and extra hassle to execute the rebuild-isle feature but I definitely still remember the pain of the old backend code-generation-at-build. When I first stepped into that old backend, it was very difficult to understand what was going on. The most difficult part, I think, was how the meta-generated code interacted with the in-tree code; I think we have a bit of that same problem today with ISLE in that it is not quite obvious that a <code>*.isle</code> file generates a <code>*.rs</code> file that uses other <code>*.rs</code> files, etc. In summary: I think the \"pain angle\" that I have felt most clearly is of the \"how does this code interact with that code?!?!\" variety.</p>\n<p>A suggestion: I wonder if several of these things disabled/enabled automatically not by explicitly using features but by either building in debug or release mode. I don't know how common this is in the Rust ecosystem, but it seems reasonable that we might want match logging for debug builds of Wasmtime but not for release builds. There might be other features (like the <code>miette</code> dependency tree) that could also be available only in debug mode?</p>\n</blockquote>",
        "id": 279888175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650668133
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1107051280\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Hmm, I'm not sure about debug-vs-release differences for the same reason I'm not sure about the suggestion above to do something different on a release branch: too much magic based on implicit state leads to hard-to-debug issues, IMHO. I'd rather have the thing behave predictably across configurations.</p>\n<blockquote>\n<p>that check exists today</p>\n</blockquote>\n<p>Indeed, I completely missed that we already have that. Sorry for the alarm there and I think today's status quo is acceptable, given that!</p>\n<blockquote>\n<p>\"how does this code interact with that code?!?!\"</p>\n</blockquote>\n<p>This question is I think super-important though, thank you for bringing it up -- we worked hard to make the output of the DSL compiler at least mostly human-readable, and I think we sort of have a split mind here about whether we want the generated Rust to be an opaque intermediate form (like an object file) or a real part of our codebase that we refer to. The answer to that question also affects how we might do other things in the future, fwiw (e.g. if there are questions around code optimizations that make the generated code harder to read but faster).</p>\n<p>I'll also share that back in the day I kept a <code>gen-cranelift</code> symlink around to wherever in <code>target/</code> the meta crate put the generated code, so I could read it more easily. It was confusing to me as well.</p>\n<p>I'm happy to table this for now if it seems there isn't clear consensus to change; I am very worried about the speedbumps, and I find the rebases annoying and painful locally, but maybe we can wait to listen for stronger signal from others having difficulties before making changes.</p>\n</blockquote>",
        "id": 279891800,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650671300
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>In our most recent Cranelift meeting, we discussed the question of whether we want to continue to rely on checked-in, pre-generated ISLE DSL compiler output, or else move back to a build strategy that always builds from the DSL.</p>\n<p>The two main advantages of the current situation are:</p>\n<ul>\n<li>The build time of <code>cranelift-codegen</code> is low: there is only a little bit of <code>build.rs</code> work (the <code>meta</code>) crate, but we don't need to build the ISLE compiler every time.</li>\n<li>The generated source is present in the main tree and can be examined and debugged easily, to see why rules are or are not matching.</li>\n</ul>\n<p>On the other hand, I believe that the following downsides are becoming more relevant:</p>\n<ul>\n<li>The workflow in general is very awkward. If we want to be friendly to newcomers who might want to tweak some instruction lowerings -- one of the main goals of ISLE, long-term -- then consider what understanding we assume:<ul>\n<li>We require the developer to build a mental model of the complex multi-step build with checked-in artifacts, which is unusual and unidiomatic in the Rust world;</li>\n<li>We require a special Cargo flag to force a generated-source rebuild;</li>\n<li>If there is ever more than one PR outstanding at a time to the ISLE DSL source, all but the first to merge will need to regenerate and rebase (most of us probably take understanding <code>git</code> for granted but this is a nontrivial speedbump for many);</li>\n<li>The diffs that one sees on GitHub are cluttered with generated-source changes, which I have mostly learned to subconsciously ignore when reviewing but are potentially pretty confusing for onlookers.</li>\n</ul>\n</li>\n</ul>\n<p>The above factors are a mix of friction for newcomers (required understanding and complexity) and regular contributors (rebase pain). If the goal of the DSL is to make modifying the compiler easy, then the above factors I think are working against the goal of the DSL.</p>\n<p>A quick survey of some other compilers and their build systems: of LLVM, SpiderMonkey and Golang, all of which have some meta-build steps, only Golang checks in generated source (and in the Go community this seems to be a bit more idiomatic).</p>\n<p>So, to me, the question becomes how to support the needs above (build time, debugging) in a different way, if we can. I'd like to see if we can:</p>\n<ul>\n<li>Find a way to reduce the dependencies of <code>cranelift-isle</code> so it can be built in a few seconds at most. We use <code>miette</code> and <code>thiserror</code> (all for good reasons, to be clear!) and these pull in a bunch of (i) derive-macro stuff and (ii) fancy terminal stuff for <code>miette</code>. The latter can be removed when not in a \"developer mode\" but the derive-macros seem to go pretty deep. I don't think we should get rid of <code>miette</code> -- its errors are fantastic -- but could we refactor its use out to <code>islec</code>, propagating a more generic and minimal error-plus-span type out of <code>isle</code>? Ideally the crate tree used by <code>build.rs</code> should have just <code>cranelift-isle</code> and its one other dep <code>log</code>.</li>\n<li>Add a means to print \"tracing\" messages (off by default) in generated code, to ease debugging of why rules did or did not match.</li>\n</ul>\n<p>Thoughts? cc @abrown @fitzgen </p>\n</blockquote>",
        "id": 281212131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694566
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1118538304\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>I definitely find the current work flow painful, especially when I have multiple isle porting patches in flight. The diff produced is also mainly generated code, which as @cfallin pointed out, is probably just ignored in review. But it also has the negative side-effect of making it more awkward to view a patch, before pushing a PR, too.</p>\n<p>I also wonder whether developers would be more inclined to prefer to add code to a specific backend, instead of in prelude.isle, just because of the extra rebase effort across all backends.</p>\n</blockquote>",
        "id": 281297514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651756659
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1123042327\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Alright, so my viewpoints are swinging back toward my original instincts here, after the <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4117\">recent confusion</a> where our prebuilt-source mechanism caused a compiler change not to be picked up, and a bug to hide on <code>main</code> (and all of this not be caught by CI). @sparker-arm also reports <a href=\"#narrow/stream/217117-cranelift/topic/trouble.20with.20if-let.20clauses/near/281862417\">here</a> that he has spent as much time dealing with understanding the build system as actually writing patches. That's the wrong balance, I think, and we can expect others to feel this way too (and in the worst case, get confused and lost after trying something and never even show up on the GitHub project).</p>\n<p>I really do think that the high-order bit is that we should follow the \"principle of least surprise\", and that would suggest here that source code in the tree is built when we build the project. Anything else is extra cognitive load and potential for bugs, confusion, lost contributors, etc.</p>\n<p>So I want to take another look at what it would take to overcome the engineering problems of (i) build time, and (ii) hidden generated-source when one actually does want to look at it.</p>\n<ol>\n<li>I'm going to spend some time tomorrow seeing if I can factor <code>miette</code> out of the core ISLE compiler and into the commandline wrapper, so we have no dependencies other than <code>log</code> during the main build. Perhaps a Cargo feature could re-enable it so <code>build.rs</code>-sourced errors are prettified as they are now.</li>\n<li>@abrown re: \"finding the source\" and \"setting breakpoints\" concerns above, what would you think about a Cargo feature that puts the source in its current location (rather than <code>target/...</code>), but is off by default? We would respect the feature in two places: <code>build.rs</code>, and wherever we <code>include!</code> the file (for the latter perhaps taking an env var from <code>build.rs</code> for the \"ISLE path\"). I'm not sure why we didn't come across this point in the design space above, but it does seem quite simple and workable.</li>\n</ol>\n</blockquote>",
        "id": 281904018,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652228746
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1124063979\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Yup, the idea of being able to configure where the generated code is placed sounds like it resolves the debugging question. An alternate approach might be to add a <code>CRANELIFT_GENERATED_ISLE_DIR</code> environment variable for ultimate control. Either way, feature or environment variable, the tricky part of this is documenting the build option: in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4135\">https://github.com/bytecodealliance/wasmtime/issues/4135</a>, I propose we add a section with a \"how to build Cranelift\" guide which has this kind of thing (and why you would want to do it).</p>\n</blockquote>",
        "id": 282001327,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652290668
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1124063979\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Yup, the idea of being able to configure where the generated code is placed sounds like it resolves the debugging question. An alternate approach might be to add a <code>CRANELIFT_GENERATED_ISLE_DIR</code> environment variable for ultimate control. Either way, feature or environment variable, the tricky part of this is documenting the build option in a place people actually look: in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4135\">https://github.com/bytecodealliance/wasmtime/issues/4135</a>, I propose we add a section with a \"how to build Cranelift\" guide which has this kind of thing (and why you would want to do it).</p>\n</blockquote>",
        "id": 282001410,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652290690
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066#issuecomment-1124286488\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>Small update: the core <code>cranelift-isle</code> crate with all deps (<code>miette</code>, <code>thiserror</code>, and even <code>log</code>) factored out under non-default features can build in 1.9s on my machine, vs. 4.9s with the current <code>main</code>. I'll incorporate this into the <code>build.rs</code> and remove the hashing, etc next (I expect it might even be break-even-ish since we won't need the hashing crate anymore).</p>\n</blockquote>",
        "id": 282026650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652302507
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4066\">issue #4066</a>:</p>\n<blockquote>\n<p>In our most recent Cranelift meeting, we discussed the question of whether we want to continue to rely on checked-in, pre-generated ISLE DSL compiler output, or else move back to a build strategy that always builds from the DSL.</p>\n<p>The two main advantages of the current situation are:</p>\n<ul>\n<li>The build time of <code>cranelift-codegen</code> is low: there is only a little bit of <code>build.rs</code> work (the <code>meta</code>) crate, but we don't need to build the ISLE compiler every time.</li>\n<li>The generated source is present in the main tree and can be examined and debugged easily, to see why rules are or are not matching.</li>\n</ul>\n<p>On the other hand, I believe that the following downsides are becoming more relevant:</p>\n<ul>\n<li>The workflow in general is very awkward. If we want to be friendly to newcomers who might want to tweak some instruction lowerings -- one of the main goals of ISLE, long-term -- then consider what understanding we assume:<ul>\n<li>We require the developer to build a mental model of the complex multi-step build with checked-in artifacts, which is unusual and unidiomatic in the Rust world;</li>\n<li>We require a special Cargo flag to force a generated-source rebuild;</li>\n<li>If there is ever more than one PR outstanding at a time to the ISLE DSL source, all but the first to merge will need to regenerate and rebase (most of us probably take understanding <code>git</code> for granted but this is a nontrivial speedbump for many);</li>\n<li>The diffs that one sees on GitHub are cluttered with generated-source changes, which I have mostly learned to subconsciously ignore when reviewing but are potentially pretty confusing for onlookers.</li>\n</ul>\n</li>\n</ul>\n<p>The above factors are a mix of friction for newcomers (required understanding and complexity) and regular contributors (rebase pain). If the goal of the DSL is to make modifying the compiler easy, then the above factors I think are working against the goal of the DSL.</p>\n<p>A quick survey of some other compilers and their build systems: of LLVM, SpiderMonkey and Golang, all of which have some meta-build steps, only Golang checks in generated source (and in the Go community this seems to be a bit more idiomatic).</p>\n<p>So, to me, the question becomes how to support the needs above (build time, debugging) in a different way, if we can. I'd like to see if we can:</p>\n<ul>\n<li>Find a way to reduce the dependencies of <code>cranelift-isle</code> so it can be built in a few seconds at most. We use <code>miette</code> and <code>thiserror</code> (all for good reasons, to be clear!) and these pull in a bunch of (i) derive-macro stuff and (ii) fancy terminal stuff for <code>miette</code>. The latter can be removed when not in a \"developer mode\" but the derive-macros seem to go pretty deep. I don't think we should get rid of <code>miette</code> -- its errors are fantastic -- but could we refactor its use out to <code>islec</code>, propagating a more generic and minimal error-plus-span type out of <code>isle</code>? Ideally the crate tree used by <code>build.rs</code> should have just <code>cranelift-isle</code> and its one other dep <code>log</code>.</li>\n<li>Add a means to print \"tracing\" messages (off by default) in generated code, to ease debugging of why rules did or did not match.</li>\n</ul>\n<p>Thoughts? cc @abrown @fitzgen </p>\n</blockquote>",
        "id": 282060027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652333125
    }
]