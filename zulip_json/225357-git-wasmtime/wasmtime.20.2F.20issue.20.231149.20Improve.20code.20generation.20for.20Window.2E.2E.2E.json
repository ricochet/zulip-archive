[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1149\">issue #1149</a>:</p>\n<blockquote>\n<ul>\n<li><strong>What is the feature or code improvement you would like to do in Cranelift?</strong></li>\n</ul>\n<p>Improve the code generation for Windows x64 ABI (a.k.a. \"fastcall\") by omitting frame pointers when possible, using the caller-provided shadow space as spill slots for optimized compilation, and omit prologues/epilogues entirely for true \"leaf\" functions.</p>\n<ul>\n<li><strong>What is the value of adding this in Cranelift?</strong></li>\n</ul>\n<p>Reduced code generation size and improved performance on optimized compilations when targeting Windows.</p>\n<ul>\n<li>**Do you have an implementation plan, and/or ideas for data structures or<br>\n  algorithms to use?**</li>\n</ul>\n<p>Windows x64 ABI has strict requirements for function prologues and epilogues.  This enables the OS to consistently walk and unwind the stack during exception handling.</p>\n<p>Because of these strict requirements, a frame pointer is rarely needed for the purpose of unwinding and is only required for a frame doing a dynamic allocation (i.e. <code>alloca</code>).  However, omitting the frame pointer might actually <em>increase</em> instruction sizes based on the displacement from a frame pointer vs. the current stack pointer.  This should be taken into account when deciding if a frame pointer should be omitted.</p>\n<p>Additionally, an explicit stack frame is not necessary at all for <a href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention\">\"leaf\" functions</a>.  We can omit prologue, epilogue, and unwind information generation entirely for functions that don't:</p>\n<ul>\n<li>Have any stack allocation.</li>\n<li>Call another function (i.e. \"leaf\").</li>\n<li>Have a need to save non-volatile registers (i.e. limited only to modifying volatile registers).</li>\n</ul>\n<p>I therefore propose the following changes:</p>\n<ul>\n<li>Favor omitting the frame pointer unless there's a call to dynamically allocate stack space (if ever supported) or such that the omission of the frame pointer results in an increase of the function's size to an unsatisfactory degree.  Note: the current implementation expects that the pushing of the previous frame pointer will realign the stack prior to the call to <code>layout_stack</code>, so omitting the frame pointer will impact this assumption.</li>\n<li>For unoptimized compilation, home register-passed function arguments into the caller-provided shadow space so debuggers can find the arguments even without debug information.</li>\n<li>For optimized compilation, consider the caller-provided shadow space to be scratch and treat it as \"preallocated\" spill slots for the current frame.  However, it looks like this may violate some layout assumptions in <code>layout_stack</code> and require more consideration.</li>\n<li>Detect if the function is leaf (based on the definition above) and skip prologue and epilogue generation.</li>\n<li><del>Skip allocation of shadow space if a function does not call.</del> (now implemented)</li>\n</ul>\n<p>The result should be smaller function code generation on Windows, especially in the case of leaf functions.</p>\n<ul>\n<li>**Have you considered alternative implementations? If so, how are they better<br>\n  or worse than your proposal?**</li>\n</ul>\n<p>I have not considered alternative implementations.</p>\n<p>This issue was motivated by <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1148\">bytecodealliance/wasmtime#1148</a>.</p>\n</blockquote>",
        "id": 281227836,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651702760
    }
]