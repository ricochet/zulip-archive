[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>Hey!</p>\n<p>I've been thinking about adding heap (and stack) support for the interpreter, but I think it would be a good idea to have a runtest test suite before doing that. </p>\n<p>To that end, I've been thinking about how to integrate heaps with runtests, and this is what I've come up with, but would like to discuss and gather some feedback before proceeding with implementation.</p>\n<h4>Benefit</h4>\n<p>We get better test coverage both for the interpreter and all cranelift backends.</p>\n<h4>Implementation</h4>\n<p>My idea would be to allocate each heap in a separate <code>Vec</code>, and pass pointers to it in a <code>vmctx</code> struct. We would do this<br>\nin the trampoline whenever a function has heap annotations and a <code>vmctx</code> argument.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">heap_load_store_test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">8</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">heap0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">gv1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"mh\">0x1000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"mh\">0x1_0000_0000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset_guard</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">heap1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dynamic</span><span class=\"w\"> </span><span class=\"n\">gv2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"n\">gv3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset_guard</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">heap_addr</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">heap0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">v7</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v6</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v7</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">heap_load_store_test</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In this example we have two heaps, so we would allocate a struct that holds info about the location of these heaps<br>\nand pass its pointer as the first argument to the function</p>\n<p>The first heap (static) is preallocated with the minimum size of 4096 bytes. I don't think we have a way to resize<br>\nit, so we would always trap on accesses past the minimum size. This heap only requires the base pointer, so<br>\nwe only allocate 8 bytes of the <code>vmctx</code> struct for the base pointer.</p>\n<p>The second heap (dynamic) requires two pointers (base + bounds), so we reserve 16 bytes in the <code>vmctx</code> struct and pass <br>\nthe base and bounds pointers. Here we can reserve a default size like 16KB. Again we don't have a way to resize it dynamically, so we just don't do that.</p>\n<p>I think the syntax for what I described above is correct in the example function, but it might not be, so take it with<br>\na grain of salt.</p>\n<p>I don't like that with this design the runtest arguments no longer match what ends up in the function. But if this is<br>\nrestricted to heap tests it shouldn't be too bad.</p>\n<p>Another note is that although we don't have to always use the first argument for <code>vmctx</code>, it would be nicer if we<br>\nrestricted (by design or by convention) it that way so that things would be less confusing.</p>\n<p>Questions:</p>\n<ul>\n<li>What happens when we have heap annotations but no <code>vmctx</code> argument? My opinion here is that we just don't allocate anything.</li>\n<li>Is there a way for us to grow heaps in the middle of a test? How is this done in other virtual machines?</li>\n</ul>\n<h4>Alternatives</h4>\n<p>We can not do this and implement heap tests in the interpreter as regular rust tests. This would be a lot more verbose and would lose the benefit of testing other backends.</p>\n<p>cc: @cfallin, @abrown </p>\n</blockquote>",
        "id": 247939045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1627921783
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136#issuecomment-892750705\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>Another alternative to this can also be to provide access to the heaps via a global symbol, which would potentially solve the mismatch between run arguments and function arguments for heap tests.</p>\n</blockquote>",
        "id": 248365419,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1628090606
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136#issuecomment-892787236\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>I think I get the main point but I have questions about some of the details:</p>\n<ul>\n<li>would this \"heap setup\" code become a part of the <code>test interpret</code> infrastructure or some new test target?</li>\n<li>is the \"heap setup\" code supposed to read and understand the function prelude (the <code>gv*</code> and <code>heap*</code> definitions) and set things up appropriately? Are there restrictions to what the test writer can write in the function prelude beyond the current CLIF restrictions?</li>\n</ul>\n</blockquote>",
        "id": 248371351,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1628093470
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136#issuecomment-892788621\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>I think the heap setup code should read special directives similar to <code>; run:</code>.</p>\n</blockquote>",
        "id": 248371582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1628093579
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136#issuecomment-892871747\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<blockquote>\n<p>would this \"heap setup\" code become a part of the test interpret infrastructure or some new test target?</p>\n</blockquote>\n<p>The idea would be to keep the same targets that we have right now, and just extending their capabilities.</p>\n<p>I thought that we could keep changes contained to the <code>SingleFunctionCompiler</code>, but we would also need to change the <code>test interpret</code> to create and pass the heap info when creating the interpreter.</p>\n<blockquote>\n<p>is the \"heap setup\" code supposed to read and understand the function prelude (the gv* and heap* definitions) and set things up appropriately?</p>\n</blockquote>\n<p>Yes, my idea would be to read the Heap structure from the <code>Function</code> that is passed into the <code>SingleFunctionCompiler</code>, I don't think we would need to understand <code>gv*</code> values, or do anything special with them.</p>\n<p>I thought about it this way mostly so we don't have to introduce any new parsing steps, we would use the parsed info that's already included in the <code>Function</code>. However, this also has some issues, where we have to infer heap size from the min size, and come up with a default for dynamic heaps, which isn't great. (see bjorn3's suggestion below)</p>\n<blockquote>\n<p>Are there restrictions to what the test writer can write in the function prelude beyond the current CLIF restrictions?</p>\n</blockquote>\n<p>I think you wouldn't be able to write static heaps with a huge min value, because this would cause a big allocation and potentially OOM. But otherwise I don't see anything that we wouldn't be able to implement correctly or ignore.</p>\n<p>By ignore here I mean for example the <code>offset_guard</code> feature or the <code>bound</code> feature, which we can't really interact with in any meaningful way.</p>\n<blockquote>\n<p>I think the heap setup code should read special directives similar to ; run:.</p>\n</blockquote>\n<p>I think this also has some positives in that it is a bit more clear that the environment is providing something extra to the function under test.  It is also a bit more clear where we won't have to infer heap size from the existing declarations.</p>\n<p>It introduces an extra parsing step, but it looks like it wouldn't be too hard to integrate with the current infrastructure.</p>\n<p>I think we can have a similar syntax to what we already have in the function prelude, but only include heap type and size:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"nc\">static</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mh\">0x1000</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"nc\">dynamic</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"err\">````</span><span class=\"w\"></span>\n\n<span class=\"n\">What</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">also</span><span class=\"w\"> </span><span class=\"n\">like</span><span class=\"w\"> </span><span class=\"n\">about</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">allows</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">extend</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">features</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">later</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">symbols</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">also</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">symbol</span>:<span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">annotation</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">expose</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">symbol</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"n\">probably</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"n\">discussion</span><span class=\"p\">).</span><span class=\"w\"></span>\n<span class=\"o\">~~~</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 248387588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1628101142
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136#issuecomment-894169735\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>I have an initial implementation in #3154.</p>\n<blockquote>\n<p>Are there restrictions to what the test writer can write in the function prelude beyond the current CLIF restrictions?</p>\n</blockquote>\n<p>Implementing this revealed that while we do not have additional restrictions to function preludes, in the current form we essentially reserve the first argument being a <code>vmctx</code> for these tests.</p>\n</blockquote>",
        "id": 248595054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1628246114
    },
    {
        "content": "<p>abrown closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3136\">issue #3136</a>:</p>\n<blockquote>\n<p>Hey!</p>\n<p>I've been thinking about adding heap (and stack) support for the interpreter, but I think it would be a good idea to have a runtest test suite before doing that. </p>\n<p>To that end, I've been thinking about how to integrate heaps with runtests, and this is what I've come up with, but would like to discuss and gather some feedback before proceeding with implementation.</p>\n<h4>Benefit</h4>\n<p>We get better test coverage both for the interpreter and all cranelift backends.</p>\n<h4>Implementation</h4>\n<p>My idea would be to allocate each heap in a separate <code>Vec</code>, and pass pointers to it in a <code>vmctx</code> struct. We would do this<br>\nin the trampoline whenever a function has heap annotations and a <code>vmctx</code> argument.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">heap_load_store_test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">8</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">gv3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">heap0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">gv1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"mh\">0x1000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"mh\">0x1_0000_0000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset_guard</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">heap1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dynamic</span><span class=\"w\"> </span><span class=\"n\">gv2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"n\">gv3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset_guard</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">heap_addr</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">heap0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">v7</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v6</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v7</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">heap_load_store_test</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In this example we have two heaps, so we would allocate a struct that holds info about the location of these heaps<br>\nand pass its pointer as the first argument to the function</p>\n<p>The first heap (static) is preallocated with the minimum size of 4096 bytes. I don't think we have a way to resize<br>\nit, so we would always trap on accesses past the minimum size. This heap only requires the base pointer, so<br>\nwe only allocate 8 bytes of the <code>vmctx</code> struct for the base pointer.</p>\n<p>The second heap (dynamic) requires two pointers (base + bounds), so we reserve 16 bytes in the <code>vmctx</code> struct and pass <br>\nthe base and bounds pointers. Here we can reserve a default size like 16KB. Again we don't have a way to resize it dynamically, so we just don't do that.</p>\n<p>I think the syntax for what I described above is correct in the example function, but it might not be, so take it with<br>\na grain of salt.</p>\n<p>I don't like that with this design the runtest arguments no longer match what ends up in the function. But if this is<br>\nrestricted to heap tests it shouldn't be too bad.</p>\n<p>Another note is that although we don't have to always use the first argument for <code>vmctx</code>, it would be nicer if we<br>\nrestricted (by design or by convention) it that way so that things would be less confusing.</p>\n<p>Questions:</p>\n<ul>\n<li>What happens when we have heap annotations but no <code>vmctx</code> argument? My opinion here is that we just don't allocate anything.</li>\n<li>Is there a way for us to grow heaps in the middle of a test? How is this done in other virtual machines?</li>\n</ul>\n<h4>Alternatives</h4>\n<p>We can not do this and implement heap tests in the interpreter as regular rust tests. This would be a lot more verbose and would lose the benefit of testing other backends.</p>\n<p>cc: @cfallin, @abrown </p>\n</blockquote>",
        "id": 250510386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629822522
    }
]