[
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602764937\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602764937\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>OK, so the only thing missing is storing handles as part of a struct and passing this struct around. Personally, I think I'm leaning towards the first suggestion of always passing handles by ref.</p>\n</blockquote>",
        "id": 191513074,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584986604
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602787789\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602787789\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>On second thought, this is going to be more tricky than I originally anticipated. <code>wiggle</code> currently is built with types that take an explicit lifetime in mind, so ideally we'd have something like <code>Fd&lt;'a&gt;</code>. In other words, if there was a way for us to hide the ref inside the type, that would be ideal. To make structs hold a ref in <code>wiggle</code>, I guess we'd need to make handles a special-case indeed, and this might perhaps lead to some overly complicated code? I'm just putting it out there. @pchickey @alexcrichton what do y'all reckon?</p>\n</blockquote>",
        "id": 191518945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584989198
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602806403\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602806403\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>I think I may be missing the motivation here, it sounds like we have u32 values from wasm, <code>Fd</code>, and <code>Entry</code>. Today <code>Entry</code> is already passed by reference, and this PR looks to be switching <code>Fd</code>, which is currently a thin newtype around u32, to also be passed by reference. Why is <code>Fd</code> being changed to be passed by reference?</p>\n<p>I feel like a better eventuality may be something where if you take a <code>handle</code> type in a function it's automatically looked up, e.g. for <code>(type $fd (handle))</code> that translates to this in the trait:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">WasiSnapshot</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lookup_fd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idx</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Entry</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>(or something like that)</p>\n<p>And that way APIs don't ever actually deal with <code>Fd</code> or u32, that all happens in the wiggle layer. Even in APIs that return <code>handle</code> we could change those to return <code>Result&lt;Entry&gt;</code> in Rust and that's automatically converted to a file descriptor under the hood.</p>\n<p>I guess I'm sort of confused why we want more types passed by reference when we already have a type passed by reference, <code>Entry</code>?</p>\n</blockquote>",
        "id": 191523444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584991395
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602878676\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-602878676\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>Hmm, those are some really good points, thanks @alexcrichton! I too don’t want to make this overly complicated and convoluted, and indeed this somewhat starts to look like it. However, one motivation for handles being non-Copy and non-Clone, and passed by ref, would be to signal that they are something more than just an “index” into a capabilities table. I guess you could think of it as <code>RawFd</code> vs <code>File</code>. Now I’m not saying this is the way to go, but personally I’d welcome it if we managed to come with a wrapper type for handles that could only be passed by reference unless reconstructed using unsafe primitives such as <code>from_raw</code> and <code>as_raw</code>. So that would be the main motivation the way I understand it. Perhaps @sunfishcode could offer some details or his point of view about all this.</p>\n</blockquote>",
        "id": 191542407,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585000712
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603035345\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603035345\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>@alexcrichton I like that idea. If it's feasible to have wiggle generate the <code>get_entry</code> calls, so that the hand-maintained code just gets an <code>&amp;Entry</code> parameter instead of a <code>Fd</code>, that achieves the same goal as passing <code>Fd</code> by reference, but in a simpler way.</p>\n</blockquote>",
        "id": 191569412,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585029838
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603383135\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603383135\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>I like the idea of looking up witx handles to get a ref to some other Rust type, and passing that to the trait method. I've been fielding <a href=\"https://github.com/WebAssembly/WASI-crypto/pull/17#discussion_r395243367\" target=\"_blank\" title=\"https://github.com/WebAssembly/WASI-crypto/pull/17#discussion_r395243367\">requests</a> for wiggle to be able to convert to and from types defined in the user's code in other contexts. So I wonder if we can come up with a generalized way for wiggle users to specify that a witx type needs to be transformed to/from some externally-defined Rust type before consumption / after production.</p>\n<p>The other big use case that has come up is in Fastly's HTTP code, we have a rich (as in <code>thiserror</code>) structured error enum that we want to implement the trait method with. If we return that Err from the trait method, we would like to call another Ctx method to log it appropriately and convert it to a \"flat\" witx error enum (as in <code>errno</code>).</p>\n</blockquote>",
        "id": 191643928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585070308
    },
    {
        "content": "<p>pchickey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603383135\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603383135\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>I like the idea of looking up witx handles to get a ref to some other Rust type, and passing that to the trait method. I've been fielding <a href=\"https://github.com/WebAssembly/WASI-crypto/pull/17#discussion_r395243367\" target=\"_blank\" title=\"https://github.com/WebAssembly/WASI-crypto/pull/17#discussion_r395243367\">requests</a> for wiggle to be able to convert to and from types defined in the user's code in other contexts. So I wonder if we can come up with a generalized way for wiggle users to specify that a witx type needs to be transformed to/from some externally-defined Rust type before consumption / after production.</p>\n<p>The other big use case that has come up is in Fastly's HTTP code, we have a rich (as in <code>thiserror</code>) structured error enum that we want to implement the trait method with. If we return that Err from the trait method, we would like to call another Ctx method to log it appropriately and convert it to a \"flat\" witx error enum (as in <code>errno</code>). That use case is similar to the <code>GuestErrorType</code> trait we already require. I would like to figure out some way for that mechanism to work for handles, and external enum definitions like Frank has, as well.</p>\n<p>This is a pretty complicated design space to figure out so if anyone wants to have a zoom call to chat about it more, lets.</p>\n</blockquote>",
        "id": 191644272,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585070427
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603389084\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603389084\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>This might be a bit more premature to ask, but I guess in a trait suggested by @alexcrichton we'd expect something like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">WasiSnapshot</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Entry</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lookup_fd</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idx</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Self</span>::<span class=\"n\">Entry</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>in the sense that we wouldn't tie some specific type to the trait and the lookup method, or would we actually? I'm just trying to get a better sense of how we'd like to achieve this.</p>\n</blockquote>",
        "id": 191645312,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585070821
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603500761\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603500761\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>That's my rough thinking yeah, although it may not literally work out as such. The idea though would be that each implementation would define what an <code>Entry</code> is, and the methods that operate on all the entries would get that object in the trait. That way lucet/wasmtime could have entirely different representations if they really wanted to (but they both use wasi-common so it likely wouldn't matter)</p>\n<p>This may be a bit pie-in-the-sky though, so don't feel like anything needs to be blocked on it.</p>\n</blockquote>",
        "id": 191671341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585083442
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603837970\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-603837970\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>This issue or pull request has been labeled: \"wasi\"</p>\n<p>&lt;details&gt; &lt;summary&gt;Users Subscribed to \"wasi\"&lt;/summary&gt;</p>\n<ul>\n<li>@kubkon</li>\n</ul>\n<p>&lt;/details&gt;</p>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\" title=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a></p>\n</blockquote>",
        "id": 191743368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585142771
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375#issuecomment-628297300\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1375\">Issue #1375</a>:</p>\n<blockquote>\n<p>Closing this PR to pursue other approaches as discussed above.</p>\n</blockquote>",
        "id": 197490077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589412367
    }
]