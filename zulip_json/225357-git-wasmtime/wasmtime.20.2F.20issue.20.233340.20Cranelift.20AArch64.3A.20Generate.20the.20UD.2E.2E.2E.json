[
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Cranelift's AArch64 backend currently uses an unallocated encoding for the <code>Inst::Udf</code> VCode instruction. There is a risk that the encoding could be allocated in the future, so it might no longer be an undefined instruction, resulting in incorrect code generation. On the other hand, there is an instruction, <code>UDF</code>, which is permanently undefined and which avoids this issue.</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2552#issuecomment-758177462\">a previous discussion</a>, @bnjbvr has explained the reasons for the current approach:</p>\n<blockquote>\n<p>Yes, a few reasons come to mind. None of them seem particularly inevitable, and they could all be worked around, if we decided to use a new value, but it was simpler to choose this one for a few reasons:</p>\n<ul>\n<li>this is the same value Spidermonkey uses for triggering SIGILL, with the reasons explained there: <a href=\"https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690\">https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690</a> . If we didn't use the same value as Spidermonkey did use, either Cranelift would need a compiler option to allow selecting which undefined instruction is used (or select it among a list of predefined), or Spidermonkey should refactor its code to support different undefined instruction encodings in their aarch64 backend.</li>\n<li>there might be an argument that a native compiler (rustc/llvm) would use the default UDF instruction, and that using a different instruction in cranelift-generated code makes it easier to spot what's the actual issue in a test case. For instance, for the initial issue discussed here in particular, we could directly infer that it was a cranelift-generated undefined encoding not being properly handled by the OS. A sigill with another undefined encoding could have been this problem _or_ another illegal encoding problem (coming from llvm codegen in native code).</li>\n</ul>\n</blockquote>\n<p>Note that <code>UDF</code> has an immediate parameter, which could be used to address the second point to an extent, e.g. <code>UDF #0xBAD</code> could signify Cranelift-generated code.</p>\n</blockquote>",
        "id": 253076468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631534028
    },
    {
        "content": "<p>akirilov-arm opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Cranelift's AArch64 backend currently uses an unallocated encoding for the <code>Inst::Udf</code> VCode instruction. There is a risk that the encoding could be allocated in the future, so it might no longer be an undefined instruction, resulting in incorrect code generation. On the other hand, there is an instruction, <code>UDF</code>, which is permanently undefined and which avoids this issue.</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2552#issuecomment-758177462\">a previous discussion</a>, @bnjbvr has explained the reasons for the current approach:</p>\n<blockquote>\n<p>Yes, a few reasons come to mind. None of them seem particularly inevitable, and they could all be worked around, if we decided to use a new value, but it was simpler to choose this one for a few reasons:</p>\n<ul>\n<li>this is the same value Spidermonkey uses for triggering SIGILL, with the reasons explained there: <a href=\"https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690\">https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690</a> . If we didn't use the same value as Spidermonkey did use, either Cranelift would need a compiler option to allow selecting which undefined instruction is used (or select it among a list of predefined), or Spidermonkey should refactor its code to support different undefined instruction encodings in their aarch64 backend.</li>\n<li>there might be an argument that a native compiler (rustc/llvm) would use the default UDF instruction, and that using a different instruction in cranelift-generated code makes it easier to spot what's the actual issue in a test case. For instance, for the initial issue discussed here in particular, we could directly infer that it was a cranelift-generated undefined encoding not being properly handled by the OS. A sigill with another undefined encoding could have been this problem _or_ another illegal encoding problem (coming from llvm codegen in native code).</li>\n</ul>\n</blockquote>\n<p>Note that <code>UDF</code> has an immediate parameter, which could be used to address the second point to an extent, e.g. <code>UDF #0xBAD</code> could signify Cranelift-generated code.</p>\n</blockquote>",
        "id": 253076469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631534028
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Cranelift's AArch64 backend currently uses an unallocated encoding for the <code>Inst::Udf</code> VCode instruction. There is a risk that the encoding could be allocated in the future, so it might no longer be an undefined instruction, resulting in incorrect code generation. On the other hand, there is an instruction, <code>UDF</code>, which is permanently undefined and which avoids this issue.</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2552#issuecomment-758177462\">a previous discussion</a>, @bnjbvr has explained the reasons for the current approach:</p>\n<blockquote>\n<p>Yes, a few reasons come to mind. None of them seem particularly inevitable, and they could all be worked around, if we decided to use a new value, but it was simpler to choose this one for a few reasons:</p>\n<ul>\n<li>this is the same value Spidermonkey uses for triggering SIGILL, with the reasons explained there: <a href=\"https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690\">https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690</a> . If we didn't use the same value as Spidermonkey did use, either Cranelift would need a compiler option to allow selecting which undefined instruction is used (or select it among a list of predefined), or Spidermonkey should refactor its code to support different undefined instruction encodings in their aarch64 backend.</li>\n<li>there might be an argument that a native compiler (rustc/llvm) would use the default UDF instruction, and that using a different instruction in cranelift-generated code makes it easier to spot what's the actual issue in a test case. For instance, for the initial issue discussed here in particular, we could directly infer that it was a cranelift-generated undefined encoding not being properly handled by the OS. A sigill with another undefined encoding could have been this problem _or_ another illegal encoding problem (coming from llvm codegen in native code).</li>\n</ul>\n</blockquote>\n<p>Note that <code>UDF</code> has an immediate parameter, which could be used to address the second point to an extent, e.g. <code>UDF #0xBAD</code> could signify Cranelift-generated code.</p>\n</blockquote>",
        "id": 253076471,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631534028
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Cranelift's AArch64 backend currently uses an unallocated encoding for the <code>Inst::Udf</code> VCode instruction. There is a risk that the encoding could be allocated in the future, so it might no longer be an undefined instruction, resulting in incorrect code generation. On the other hand, there is an instruction, <code>UDF</code>, which is permanently undefined and which avoids this issue.</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2552#issuecomment-758177462\">a previous discussion</a>, @bnjbvr has explained the reasons for the current approach:</p>\n<blockquote>\n<p>Yes, a few reasons come to mind. None of them seem particularly inevitable, and they could all be worked around, if we decided to use a new value, but it was simpler to choose this one for a few reasons:</p>\n<ul>\n<li>this is the same value Spidermonkey uses for triggering SIGILL, with the reasons explained there: <a href=\"https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690\">https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690</a> . If we didn't use the same value as Spidermonkey did use, either Cranelift would need a compiler option to allow selecting which undefined instruction is used (or select it among a list of predefined), or Spidermonkey should refactor its code to support different undefined instruction encodings in their aarch64 backend.</li>\n<li>there might be an argument that a native compiler (rustc/llvm) would use the default UDF instruction, and that using a different instruction in cranelift-generated code makes it easier to spot what's the actual issue in a test case. For instance, for the initial issue discussed here in particular, we could directly infer that it was a cranelift-generated undefined encoding not being properly handled by the OS. A sigill with another undefined encoding could have been this problem _or_ another illegal encoding problem (coming from llvm codegen in native code).</li>\n</ul>\n</blockquote>\n<p>Note that <code>UDF</code> has an immediate parameter, which could be used to address the second point to an extent, e.g. <code>UDF #0xBAD</code> could signify Cranelift-generated code.</p>\n</blockquote>",
        "id": 253076472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631534028
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340#issuecomment-918149705\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Maybe use <code>0xC11F</code> as immediate? (clif) Or encode the trap code directly without requiring a side table like it does right now?</p>\n</blockquote>",
        "id": 253081980,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631536745
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340#issuecomment-918379263\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>The requirement seems mainly to come from our desire to conform to SpiderMonkey's convention when used in that context, but I don't think we need to completely freeze the bits of our design that overlap with the integration if it prevents us from \"doing the right thing\" otherwise. It does seem more idiomatic / in line with what the ISA design and other tools expect to actually use the canonical \"undefined\" instruction for traps; and from the SM point of view, this is a slight adjustment (catch a different signal or similar) in line with other API-change and similar updates that need to happen in the normal course of updating to new crate versions.</p>\n<p>cc @bnjbvr for any updated thoughts on this? Also @julian-seward1, if you're around: what's the latest (if any) on maintaining usage of Cranelift in SpiderMonkey, and if it's maintained, would it be a significant blocker to adapt to the use of <code>udf</code> for traps rather than the arbitrarily-selected instruction used now?</p>\n</blockquote>",
        "id": 253122159,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631551636
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340#issuecomment-918893447\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Agreed that keeping a custom convention that's required by a single Cranelift user makes it less relevant for other users, not much to add on the topic otherwise.</p>\n</blockquote>",
        "id": 253210269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631605127
    },
    {
        "content": "<p>akirilov-arm closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3340\">issue #3340</a>:</p>\n<blockquote>\n<p>Cranelift's AArch64 backend currently uses an unallocated encoding for the <code>Inst::Udf</code> VCode instruction. There is a risk that the encoding could be allocated in the future, so it might no longer be an undefined instruction, resulting in incorrect code generation. On the other hand, there is an instruction, <code>UDF</code>, which is permanently undefined and which avoids this issue.</p>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2552#issuecomment-758177462\">a previous discussion</a>, @bnjbvr has explained the reasons for the current approach:</p>\n<blockquote>\n<p>Yes, a few reasons come to mind. None of them seem particularly inevitable, and they could all be worked around, if we decided to use a new value, but it was simpler to choose this one for a few reasons:</p>\n<ul>\n<li>this is the same value Spidermonkey uses for triggering SIGILL, with the reasons explained there: <a href=\"https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690\">https://searchfox.org/mozilla-central/source/js/src/jit/arm64/vixl/Constants-vixl.h#2668-2690</a> . If we didn't use the same value as Spidermonkey did use, either Cranelift would need a compiler option to allow selecting which undefined instruction is used (or select it among a list of predefined), or Spidermonkey should refactor its code to support different undefined instruction encodings in their aarch64 backend.</li>\n<li>there might be an argument that a native compiler (rustc/llvm) would use the default UDF instruction, and that using a different instruction in cranelift-generated code makes it easier to spot what's the actual issue in a test case. For instance, for the initial issue discussed here in particular, we could directly infer that it was a cranelift-generated undefined encoding not being properly handled by the OS. A sigill with another undefined encoding could have been this problem _or_ another illegal encoding problem (coming from llvm codegen in native code).</li>\n</ul>\n</blockquote>\n<p>Note that <code>UDF</code> has an immediate parameter, which could be used to address the second point to an extent, e.g. <code>UDF #0xBAD</code> could signify Cranelift-generated code.</p>\n</blockquote>",
        "id": 287058206,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655906610
    }
]