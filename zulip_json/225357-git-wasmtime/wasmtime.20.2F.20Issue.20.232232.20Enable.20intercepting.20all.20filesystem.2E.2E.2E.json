[
    {
        "content": "<p>joshuawarner32 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>I'm interested in using wasmtime as a VM to run wasi scripts in a sandbox - and by being at the level normally reserved for the OS, being able to get precise information about which files/dirs the sandboxed application reads and writes. I'd also like to be able to dynamically fill in the filesystem tree exposed to the wasi program rather than having to have the tree pre-populated, as in my case the filesystem tree could be prohibitively large.</p>\n<p>There are a couple things missing from the existing <code>VirtualDirEntry</code>:</p>\n<ul>\n<li>Listing a directory dynamically - e.g. by changing the <code>Directory</code> enum from storing <code>HashMap&lt;String, VirtualDirEntry&gt;</code> to storing <code>Box&lt;dyn DirContents&gt;</code>, analogous to FileContents</li>\n<li>Receiving callbacks for when new files are created in a given dir, presumably via the new <code>trait DirContents</code></li>\n</ul>\n<p>This design is of course pretty fuzzy at this point, and I've only done a cursory inspection of the interfaces involved. I'd be interested in working on this, if this seems to be in alignment with the project's goals. Feedback is most welcome!</p>\n</blockquote>",
        "id": 211297194,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601059201
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699140891\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>Welcome! The use case you describe is very much something we want to enable.</p>\n<p>I'm presently working on a bunch of renovations to the wasi-common crate (see #2202, #2205). @sunfishcode and @alexcrichton have some ideas and works-in-progress that will also help us change the architecture of this crate. Your design ideas sound right in line with what we'd like to see, so I'd encourage you to either expand on them here or make a PR where we can all take a look together.</p>\n<p>One thing I'm failing at right now is describing a cohesive vision for what we want wasi-common to become - there are a lot of moving parts right now, and I'm trying to balance the limited time I get to do code gardening against bigger concerns like shipping a new wasi snapshot (long overdue at this point, but none of the folks involved have had much spare bandwidth this summer) and some more urgent aspects of the design which need fixing for the sake of production systems using it. We're eager to get more help with any and all of these parts of the WASI puzzle, if you'd like to be more involved we can chat on the bytecode alliance zulip.</p>\n</blockquote>",
        "id": 211314352,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601065902
    },
    {
        "content": "<p>kamyuentse <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699654686\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>I am interested in the new architecture of this crate, @joshuawarner32 describe a use case to access the host file system. And I think we need to consider how to interoperate with the remote filesystem or object storage service, hdfs, s3, etc on the cloud platform.</p>\n</blockquote>",
        "id": 211422916,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601223087
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699677537\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>One of the big pieces of this puzzle will be API virtualization. When an application imports eg. <code>fd_read</code> from <code>wasi_snapshot_preview1</code>, it should be possible at link time to resolve that to wasi-common's native implementation, to a different native implementation, or to a wasm implementation. And, these other implementations should be able to import <code>fd_read</code> from <code>wasi_snapshot_preview</code> themselves, allowing them to forward requests on to the next level down when they want to.</p>\n<p>One we have a system which can do that, we won't need traits like <code>VirtualDirEntry</code>, and won't need to worry about ensuring that traits have all the needed hooks for everyone, because people will be able to wrap the WASI APIs themselves. And, this will generalize to all APIs, and not require a trait for each API that people want to customize. And, it'll allow for completely custom implementations, so people can experiment with other backends.</p>\n</blockquote>",
        "id": 211430544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601234872
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699678266\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>I've taken a bit of a deeper look, and I think one complicated factor here is that there are actually two levels of access here:</p>\n<ul>\n<li>a tree of VirtualDirEntry's</li>\n<li>... which is transformed into a tree of InMemoryFile / VirtualDirs before execution begins</li>\n</ul>\n<p>It's not immediately clear why this layering exists, but it appears there are multiple differences:</p>\n<ul>\n<li>Config time vs runtime</li>\n<li>Data vs permissions/rights</li>\n<li>Owned vs Rc'd</li>\n</ul>\n<p>For my purposes, I'd propose that the first distinction (config time vs runtime) doesn't really make any sense; I'd actually like the same structure to live all the way to the end of the execution so that I can inspect it after the fact.</p>\n<p>Both the second (data vs rights) and third (owned vs rc'd) do probably make sense to retain, as this is necessary to properly implement multiple handles with separate rights attached, as required in posix/wasi.</p>\n<p>I do have a bit of experience in implementing filesystem-like datastructures, and one thing that's worked well in the past is to maintain a first-class concept of inodes (as identifiers for files/dirs on disk). All of the backing data for the file content / dir listing goes in a single \"Filesystem\" object, and all dir listings indirect through inode. A Handle is then just a combination of an inode and some set of rights.</p>\n<p>Concretely, I'd propose the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Inode</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// abstract identifier, maybe the usize is public maybe not</span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">Contents</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Directory</span><span class=\"p\">(</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">DirContents</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">FileContents</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">VNode</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">// explicit ref counting, to account for hard-linking files (and maybe dirs) in the tree</span>\n<span class=\"w\">  </span><span class=\"c1\">// I'm actually not sure if this is part of the wasi spec, but it is certainly typical of filesytstems</span>\n<span class=\"w\">  </span><span class=\"n\">ref_count</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">contents</span>: <span class=\"nc\">Contents</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Handle</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">inode</span>: <span class=\"nc\">Inode</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">rights</span>: <span class=\"nc\">Rights</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// There should be one single Filesystem instance per WasiCtx</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Filesystem</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// Indexed by inode</span>\n<span class=\"w\">  </span><span class=\"n\">nodes</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">VNodeRef</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"c1\">// maybe this should be separate?</span>\n<span class=\"w\">  </span><span class=\"n\">handles</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Handle</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n</blockquote>",
        "id": 211430790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601235226
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699679079\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>(sorry @sunfishcode, didn't see your reply until after I hit submit on mine)</p>\n<blockquote>\n<p>When an application imports eg. fd_read from wasi_snapshot_preview1, it should be possible at link time to resolve that to wasi-common's native implementation, to a different native implementation, or to a wasm implementation.</p>\n</blockquote>\n<p>Ooh interesting! I definitely agree this should be possible, and would certainly be pretty cool to be able to swap things out at this level too - however I'd argue that many/most users will want to customize small parts of the behavior of the runtime (such as myself), without inheriting the complexity of building a sane implementation of a posix-like FS API in their application code.</p>\n<p>In other words, I'd propose that a simpler VFS-like interface (using perhaps something inspired by interfaces used in pick-your-favorite-os-kernel for navigating/mounting different filesystems together - should exist somewhere, whether part of wasi-common, or in some other \"helper\" crate.</p>\n<p>There's substantial value in centralizing the implementation of things like rights-checking on handles, and cycle-detection (to prevent parent dirs from being moved into children).</p>\n</blockquote>",
        "id": 211431086,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601235638
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699679094\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>The difference between the two layers is because libpreopen (part of the wasi libc) gets a static list of path -&gt; fd mappings when starting. The first layer is that list, while the second layer is when reading directories at runtime.</p>\n</blockquote>",
        "id": 211431095,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601235647
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699679526\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>@bjorn3 Ah interesting. I guess in my proposal then the list passed to libpreopen would be a <code>HashMap&lt;PathBuf, Inode&gt;</code> or something similar.</p>\n</blockquote>",
        "id": 211431305,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601235882
    },
    {
        "content": "<p>joshuawarner32 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699679526\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>@bjorn3 Ah interesting. I guess in my proposal then the list passed to libpreopen would be a <code>HashMap&lt;PathBuf, Handle&gt;</code> or something similar.</p>\n</blockquote>",
        "id": 211431314,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601235896
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699679963\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>Also, to flesh out the above, here's what DirContents might look like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">DirContents</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">list</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;&amp;</span><span class=\"kt\">str</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">child_name</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Inode</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">child_name</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inode</span>: <span class=\"nc\">Inode</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n</blockquote>",
        "id": 211431469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601236111
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699680699\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>Wasmtime currently uses the host inode as wasi inode: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/b37adbbe317787fc1c627a93e36327c154e0fa68/crates/wasi-common/src/old/snapshot_0/sys/unix/linux/host_impl.rs#L11\">https://github.com/bytecodealliance/wasmtime/blob/b37adbbe317787fc1c627a93e36327c154e0fa68/crates/wasi-common/src/old/snapshot_0/sys/unix/linux/host_impl.rs#L11</a> This doesn't work well with a <code>nodes: Vec&lt;Option&lt;NodeRef&gt;&gt;</code>. Also keeping the <code>ref_count</code> of <code>Vnode</code> in sync with the host will be impossible. Lastly a file could turn into a directory without changing the inode if for example all inodes are used and then a single file is removed followed by a single directory created.</p>\n</blockquote>",
        "id": 211431759,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601236531
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699682022\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<blockquote>\n<p>Wasmtime currently uses the host inode as wasi inode</p>\n</blockquote>\n<p>This might be ideal for implementations that redirect all FS interaction to the host, but for anything that tries to virtualize part of the filesystem tree. I'd argue that in many cases it may actually be preferable to (by default) virtualize all the inodes that are passed to the wasi binary, both so that different runs can have better guarantees of determinism and for better sandboxing (since observing assigned inodes could give information about what else is running on the host).</p>\n<blockquote>\n<p>Also keeping the ref_count of Vnode in sync with the host will be impossible.</p>\n</blockquote>\n<p>I certainly wouldn't suggest keeping these in sync! The ref_count of Vnode should only represent references within the virtualized filesystem (i.e. the part accessible to the wasi binary).</p>\n<blockquote>\n<p>Lastly a file could turn into a directory without changing the inode if for example all inodes are used and then a single file is removed followed by a single directory created.</p>\n</blockquote>\n<p>This is a thing that can happen on a real filesystem too. In linux this is generally handled with the <a href=\"https://stackoverflow.com/questions/11071996/what-are-inode-generation-numbers\">generation number</a> (which is incremented whenever an inode number is reused).</p>\n</blockquote>",
        "id": 211432264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601237210
    },
    {
        "content": "<p>joshuawarner32 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-699682022\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<blockquote>\n<p>Wasmtime currently uses the host inode as wasi inode</p>\n</blockquote>\n<p>This might be ideal for implementations that redirect all FS interaction to the host, but not for anything that tries to virtualize part of the filesystem tree. I'd argue that in many cases it may actually be preferable to (by default) virtualize all the inodes that are passed to the wasi binary, both so that different runs can have better guarantees of determinism and for better sandboxing (since observing assigned inodes could give information about what else is running on the host).</p>\n<blockquote>\n<p>Also keeping the ref_count of Vnode in sync with the host will be impossible.</p>\n</blockquote>\n<p>I certainly wouldn't suggest keeping these in sync! The ref_count of Vnode should only represent references within the virtualized filesystem (i.e. the part accessible to the wasi binary).</p>\n<blockquote>\n<p>Lastly a file could turn into a directory without changing the inode if for example all inodes are used and then a single file is removed followed by a single directory created.</p>\n</blockquote>\n<p>This is a thing that can happen on a real filesystem too. In linux this is generally handled with the <a href=\"https://stackoverflow.com/questions/11071996/what-are-inode-generation-numbers\">generation number</a> (which is incremented whenever an inode number is reused).</p>\n</blockquote>",
        "id": 211432273,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601237230
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-700005040\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>If you just want to customize small part of the behavior of an API, API virtualization should work well. You wouldn't need to build a whole filesystem yourself; you'd call into the \"next level down\" as needed. In the use case described at the top of this issue, the implementation of <code>path_open</code> would record the path being accessed, and then import and call <code>path_open</code> to do the actual work of opening the file.</p>\n<p>A VFS layer makes sense to have when implementing filesystem APIs on top of things that aren't already filesystems, and which you have exclusive access to, such as block devices or in-memory filesystems. But when implementing filesystems in terms of APIs which already are filesystems, and which could be accessed concurrently by other processes, an extra layer of reference counting and and extra inode index space are redundant and potentially tricky to keep in sync. So if we have a VFS mechanism, it seems like we'd provide it as a library that filesystem implementations could use independently, rather than being something built into <code>WasiCtx</code>.</p>\n</blockquote>",
        "id": 211491536,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601299537
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-700077993\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<blockquote>\n<p>So if we have a VFS mechanism, it seems like we'd provide it as a library</p>\n</blockquote>\n<p>I could get behind that.</p>\n<p>In that case the more pressing question becomes, what's the right way to let crates use most of the existing wasi infrastructure, but also plug in this hypothetical library (wasi-vfs, maybe)? Would the right interface be directly (re)implementing the <code>fd_read</code>/etc. If so, is that possible now with <code>WasiCtx</code>?</p>\n<p>Or perhaps there could be an intermediate layer that lets WasiCtx handle things like rights/perms on handles, but derer all other logic to a lower-level interface for data access - perhaps something like FileContents, but \"global\" to the filesystem? Maybe this could be similar in spirit to the <code>Filesystem</code> trait I discussed above, except it would _not_ take any responsibility for virtualizing inodes/etc.</p>\n</blockquote>",
        "id": 211507463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601306661
    },
    {
        "content": "<p>joshuawarner32 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232#issuecomment-700401771\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2232\">Issue #2232</a>:</p>\n<blockquote>\n<p>I've continued to look through the code, and it looks like <code>Handle</code> is actually not too far away from the abstraction level I'm looking for. What about exposing that trait and adding a <code>WasiCtxBuilder::preopened_handle</code> method that accepts a <code>Box&lt;dyn Handle&gt;</code> (or similar) instead?</p>\n</blockquote>",
        "id": 211576885,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1601349616
    }
]