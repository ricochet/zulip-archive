[
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/708\">Issue #708</a>:</p>\n<blockquote>\n<p>I've been reviewing the <code>wasmtime</code> crate from a Rust API perspective and ended up realizing that there's actually quite a few changes that I would like to make to the crate. I think that these changes are far too large so simply send in a PR, so I wanted to make sure that we had some discussion of this first!</p>\n<p>In this issue I hope to lay out a vision for an end-state <code>wasmtime</code> crate and what the API might look like. I'm assuming that we can incrementally reach this end-goal over time and the exact route through which we get here isn't too too important. In any case, I'm curious if others have thoughts on all this!</p>\n<p>Some of these items below may warrant their own separate issue as well, but I wanted to make sure that I had this all written down in one location first</p>\n<h2>High-level changes</h2>\n<ul>\n<li>All <code>wasmtime-*</code> crates should be private dependencies</li>\n<li><code>Store</code> should implement <code>Default</code></li>\n<li>Document everything</li>\n<li>Update <code>Send</code> and <code>Sync</code> of all types</li>\n<li>Internal reference counting instead of <code>HostRef</code>, <code>HostRef</code> is hidden</li>\n<li>No methods should use raw identifiers</li>\n<li><code>Instance</code> is no longer reference counted to ensure that it's <code>Send</code> meaning globals/tables/functions are no longer reference counted either.</li>\n</ul>\n<h2><code>Config</code></h2>\n<ul>\n<li>[x] Should remove methods referencing foreign <code>wasmtime-*</code> types</li>\n<li>[x] Should assert <code>Send</code> and <code>Sync</code></li>\n</ul>\n<h2><code>Engine</code></h2>\n<ul>\n<li>[x] Should implement <code>Default</code> (uses default <code>Config</code>)</li>\n<li>[x] Should assert <code>Send</code> and <code>Sync</code></li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n</ul>\n<h2><code>Store</code></h2>\n<ul>\n<li>[x] Should implement <code>Default</code> (uses default <code>Config</code> and <code>Engine</code>)</li>\n<li>[x] <del>Should be <code>Send</code> and <code>Sync</code></del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/777\">https://github.com/bytecodealliance/wasmtime/issues/777</a>)</li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n<li>[ ] Remove <code>wasmtime-*</code> accessors</li>\n</ul>\n<h2><code>Module</code></h2>\n<ul>\n<li>[x] <del>Should be <code>Send</code> and <code>Sync</code></del> (covered by <a href=\"https://github.com/bytecodealliance/wasmtime/issues/777\">https://github.com/bytecodealliance/wasmtime/issues/777</a>)</li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n<li>[x] Expose a <code>&amp;Store</code> accessor</li>\n<li>[x] Implementation-wise constructor should likely compile the wasm code</li>\n</ul>\n<h2><code>Instance</code></h2>\n<ul>\n<li>[x] Constructor shouldn't require <code>Store</code> (inferred from <code>Module</code>)</li>\n<li>[x] Constructor's return should expose <code>Trap</code> (handled if <code>Trap</code> is an <code>Error</code>)</li>\n<li>[x] Should expose <code>module</code> and <code>store</code> accessor</li>\n<li>[x] <del>Should be <code>Send</code> </del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\">https://github.com/bytecodealliance/wasmtime/issues/793</a>)<ul>\n<li>Internally <strong>not reference counted</strong></li>\n<li>Accessing tables/etc all return a <em>reference</em>, not an owned type</li>\n</ul>\n</li>\n<li>[x] <code>find_export_by_name</code> =&gt; <code>get_export</code></li>\n</ul>\n<h2><code>Global</code>, <code>Table</code>, <code>Memory</code></h2>\n<ul>\n<li>[x] Remove all internal reference counts<ul>\n<li><code>Memory</code> should be fine to leave with an internal <code>Arc</code></li>\n</ul>\n</li>\n<li>[x] <del>Everything should be <code>Send</code>, only <code>Memory</code> should be <code>Sync</code></del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\">https://github.com/bytecodealliance/wasmtime/issues/793</a>)</li>\n<li>[x] <code>Table::grow</code> shouldn't need <code>mut</code></li>\n<li>[x] <code>Global::set</code> shouldn't need <code>mut</code></li>\n<li>[x] <code>type</code> methods renamed to <code>ty</code></li>\n<li>[x] <code>Memory::grow</code> shouldn't need <code>mut</code></li>\n</ul>\n<p>These types are only accessed via a <em>reference</em> when fetched through an <code>Instance</code>.</p>\n<h2><code>Func</code></h2>\n<p>This type I think needs a lot of improvements. I think it's best to separate out these concerns into a separate issue, however. Some high-level unbaked thoughts are:</p>\n<ul>\n<li>Right now it's very allocation-heavy, probably too much so</li>\n<li>There should be a way of taking a function pointer (as a <code>usize</code>) and registering it with a type signature. This would skip all trampolines/etc and we'd document the expected ABI. This would be an <code>unsafe</code> method.</li>\n<li>There should also be a method of <em>extracting</em> an internal function pointer with the right ABI. You would then manually assert the function type as necessary and would unsafely transmute the function pointer returned to a function pointer of the right type.</li>\n<li>Somehow data payloads are handled for the above \"raw\" methods, haven't fully thought this through...</li>\n</ul>\n<h2><code>MemoryType</code>, <code>TableType</code>, <code>GlobalType</code></h2>\n<ul>\n<li>Bikeshed on the name <code>Mutability</code>, otherwise seems good!</li>\n</ul>\n<h2><code>ImportType</code>, <code>ExportType</code></h2>\n<ul>\n<li>a little allocation-heavy, but probably fine</li>\n</ul>\n<h2><code>FuncType</code></h2>\n<ul>\n<li>Feels a bit allocation-heavy right now</li>\n<li>Maybe intern in a <code>Store</code>, but probably fine for now.</li>\n</ul>\n<h2><code>Trap</code></h2>\n<ul>\n<li>[x] Implement the <code>Error</code> trait</li>\n<li>[x] Ensure it's pointer-sized</li>\n<li>[x] Ensure it's <code>Clone</code>, <code>Send</code>, and <code>Sync</code></li>\n</ul>\n<h2><code>Val</code></h2>\n<ul>\n<li>Commit to \"ownership semantics\"</li>\n<li><code>AnyRef</code> will become some custom form of <code>Rc</code> defined by <code>wasmtime</code> itself<ul>\n<li>jit will have its own refcounting management for tables/globals/etc (needs to be implemented)</li>\n</ul>\n</li>\n<li>Let's do <code>Box&lt;u128&gt;</code> for now to avoid blowing up the size</li>\n<li>Enusring \"ownership semantics\" leaves room for implementing interface types strings eventually</li>\n<li>Consider making <code>Val</code> an entirely opaque struct, perhaps with a <code>decode</code> method which returns a full <code>enum</code>. We may not want to commit to a public byte-by-byte representation of a <code>Val</code> just yet. This seems like an advanced concern we can punt though.</li>\n</ul>\n<h2>WASI</h2>\n<blockquote>\n<p>This is now split off to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/727\">https://github.com/bytecodealliance/wasmtime/issues/727</a></p>\n</blockquote>\n<ul>\n<li>Somehow we need to add WASI support to the <code>wasmtime</code> crate</li>\n<li>\"bare minimum\" is <code>fn wasi_unstable(&amp;WasiConfiguration) -&gt; HashMap&lt;String, Extern&gt;</code></li>\n<li>Perhaps related to the name resolution point below?<br>\n    * Or perhaps create an <code>Instance</code> somehow?</li>\n</ul>\n<h2>Name Resolution</h2>\n<blockquote>\n<p>This is now split off to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/727\">https://github.com/bytecodealliance/wasmtime/issues/727</a></p>\n</blockquote>\n<p>Instantiation is a bit wonky where you have to line up imports 1:1 with the expected imports of the module. We should explore ideas where we have a more name resolution based mechanism which leverages the module system. Would perhaps make it much easier to slot in WASI or slot in a module. Pretty tricky API though so we'd have to think elsewhere about this.</p>\n</blockquote>",
        "id": 233556185,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1617827479
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/708\">Issue #708</a>:</p>\n<blockquote>\n<p>I've been reviewing the <code>wasmtime</code> crate from a Rust API perspective and ended up realizing that there's actually quite a few changes that I would like to make to the crate. I think that these changes are far too large so simply send in a PR, so I wanted to make sure that we had some discussion of this first!</p>\n<p>In this issue I hope to lay out a vision for an end-state <code>wasmtime</code> crate and what the API might look like. I'm assuming that we can incrementally reach this end-goal over time and the exact route through which we get here isn't too too important. In any case, I'm curious if others have thoughts on all this!</p>\n<p>Some of these items below may warrant their own separate issue as well, but I wanted to make sure that I had this all written down in one location first</p>\n<h2>High-level changes</h2>\n<ul>\n<li>All <code>wasmtime-*</code> crates should be private dependencies</li>\n<li><code>Store</code> should implement <code>Default</code></li>\n<li>Document everything</li>\n<li>Update <code>Send</code> and <code>Sync</code> of all types</li>\n<li>Internal reference counting instead of <code>HostRef</code>, <code>HostRef</code> is hidden</li>\n<li>No methods should use raw identifiers</li>\n<li><code>Instance</code> is no longer reference counted to ensure that it's <code>Send</code> meaning globals/tables/functions are no longer reference counted either.</li>\n</ul>\n<h2><code>Config</code></h2>\n<ul>\n<li>[x] Should remove methods referencing foreign <code>wasmtime-*</code> types</li>\n<li>[x] Should assert <code>Send</code> and <code>Sync</code></li>\n</ul>\n<h2><code>Engine</code></h2>\n<ul>\n<li>[x] Should implement <code>Default</code> (uses default <code>Config</code>)</li>\n<li>[x] Should assert <code>Send</code> and <code>Sync</code></li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n</ul>\n<h2><code>Store</code></h2>\n<ul>\n<li>[x] Should implement <code>Default</code> (uses default <code>Config</code> and <code>Engine</code>)</li>\n<li>[x] <del>Should be <code>Send</code> and <code>Sync</code></del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/777\">https://github.com/bytecodealliance/wasmtime/issues/777</a>)</li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n<li>[x] Remove <code>wasmtime-*</code> accessors</li>\n</ul>\n<h2><code>Module</code></h2>\n<ul>\n<li>[x] <del>Should be <code>Send</code> and <code>Sync</code></del> (covered by <a href=\"https://github.com/bytecodealliance/wasmtime/issues/777\">https://github.com/bytecodealliance/wasmtime/issues/777</a>)</li>\n<li>[x] Should internally reference count (implements <code>Clone</code>)</li>\n<li>[x] Expose a <code>&amp;Store</code> accessor</li>\n<li>[x] Implementation-wise constructor should likely compile the wasm code</li>\n</ul>\n<h2><code>Instance</code></h2>\n<ul>\n<li>[x] Constructor shouldn't require <code>Store</code> (inferred from <code>Module</code>)</li>\n<li>[x] Constructor's return should expose <code>Trap</code> (handled if <code>Trap</code> is an <code>Error</code>)</li>\n<li>[x] Should expose <code>module</code> and <code>store</code> accessor</li>\n<li>[x] <del>Should be <code>Send</code> </del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\">https://github.com/bytecodealliance/wasmtime/issues/793</a>)<ul>\n<li>Internally <strong>not reference counted</strong></li>\n<li>Accessing tables/etc all return a <em>reference</em>, not an owned type</li>\n</ul>\n</li>\n<li>[x] <code>find_export_by_name</code> =&gt; <code>get_export</code></li>\n</ul>\n<h2><code>Global</code>, <code>Table</code>, <code>Memory</code></h2>\n<ul>\n<li>[x] Remove all internal reference counts<ul>\n<li><code>Memory</code> should be fine to leave with an internal <code>Arc</code></li>\n</ul>\n</li>\n<li>[x] <del>Everything should be <code>Send</code>, only <code>Memory</code> should be <code>Sync</code></del> (moved to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/793\">https://github.com/bytecodealliance/wasmtime/issues/793</a>)</li>\n<li>[x] <code>Table::grow</code> shouldn't need <code>mut</code></li>\n<li>[x] <code>Global::set</code> shouldn't need <code>mut</code></li>\n<li>[x] <code>type</code> methods renamed to <code>ty</code></li>\n<li>[x] <code>Memory::grow</code> shouldn't need <code>mut</code></li>\n</ul>\n<p>These types are only accessed via a <em>reference</em> when fetched through an <code>Instance</code>.</p>\n<h2><code>Func</code></h2>\n<p>This type I think needs a lot of improvements. I think it's best to separate out these concerns into a separate issue, however. Some high-level unbaked thoughts are:</p>\n<ul>\n<li>Right now it's very allocation-heavy, probably too much so</li>\n<li>There should be a way of taking a function pointer (as a <code>usize</code>) and registering it with a type signature. This would skip all trampolines/etc and we'd document the expected ABI. This would be an <code>unsafe</code> method.</li>\n<li>There should also be a method of <em>extracting</em> an internal function pointer with the right ABI. You would then manually assert the function type as necessary and would unsafely transmute the function pointer returned to a function pointer of the right type.</li>\n<li>Somehow data payloads are handled for the above \"raw\" methods, haven't fully thought this through...</li>\n</ul>\n<h2><code>MemoryType</code>, <code>TableType</code>, <code>GlobalType</code></h2>\n<ul>\n<li>Bikeshed on the name <code>Mutability</code>, otherwise seems good!</li>\n</ul>\n<h2><code>ImportType</code>, <code>ExportType</code></h2>\n<ul>\n<li>a little allocation-heavy, but probably fine</li>\n</ul>\n<h2><code>FuncType</code></h2>\n<ul>\n<li>Feels a bit allocation-heavy right now</li>\n<li>Maybe intern in a <code>Store</code>, but probably fine for now.</li>\n</ul>\n<h2><code>Trap</code></h2>\n<ul>\n<li>[x] Implement the <code>Error</code> trait</li>\n<li>[x] Ensure it's pointer-sized</li>\n<li>[x] Ensure it's <code>Clone</code>, <code>Send</code>, and <code>Sync</code></li>\n</ul>\n<h2><code>Val</code></h2>\n<ul>\n<li>Commit to \"ownership semantics\"</li>\n<li><code>AnyRef</code> will become some custom form of <code>Rc</code> defined by <code>wasmtime</code> itself<ul>\n<li>jit will have its own refcounting management for tables/globals/etc (needs to be implemented)</li>\n</ul>\n</li>\n<li>Let's do <code>Box&lt;u128&gt;</code> for now to avoid blowing up the size</li>\n<li>Enusring \"ownership semantics\" leaves room for implementing interface types strings eventually</li>\n<li>Consider making <code>Val</code> an entirely opaque struct, perhaps with a <code>decode</code> method which returns a full <code>enum</code>. We may not want to commit to a public byte-by-byte representation of a <code>Val</code> just yet. This seems like an advanced concern we can punt though.</li>\n</ul>\n<h2>WASI</h2>\n<blockquote>\n<p>This is now split off to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/727\">https://github.com/bytecodealliance/wasmtime/issues/727</a></p>\n</blockquote>\n<ul>\n<li>Somehow we need to add WASI support to the <code>wasmtime</code> crate</li>\n<li>\"bare minimum\" is <code>fn wasi_unstable(&amp;WasiConfiguration) -&gt; HashMap&lt;String, Extern&gt;</code></li>\n<li>Perhaps related to the name resolution point below?<br>\n    * Or perhaps create an <code>Instance</code> somehow?</li>\n</ul>\n<h2>Name Resolution</h2>\n<blockquote>\n<p>This is now split off to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/727\">https://github.com/bytecodealliance/wasmtime/issues/727</a></p>\n</blockquote>\n<p>Instantiation is a bit wonky where you have to line up imports 1:1 with the expected imports of the module. We should explore ideas where we have a more name resolution based mechanism which leverages the module system. Would perhaps make it much easier to slot in WASI or slot in a module. Pretty tricky API though so we'd have to think elsewhere about this.</p>\n</blockquote>",
        "id": 233556192,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1617827482
    }
]