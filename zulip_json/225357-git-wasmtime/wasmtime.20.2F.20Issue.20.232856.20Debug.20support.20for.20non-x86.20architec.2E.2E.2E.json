[
    {
        "content": "<p>uweigand opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2856\">Issue #2856</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Support debugging JITted WebAssembly code on non-x86 platforms.</p>\n<h4>Benefit</h4>\n<p>Currently, the debug crate only supports x86.  All other platforms should be supported as well.</p>\n<h4>Implementation</h4>\n<p>There are a number of places that currently prevent the debug crate from supporting non-x86 platforms:</p>\n<ul>\n<li>Explicit architecture check in <a href=\"http://lib.rs\">lib.rs</a>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">e_machine</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">EM_X86_64</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">machine</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">bail</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Unsupported ELF target machine: {:x}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">machine</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(This should just go away, I think.)</p>\n<ul>\n<li>Explicit X86 assumptions in transform/expression.rs: </li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">writer</span><span class=\"p\">.</span><span class=\"n\">write_op_breg</span><span class=\"p\">(</span><span class=\"n\">X86_64</span>::<span class=\"n\">RBP</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">writer</span><span class=\"p\">.</span><span class=\"n\">write_sleb128</span><span class=\"p\">(</span><span class=\"n\">ss_offset</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">X86_64_STACK_OFFSET</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(This is only used for old-style back-ends and can probably go away soon.)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">writer</span><span class=\"p\">.</span><span class=\"n\">write_op_breg</span><span class=\"p\">(</span><span class=\"n\">X86_64</span>::<span class=\"n\">RSP</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(This should probably use the register mapper that unwinder code also uses.)</p>\n<ul>\n<li>\n<p>Various little-endian assumptions accessing ELF files and WebAssembly memory<br>\n(See <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2854\">https://github.com/bytecodealliance/wasmtime/pull/2854</a> for details.)</p>\n</li>\n<li>\n<p>Additional endian issues (not solved by the PR above) in creating DWARF expressions<br>\nCurrent code in transform/expression.rs simply copies portions of the incoming WebAssembly DWARF expressions directly into the native DWARF output.  This is not correct in case the native architecture is big-endian.  Fortunately, the byte code for many DWARF expressions is not endian-sensitive, so I can actually debug simple applications even so.  But to be fully correct, those portions of DWARF bytecode that _are_ endian-sensitive will need to be handled here somehow.<br>\n</p>\n</li>\n</ul>\n</blockquote>",
        "id": 235503664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619009479
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2856#issuecomment-824035303\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2856\">Issue #2856</a>:</p>\n<blockquote>\n<p>Hi @cfallin, this is the topic we talked about recently.  I just wanted to open this issue to document all the places I've found where there is currently X86-specific code in the debug crate.</p>\n</blockquote>",
        "id": 235503828,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619009543
    }
]