[
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572\">issue #9572</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>While <a href=\"https://github.com/WebAssembly/memory-control/blob/main/proposals/memory-control/discard.md\"><code>memory.discard</code></a> isn't here yet, we could use a way to shrink Wasm module memory without having to reinitialise it. I propose a Wasmtime function to simply shrink the linear memory.</p>\n<h4>Context</h4>\n<p>I have a C <a href=\"https://github.com/Photosounder/WAHE/tree/main/wahelib\">library</a> with which I can make native host programs that call Wasm reactor module functions sequentially using Wasmtime and the modules have access to one C function to send commands back to the host. Lots of things can be done this way, as it is I could even shrink memory by reinitialising it, but there could be a better way. In many cases I can even see the exact contents of a module's heap from the host so I can see how much free space there is at the end of the heap.</p>\n<h4>Benefit</h4>\n<p>In some situations a Wasm module can temporarily need lots of memory. As it is we're not really able to then release that memory without reinitialising the module. If we had a way to simply directly shrink the linear memory buffer to a given number of pages that would go a long way. In my case the host could shrink it either by user input, its own determination (many of my modules use an allocator that allows the host to clearly identify all the allocations on the module's heap) or the module could even send a message to the host requesting for the memory to be shrank either right away or after <code>wasmtime_func_call()</code> is done.</p>\n<h4>Implementation</h4>\n<p>I think a simple function (in terms of the C API, I don't know about the Rust side) like <code>wasmtime_error_t *wasmtime_memory_shrink(wasmtime_context_t *store, const wasmtime_memory_t *memory, uint64_t new_size, uint64_t *prev_size)</code> would do nicely, and it would very simply just shrink the linear memory buffer. We have <code>wasmtime_memory_grow()</code> so why not <code>wasmtime_memory_shrink()</code>.</p>\n<h4>Alternatives</h4>\n<p>Without this I would wait for the module's function to be done executing, copy its memory up to the new size somewhere else, reinitialise the module so it has a new memory, grow it to the desired size and copy the copy back into the module's new linear memory. My proposal would make things smoother. Even better if it's something effectively just like calling <code>realloc()</code> on a buffer so that shrinking regularly by a page or two would happen in no time.</p>\n</blockquote>",
        "id": 481181969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731005950
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572\">issue #9572</a>:</p>\n<blockquote>\n<p>Edited by @fitzgen: This issue has evolved. For the up-to-date description, see <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572#issuecomment-2462953435\">this comment</a></p>\n<hr>\n<p>&lt;details&gt; &lt;summary&gt;Original Issue Text&lt;/summary&gt;</p>\n<h4>Feature</h4>\n<p>While <a href=\"https://github.com/WebAssembly/memory-control/blob/main/proposals/memory-control/discard.md\"><code>memory.discard</code></a> isn't here yet, we could use a way to shrink Wasm module memory without having to reinitialise it. I propose a Wasmtime function to simply shrink the linear memory.</p>\n<h4>Context</h4>\n<p>I have a C <a href=\"https://github.com/Photosounder/WAHE/tree/main/wahelib\">library</a> with which I can make native host programs that call Wasm reactor module functions sequentially using Wasmtime and the modules have access to one C function to send commands back to the host. Lots of things can be done this way, as it is I could even shrink memory by reinitialising it, but there could be a better way. In many cases I can even see the exact contents of a module's heap from the host so I can see how much free space there is at the end of the heap.</p>\n<h4>Benefit</h4>\n<p>In some situations a Wasm module can temporarily need lots of memory. As it is we're not really able to then release that memory without reinitialising the module. If we had a way to simply directly shrink the linear memory buffer to a given number of pages that would go a long way. In my case the host could shrink it either by user input, its own determination (many of my modules use an allocator that allows the host to clearly identify all the allocations on the module's heap) or the module could even send a message to the host requesting for the memory to be shrank either right away or after <code>wasmtime_func_call()</code> is done.</p>\n<h4>Implementation</h4>\n<p>I think a simple function (in terms of the C API, I don't know about the Rust side) like <code>wasmtime_error_t *wasmtime_memory_shrink(wasmtime_context_t *store, const wasmtime_memory_t *memory, uint64_t new_size, uint64_t *prev_size)</code> would do nicely, and it would very simply just shrink the linear memory buffer. We have <code>wasmtime_memory_grow()</code> so why not <code>wasmtime_memory_shrink()</code>.</p>\n<h4>Alternatives</h4>\n<p>Without this I would wait for the module's function to be done executing, copy its memory up to the new size somewhere else, reinitialise the module so it has a new memory, grow it to the desired size and copy the copy back into the module's new linear memory. My proposal would make things smoother. Even better if it's something effectively just like calling <code>realloc()</code> on a buffer so that shrinking regularly by a page or two would happen in no time.</p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 481182294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731006063
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572#issuecomment-2463004386\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572\">issue #9572</a>:</p>\n<blockquote>\n<p>I've updated the issue title to reflect the new intentions here.</p>\n<p>@Photosounder are you interested in trying your hand at implementing this feature?</p>\n</blockquote>",
        "id": 481182433,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731006123
    },
    {
        "content": "<p>Photosounder <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572#issuecomment-2463033565\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9572\">issue #9572</a>:</p>\n<blockquote>\n<blockquote>\n<p>I've updated the issue title to reflect the new intentions here.</p>\n<p>@Photosounder are you interested in trying your hand at implementing this feature?</p>\n</blockquote>\n<p>Thanks, but I don't know Rust at all and like I said the topic of dealing with OS pages is new to me so it's best left to someone competent <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>",
        "id": 481185058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731007187
    }
]