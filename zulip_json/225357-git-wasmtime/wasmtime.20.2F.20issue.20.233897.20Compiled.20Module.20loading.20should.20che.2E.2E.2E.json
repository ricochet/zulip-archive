[
    {
        "content": "<p>pchickey opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a>:</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274484130,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646702864
    },
    {
        "content": "<p>pchickey assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a>:</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274484175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646702884
    },
    {
        "content": "<p>pchickey unassigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a> (assigned to cfallin):</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274484181,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646702896
    },
    {
        "content": "<p>pchickey assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a> (assigned to cfallin):</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274484190,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646702903
    },
    {
        "content": "<p>pchickey assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a> (assigned to alexcrichton):</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274484192,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646702909
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897#issuecomment-1061892588\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a>:</p>\n<blockquote>\n<p>Concerning item 2, there is a subtlety - it might be acceptable to have some discrepancy between the features supported by the host CPU and those used by the compiled module if the difference consists of features that are backward-compatible. Examples are Pointer Authentication and Branch Target Identification from the Arm instruction set architecture (which I am discussing in <a href=\"https://github.com/bytecodealliance/rfcs/issues/17\">bytecodealliance/rfcs#17</a> and have prototyped in PR #3693) and I believe that the <code>ENDBR</code> instruction introduced by Intel CET behaves similarly.</p>\n<p>cc @abrown</p>\n</blockquote>",
        "id": 274555239,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646752888
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897#issuecomment-1062154456\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a>:</p>\n<blockquote>\n<p>I implemented #3899 in a way that can accomodate the pointer authentication bits since the query made is \"is this feature compatible with the native host\" so there's room to say whether or not pointer authentication is enabled that's always compatible with the native host (possibly with extra handling to enter/exit the module in a different fashion if it's enabled/disabled). </p>\n</blockquote>",
        "id": 274597620,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646769495
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3897\">issue #3897</a> (assigned to alexcrichton):</p>\n<blockquote>\n<p>Loading a compiled module into wasmtime may mean the Module was compiled on a different machine. Wasmtime does not provide a mechanism to make sure the set of flags on a compiled module is compatible with the CPU that the compiled module will be executed on.</p>\n<p>Presently, when wasmtime loads a compiled <code>Module</code> (e.g. <code>Module::deserialize_file</code>), the isa flags in the loaded module are only checked when <code>cfg(compiler)</code>:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321\">https://github.com/bytecodealliance/wasmtime/blob/802302602c94c6c171553d0f2bd2e4a6371ea1fc/crates/wasmtime/src/module/serialization.rs#L316-L321</a></p>\n<p>This check doesn't even perform precisely what we want - it will determine if the Engine's flags are compatible with the loaded module, which do not necessarily match the host cpu.</p>\n<p>So, I propose the following additions to wasmtime:</p>\n<ol>\n<li><code>wasmtime::Config</code> should have the <code>target</code> and <code>cranelift_flag_set</code> methods available even when the feature <code>cranelift</code> is not enabled (e.g. in runtime-only mode).</li>\n<li><code>wasmtime::Config</code> should have a setting which mandates that <code>Engine</code> construction validates those target and cranelift flags against the host cpu. This needs to be configable so that an engine Engine can be used for cross-compilation.</li>\n<li>When loading a compiled Module, the isa flags should be checked against the Engine settings even when <code>cfg(compiler)</code> is not enabled.</li>\n</ol>\n</blockquote>",
        "id": 274706360,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1646840787
    }
]