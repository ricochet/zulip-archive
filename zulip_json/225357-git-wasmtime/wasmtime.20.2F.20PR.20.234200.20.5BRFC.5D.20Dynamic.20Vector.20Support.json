[
    {
        "content": "<p>sparker-arm opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>:</p>\n<blockquote>\n<p>Introduce a new concept in the IR that allows a producer to create<br>\ndynamic vector types. An IR function can now contain global value(s)<br>\nthat represent a dynamic scaling factor, for a given fixed-width<br>\nvector type. A dynamic type is then created by 'multiplying' the<br>\ncorresponding global value with a fixed-width type. These new types<br>\ncan be used just like the existing types and the type system has a<br>\nset of hard-coded dynamic types, such as I32X4XN, which the user<br>\ndefined types map onto. The dynamic types are also used explicitly<br>\nto create dynamic stack slots, which have no set size like their<br>\nexisting counterparts. New IR instructions are added to access these<br>\nnew stack entities.</p>\n<p>Currently, during codegen, the dynamic scaling factor has to be<br>\nlowered to a constant so the dynamic slots do eventually have a<br>\ncompile-time known size, as do spill slots.</p>\n<p>The current lowering for aarch64 just targets Neon, using a dynamic<br>\nscale of 1.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 284591607,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654078884
    },
    {
        "content": "<p><strong>sparker-arm</strong> requested <a href=\"https://github.com/cfallin\">cfallin</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a>.</p>",
        "id": 284591745,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654078981
    },
    {
        "content": "<p><strong>sparker-arm</strong> requested <a href=\"https://github.com/abrown\">abrown</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a>.</p>",
        "id": 284591767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654078996
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-992511935\">PR review</a>.</p>",
        "id": 284653595,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654109243
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-992511935\">PR review</a>.</p>",
        "id": 284653597,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654109244
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r887184832\">PR review comment</a>:</p>\n<blockquote>\n<p>Can you say more about the \"minimum lane count\" concept -- why it exists, and cases where one might provide different minimum lane counts? And why only {1/2, 1, 2} as factors?</p>\n<p>In particular if this comes from a machine restriction, I'm somewhat concerned that we would be baking a specific set of details into the type-system framework forever. I'd rather have a somewhat higher-level notion of dynamic types in CLIF, e.g. <code>i32xN</code>; and then when we evaluate the <code>dyn_scale_...</code> global value, we can either make whatever guarantees we need for <code>N</code> if the value is at the discretion of the ISA backend, or for values loaded from the user, we can place additional restrictions as needed (e.g., a backend provides the embedder a \"minimum multiple for dynamic vector size\" and the embedder uses this).</p>\n</blockquote>",
        "id": 284653598,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654109244
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r887179373\">PR review comment</a>:</p>\n<blockquote>\n<p>This is slightly unclear to me: does this mean that it takes the size of the target's register width and divides by <code>vector_type</code>? i.e. that it has a concrete value determined by the compiler configuration / target microarchitecture? Or is it passed in / determined in some other way?</p>\n<p>Or I guess my confusion comes from: I would expect <code>DynScale</code> as a name to imply that this is some generic sort of scale parameter, while this seems to say that it is a specific scale value determined by some algorithm (\"what will fit in ...\"). So maybe a better name would help: <code>DynScaleTargetReg</code>? And in the future we may have some other <code>DynScale...</code> options based on loads of parameters from vmctx, or a special vector-length register, or a <code>DynScaleConstant</code>, or ...</p>\n</blockquote>",
        "id": 284653599,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654109244
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-996336685\">PR review</a>.</p>",
        "id": 285088979,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654505996
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r889956125\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>does this mean that it takes the size of the target's register width and divides by vector_type?</p>\n</blockquote>\n<p>Yes. So for a given dynamic type, the backend will scale the fixed part of the type by <code>DynScale</code>. The name is likely misleading.</p>\n<p>I feel we shouldn't need to prescribe different global values for constant scale or truly dynamic ones via a register, as it's not immediately obvious, to me, why this would be helpful at the IR level. I feel we should be able to encapsulate the semantics we want with a single construct and allow a backend to lower it how it wishes.... but...</p>\n<p>It would almost certainly make it far easier to implement the machinst ABI and, as that is a particular point of pain, it would be good to make that as simple as possible :)</p>\n<p>For this first implementation we could rename to <code>DynScaleConstant</code> and it would much better describe the current limitations. </p>\n</blockquote>",
        "id": 285088980,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654505996
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r889972548\">PR review comment</a>:</p>\n<blockquote>\n<p>The minimum lane count comes from the fact that we build a dynamic vector type from a fixed base vector type. The fixed base type provides the minimum lane count.</p>\n<p>I added the halving/doubling to try to mimic the functionality of the existing SIMD types, and the ones commonly used, but I don't think it's needed and possibly doesn't make sense. But the main reason was for encoding space...</p>\n<p>My problem here was that cranelift has a very large range of SIMD types, which made it hard, for me, to add another group of types with a reasonable range. What I wanted to do was just to use a single bit, along with the existing SIMD types, to express a dynamic vector type but I struggled and failed there.... So I'm very much happy to hear suggestions, I would really prefer to not use this 2-bit system.</p>\n</blockquote>",
        "id": 285090441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654507344
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-996359769\">PR review</a>.</p>",
        "id": 285090442,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654507344
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-997344268\">PR review</a>.</p>",
        "id": 285185888,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654557823
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r890641362\">PR review comment</a>:</p>\n<blockquote>\n<p>What if we define dynamic vector types not on top of a base fixed-vector type, but on top of the lane type alone, and then make the dynamic factor (the symbolic <code>N</code>) provide a bit width, rather than a multiplier? This is sort of starting from I was getting at with <code>i32xN</code> above (rather than <code>i32x4xN</code>) but then shifting the meaning of <code>N</code> a bit so that we can have the same <code>N</code> (symbolically at least, in practice this is all resolved at compile time) for every lane type.</p>\n<p>Maybe we need a slightly different notation to make this more clear: perhaps (please suggestion other punctuation, anyone!) <code>i32/N</code> (<code>i32</code>s over <code>N</code> bits). Then we could have</p>\n<div class=\"codehilite\" data-code-language=\"plain\"><pre><span></span><code>  N = dyn_width_constant 1024\n  dt0 = i32/N\n  dt1 = i64/N\n\n  v1 := load.dt0 ...\n  v2 = bitcast.dt1 v1\n  store.dt2 v2, ...\n</code></pre></div>\n<p>I like this because it removes any notion of \"minimum lane count\" or some other factor (why <code>4</code> in <code>i32x4xN</code>, other than the fact that historically we started with 128-bit vectors and we're expanding from there?). We just have the important bits: the lane type (<code>i32</code>), and the machine width we're scaling to (<code>N</code>). Thoughts?</p>\n</blockquote>",
        "id": 285185889,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654557823
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-997854575\">PR review</a>.</p>",
        "id": 285226530,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654595520
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r891015371\">PR review comment</a>:</p>\n<blockquote>\n<p>I'm not sure I follow... for one, with <code>dyn_width_constant</code> taking an immediate value, shouldn't we really should just use fixed sizes at the IR level? This doesn't appear to enable anything dynamic.</p>\n<p>The other problem is that I think we should aim to enable writing clif in dynamic terms without losing too much the functionality of fixed widths - otherwise people have to make a hard choice of whether to use it or not. I think with your suggestion, we now only have types that use the full width of the register and so we wouldn't be able to support widen and narrow operations?</p>\n</blockquote>",
        "id": 285226531,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654595520
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-998433398\">PR review</a>.</p>",
        "id": 285274483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654617966
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r891422812\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm not sure I follow... for one, with <code>dyn_width_constant</code> taking an immediate value, shouldn't we really should just use fixed sizes at the IR level? This doesn't appear to enable anything dynamic.</p>\n</blockquote>\n<p>Ah, so I didn't mean for the <code>dyn_width_constant</code> to be the interesting part of that example; perhaps it results from a pass that legalizes to a particular microarchitecture with a known width. The point was to have the global value that defines machine width, as we've had so far; maybe <code>dyn_width_vl</code> for a vector-length register or somesuch...</p>\n<p>The basic idea I was going for was to have a parameter for the machine width, and say \"vector of lane type T up to width <code>N</code>\". Whereas the <code>i64x2xN</code> sort of syntax says \"an <code>N</code>-times multiple of a base 128-bit vector machine\". Just holding a different set of two of the three variables in \"machine width = lane width * lanes\" constant, I guess.</p>\n<p>Said another way, the existing vector types <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code> can be written as <code>i8/128</code>, <code>i16/128</code>, <code>i32/128</code>, <code>i64/128</code>; and then this is making that width configurable, rather than the multiplier over 128 bits base width configurable.</p>\n<p>That said...</p>\n<blockquote>\n<p>The other problem is that I think we should aim to enable writing clif in dynamic terms without losing too much the functionality of fixed widths - otherwise people have to make a hard choice of whether to use it or not.</p>\n</blockquote>\n<p>I also see the advantages of the <code>i64x2xN</code> approach with respect to the existing SIMD types: we're basically \"slapping a multiplier on it\" and everything else remains the same. The downside is the encoding and from-first-principles comprehensibility of the types.</p>\n<p>All else being equal, I think either could work, and an easier migration path is important; and you've done the work to prototype the latter; so <code>i64x2xN</code> is totally workable. I won't push the above ideas too hard against it :-)</p>\n<blockquote>\n<p>I think with your suggestion, we now only have types that use the full width of the register and so we wouldn't be able to support widen and narrow operations?</p>\n</blockquote>\n<p>Ah so here it actually gets interesting: what happens to the {1/2, 1, 2} multipliers if we do two narrow or widen ops in a row?</p>\n</blockquote>",
        "id": 285274485,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654617967
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r892029975\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ah so here it actually gets interesting: what happens to the {1/2, 1, 2} multipliers if we do two narrow or widen ops in a row?</p>\n</blockquote>\n<p>Everything breaks :)</p>\n<p>Although it would also break for fixed vectors after a certain amount of doubling too. We're never going to be able to support everything with a small, fixed, number of types, but I would really like dynamic types to have the same limitations as their fixed-width counterparts. I will look at the encoding again, but I think this is tough with how many vector types already exist. I take it that moving to a u16 is out of the question...?</p>\n<p>I'll also prototype support for widen and narrow, because now I'm wondering how that will actually work... I assume we shouldn't support an implicit result type, unless that type has already been created for function?</p>\n</blockquote>",
        "id": 285355887,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654674421
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-999269028\">PR review</a>.</p>",
        "id": 285355888,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654674421
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r892450761\">PR review comment</a>:</p>\n<blockquote>\n<p>So, I've currently got this encoding scheme:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// 0x00-0x0d: Lane types</span>\n<span class=\"c1\">// 0x0e-0x0f: Reference types</span>\n<span class=\"c1\">// 0x10-0x7f: Vector types</span>\n<span class=\"c1\">// 0x80-0xef: Dynamic vector types    (excluding refs, I128 and all bools except B1)</span>\n<span class=\"c1\">// 0xf0-0xfe: Special types</span>\n<span class=\"c1\">// 0xff:      Void</span>\n</code></pre></div>\n<p>And this is pretty ugly... it requires:</p>\n<ul>\n<li>Everything to be shuffled around (maybe unnecessarily...)</li>\n<li>Both fixed and dynamic vectors to be limited to 128 lanes, instead of 256.</li>\n<li>Dynamic vectors can only use 3 bits for the <code>lane_type</code>, which has meant I've re-encoded lane types so that the ones I want to support use the bottom 3 bits.</li>\n</ul>\n<p>So, this poses two question with our existing types:</p>\n<ul>\n<li>Do we have a strong reason to support so many bool types?</li>\n<li>Do we have a strong reason to support a max of 256 lanes? @bjorn3, you raised concerns about limiting lanes to 128 so I'd like to hear your opinion too. </li>\n</ul>\n</blockquote>",
        "id": 285399066,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654698192
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-999862124\">PR review</a>.</p>",
        "id": 285399071,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654698194
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1001771639\">PR review</a>.</p>",
        "id": 285572425,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654797447
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r893807261\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it could be worthwhile to run some quick experiments with <code>Type</code> as a <code>u16</code> instead. It may pessimize a tiny bit where we have a <code>Vec&lt;Type&gt;</code> rather than a <code>Type</code> as a field (in the latter case we probably have some slack with padding) but if it's in the noise or say 0.1% or something, it seems like it would make this work substantially easier...</p>\n<blockquote>\n<p>I'll also prototype support for widen and narrow, because now I'm wondering how that will actually work... I assume we shouldn't support an implicit result type, unless that type has already been created for function?</p>\n</blockquote>\n<p>Yes, actually, now that I think about it more, this seems right (and like a small difference from existing fixed SIMD types): one will need to explicitly declare the types on both sides. I'm curious to see how that will work out wrt our instruction constraint system; I don't have enough details paged in right now to say for sure if there will be any problems...</p>\n</blockquote>",
        "id": 285572426,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654797447
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1001814726\">PR review</a>.</p>",
        "id": 285577363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654799614
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r893838345\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>where we have a <code>Vec&lt;Type&gt;</code> </p>\n</blockquote>\n<p>As a followup after an astute question by @jameysharp , it turns out this is likely not an issue. I had for some reason thought that we kept types in a struct-of-arrays sort of way (<code>SecondaryMap&lt;Value, Type&gt;</code> for types of every value in the <code>DataFlowGraph</code>) but we actually just stuff the <code>Type</code> into the <code>ValueData</code> <a href=\"https://github.com/bytecodealliance/wasmtime/blob/72c6b79e9c96c75b7fa31e4d84ece5145e4a9aa3/cranelift/codegen/src/ir/dfg.rs#L431\">here</a> so we almost certainly have the padding to absorb a <code>u16</code> instead. (Thanks Jamey!)</p>\n</blockquote>",
        "id": 285577364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654799614
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1002696125\">PR review</a>.</p>",
        "id": 285668853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654864466
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894472941\">PR review comment</a>:</p>\n<blockquote>\n<p>Sounds good to me!</p>\n</blockquote>",
        "id": 285668855,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654864466
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 285683149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654871207
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894612321\">PR review comment</a>:</p>\n<blockquote>\n<p>Could you please keep the original name? This is an unnecessary breaking change that would break the nightly cranelift tests of cg_clif.</p>\n</blockquote>",
        "id": 285685871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654872422
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1002910343\">PR review</a>.</p>",
        "id": 285685872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654872422
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894750287\">PR review comment</a>:</p>\n<blockquote>\n<p>I have no strong opinion, but opposing feedback that I've previously received from @fitzgen (I can't remember in which area) was that we should make it clear it clear to differentiate between fixed and dynamic. If that was just around type naming, then it is a non-issue and I'm happy to revert. It's already been a problem for me while rebasing!</p>\n</blockquote>",
        "id": 285707062,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654881586
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1003110526\">PR review</a>.</p>",
        "id": 285707064,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654881586
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894750968\">PR review comment</a>:</p>\n<blockquote>\n<p>@cfallin What should I be running for looking at to get the metrics that you're interested in?</p>\n</blockquote>",
        "id": 285707239,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654881645
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1003111506\">PR review</a>.</p>",
        "id": 285707240,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654881645
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1003132610\">PR review</a>.</p>",
        "id": 285709847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654882908
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894766108\">PR review comment</a>:</p>\n<blockquote>\n<p>Any sort of profiling (even just a <code>perf stat ...</code>) on a compilation of a large module (<code>benchmarks-next/spidermonkey/benchmark.wasm</code> from the Sightglass repo?) should be enough to see if making <code>Type</code> a <code>u16</code> has any impact, I think. Though given the above I <em>expect</em> it shouldn't and would be surprised if we see anything more than a blip...</p>\n</blockquote>",
        "id": 285709848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654882908
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894767452\">PR review comment</a>:</p>\n<blockquote>\n<p>I'd prefer we have the explicit name as well; @bjorn3 each Cranelift upgrade is a semver break currently and our APIs are still considered unstable. We shouldn't <em>needlessly</em> break compatibility, but getting things right and finding clearer names and less error-prone APIs is a higher priority right now.</p>\n</blockquote>",
        "id": 285710058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654883026
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1003134565\">PR review</a>.</p>",
        "id": 285710059,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654883026
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r894791904\">PR review comment</a>:</p>\n<blockquote>\n<p>I guess so @cfallin.</p>\n</blockquote>",
        "id": 285714265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654885245
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1003169233\">PR review</a>.</p>",
        "id": 285714266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1654885245
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r895581941\">PR review comment</a>:</p>\n<blockquote>\n<p>Taking the example that you suggested, compilation is 0.7% slower when using u16. This is taking the mean over three runs. I'm using a laptop... so not the best benchmarking setup, but hopefully this sounds like a low enough impact?</p>\n</blockquote>",
        "id": 285909609,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655117319
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1004137223\">PR review</a>.</p>",
        "id": 285909610,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655117319
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r896260961\">PR review comment</a>:</p>\n<blockquote>\n<p>Hmm, that's actually a bit higher than I was expecting. Wins from significant efforts can sometimes be 5-10% (and e.g. RA2 with ~6 months of work was 10-20% compile time reduction), so throwing away 0.7% here should be avoided if we can find a way around it at all.</p>\n<p>I suspect it might be <a href=\"https://github.com/bytecodealliance/wasmtime/blob/7e0bb465d0205fd7942a48dce931a8221dccabb8/cranelift/codegen/src/machinst/vcode.rs#L63\">this</a> <code>Vec&lt;Type&gt;</code> in the <code>VCode</code>. Could you run another experiment where you keep <code>Type</code> at <code>u8</code> but just inflate that to <code>u16</code> (maybe make it a <code>Vec&lt;(Type, u8)&gt;</code> and the minimal hacks to stuff the extra <code>u8</code> in)?</p>\n<p>If it turns out to be that <code>Vec</code>, we could keep it a <code>Vec&lt;u8&gt;</code>, reserve one <code>u8</code> value for <code>&gt;= 0xff</code>, and keep a <code>FxHashMap&lt;VReg, Type&gt;</code> sparse map for the \"out of bounds\" types, if that makes sense.</p>\n<p>Otherwise, would you be willing to hunt down the perf delta a bit and see if it's coming from somewhere else?</p>\n</blockquote>",
        "id": 286004202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655164593
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1005082438\">PR review</a>.</p>",
        "id": 286004204,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655164593
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1005489529\">PR review</a>.</p>",
        "id": 286040886,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655197034
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r896559556\">PR review comment</a>:</p>\n<blockquote>\n<p>Okay, I will have a look. FWIW, I've also just tested on a more suitable benchmarking machine, and I now see a 0.3% slow down over 5 runs.</p>\n</blockquote>",
        "id": 286040887,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655197034
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r896901878\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Could you run another experiment where you keep Type at u8 but just inflate that to u16 (maybe make it a Vec&lt;(Type, u8)&gt;</p>\n</blockquote>\n<p>This actually gave a small speedup instead!</p>\n<blockquote>\n<p>we actually just stuff the Type into the ValueData <a href=\"https://github.com/bytecodealliance/wasmtime/blob/72c6b79e9c96c75b7fa31e4d84ece5145e4a9aa3/cranelift/codegen/src/ir/dfg.rs#L431\">here</a> so we almost certainly have the padding to absorb a u16 instead</p>\n</blockquote>\n<p>Unfortunately, this doesn't appear to be the case, at least this appears to be where the regression is coming from. perf showed <code>DataFlowGraph::value_def</code> taking a longer time, so I converted <code>ty</code> into <code>(Type, u8)</code> in the <code>ValueData</code> enum and saw a 1.4% slow down. Setting <code>repr(align(8))</code> fixed this regression, but not for the original case of <code>Type(u16)</code>....</p>\n<p>However, using <code>num: usize</code> for <code>ValueData::Inst</code> and <code>ValueData::Param</code> reduces the regression to 0.19% when using u16.</p>\n</blockquote>",
        "id": 286080650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655217056
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1005981899\">PR review</a>.</p>",
        "id": 286080654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655217056
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897002918\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, I think I missed that the enum dscriminant in <code>ValueData</code> is an implicit <code>u8</code>, so right now it fits in <code>u64</code> but making <code>Type</code> a <code>u16</code> inflates that (probably at least to 12 bytes if not 16?).</p>\n<p>I have some thoughts on bitpacking and giving <code>Type</code> 14 bits instead; I'll do a PR and do some measurements, and get this in as a separate refactor if it works to pave the way for your work :-)</p>\n</blockquote>",
        "id": 286093172,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655221805
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1006123053\">PR review</a>.</p>",
        "id": 286093175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655221806
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897002918\">PR review comment</a>.</p>",
        "id": 286093196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655221814
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897135437\">PR review comment</a>:</p>\n<blockquote>\n<p>Maybe I missed this at some point, but why do we need new stack manipulation instructions? Wouldn't the old instructions have the attached dynamic type which would be enough to determine where the dynamic slots exist?</p>\n</blockquote>",
        "id": 286110556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655229659
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1006308760\">PR review</a>.</p>",
        "id": 286110557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655229660
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1006321872\">PR review</a>.</p>",
        "id": 286112144,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655230359
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897144777\">PR review comment</a>:</p>\n<blockquote>\n<p>The issue is the operand typing -- these take a <code>DynamicStackSlot</code> rather than a <code>StackSlot</code>, and that distinction in turn is needed for the ABI code. We could have made each <code>StackSlot</code> be polymorphic over statically-sized or dynamically-sized type, though that adds a bit of complication. Given that we do the layout differently for each, and lower each slightly differently, I think it's reasonable to keep them separated, but i don't feel too strongly about that.</p>\n</blockquote>",
        "id": 286112145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655230359
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1006394855\">PR review</a>.</p>",
        "id": 286114378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655231489
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897199351\">PR review comment</a>:</p>\n<blockquote>\n<p>@sparker-arm I took a look at this just now in #4269. The impact on compiling SpiderMonkey.wasm was actually 4.5%, which is quite serious and so we definitely need to do something here -- the bitpacking in that PR gets it down to 1.0% but I'm hoping we can do better (ideally I wouldn't want to pay more than 0.1% for this, given that compile-time wins are generally hard to come by).</p>\n</blockquote>",
        "id": 286114379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655231489
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1007176662\">PR review</a>.</p>",
        "id": 286186617,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655285273
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897753264\">PR review comment</a>:</p>\n<blockquote>\n<p>So, I re-ran my experiments and looking at reported time, instead of raw cycles, and I see u16 causing a 1.1% or 1.3% slowdown, depending on whether I use the mean or minimum values. (I don't understand why cycles and time are so different...) And I'm a bit concerned that your results are significantly different than mine. What are machine you running on? And are you running sightglass in a way to mimic a 'real-life' scenario, with the commands <code>--iterations-per-process 10 --processes 2</code>?</p>\n<p>To add to my confusion, when I benchmark your 14-bit patch I confirm your results, with a 0.78% slowdown... </p>\n</blockquote>",
        "id": 286186618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655285273
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1007459215\">PR review</a>.</p>",
        "id": 286208026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655298042
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897950072\">PR review comment</a>:</p>\n<blockquote>\n<p>Results for me were on a desktop Ryzen 3900X 12-core system. The iteration count and process count were a tradeoff to get some results and not wait forever, but all else equal, larger counts are better (it lets Sightglass get a tighter confidence interval). If run with just two engines rather than three it'll do a statistical-significance test too.</p>\n<p>Compilation input can make a big difference in slowdowns observed (e.g. if functions get big enough for IR data structures to exceed L1), are you testing with SpiderMonkey.wasm or something else?</p>\n</blockquote>",
        "id": 286208028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655298043
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r897970881\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, I'm using spidermonkey.wasm and I'm on a big and shiny ampere altra. Maybe this has something to do with x64 vs aarch64, because I assume that the size of L1 caches varies very little between CPUs these days. Considering the benchmark takes &lt; 10 seconds, is the tradeoff really necessary..?</p>\n</blockquote>",
        "id": 286210065,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655299073
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1007488910\">PR review</a>.</p>",
        "id": 286210066,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655299073
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 286890385,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1655805172
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1025347086\">PR review</a>.</p>",
        "id": 288072047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911350126\">PR review comment</a>:</p>\n<blockquote>\n<p>followup issue or assert? (I'm not sure I fully understand the TODO)</p>\n</blockquote>",
        "id": 288072048,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911346784\">PR review comment</a>:</p>\n<blockquote>\n<p>constant rather than magic <code>0x100</code> here?</p>\n</blockquote>",
        "id": 288072049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911350492\">PR review comment</a>:</p>\n<blockquote>\n<p>The <code>value_reg</code> and <code>put_in_reg</code> should be unnecessary now thanks to implicit conversions, if you want to remove them!</p>\n</blockquote>",
        "id": 288072050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1025347086\">PR review</a>.</p>",
        "id": 288072051,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911349800\">PR review comment</a>:</p>\n<blockquote>\n<p>I'd prefer for these new lowerings to be in ISLE, if that's not too much trouble...</p>\n</blockquote>",
        "id": 288072052,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911348109\">PR review comment</a>:</p>\n<blockquote>\n<p>Can we file a followup issue to track what to do about dynamic vector types as args?</p>\n<p>(Am I assuming right that usually they won't be args, but rather the args themselves will be pointers to the data we use with dynamically-sized vectors?)</p>\n</blockquote>",
        "id": 288072053,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911350662\">PR review comment</a>:</p>\n<blockquote>\n<p>Commented-out code removed or fixed?</p>\n</blockquote>",
        "id": 288072054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911351592\">PR review comment</a>:</p>\n<blockquote>\n<p>commented-out code</p>\n</blockquote>",
        "id": 288072055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911353164\">PR review comment</a>:</p>\n<blockquote>\n<p>I may be missing it but where does the global value (vector scale) actually come in here to determine the size of the dynamically-sized type?</p>\n</blockquote>",
        "id": 288072056,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911351028\">PR review comment</a>:</p>\n<blockquote>\n<p>Noting the FIXME here</p>\n</blockquote>",
        "id": 288072057,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911351876\">PR review comment</a>:</p>\n<blockquote>\n<p>remove?</p>\n</blockquote>",
        "id": 288072058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911348946\">PR review comment</a>:</p>\n<blockquote>\n<p>Commented-out code here should be removed.</p>\n</blockquote>",
        "id": 288072059,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911353271\">PR review comment</a>:</p>\n<blockquote>\n<p>commented-out code</p>\n</blockquote>",
        "id": 288072060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r911344809\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, I think <code>DynScaleTargetWidth</code> or something might be best here. As to why different global values for the different cases -- if I'm understanding the question right, the answer is that the details are really ABI-visible (e.g., is there a hidden register that controls how much data we read at once that must be set up? is it part of a vmcontext in a runtime?) so they should be surfaced in the IR. And having it clearly here also lets us define CLIF semantics for it, which is useful for interpreters and for formal verification.</p>\n<p>Anyway with the above rename I think this is settled for now!</p>\n</blockquote>",
        "id": 288072061,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656615318
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1028234374\">PR review</a>.</p>",
        "id": 288493517,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657009075
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r913517983\">PR review comment</a>:</p>\n<blockquote>\n<p>AFAIK, yes. It's either in a scalable register (data or predicate) or we pass a pointer. </p>\n</blockquote>",
        "id": 288493518,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657009075
    },
    {
        "content": "<p>sparker-arm created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r913666821\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, this is a problem, as they are currently disjoint. I've currently renamed this to <code>dynamic_vector_bytes</code> to differentiate it from the scaling factor. The only way to tie them together, that I can think of, is to pass the value from TargetIsa when legalizing the GlobalValue, which I'll try out. </p>\n</blockquote>",
        "id": 288510634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657018774
    },
    {
        "content": "<p>sparker-arm submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1028444974\">PR review</a>.</p>",
        "id": 288510636,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657018774
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 288516796,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657022276
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 288661321,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657110036
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 288666613,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657112629
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1031920689\">PR review</a>.</p>",
        "id": 288837390,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657214359
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#discussion_r916111742\">PR review comment</a>:</p>\n<blockquote>\n<p>OK, I think this is fine to start, but let's add a TODO and a tracking issue for truly dynamic stack frame layout based on some runtime value. At least, if I understand correctly, one option all along has been for runtime-determined size (from a vmcontext configuration field or some other input), which is what motivated us to take the GV-based approach; so we should build that eventually. I'm happy to see it done incrementally though in this case.</p>\n</blockquote>",
        "id": 288837393,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657214360
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200#pullrequestreview-1031925243\">PR review</a>.</p>",
        "id": 288837899,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657214602
    },
    {
        "content": "<p>sparker-arm updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a> from <code>dynamic-types</code> to <code>main</code>.</p>",
        "id": 288846459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657218350
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4200\">PR #4200</a>.</p>",
        "id": 288857406,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657223680
    }
]