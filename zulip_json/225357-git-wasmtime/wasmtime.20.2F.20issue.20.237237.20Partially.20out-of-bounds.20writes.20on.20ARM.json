[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>Apparently on ARM when</p>\n<ul>\n<li>a store is unaligned</li>\n<li>and crosses a page boundary</li>\n<li>and one page faults but the other doesn't</li>\n</ul>\n<p>then there is no guarantee that the part of the store to the page that didn't fault will not succeed, despite the other part raising a signal.</p>\n<p>This means that partially out-of-bounds Wasm stores that trigger a trap can potentially mutate memory for the in-bounds portion of the write, which is not spec compliant.</p>\n<p>Apparently it is implementation-defined behavior, so it may or may not be an issue on any given ARM machine.</p>\n<p>Thus far, @cfallin tested on the ARM machines he has access to and none of the following have failed the attached test case:</p>\n<ul>\n<li>Apple M2</li>\n<li>RPi4</li>\n<li>the BA ARM server (\"Neoverse N1 core, I think, in an Ampere Altra CPU\")</li>\n</ul>\n<h3>Test Case</h3>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">module</span>\n  <span class=\"p\">(</span><span class=\"k\">memory</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"i64.store\"</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">param</span> <span class=\"kt\">i32</span> <span class=\"kt\">i64</span><span class=\"p\">)</span>\n    <span class=\"nb\">local.get</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">local.get</span> <span class=\"mi\">1</span>\n    <span class=\"nb\">i64.store</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"i32.load8_u\"</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">param</span> <span class=\"kt\">i32</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"kt\">i32</span><span class=\"p\">)</span>\n    <span class=\"nb\">local.get</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">i32.load8_u</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"err\">assert_trap</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i64.store\"</span>\n                     <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65529</span><span class=\"p\">)</span>\n                     <span class=\"p\">(</span><span class=\"nb\">i64.const</span> <span class=\"mf\">0xffffffffffffffff)</span><span class=\"p\">)</span>\n             <span class=\"s2\">\"out of bounds memory access\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; Partial bytes were not written.</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65529</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65530</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65531</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65532</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65533</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65534</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"err\">assert_</span><span class=\"nb\">return</span> <span class=\"p\">(</span><span class=\"err\">invoke</span> <span class=\"s2\">\"i32.load8_u\"</span> <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mf\">65535</span><span class=\"p\">))</span>\n               <span class=\"p\">(</span><span class=\"nb\">i32.const</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n</code></pre></div>\n<h3>See Also</h3>\n<ul>\n<li><a href=\"https://github.com/WebAssembly/design/issues/1490\">https://github.com/WebAssembly/design/issues/1490</a></li>\n<li><a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1666747\">https://bugzilla.mozilla.org/show_bug.cgi?id=1666747</a></li>\n</ul>\n</blockquote>",
        "id": 396553953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697221783
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1762003450\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>Modulo relaxing the spec, the only 100% sure way to fix this that I am aware of would be to use explicit bounds checks for all stores on ARM.</p>\n</blockquote>",
        "id": 396554221,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697221897
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1762015159\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>Oh also, we should double check whether risc-v and s390x give us the stronger guarantees we need to match wasm semantics.</p>\n<p>cc @uweigand: happen to know the answer for s390x?</p>\n</blockquote>",
        "id": 396554783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697222143
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1762026196\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>I've been trying to figure out the state of RISC-V's specs on this matter. The <a href=\"https://drive.google.com/file/d/1EMip5dZlnypTk7pt4WWUKmtjUKTOkBqh/view\">privileged-mode spec</a> includes details on page translation, but the translation algorithm and surrounding text (section 4.3.2) talk about a single address being translated, and don't seem to mention what happens when a single usermode instruction requires multiple translations. The <a href=\"https://riscv.org/wp-content/uploads/2019/06/riscv-spec.pdf\">user-mode spec</a> is pretty high-level and only talks about \"invisible traps\", including page-faults, that can happen during execution of an instruction but are unobservable. So it seems to be a bit underspecified.</p>\n</blockquote>",
        "id": 396555589,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697222551
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1762039461\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>Two other possible fixes:</p>\n<ul>\n<li>Somehow detect if the underlying platform actually tears partially-faulting writes, and only enable bounds-checks if so;</li>\n<li>Disallow access to the memory on which the fault occurred, after-the-fact. This would still then be spec-compliant during Wasm execution, we just don't provide the final memory state as an output on affected systems with the \"fast\" (guard-page) configuration. I'm not sure exactly how to enforce this (maybe unmap the whole thing at trap-termination?) but perhaps there's a way. Or just document it.</li>\n</ul>\n</blockquote>",
        "id": 396556862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697223265
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1763519724\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<blockquote>\n<p>Oh also, we should double check whether risc-v and s390x give us the stronger guarantees we need to match wasm semantics.</p>\n<p>cc @uweigand: happen to know the answer for s390x?</p>\n</blockquote>\n<p>For most instructions on s390x, the architecture guarantees that they either complete successfully, or else are \"nullified\" or \"suppressed\", which means none of the output operands (either in memory or in registers) are changed at all.  This also applies to the case of an unaligned store crossing a page boundary.  [ The one side effect allowed by the architecture is that a nullified or suppressed instruction may cause the hardware change bit of a page containing (part of) a memory output operand to be set, even if the output actually is not modified.  This doesn't have any observable effect on a wasm program, though. ]</p>\n<p>The exception to this rule are so-called \"interruptible\" instructions; these are long-running operations (e.g. copying a large block of memory).  Those are allowed to \"partially complete\", e.g. after copying only part of the total memory block.  They will indicate this outcome by modifying the output registers and condition code accordingly.   If such an instruction incurs a page fault halfway through, partial completion will usually result.   But those instructions are not generated by the wasmtime s390x backend (certainly not to implement a single wasm store).<br>\n</p>\n</blockquote>",
        "id": 396786741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697408392
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1763523982\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>For RISC-V it looks like this was recently clarified in the ISA (see <a href=\"https://github.com/riscv/riscv-isa-manual/pull/1119\">https://github.com/riscv/riscv-isa-manual/pull/1119</a>). The ISA now states:</p>\n<blockquote>\n<p>On some implementations, misaligned loads, stores, and instruction<br>\nfetches may also be decomposed into multiple accesses, some of which may<br>\nsucceed before a page-fault exception occurs. In particular, a<br>\nportion of a misaligned store that passes the exception check may become<br>\nvisible, even if another portion fails the exception check. The same behavior<br>\nmay manifest for stores wider than XLEN bits (e.g., the FSD instruction<br>\nin RV32D), even when the store address is naturally aligned.</p>\n</blockquote>\n</blockquote>",
        "id": 396787649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697409409
    },
    {
        "content": "<p>sparker-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1764095888\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<blockquote>\n<p>Somehow detect if the underlying platform actually tears partially-faulting writes, and only enable bounds-checks if so.</p>\n</blockquote>\n<p>Just FYI, this is what <a href=\"https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/compilation-environment.h;drc=3252e11c56b69700a79d0335b8bc667cda82b6dc;l=39\">V8</a> does, which is on arm64 MacOS.</p>\n</blockquote>",
        "id": 396861651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697449116
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1763523982\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<p>For RISC-V it looks like this was recently clarified in the ISA (see <a href=\"https://github.com/riscv/riscv-isa-manual/pull/1119\">https://github.com/riscv/riscv-isa-manual/pull/1119</a>). The ISA now states:</p>\n<blockquote>\n<p>On some implementations, misaligned loads, stores, and instruction<br>\nfetches may also be decomposed into multiple accesses, some of which may<br>\nsucceed before a page-fault exception occurs. In particular, a<br>\nportion of a misaligned store that passes the exception check may become<br>\nvisible, even if another portion fails the exception check. The same behavior<br>\nmay manifest for stores wider than XLEN bits (e.g., the FSD instruction<br>\nin RV32D), even when the store address is naturally aligned.</p>\n</blockquote>\n<p>Edit: By the way, I ran the above test on a JH7110 (SiFive u74 core) and it failed with:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">script</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">test</span><span class=\"p\">.</span><span class=\"n\">wast</span><span class=\"o\">'</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">directive</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">test</span><span class=\"p\">.</span><span class=\"n\">wast</span>:<span class=\"mi\">17</span>:<span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"nc\">result</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">didn</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"k\">match</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"nc\">expected</span><span class=\"w\">                  </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"mh\">0x0000000000000000</span>\n<span class=\"w\">       </span><span class=\"n\">actual</span><span class=\"w\">                  </span><span class=\"mi\">255</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"mh\">0x00000000000000ff</span>\n</code></pre></div>\n<p>So it looks like this actually happens for RISC-V cores.</p>\n</blockquote>",
        "id": 396866782,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697450802
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1764806794\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Somehow detect if the underlying platform actually tears partially-faulting writes, and only enable bounds-checks if so.</p>\n</blockquote>\n<p>Just FYI, this is what <a href=\"https://source.chromium.org/chromium/chromium/src/+/main:v8/src/wasm/compilation-environment.h;drc=3252e11c56b69700a79d0335b8bc667cda82b6dc;l=39\">V8</a> does, which is on arm64 MacOS.</p>\n</blockquote>\n<p>It seems like given @akirilov-arm's reply <a href=\"https://github.com/WebAssembly/design/issues/1490#issuecomment-1764552895\">here</a>, V8's behavior is also technically non-conforming then: if the platform doesn't guarantee consistency in its behavior, then one can't test and choose a strategy at startup and rely on it to remain working.</p>\n</blockquote>",
        "id": 396934647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697472194
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1764823269\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<blockquote>\n<p>So it looks like this actually happens for RISC-V cores.</p>\n</blockquote>\n<p>Thanks for testing @afonso360!</p>\n<p>Will update the issue title to reflect that this is both an ARM and riscv issue.</p>\n</blockquote>",
        "id": 396936356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697472747
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237#issuecomment-1764823891\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7237\">issue #7237</a>:</p>\n<blockquote>\n<blockquote>\n<p>For most instructions on s390x, the architecture guarantees that they either complete successfully, or else are \"nullified\" or \"suppressed\",</p>\n</blockquote>\n<p>Thanks @uweigand!</p>\n</blockquote>",
        "id": 396936404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697472767
    }
]