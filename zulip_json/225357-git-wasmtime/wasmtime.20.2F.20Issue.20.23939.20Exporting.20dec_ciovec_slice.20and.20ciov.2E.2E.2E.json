[
    {
        "content": "<p>jeffcharles <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-609925119\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-609925119\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>Glad to see #701 has been merged. Unfortunately I can't seem to figure out how to use the new <code>FileContents</code> trait as a destination for stdout or stderr. The <code>stdout</code> and <code>stderr</code> methods on the builder only appear to take <code>File</code>s and not something that implements <code>FileContents</code>. As well, it's not clear to me if there's a way to wire up <code>preopened_virt</code> to provide destinations for <code>stdout</code> and <code>stderr</code> though I do see a guard in the code that they should not among the pre-opens so I'm guessing that won't work.</p>\n<p>How do I map stdout and stderr to a custom implementation of <code>FileContents</code>?</p>\n</blockquote>",
        "id": 193072861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586193437
    },
    {
        "content": "<p>jeffcharles <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-616732622\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-616732622\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>Is there anything on the roadmap for supporting what I've proposed above? Another option is if we could get access to the pre-opened file descriptors in the WASI context, then we could wrap <code>fd_write</code> with something that passes through but with a different file descriptor (e.g., if we see a write for file descriptor <code>1</code>, then pass it through to <code>wasi-common</code> as a write to file descriptor <code>4</code>), but it doesn't look like that's exposed anywhere other than making a series of WASI calls.</p>\n</blockquote>",
        "id": 194714701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587407379
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-616826476\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-616826476\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>Sorry for the delay. I think @kubkon is currently working on that aspect of the code. I haven't kept up with every change that has landed &amp; is underway over there.</p>\n</blockquote>",
        "id": 194737445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587418986
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617237825\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617237825\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>Hi @jeffcharles! I haven't read into your issue here in too much detail, but I think what you might be looking for, I'm just now trying to bake in into <code>wasi-common</code>. See #1561 for details. Oh, and just to sum up and check that I understand correctly, it all boils down for you to be able to attach your own virtualfs handle as stdio, is it? The PR I've mentioned should hopefully bring us a step closer to that at the very least.</p>\n</blockquote>",
        "id": 194815364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587481492
    },
    {
        "content": "<p>jeffcharles deleted a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617257878\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617257878\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<blockquote>\n<p>it all boils down for you to be able to attach your own virtualfs handle as stdio, is it?</p>\n</blockquote>\n<p>Almost, I want to attach our own virtual files to stdout and stderr. Attaching our own virtualfs to stdio would accomplish that. Really I just want some sort of interface that gives us byte arrays or io slices that we can operate on when an <code>fd_write</code> call occurs which the virtual file stuff does except for calls to file descriptors <code>1</code> or <code>2</code>.</p>\n</blockquote>",
        "id": 194824600,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587485108
    },
    {
        "content": "<p>jeffcharles <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617256286\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617256286\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<blockquote>\n<p>it all boils down for you to be able to attach your own virtualfs handle as stdio, is it?</p>\n</blockquote>\n<p>Almost, I want to attach our own virtual files to stdout and stderr. Attaching our own virtualfs to stdio would accomplish that. Really I just want some sort of interface that gives us byte arrays or io slices that we can operate on when an <code>fd_write</code> call occurs which the virtual file stuff does except for calls to file descriptors <code>1</code> or <code>2</code>.</p>\n</blockquote>",
        "id": 194825203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587485363
    },
    {
        "content": "<p>jeffcharles <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617261050\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617261050\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<blockquote>\n<p>it all boils down for you to be able to attach your own virtualfs handle as stdio, is it?</p>\n</blockquote>\n<p>Almost, I want to attach our own virtual files to stdout and stderr. Attaching our own virtualfs to stdio would accomplish that. Really I just want some sort of interface that gives us byte arrays or io slices that we can operate on when an <code>fd_write</code> call occurs which the virtual file stuff does except for calls to file descriptors <code>1</code> or <code>2</code>.</p>\n</blockquote>",
        "id": 194826910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587486134
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-619336872\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-619336872\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>@jeffcharles Cool! Let me see what I can conjure up! If I have any questions, is it OK if I ping you now and then? Also, if it's any more convenient for you, we can sync up on [BA's zulip chat] as well. Let me know what works best!</p>\n<p>[BA's zulip chat]: <a href=\"\" title=\"\">https://bytecodealliance.zulipchat.com/</a></p>\n</blockquote>",
        "id": 195273085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587800534
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-619507584\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-619507584\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>@pchickey @jeffcharles ok, I've now created a draft PR (#1600) that hopefully addresses your requirements. With this PR, you should now be able to pass in any implementor of the <code>Handle</code> trait as a valid handle to stdio. Lemme know if that fixes it or if I (very likely!) misunderstood what the problem here actually is :-D </p>\n</blockquote>",
        "id": 195323705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587889094
    },
    {
        "content": "<p>jeffcharles deleted a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617261050\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-617261050\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<blockquote>\n<p>it all boils down for you to be able to attach your own virtualfs handle as stdio, is it?</p>\n</blockquote>\n<p>Almost, I want to attach our own virtual files to stdout and stderr. Attaching our own virtualfs to stdio would accomplish that. Really I just want some sort of interface that gives us byte arrays or io slices that we can operate on when an <code>fd_write</code> call occurs which the virtual file stuff does except for calls to file descriptors <code>1</code> or <code>2</code>.</p>\n</blockquote>",
        "id": 195447813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588007573
    },
    {
        "content": "<p>jeffcharles <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620138808\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620138808\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>It looks like that draft PR does. Just to confirm my understanding of how this would work as a consumer, I should be able to define a custom implementation for <code>FileContents</code> and pass that implementation in a call to <code>InMemoryFile::new</code> and then specify that <code>InMemoryFile</code> I get back from that call to <code>stdout</code> and <code>stderr</code> on <code>WasiCtxBuilder</code> which will result in my custom <code>FileContents</code> implementation's <code>pwrite</code> or <code>pwritev</code>'s methods being invoked when a WASI <code>fd_write</code> hostcall occurs?</p>\n</blockquote>",
        "id": 195453167,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588010123
    },
    {
        "content": "<p>kubkon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620172817\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620172817\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>If I read it right, then yeah, that's the basic idea. In fact, in that draft PR, anything that conforms to the <code>Handle</code> trait will do the job, and in this case, specifying your own implementation of <code>FileContents</code> and then injecting that into <code>InMemoryFile</code> which you then add to the context as a relevant stdio handle should do the job:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">virt_stdout</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">InMemoryFile</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">custom_file_contents</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span>: <span class=\"nc\">WasiCtx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WasiCtxBuilder</span>::<span class=\"n\">new</span><span class=\"p\">().</span><span class=\"n\">stdout</span><span class=\"p\">(</span><span class=\"n\">in_mem</span><span class=\"p\">).</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>While we're here, you'll note that you have to provide an instance that implements the <code>Handle</code> trait which effectively should be an internal trait of <code>wasi-common</code>. In the future, we'd like to make it completely independent of the underlying runtime and WASI implementation. @sunfishcode has drafted out some really good ideas about this, where the dynamic dispatch problem of this type would be handled at a layer one above the WASI implementation. This essentially implies that as a consumer of WASI you won't have to worry about implementing any traits specific to the runtime at hand. I hope I got the basic idea right. @sunfishcode could you confirm/clarify? :-)</p>\n</blockquote>",
        "id": 195461055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588014112
    },
    {
        "content": "<p>kubkon edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620172817\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939#issuecomment-620172817\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\" title=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>If I read it right, then yeah, that's the basic idea. In fact, in that draft PR, anything that conforms to the <code>Handle</code> trait will do the job, and in this case, specifying your own implementation of <code>FileContents</code> and then injecting that into <code>InMemoryFile</code> which you then add to the context as a relevant stdio handle should do the job:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">virt_stdout</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">InMemoryFile</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">custom_file_contents</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span>: <span class=\"nc\">WasiCtx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WasiCtxBuilder</span>::<span class=\"n\">new</span><span class=\"p\">().</span><span class=\"n\">stdout</span><span class=\"p\">(</span><span class=\"n\">virt_stdout</span><span class=\"p\">).</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>While we're here, you'll note that you have to provide an instance that implements the <code>Handle</code> trait which effectively should be an internal trait of <code>wasi-common</code>. In the future, we'd like to make it completely independent of the underlying runtime and WASI implementation. @sunfishcode has drafted out some really good ideas about this, where the dynamic dispatch problem of this type would be handled at a layer one above the WASI implementation. This essentially implies that as a consumer of WASI you won't have to worry about implementing any traits specific to the runtime at hand. I hope I got the basic idea right. @sunfishcode could you confirm/clarify? :-)</p>\n</blockquote>",
        "id": 195461122,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588014128
    },
    {
        "content": "<p>kubkon closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/939\">Issue #939</a>:</p>\n<blockquote>\n<p>I have a use-case where I'd like to perform some operations on the data being sent through an <code>fd_write</code> call on the host rather than sending it through to an underlying file descriptor. The existing <code>fd_write</code> call doesn't appear to offer the ability to work with the input data on the host.</p>\n<p>What I think I want (and feel free to correct me if it isn't) is something that would convert the scatter gather IO vectors passed into <code>fd_write</code> to a u8 slice. I think combining <code>dec_ciovec_slice</code> and <code>ciovec_to_host</code> and flattening the resulting IO slices _should_ do that. Would there be any interest in either exporting these functions or exporting a function that would use these two functions to return a slice of the data provided as input to <code>fd_write</code>?</p>\n</blockquote>",
        "id": 200269705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591726761
    }
]