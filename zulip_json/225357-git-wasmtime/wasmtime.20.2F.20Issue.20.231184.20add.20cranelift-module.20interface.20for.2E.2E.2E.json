[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1184#issuecomment-772722235\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1184\">Issue #1184</a>:</p>\n<blockquote>\n<p>Since #1389 <code>define_function</code> gets a <code>TrapSink</code> argument.</p>\n</blockquote>",
        "id": 225058617,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612376781
    },
    {
        "content": "<p>froydnj closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1184\">Issue #1184</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p><code>lucetc</code> needs some way of accessing the trap sites for every function it compiles:</p>\n<p><a href=\"https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89\">https://github.com/bytecodealliance/lucet/blob/23305e5d8e08bed442c244d282b1a0389ed3d822/lucetc/src/output.rs#L69-L89</a></p>\n<p>In the above snippet, the trap site access happens after <code>Module::finish</code> has been called, so we're working with <code>faerie</code> interfaces.</p>\n<p>We are trying to port <code>lucetc</code> to use <code>object</code> instead of <code>faerie</code> underneath, mostly so <code>lucetc</code> can start generating PE/COFF objects with ease.  It would reduce risk somewhat to be able to use <code>cranelift-module</code> as a high-level interface, swap between <code>cranelift-object</code> and <code>cranelift-faerie</code> with as few lines of code as possible, and deal with <code>object</code> and <code>faerie</code> themselves as little as possible (probably just to write out the .o file).  Therefore, it would be convenient if this information about traps associated with each function were accessible through <code>cranelift-module</code> interfaces, rather than through lower-level interfaces.</p>\n<h4>Benefit</h4>\n<p>Trap information would be more easily accessible prior to module finalization.  Though I don't know of anybody else who needs this kind of information about besides <code>lucetc</code> at this point.</p>\n<h4>Implementation</h4>\n<p>This is the tricky bit, because the three in-tree implementations differ substantially in their approach to trap collection:</p>\n<ul>\n<li><code>cranelift-faerie</code> collects essentially <code>(string-name, Vec&lt;TrapSite&gt;)</code> pairs.</li>\n<li><code>cranelift-object</code> collects a mapping of <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code>.</li>\n<li><code>cranelift-simplejit</code> ignores traps entirely.</li>\n</ul>\n<p>I don't think there is a single method that all three interfaces could easily implement to iterate over <code>(string-name, &amp;Vec&lt;TrapSite&gt;)</code> pairs.  To implement such an interface, <code>cranelift-object</code> would need to have a way to map from <code>FuncId</code> to <code>string-name</code>, and that's awkward to do, given that <code>object</code> itself doesn't deal with symbol names as strings, but as <code>Vec&lt;u8&gt;</code>.</p>\n<p>The alternative, iterating over <code>(FuncId, &amp;Vec&lt;TrapSite&gt;)</code> pairs, would require some kind of modification to <code>cranelift-faerie</code>.  We could change <code>cranelift-faerie</code> to map from <code>string-name</code> to <code>FuncId</code>: <code>cranelift-faerie</code> could grow a separate table for storing that mapping, but <code>cranelift-module</code> is already storing that mapping, and requiring <code>cranelift-faerie</code> to store it seems like wasted effort.  Alternatively, the way <code>cranelift-faerie</code> stores its traps could be modified to look more like <code>cranelift-object</code>.</p>\n<p>But then maybe the right thing to do is just moving trap collection into <code>cranelift-module</code> itself?  <code>Module::new</code> would then grow a flag for indicating whether trap collection should be done.  <code>Module</code> itself would probably contain a <code>FuncId</code> to <code>Vec&lt;TrapSite&gt;</code> mapping similar to <code>cranelift-object</code>, and then <code>Backend::define_function</code> would receive <code>Option&lt;&amp;mut Vec&lt;TrapSite&gt;&gt;</code> for potentially accumulating traps.</p>\n<p>Since <code>cranelift-simplejit</code> doesn't collect traps, it doesn't matter too much what interface gets decided on.</p>\n<p>I think I prefer moving trap collection into <code>cranelift-module</code> itself, but modifying <code>cranelift-faerie</code> to make it more like <code>cranelift-object</code> and the implementing some sort of common iterator interface works, too.</p>\n<h4>Alternatives</h4>\n<p>The alternative is to keep the status quo, and <code>lucetc</code> would need to write two sets of code for defining certain pieces of information: one that defines those pieces with <code>faerie</code> and another that defines them with <code>object</code>.</p>\n</blockquote>",
        "id": 225063419,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612378617
    }
]