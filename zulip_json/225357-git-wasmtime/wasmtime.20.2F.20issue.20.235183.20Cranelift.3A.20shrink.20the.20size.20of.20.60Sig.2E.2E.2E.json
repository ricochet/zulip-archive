[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>This could maybe give us some small perf gains due to a smaller working set that better fits in cache.</p>\n<p><code>SigData</code> is defined here: <a href=\"https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627\">https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627</a></p>\n<p>The two changes we could make to shrink its size are:</p>\n<ol>\n<li>\n<p>We have implementation limits on the number of arguments and returns from a function, so we don't need a fulle <code>Range&lt;u32&gt;</code> to represent the subslice in <code>SigSet::abi_args</code> for this signature's arguments and returns. Instead we could have a <code>u32</code> start and a <code>u16</code> length. Doing this for both args and returns would save a total of 4 bytes.</p>\n</li>\n<li>\n<p><code>SigData::stack_reg_arg</code> is currently an <code>Option&lt;usize&gt;</code> but, again because of implementation limits on the number of returns, could be <code>Option&lt;u16&gt;</code>. This would save 12 bytes for this field, but I think we might end up actually saving only 8 on the struct because of alignment.</p>\n</li>\n</ol>\n<p>For anyone who picks this up, we can measure the impact this change has via</p>\n<ol>\n<li>\n<p>Building the bench API on <code>main</code>:<br>\n<code>\n   $ git checkout main\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/main.so\n   </code></p>\n</li>\n<li>\n<p>Building the bench API on the feature branch for this patch:<br>\n<code>\n   $ git checkout my-feature-branch\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/smaller-sig-data.so\n   </code></p>\n</li>\n<li>\n<p>Running the <a href=\"https://github.com/bytecodealliance/sightglass\">sightglass</a> benchmarks:<br>\n<code>\n   $ cd ~/path/to/sightglass\n   $ cargo run --release -- benchmark -e /tmp/main.so -e /tmp/smaller-sig-data.so --stop-after compilation -- benchmarks/default.suite \n   </code><br>\n   (You can also try passing <code>--measure perf-counters</code> to see the effects on cache accesses/misses if you're on linux.)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 307617363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667422804
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>This could maybe give us some small perf gains due to a smaller working set that better fits in cache.</p>\n<p><code>SigData</code> is defined here: <a href=\"https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627\">https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627</a></p>\n<p>The two changes we could make to shrink its size are:</p>\n<ol>\n<li>\n<p>We have implementation limits on the number of arguments and returns from a function, so we don't need a fulle <code>Range&lt;u32&gt;</code> to represent the subslice in <code>SigSet::abi_args</code> for this signature's arguments and returns. Instead we could have a <code>u32</code> start and a <code>u16</code> length. Doing this for both args and returns would save a total of 4 bytes.</p>\n</li>\n<li>\n<p><code>SigData::stack_reg_arg</code> is currently an <code>Option&lt;usize&gt;</code> but, again because of implementation limits on the number of returns, could be <code>Option&lt;u16&gt;</code>. This would save 12 bytes for this field, but I think we might end up actually saving only 8 on the struct because of alignment.</p>\n</li>\n</ol>\n<p>For anyone who picks this up, we can measure the impact this change has via</p>\n<ol>\n<li>\n<p>Building the bench API on <code>main</code>:<br>\n<code>\n   $ git checkout main\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/main.so\n   </code></p>\n</li>\n<li>\n<p>Building the bench API on the feature branch for this patch:<br>\n<code>\n   $ git checkout my-feature-branch\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/smaller-sig-data.so\n   </code></p>\n</li>\n<li>\n<p>Running the <a href=\"https://github.com/bytecodealliance/sightglass\">sightglass</a> benchmarks:<br>\n<code>\n   $ cd ~/path/to/sightglass\n   $ cargo run --release -- benchmark -e /tmp/main.so -e /tmp/smaller-sig-data.so --stop-after compilation -- benchmarks/default.suite \n   </code><br>\n   (You can also try passing <code>--measure perf-counters</code> to see the effects on cache accesses/misses if you're on linux.)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 307617364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667422804
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>This could maybe give us some small perf gains due to a smaller working set that better fits in cache.</p>\n<p><code>SigData</code> is defined here: <a href=\"https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627\">https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627</a></p>\n<p>The two changes we could make to shrink its size are:</p>\n<ol>\n<li>\n<p>We have implementation limits on the number of arguments and returns from a function, so we don't need a fulle <code>Range&lt;u32&gt;</code> to represent the subslice in <code>SigSet::abi_args</code> for this signature's arguments and returns. Instead we could have a <code>u32</code> start and a <code>u16</code> length. Doing this for both args and returns would save a total of 4 bytes.</p>\n</li>\n<li>\n<p><code>SigData::stack_reg_arg</code> is currently an <code>Option&lt;usize&gt;</code> but, again because of implementation limits on the number of returns, could be <code>Option&lt;u16&gt;</code>. This would save 12 bytes for this field, but I think we might end up actually saving only 8 on the struct because of alignment.</p>\n</li>\n</ol>\n<p>For anyone who picks this up, we can measure the impact this change has via</p>\n<ol>\n<li>\n<p>Building the bench API on <code>main</code>:<br>\n<code>\n   $ git checkout main\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/main.so\n   </code></p>\n</li>\n<li>\n<p>Building the bench API on the feature branch for this patch:<br>\n<code>\n   $ git checkout my-feature-branch\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/smaller-sig-data.so\n   </code></p>\n</li>\n<li>\n<p>Running the <a href=\"https://github.com/bytecodealliance/sightglass\">sightglass</a> benchmarks:<br>\n<code>\n   $ cd ~/path/to/sightglass\n   $ cargo run --release -- benchmark -e /tmp/main.so -e /tmp/smaller-sig-data.so --stop-after compilation -- benchmarks/default.suite \n   </code><br>\n   (You can also try passing <code>--measure perf-counters</code> to see the effects on cache accesses/misses if you're on linux.)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 307617365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667422804
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>This could maybe give us some small perf gains due to a smaller working set that better fits in cache.</p>\n<p><code>SigData</code> is defined here: <a href=\"https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627\">https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627</a></p>\n<p>The two changes we could make to shrink its size are:</p>\n<ol>\n<li>\n<p>We have implementation limits on the number of arguments and returns from a function, so we don't need a fulle <code>Range&lt;u32&gt;</code> to represent the subslice in <code>SigSet::abi_args</code> for this signature's arguments and returns. Instead we could have a <code>u32</code> start and a <code>u16</code> length. Doing this for both args and returns would save a total of 4 bytes.</p>\n</li>\n<li>\n<p><code>SigData::stack_reg_arg</code> is currently an <code>Option&lt;usize&gt;</code> but, again because of implementation limits on the number of returns, could be <code>Option&lt;u16&gt;</code>. This would save 12 bytes for this field, but I think we might end up actually saving only 8 on the struct because of alignment.</p>\n</li>\n</ol>\n<p>For anyone who picks this up, we can measure the impact this change has via</p>\n<ol>\n<li>\n<p>Building the bench API on <code>main</code>:<br>\n<code>\n   $ git checkout main\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/main.so\n   </code></p>\n</li>\n<li>\n<p>Building the bench API on the feature branch for this patch:<br>\n<code>\n   $ git checkout my-feature-branch\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/smaller-sig-data.so\n   </code></p>\n</li>\n<li>\n<p>Running the <a href=\"https://github.com/bytecodealliance/sightglass\">sightglass</a> benchmarks:<br>\n<code>\n   $ cd ~/path/to/sightglass\n   $ cargo run --release -- benchmark -e /tmp/main.so -e /tmp/smaller-sig-data.so --stop-after compilation -- benchmarks/default.suite \n   </code><br>\n   (You can also try passing <code>--measure perf-counters</code> to see the effects on cache accesses/misses if you're on linux.)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 307617366,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667422804
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1301337781\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>It might also be possible to entirely remove the end-points of the argument and return ranges. I haven't checked carefully but I think the end-point in one <code>SigData</code> is always equal to the start-point in the next <code>SigData</code>, and the last <code>SigData</code>'s end-point is the length of the corresponding backing array.</p>\n<p>If we move all the <code>SigData</code> methods that take a <code>SigSet</code> to be on <code>SigSet</code> instead and take a <code>Sig</code> index—which I think is a good idea for API design reasons anyway—then it's easy to access the <code>Sig+1</code> index.</p>\n<p>Are there any constraints on where the stack-ret arg can appear in the list? For example, if it's always the first argument, we could replace the <code>Option&lt;usize&gt;</code> with a <code>bool</code>. If there are no constraints, we could still cut the field's size in half by getting rid of the <code>Option</code>, if we can pick a reserved value like <code>u16::MAX</code> to indicate that there's no stack-ret arg.</p>\n<p>Also, do the <code>sized_stack_*_space</code> fields need to be <code>i64</code>? For one thing, what does it mean to reserve a negative amount of stack space? For another, surely 32 bits is enough for the size of a stack frame...?</p>\n<p>All together, I think we can shrink <code>SigData</code> from 7 <code>u64</code> to 5 <code>u32</code>, taking padding and alignment into account, for a savings of 64%.</p>\n</blockquote>",
        "id": 307623484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667425426
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1302297490\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<blockquote>\n<p>It might also be possible to entirely remove the end-points of the argument and return ranges. I haven't checked carefully but I think the end-point in one <code>SigData</code> is always equal to the start-point in the next <code>SigData</code>, and the last <code>SigData</code>'s end-point is the length of the corresponding backing array.</p>\n<p>If we move all the <code>SigData</code> methods that take a <code>SigSet</code> to be on <code>SigSet</code> instead and take a <code>Sig</code> index—which I think is a good idea for API design reasons anyway—then it's easy to access the <code>Sig+1</code> index.</p>\n</blockquote>\n<p>Yeah, this is possible but a larger change and probably not a <code>good first issue</code> anymore.</p>\n<blockquote>\n<p>Are there any constraints on where the stack-ret arg can appear in the list? For example, if it's always the first argument, we could replace the <code>Option&lt;usize&gt;</code> with a <code>bool</code>. If there are no constraints, we could still cut the field's size in half by getting rid of the <code>Option</code>, if we can pick a reserved value like <code>u16::MAX</code> to indicate that there's no stack-ret arg.</p>\n</blockquote>\n<p>There aren't, but in practice I think it is always the first. Maybe we could just start enforcing that? Again, probably not in the realm of a <code>good first issue</code> though.</p>\n<blockquote>\n<p>Also, do the <code>sized_stack_*_space</code> fields need to be <code>i64</code>? For one thing, what does it mean to reserve a negative amount of stack space? For another, surely 32 bits is enough for the size of a stack frame...?</p>\n</blockquote>\n<p>Yeah I was kinda wondering that too. Haven't investigated it, so didn't want to include it in a <code>good first issue</code>.</p>\n</blockquote>",
        "id": 307758051,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667489859
    },
    {
        "content": "<p>tnachen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1319648732\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>I'll try out changing the SigData methods as suggested with Sigset</p>\n</blockquote>",
        "id": 310762919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1668757021
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1320308834\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>Let us know if you have any questions! I'm excited that you're digging into this.</p>\n</blockquote>",
        "id": 310871022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1668791951
    },
    {
        "content": "<p>TornaxO7 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1834675194\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>May I ask what's still missing for this issue?</p>\n</blockquote>",
        "id": 405220698,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1701384116
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>This could maybe give us some small perf gains due to a smaller working set that better fits in cache.</p>\n<p><code>SigData</code> is defined here: <a href=\"https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627\">https://cs.github.com/bytecodealliance/wasmtime/blob/348f962d23df0a598ea80629ca6d8e4a158fe153/cranelift/codegen/src/machinst/abi.rs?q=SigData#L601-L627</a></p>\n<p>The two changes we could make to shrink its size are:</p>\n<ol>\n<li>\n<p>We have implementation limits on the number of arguments and returns from a function, so we don't need a fulle <code>Range&lt;u32&gt;</code> to represent the subslice in <code>SigSet::abi_args</code> for this signature's arguments and returns. Instead we could have a <code>u32</code> start and a <code>u16</code> length. Doing this for both args and returns would save a total of 4 bytes.</p>\n</li>\n<li>\n<p><code>SigData::stack_reg_arg</code> is currently an <code>Option&lt;usize&gt;</code> but, again because of implementation limits on the number of returns, could be <code>Option&lt;u16&gt;</code>. This would save 12 bytes for this field, but I think we might end up actually saving only 8 on the struct because of alignment.</p>\n</li>\n</ol>\n<p>For anyone who picks this up, we can measure the impact this change has via</p>\n<ol>\n<li>\n<p>Building the bench API on <code>main</code>:<br>\n<code>\n   $ git checkout main\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/main.so\n   </code></p>\n</li>\n<li>\n<p>Building the bench API on the feature branch for this patch:<br>\n<code>\n   $ git checkout my-feature-branch\n   $ cargo build --release -p wasmtime-bench-api\n   $ cp target/release/libwasmtime_bench_api.so /tmp/smaller-sig-data.so\n   </code></p>\n</li>\n<li>\n<p>Running the <a href=\"https://github.com/bytecodealliance/sightglass\">sightglass</a> benchmarks:<br>\n<code>\n   $ cd ~/path/to/sightglass\n   $ cargo run --release -- benchmark -e /tmp/main.so -e /tmp/smaller-sig-data.so --stop-after compilation -- benchmarks/default.suite \n   </code><br>\n   (You can also try passing <code>--measure perf-counters</code> to see the effects on cache accesses/misses if you're on linux.)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 405234634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1701390684
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183#issuecomment-1835106497\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5183\">issue #5183</a>:</p>\n<blockquote>\n<p>Good question! I don't remember for sure.</p>\n<p>I think the only remaining possibility for shrinking this struct further is the <code>Option&lt;u16&gt;</code> storing <code>stack_ret_arg</code>, which is four bytes with one byte of padding in the middle. I think the <code>isa::CallConv</code> type is one byte, so with all the other fields being four bytes, the <code>call_conv</code> field has three bytes of padding. Therefore if we can pack the calling convention in with the return argument index, we can save four bytes.</p>\n<p>However, I don't think that's a \"good first issue\". I'm not even sure it's worth doing.</p>\n<p>So I'm going to go ahead and close this because I think it's basically done. Thanks for checking!</p>\n</blockquote>",
        "id": 405234635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1701390684
    }
]