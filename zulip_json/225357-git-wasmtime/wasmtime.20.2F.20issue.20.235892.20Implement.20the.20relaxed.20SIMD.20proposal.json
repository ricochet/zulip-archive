[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447280501\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>This is a substantial bit of work (regardless of the \"small\" proposal -- thanks for this!</p>\n<p>I have some thoughts on the Cranelift side below. To preface these thoughts: this is a good change, and we need to support this proposal. However, determinism has been a significant discussion point in CLIF and has significant implications for testing and verification, so I want to suggest that we might consider some tweaks to the approach. So:</p>\n<blockquote>\n<p>Implementation-wise this commit adds a number of new instructions to Cranelift all prefixed with arch_*. I've tried to document that the intended equivalence to a deterministic instruction and additionally document the edge cases (currently they've all got edge cases for x86_64 and none for aarch64, which I believe represents the current state of things). There may be better methods to do this, however, since this strategy does not seems scalable into the future if dozens-to-hundreds more instructions get proposed and implemented.</p>\n</blockquote>\n<p>Skimming the added instructions' definitions, my main concern is basically a mirror of the determinism concern at the Wasm standards discussion level. In CLIF, we've had a lot of discussion around determism as it relates to endianness (#3369 and subsequent discussions and PRs), which became especially relevant as we built the CLIF interpreter and started to fuzz against it. If we let CLIF semantics be partly defined by architecture-specific details, then we can't possibly define an interpreter behavior that matches all backends. Our solution in the endianness case was to reify endian as an explicit detail in the IR, let loads/stores be tagged as such. Ultimately in that case one can support big+little endian on all machines with the help of bswaps (and s390x actually does, so Wasm lowerings work), but that's a separate and additional step no different from any other \"support operand combinations\" enhancement.</p>\n<p>This is important for verification efforts too: we shouldn't have CLIF whose meaning depends on the compilation target. We <em>could</em> adopt a refinement semantics approach (\"result may be one of the values in this set\" and then compiled code refines those sets) but that's harder to reason about in general.</p>\n<p>I think a similar approach as we had with endianness might work here: define a Cranelift setting that is something like \"<code>arch_*</code> behavior\", or more granular settings for each (\"<code>insertlane</code> behavior\", ...), set them as appropriate for the expected target, and implement the appropriate lowerings (and all lowerings in the interpreter).</p>\n<p>There are some issues with that -- namely, we now need to plumb \"expected native settings for target T\" up to the CLIF producer, and the actual CLIF will now differ on x86-64 and aarch64 for programs that use these opcodes -- but the semantics are at least defined fully and machine-independently for any CLIF.</p>\n<p>Thoughts? Also, the Cranelift meeting on Wednesday would probably be a good venue to get a wider set of thoughts on this :-)</p>\n</blockquote>",
        "id": 338471535,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677540649
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447280501\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>This is a substantial bit of work (regardless of the \"small\" proposal) -- thanks for this!</p>\n<p>I have some thoughts on the Cranelift side below. To preface these thoughts: this is a good change, and we need to support this proposal. However, determinism has been a significant discussion point in CLIF and has significant implications for testing and verification, so I want to suggest that we might consider some tweaks to the approach. So:</p>\n<blockquote>\n<p>Implementation-wise this commit adds a number of new instructions to Cranelift all prefixed with arch_*. I've tried to document that the intended equivalence to a deterministic instruction and additionally document the edge cases (currently they've all got edge cases for x86_64 and none for aarch64, which I believe represents the current state of things). There may be better methods to do this, however, since this strategy does not seems scalable into the future if dozens-to-hundreds more instructions get proposed and implemented.</p>\n</blockquote>\n<p>Skimming the added instructions' definitions, my main concern is basically a mirror of the determinism concern at the Wasm standards discussion level. In CLIF, we've had a lot of discussion around determism as it relates to endianness (#3369 and subsequent discussions and PRs), which became especially relevant as we built the CLIF interpreter and started to fuzz against it. If we let CLIF semantics be partly defined by architecture-specific details, then we can't possibly define an interpreter behavior that matches all backends. Our solution in the endianness case was to reify endian as an explicit detail in the IR, and let loads/stores be tagged as such. Ultimately in that case one can support big+little endian on all machines with the help of bswaps (and s390x actually does, so Wasm lowerings work), but that's a separate and additional step no different from any other \"support operand combinations\" enhancement.</p>\n<p>This is important for verification efforts too: we shouldn't have CLIF whose meaning depends on the compilation target. We <em>could</em> adopt a refinement semantics approach (\"result may be one of the values in this set\" and then compiled code refines those sets) but that's harder to reason about in general.</p>\n<p>I think a similar approach as we had with endianness might work here: define a Cranelift setting that is something like \"<code>arch_*</code> behavior\", or more granular settings for each (\"<code>insertlane</code> behavior\", ...), set them as appropriate for the expected target, and implement the appropriate lowerings (and all lowerings in the interpreter).</p>\n<p>There are some issues with that -- namely, we now need to plumb \"expected native settings for target T\" up to the CLIF producer, and the actual CLIF will now differ on x86-64 and aarch64 for programs that use these opcodes -- but the semantics are at least defined fully and machine-independently for any CLIF.</p>\n<p>Thoughts? Also, the Cranelift meeting on Wednesday would probably be a good venue to get a wider set of thoughts on this :-)</p>\n</blockquote>",
        "id": 338471749,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677540767
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447283907\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>(An addendum to the above: in the endianness case we have a third endian, \"native\", which lets us avoid the plumbing problem of \"which endian is faster / even supported\" in the CLIF producer; but IMHO that's a bit of a wart, which I'd like to remove eventually for all of the reasons above, to fully capture the meaning in the IR. So I'd prefer we bite the bullet and plumb this through with settings and \"machine info\" of some sort.)</p>\n</blockquote>",
        "id": 338472001,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677540908
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447290796\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>If we want to offer the option of using the deterministic semantics for the relaxed SIMD proposal anyway, what if we start by shipping only that version? Then we can support the new wasm instructions now, while taking some more time to think through how best to expose architecture-specific instructions in Cranelift.</p>\n</blockquote>",
        "id": 338472861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677541397
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447292555\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"cranelift:area:aarch64\", \"cranelift:area:x64\", \"cranelift:meta\", \"cranelift:wasm\", \"wasmtime:api\", \"wasmtime:config\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 338473112,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677541526
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447292758\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 338473135,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677541540
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447299240\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>Definitely happy to discuss more at a Cranelift meeting! Sorry should have clarified that in the PR description, I figured the precise method of implementing this would be contentious and want to emphasize that this current iteration is just one point in the design space and I'm happy to adjust as preferred. My motivation for working on this was I wanted to add the instructions to the Rust standard library, but doing that required having a runtime that implements them, and since Wasmtime is currently used to validate simd intrinsics for Rust I figured I may as well give it a stab to implement here. In that sense I'm in no rush to get something in, and I would prefer to not land anything unless there's a path forward to getting the fast lowerings of these instructions since I suspect it's not really that useful of a proposal if only the deterministic lowerings are offered.</p>\n<hr>\n<p>One alternative is to basically just implement new <code>x86_*</code> instructions for CLIF which aren't implemented for any backend other than x86 (unless someone really really wants to do that) and are defined in terms of the actual x86 instructions. I don't know how scalable this is though in the sense that this PR only implements AArch64 and x86 lowerings for the relaxed simd instructions and while I don't believe any <code>aarch64_*</code> instructions would be necessary I don't know if CLIF would need to grow <code>riscv64_*</code> or <code>s390x_*</code> instructions.</p>\n<p>Another alternative would be to take inspiration which has intrinsics of the form <code>@llvm.x86.*</code> where any backend could have any number of intrinsics which are well-defined for each backend. CLIF AFAIK isn't really set up for this right now, though, but would provide more easy extensibility while retaining \"everything can in theory be implemented on every platform for every other platform simultaneously\".</p>\n<p>These alternatives, as noted, do indeed lift the complexity into the producer but that's not really the end of the world if the main producer here for these instructions is Wasmtime. </p>\n</blockquote>",
        "id": 338473986,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677542055
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447351829\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<blockquote>\n<p>One alternative is to basically just implement new x86_* instructions for CLIF which aren't implemented for any backend other than x86 (unless someone really really wants to do that) and are defined in terms of the actual x86 instructions. I don't know how scalable this is though in the sense that this PR only implements AArch64 and x86 lowerings for the relaxed simd instructions and while I don't believe any aarch64_* instructions would be necessary I don't know if CLIF would need to grow riscv64_* or s390x_* instructions.</p>\n</blockquote>\n<p>I actually kind of like this too, weirdly enough: it's dead-simple, and it doesn't create instructions whose semantics are \"parameterized\" on a Cranelift setting. If anyone were perplexed by \"x86\" appearing in a machine-dependent IR, we could expand it to <code>x86like_insertlane</code> or whatever -- the ISA name is the inspiration for the semantics but the semantics are machine-independent once we define this.</p>\n</blockquote>",
        "id": 338479418,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677544941
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447422171\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>A WebAssembly module can't select which code path to use based on which wasm extensions are available in the host, right? In that case I think there is value in having any implementation at all of the relaxed SIMD instructions, even if for some reason we never get around to making them fast on x86, so we can at least run modules that use them. I also think it's good to merge the uncontroversial parts of this first while we sort out the path to making it fast, so later we're iterating on a smaller PR.</p>\n</blockquote>",
        "id": 338484165,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677547418
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1447351829\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<blockquote>\n<p>One alternative is to basically just implement new x86_* instructions for CLIF which aren't implemented for any backend other than x86 (unless someone really really wants to do that) and are defined in terms of the actual x86 instructions. I don't know how scalable this is though in the sense that this PR only implements AArch64 and x86 lowerings for the relaxed simd instructions and while I don't believe any aarch64_* instructions would be necessary I don't know if CLIF would need to grow riscv64_* or s390x_* instructions.</p>\n</blockquote>\n<p>I actually kind of like this too, weirdly enough: it's dead-simple, and it doesn't create instructions whose semantics are \"parameterized\" on a Cranelift setting. If anyone were perplexed by \"x86\" appearing in a machine-independent IR, we could expand it to <code>x86like_insertlane</code> or whatever -- the ISA name is the inspiration for the semantics but the semantics are machine-independent once we define this.</p>\n</blockquote>",
        "id": 338488179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677550233
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1449086598\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>I've split out <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5895\">https://github.com/bytecodealliance/wasmtime/pull/5895</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5896\">https://github.com/bytecodealliance/wasmtime/pull/5896</a>, and <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5897\">https://github.com/bytecodealliance/wasmtime/pull/5897</a>, rebased this PR on top of those, and then split the bulk into two commits -- the first adds all the scaffolding/support/deterministic lowerings and the second adds all the x86-specific goop. I went ahead and switched to <code>x86_*</code> style instructions in CLIF, but I'd still like to discuss this in tomorrow's Cranelift meeting.</p>\n</blockquote>",
        "id": 338713742,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677627180
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892#issuecomment-1456330596\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5892\">issue #5892</a>:</p>\n<blockquote>\n<p>@cfallin or @jameysharp did y'all want to take another pass over this? If not I can go ahead and hit the button too</p>\n</blockquote>",
        "id": 339896336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1678115941
    }
]