[
    {
        "content": "<p>veluca93 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7734\">issue #7734</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As far as I could tell, the current implementation of shared memory and in particular the atomic_wait instructions will eventually block the calling thread (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/b583c54fda13b53dea362861125dd1e2ced1381d/crates/runtime/src/parking_spot.rs#L169\">https://github.com/bytecodealliance/wasmtime/blob/b583c54fda13b53dea362861125dd1e2ced1381d/crates/runtime/src/parking_spot.rs#L169</a>). This makes it impossible (I think) to implement custom scheduling of WASM threads, leaving control to the OS.</p>\n<h4>Benefit</h4>\n<p>Being able to fully control WASM thread scheduling would allow some interesting usecases for embedders:</p>\n<ul>\n<li>deterministic concurrent-but-not-parallel executions (by implementing a scheduler that cycles between non-waiting threads after a certain amount of fuel is consumed in a controlled way)</li>\n<li>debugging utilities for multi-threaded code that explore different execution orders to catch race conditions</li>\n<li>(maybe?) execution of multi-threaded WASM code without OS threads assuming that the wasmtime-fiber implementation is adapted</li>\n</ul>\n<h4>Implementation</h4>\n<p>My first idea would be to (optionally) modify the SharedMemory implementation of atomic_wait/atomic_notify to instead behave similarly to the implementation of <a href=\"https://docs.wasmtime.dev/api/wasmtime/struct.Store.html#method.fuel_async_yield_interval\">fuel_async_yield_interval</a>, yield control back to the caller and have them figure out how to do scheduling and when to resume the WASM thread. </p>\n<h4>Alternatives</h4>\n<p>I believe it should be possible to implement this behaviour also by replacing the calls to the atomic instructions with call to user-specified async <code>Func</code>s, which might possibly have better ergonomics (in principle, such a modification could be done without explicit support from wasmtime itself)</p>\n</blockquote>",
        "id": 410546272,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703943639
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7734#issuecomment-1874422016\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7734\">issue #7734</a>:</p>\n<blockquote>\n<p>I agree it would be good to have embedder-configurable hooks here! Yielding control back to the caller is not easy in the synchronous-call-to-wasm case because the API doesn't really afford for that, but for the async case I definitely agree that yielding back is the way to go here. That'd take some plumbing to get that all hooked up, for example when suspending a future we'd need to record the <code>Waker</code> to get woken when a <code>memory.atomic.notify</code> happens. Nothing that can't be done, however!</p>\n</blockquote>",
        "id": 410890980,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704221927
    }
]