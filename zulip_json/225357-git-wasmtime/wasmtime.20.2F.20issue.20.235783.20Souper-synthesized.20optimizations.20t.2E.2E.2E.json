[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>Here are some synthesized optimizations for CLIF harvested from<br>\n<code>spidermonkey.wasm</code> with explicit bounds checks enabled. I won't have time to<br>\ninvestigate, generalize, or implement them before I go on vacation, so I want to<br>\nnote them down in an issue for posterity.</p>\n<hr>\n<p>Replacing <code>clz(x) == 0</code> with a comparison:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2559773154913247904.result =========\n%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult 2147483647:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Similarly, we can do this for <code>clz(x) == 1</code>, which wasn't harvested from the<br>\nCLIF:</p>\n<div class=\"codehilite\"><pre><span></span><code>%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt 1073741823:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Note that there is no generalization for <code>clz(x) == C</code> available here (unless<br>\n<code>C</code> is larger than <code>x</code>'s bit width, in which case it is always false). It only<br>\nworks for zero and one because we don't need to check for a lower bound on <code>x</code>.</p>\n<p>Probably a similar rewrite we could do with <code>clz(x) == OP_BIT_WIDTH</code>.</p>\n<hr>\n<p>\"Reverse\" const propagation of a <code>shl</code> into a <code>select</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./11901186248914954319.result =========\n%1:i1 = var\n%2:i32 = select %1, 9:i32, 1:i32\n%3:i32 = shl -1:i32, %2\ninfer %3\n\n; RHS inferred successfully\n%3:i32 = select %1, 4294966784:i32, 4294967294:i32\nresult %3\n</code></pre></div>\n\n<p>Maybe not profitable if <code>%2</code> is used multiple times, in which case <code>%1</code>'s live<br>\nrange might be extended after this optimization. But I guess this is always true<br>\nwith these sorts of peepholes...</p>\n<hr>\n<p>Haven't dug into this one yet:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2969648510667058023.result =========\n%0:i32 = var\n%1:i32 = and %0, 2147483647:i32\n%2:i32 = shl %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = add %0, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A bunch of masking off bits that will be shifted out anyways:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./4985840733093600201.result =========\n%0:i32 = var\n%1:i32 = and %0, 1073741823:i32\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 2:i32\nresult %3\n\n========= ./17860953418551930245.result =========\n%0:i32 = var\n%1:i32 = and %0, 268435455:i32\n%2:i32 = shl %1, 4:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 4:i32\nresult %3\n\n========= ./8617343957324108668.result =========\n%0:i32 = var\n%1:i32 = and %0, 536870911:i32\n%2:i32 = shl %1, 3:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 3:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Replacing an <code>and</code> and an <code>eq</code> with an <code>ult</code>. Haven't thought about these yet.</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./9633751011751143656.result =========\n%0:i32 = var\n%1:i32 = and %0, -2147483648:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 2147483648:i32\nresult %3\n\n========= ./3840756061434214754.result =========\n%0:i32 = var\n%1:i32 = and %0, 4294967280:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 16:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Unnecessary <code>or</code>s:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./14551618322220925804.result =========\n%0:i32 = var\n%1:i32 = or %0, 1024:i32\n%2:i32 = and %1, 2048:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 2048:i32, %0\nresult %3\n\n========= ./13190508444419006141.result =========\n%0:i32 = var\n%1:i32 = or %0, 33032:i32\n%2:i32 = and %1, 192:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 192:i32, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>More masking off bits that will be shifted away:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./3703682576609255056.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 24:i32\nresult %3\n\n========= ./5310030443405410098.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 25:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 25:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A <em>ton</em> of \"reverse\" const prop with comparisons found, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./13877742632332331899.result =========\n%0:i32 = var\n%1:i32 = add %0, 1:i32\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 0:i32, %0\nresult %3\n\n========= ./3568272213429168939.result =========\n%0:i32 = var\n%1:i32 = add %0, 44:i32\n%2:i1 = eq %1, 3608:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 3564:i32, %0\nresult %3\n\n========= ./12119931432587256453.result =========\n%0:i32 = var\n%1:i32 = ashr %0, 2:i32\n%2:i1 = slt %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 96:i32\nresult %3\n\n========= ./7033427926372082757.result =========\n%0:i32 = var\n%1:i32 = and %0, -8:i32\n%2:i1 = sle %1, 31:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 32:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>And also a bunch \"reverse\" const prop with other operators as well (not as many<br>\nas with comparisons though). Again, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./7402500702784523674.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = shl %1, 16:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 17:i32\nresult %3\n\n========= ./10936462652029262118.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = mul %1, 12:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = mul 24:i32, %0\nresult %3\n\n========= ./13431533325972989820.result =========\n%0:i32 = var\n%1:i32 = shl -1:i32, %0\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl 4294967292:i32, %0\nresult %3\n</code></pre></div>\n\n</blockquote>",
        "id": 327899408,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676420129
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>Here are some synthesized optimizations for CLIF harvested from<br>\n<code>spidermonkey.wasm</code> with explicit bounds checks enabled. I won't have time to<br>\ninvestigate, generalize, or implement them before I go on vacation, so I want to<br>\nnote them down in an issue for posterity.</p>\n<hr>\n<p>Replacing <code>clz(x) == 0</code> with a comparison:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2559773154913247904.result =========\n%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult 2147483647:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Similarly, we can do this for <code>clz(x) == 1</code>, which wasn't harvested from the<br>\nCLIF:</p>\n<div class=\"codehilite\"><pre><span></span><code>%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt 1073741823:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Note that there is no generalization for <code>clz(x) == C</code> available here (unless<br>\n<code>C</code> is larger than <code>x</code>'s bit width, in which case it is always false). It only<br>\nworks for zero and one because we don't need to check for a lower bound on <code>x</code>.</p>\n<p>Probably a similar rewrite we could do with <code>clz(x) == OP_BIT_WIDTH</code>.</p>\n<hr>\n<p>\"Reverse\" const propagation of a <code>shl</code> into a <code>select</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./11901186248914954319.result =========\n%1:i1 = var\n%2:i32 = select %1, 9:i32, 1:i32\n%3:i32 = shl -1:i32, %2\ninfer %3\n\n; RHS inferred successfully\n%3:i32 = select %1, 4294966784:i32, 4294967294:i32\nresult %3\n</code></pre></div>\n\n<p>Maybe not profitable if <code>%2</code> is used multiple times, in which case <code>%1</code>'s live<br>\nrange might be extended after this optimization. But I guess this is always true<br>\nwith these sorts of peepholes...</p>\n<hr>\n<p>Haven't dug into this one yet:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2969648510667058023.result =========\n%0:i32 = var\n%1:i32 = and %0, 2147483647:i32\n%2:i32 = shl %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = add %0, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A bunch of masking off bits that will be shifted out anyways:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./4985840733093600201.result =========\n%0:i32 = var\n%1:i32 = and %0, 1073741823:i32\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 2:i32\nresult %3\n\n========= ./17860953418551930245.result =========\n%0:i32 = var\n%1:i32 = and %0, 268435455:i32\n%2:i32 = shl %1, 4:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 4:i32\nresult %3\n\n========= ./8617343957324108668.result =========\n%0:i32 = var\n%1:i32 = and %0, 536870911:i32\n%2:i32 = shl %1, 3:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 3:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Replacing an <code>and</code> and an <code>eq</code> with an <code>ult</code>. Haven't thought about these yet.</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./9633751011751143656.result =========\n%0:i32 = var\n%1:i32 = and %0, -2147483648:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 2147483648:i32\nresult %3\n\n========= ./3840756061434214754.result =========\n%0:i32 = var\n%1:i32 = and %0, 4294967280:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 16:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Unnecessary <code>or</code>s:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./14551618322220925804.result =========\n%0:i32 = var\n%1:i32 = or %0, 1024:i32\n%2:i32 = and %1, 2048:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 2048:i32, %0\nresult %3\n\n========= ./13190508444419006141.result =========\n%0:i32 = var\n%1:i32 = or %0, 33032:i32\n%2:i32 = and %1, 192:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 192:i32, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>More masking off bits that will be shifted away:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./3703682576609255056.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 24:i32\nresult %3\n\n========= ./5310030443405410098.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 25:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 25:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A <em>ton</em> of \"reverse\" const prop with comparisons found, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./13877742632332331899.result =========\n%0:i32 = var\n%1:i32 = add %0, 1:i32\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 0:i32, %0\nresult %3\n\n========= ./3568272213429168939.result =========\n%0:i32 = var\n%1:i32 = add %0, 44:i32\n%2:i1 = eq %1, 3608:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 3564:i32, %0\nresult %3\n\n========= ./12119931432587256453.result =========\n%0:i32 = var\n%1:i32 = ashr %0, 2:i32\n%2:i1 = slt %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 96:i32\nresult %3\n\n========= ./7033427926372082757.result =========\n%0:i32 = var\n%1:i32 = and %0, -8:i32\n%2:i1 = sle %1, 31:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 32:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>And also a bunch \"reverse\" const prop with other operators as well (not as many<br>\nas with comparisons though). Again, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./7402500702784523674.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = shl %1, 16:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 17:i32\nresult %3\n\n========= ./10936462652029262118.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = mul %1, 12:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = mul 24:i32, %0\nresult %3\n\n========= ./13431533325972989820.result =========\n%0:i32 = var\n%1:i32 = shl -1:i32, %0\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl 4294967292:i32, %0\nresult %3\n</code></pre></div>\n\n</blockquote>",
        "id": 327899409,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676420129
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>Here are some synthesized optimizations for CLIF harvested from<br>\n<code>spidermonkey.wasm</code> with explicit bounds checks enabled. I won't have time to<br>\ninvestigate, generalize, or implement them before I go on vacation, so I want to<br>\nnote them down in an issue for posterity.</p>\n<hr>\n<p>Replacing <code>clz(x) == 0</code> with a comparison:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2559773154913247904.result =========\n%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult 2147483647:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Similarly, we can do this for <code>clz(x) == 1</code>, which wasn't harvested from the<br>\nCLIF:</p>\n<div class=\"codehilite\"><pre><span></span><code>%0:i32 = var\n%1:i32 = ctlz %0\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt 1073741823:i32, %0\nresult %3\n</code></pre></div>\n\n<p>Note that there is no generalization for <code>clz(x) == C</code> available here (unless<br>\n<code>C</code> is larger than <code>x</code>'s bit width, in which case it is always false). It only<br>\nworks for zero and one because we don't need to check for a lower bound on <code>x</code>.</p>\n<p>Probably a similar rewrite we could do with <code>clz(x) == OP_BIT_WIDTH</code>.</p>\n<hr>\n<p>\"Reverse\" const propagation of a <code>shl</code> into a <code>select</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./11901186248914954319.result =========\n%1:i1 = var\n%2:i32 = select %1, 9:i32, 1:i32\n%3:i32 = shl -1:i32, %2\ninfer %3\n\n; RHS inferred successfully\n%3:i32 = select %1, 4294966784:i32, 4294967294:i32\nresult %3\n</code></pre></div>\n\n<p>Maybe not profitable if <code>%2</code> is used multiple times, in which case <code>%1</code>'s live<br>\nrange might be extended after this optimization. But I guess this is always true<br>\nwith these sorts of peepholes...</p>\n<hr>\n<p>Haven't dug into this one yet:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./2969648510667058023.result =========\n%0:i32 = var\n%1:i32 = and %0, 2147483647:i32\n%2:i32 = shl %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = add %0, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A bunch of masking off bits that will be shifted out anyways:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./4985840733093600201.result =========\n%0:i32 = var\n%1:i32 = and %0, 1073741823:i32\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 2:i32\nresult %3\n\n========= ./17860953418551930245.result =========\n%0:i32 = var\n%1:i32 = and %0, 268435455:i32\n%2:i32 = shl %1, 4:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 4:i32\nresult %3\n\n========= ./8617343957324108668.result =========\n%0:i32 = var\n%1:i32 = and %0, 536870911:i32\n%2:i32 = shl %1, 3:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 3:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Replacing an <code>and</code> and an <code>eq</code> with an <code>ult</code>. Haven't thought about these yet.</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./9633751011751143656.result =========\n%0:i32 = var\n%1:i32 = and %0, -2147483648:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 2147483648:i32\nresult %3\n\n========= ./3840756061434214754.result =========\n%0:i32 = var\n%1:i32 = and %0, 4294967280:i32\n%2:i1 = eq %1, 0:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = ult %0, 16:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>Unnecessary <code>or</code>s:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./14551618322220925804.result =========\n%0:i32 = var\n%1:i32 = or %0, 1024:i32\n%2:i32 = and %1, 2048:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 2048:i32, %0\nresult %3\n\n========= ./13190508444419006141.result =========\n%0:i32 = var\n%1:i32 = or %0, 33032:i32\n%2:i32 = and %1, 192:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = and 192:i32, %0\nresult %3\n</code></pre></div>\n\n<hr>\n<p>More masking off bits that will be shifted away:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./3703682576609255056.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 24:i32\nresult %3\n\n========= ./5310030443405410098.result =========\n%0:i32 = var\n%1:i32 = and %0, 255:i32\n%2:i32 = shl %1, 25:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 25:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>A <em>ton</em> of \"reverse\" const prop with comparisons found, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./13877742632332331899.result =========\n%0:i32 = var\n%1:i32 = add %0, 1:i32\n%2:i1 = eq %1, 1:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 0:i32, %0\nresult %3\n\n========= ./3568272213429168939.result =========\n%0:i32 = var\n%1:i32 = add %0, 44:i32\n%2:i1 = eq %1, 3608:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = eq 3564:i32, %0\nresult %3\n\n========= ./12119931432587256453.result =========\n%0:i32 = var\n%1:i32 = ashr %0, 2:i32\n%2:i1 = slt %1, 24:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 96:i32\nresult %3\n\n========= ./7033427926372082757.result =========\n%0:i32 = var\n%1:i32 = and %0, -8:i32\n%2:i1 = sle %1, 31:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i1 = slt %0, 32:i32\nresult %3\n</code></pre></div>\n\n<hr>\n<p>And also a bunch \"reverse\" const prop with other operators as well (not as many<br>\nas with comparisons though). Again, here are a few:</p>\n<div class=\"codehilite\"><pre><span></span><code>========= ./7402500702784523674.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = shl %1, 16:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl %0, 17:i32\nresult %3\n\n========= ./10936462652029262118.result =========\n%0:i32 = var\n%1:i32 = shl %0, 1:i32\n%2:i32 = mul %1, 12:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = mul 24:i32, %0\nresult %3\n\n========= ./13431533325972989820.result =========\n%0:i32 = var\n%1:i32 = shl -1:i32, %0\n%2:i32 = shl %1, 2:i32\ninfer %2\n\n; RHS inferred successfully\n%3:i32 = shl 4294967292:i32, %0\nresult %3\n</code></pre></div>\n\n</blockquote>",
        "id": 327899410,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676420129
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-1441538036\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>I was looking into souper the other day. I wasn't able to set it up properly, but I noticed we are missing a translation for <code>Bswap</code> in our harvest program. So there might be a few more optimizations possible there.</p>\n</blockquote>",
        "id": 329682806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677148937
    },
    {
        "content": "<p>regehr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2007775641\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>hello, please see this list of generalized versions of these:</p>\n<p><a href=\"https://gist.github.com/manasij7479/602e770d45169d5ffa73d8cd100d5b05\">https://gist.github.com/manasij7479/602e770d45169d5ffa73d8cd100d5b05</a></p>\n<p>maybe read them over and if you have any questions, ask me and @manasij7479 to explain.</p>\n<p>in Hydra's output, <code>sext(1)</code> is just a bitwidth-independent way to say <code>-1</code></p>\n<p>hope this is useful!</p>\n</blockquote>",
        "id": 427778858,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710869949
    },
    {
        "content": "<p>regehr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2007784617\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>I should add that in the general case, generalizing an optimization is not a well-posed problem. there are often multiple solutions, and it is often the case that it's not totally clear which one to prefer. so while the Hydra output is (hopefully) correct, it probably contains some examples where you might want to generalize things a different way in practice.</p>\n<p>also, this notation:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">sext</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">x0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">C2</span>\n<span class=\"w\">  </span><span class=\"o\">=&gt;</span>\n<span class=\"p\">(</span><span class=\"n\">sext</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">C2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">x0</span>\n</code></pre></div>\n<p>comes from a pretty-printer and is intended to make things easy to read for humans. the machine-readable form is Hydra's internal IR which is an extended version of Souper IR. what I'm saying is that I'm not sure that writing a parser for the pretty-printed output is the right answer. the right answer is probably to write some C++ that fits into Hydra and directly emits Cranelift pattern-matching / rewriting code. if you want to do this, please talk to us and hopefully also Manasij will help out</p>\n</blockquote>",
        "id": 427779775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710870248
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2010307854\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>Thanks @regehr!! Will take a look at these when I have some free cycles.</p>\n<p>Out of curiosity, can you provide some more details on what the reported \"profit\" scores are?</p>\n</blockquote>",
        "id": 427991228,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710958857
    },
    {
        "content": "<p>regehr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2010314018\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>ah, sorry, that's the difference in cost between the LHS and RHS, where cost is souper's idiosyncratic cost model where most stuff has cost 1, a few things like select have cost 3, and then some stuff like intrinsics have cost 5. </p>\n<p>we never really arrived at a good cost model for LLVM IR (I talked to many LLVM people about this many times and never really made good progress) and I don't expect it to be a great cost model for Cranelift either. but perhaps it's close enough.</p>\n</blockquote>",
        "id": 427991859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710959060
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2010322504\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<blockquote>\n<p>what I'm saying is that I'm not sure that writing a parser for the pretty-printed output is the right answer.</p>\n</blockquote>\n<p>FWIW, if Hydra outputted the same text format as Souper, we would be able to reuse the existing parser I wrote: <a href=\"https://docs.rs/souper-ir/latest/souper_ir/\">https://docs.rs/souper-ir/latest/souper_ir/</a></p>\n<p>But yeah, we will definitely reach out again when we look at automating this whole process in the future</p>\n</blockquote>",
        "id": 427992664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710959370
    },
    {
        "content": "<p>manasij7479 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2010379981\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>what I'm saying is that I'm not sure that writing a parser for the pretty-printed output is the right answer.</p>\n</blockquote>\n<p>FWIW, if Hydra outputted the same text format as Souper, we would be able to reuse the existing parser I wrote: <a href=\"https://docs.rs/souper-ir/latest/souper_ir/\">https://docs.rs/souper-ir/latest/souper_ir/</a></p>\n<p>But yeah, we will definitely reach out again when we look at automating this whole process in the future</p>\n</blockquote>\n<p>It does, and that is what our automation for generating an LLVM pass uses.  </p>\n<p>It assigns meaning to specific identifier names, and has different semantics for width constraints.<br>\nFor example a %symconst prefix means it is a symbolic constant.  It is pretty much Souper IR other than some details like this, so your parser could work pretty well.</p>\n</blockquote>",
        "id": 427997390,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710961226
    },
    {
        "content": "<p>regehr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783#issuecomment-2010687799\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5783\">issue #5783</a>:</p>\n<blockquote>\n<p>this all sounds great.</p>\n<p>but note that some things like bitwidth independence are handled outside of Souper IR, and require some care</p>\n<p>if there's something we can do on our side, please let us know, but keep in mind that Manasij plans to defend later this spring, so the earlier the better!</p>\n</blockquote>",
        "id": 428019980,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710970788
    }
]