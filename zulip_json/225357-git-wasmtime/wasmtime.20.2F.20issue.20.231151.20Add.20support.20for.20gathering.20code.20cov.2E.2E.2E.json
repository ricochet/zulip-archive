[
    {
        "content": "<p>kimdora <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084095240\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>Hello, is there further progress for tracking code coverage?</p>\n</blockquote>",
        "id": 277235110,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648704899
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084104639\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>Hi @kimdora, unfortunately no one has had time to look at this yet. If you or someone else is interested in trying to implement this, we would definitely be able to help guide the effort, though.</p>\n</blockquote>",
        "id": 277236179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648706057
    },
    {
        "content": "<p>kimdora <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084249321\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>Hi @cfallin, actually I'm interested in this. I wanna try to implement this, but unfortunately I'm not sure where to start. Is there any guide on things regarding this?</p>\n</blockquote>",
        "id": 277246933,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648714604
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084794163\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>@kimdora our contributing docs are here: <a href=\"https://docs.wasmtime.dev/contributing.html\">https://docs.wasmtime.dev/contributing.html</a> (those are a little wasmtime specific but cranelift's process is pretty much identical)</p>\n</blockquote>",
        "id": 277304622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648742929
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084833450\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>@kimdora to get started on this particular idea, a few things that might be helpful:</p>\n<ul>\n<li>Instrumentation for generated code run by Wasmtime is generally done in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/cranelift/src/func_environ.rs\">this file</a>: it has hooks that are invoked by the Wasm-to-IR lowering at certain points (loop headers, before and after every instruction, etc).</li>\n<li>The runtime has a toplevel data structure called the <code>VMContext</code> that is accessible from generated code. It is defined implicitly by computing offsets <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/environ/src/vmoffsets.rs\">here</a>. In the lowering above, you'll see various references to the vmctx and loads of pointers from its fields, for example.</li>\n<li>The IR opcodes (our IR is called \"CLIF\") that are available can be seen in the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html\">InstBuilder documentation</a>.</li>\n</ul>\n<p>My first step would probably be to design the data structures. To track code coverage, we probably want to keep counters of some sort, one counter per \"location\", and increment a counter when control-flow reaches that location in the generated code. A location might be a basic block, or an individual Wasm opcode; the latter may be simplest with the existing hooks, but will be significantly slower (2x-5x slowdown probably). Then given that data structure, allocate it during VMContext construction, and in the generated-code hooks, load a pointer to the array once at the beginning of the function and emit a load-add-store sequence at a particular offset before every Wasm opcode is lowered.</p>\n<p>@fitzgen mentions above that there are tricks to reduce the number of points at which you increment a counter, and reconstruct later. For an example of the intuition, a loop with a straight-line-code body, i.e. no conditionals inside the loop, only needs a single counter increment for each loop iteration. And an if-else needs a counter for each path (or I guess one could recover one given the other), but the control flow merge doesn't need a counter because we know control must flow there. In general I think we can use the domtree to work this out. I know I've seen a paper about this but can't recall it now; anyway we can talk about this more when we need it and we definitely don't need to implement it right away!</p>\n<p>I would estimate that the simplest version (array of counters one per Wasm opcode, instrumentation at each Wasm opcode) is probably ~100 lines of code; it shouldn't be too complex in an absolute sense, but I recognize this is probably a lot of new context to learn. We're happy to help explain more or work things out if you get stuck!</p>\n</blockquote>",
        "id": 277309220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648745106
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1084846616\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>Ah, and I should add that in the above I was assuming doing this for Wasm code running in Wasmtime specifically; were you interested in that or in coverage instrumentation for some other Cranelift frontend? In the latter case the basic steps would be the same but the implementation would probably best be done in whatever other frontend (since it requires interaction with runtime data structures) rather than purely in Cranelift.</p>\n</blockquote>",
        "id": 277310614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648745875
    },
    {
        "content": "<p>kimdora <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151#issuecomment-1085486471\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1151\">issue #1151</a>:</p>\n<blockquote>\n<p>@cfallin, really thank you for your kind reply. I should carefully read your above comment. There are lots of information that you provided so that I haven't read all of things in detail at this moment... If there is any progress or question, I'll comment again! Also I think your comment is quite enough because I'm interested in tracking code coverage during running WebAssembly code running in Wasmtime!</p>\n</blockquote>",
        "id": 277375443,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648794598
    }
]