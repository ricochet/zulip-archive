[
    {
        "content": "<p>SteveSandersonMS opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<h3>Test Case</h3>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/files/8267462/testcase.zip\">testcase.zip</a></p>\n<h3>Steps to Reproduce</h3>\n<ol>\n<li>Extract <code>main.wasm</code> from the test case zip file. Or compile it yourself using WASI SDK and the following source code, e.g. via <code>~/wasi-sdk/bin/clang main.c --sysroot ~/wasi-sdk/share/wasi-sysroot -o main.wasm</code> if you have WASI SDK at <code>~/wasi-sdk</code>.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;dirent.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">DIR</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">opendir</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"s\">\"./\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">dirent</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ep</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"nb\">NULL</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">ep</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">readdir</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%s</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ep</span><span class=\"o\">-&gt;</span><span class=\"n\">d_name</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">closedir</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Couldn't open the directory</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Run <code>wasmtime main.wasm --dir=.</code> and observe it print a directory listing</li>\n<li>Run <code>wasmtime main.wasm --dir=. --tcplisten=127.0.0.1:9000</code> and observe it fail to do so (it will print <em>Couldn't open the directory</em>)</li>\n</ol>\n<h3>Expected Results</h3>\n<p>I expect that <code>--tcplisten</code> should <em>not</em> break the directory mapping.</p>\n<h3>Actual Results</h3>\n<p>Passing <code>--tcplisten</code> makes it behave as if you didn't pass <code>--dir=.</code>.</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: 0.35.1</p>\n<p>Operating system: linux</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>Other than this, <code>--tcplisten</code> works brilliantly and I've been able to implement a nontrivial web server application using this flag and the new <code>sock_accept</code> API.</p>\n</blockquote>",
        "id": 275558560,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1647455836
    },
    {
        "content": "<p>SteveSandersonMS labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<h3>Test Case</h3>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/files/8267462/testcase.zip\">testcase.zip</a></p>\n<h3>Steps to Reproduce</h3>\n<ol>\n<li>Extract <code>main.wasm</code> from the test case zip file. Or compile it yourself using WASI SDK and the following source code, e.g. via <code>~/wasi-sdk/bin/clang main.c --sysroot ~/wasi-sdk/share/wasi-sysroot -o main.wasm</code> if you have WASI SDK at <code>~/wasi-sdk</code>.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;dirent.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">DIR</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">opendir</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"s\">\"./\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">dirent</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ep</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"nb\">NULL</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">ep</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">readdir</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%s</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ep</span><span class=\"o\">-&gt;</span><span class=\"n\">d_name</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">closedir</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"Couldn't open the directory</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Run <code>wasmtime main.wasm --dir=.</code> and observe it print a directory listing</li>\n<li>Run <code>wasmtime main.wasm --dir=. --tcplisten=127.0.0.1:9000</code> and observe it fail to do so (it will print <em>Couldn't open the directory</em>)</li>\n</ol>\n<h3>Expected Results</h3>\n<p>I expect that <code>--tcplisten</code> should <em>not</em> break the directory mapping.</p>\n<h3>Actual Results</h3>\n<p>Passing <code>--tcplisten</code> makes it behave as if you didn't pass <code>--dir=.</code>.</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: 0.35.1</p>\n<p>Operating system: linux</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>Other than this, <code>--tcplisten</code> works brilliantly and I've been able to implement a nontrivial web server application using this flag and the new <code>sock_accept</code> API.</p>\n</blockquote>",
        "id": 275559918,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1647456338
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1069705189\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>CC @haraldh. It's possible this is related to how WASI programs discover the preopened sockets. Would it work to do the <code>self.compute_preopen_dirs()</code> before the <code>self.compute_preopen_sockets()</code>, so that the directories have lower file descriptor numbers and are found first?</p>\n<p>This is an area where, in the future, Typed Main will help: instead of having WASI programs search through the file descriptor space to find preopens, we ideally want them provided explicitly.<br>\n</p>\n</blockquote>",
        "id": 275586186,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1647470218
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1082275996\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@haraldh is this something you might be able to look into? Addressing this looks like it'd help make <code>--tcplisten</code> quite a bit more useful :)</p>\n</blockquote>",
        "id": 277052769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648581434
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1084660308\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>yes, will do</p>\n</blockquote>",
        "id": 277289416,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1648736738
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1087189512\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Ok, here is the analysis.</p>\n<ul>\n<li>socket gets fd 3</li>\n<li>directory gets fd 4</li>\n<li><code>wasi-libc/libc-bottom-half/sources/preopens.c:__wasilibc_populate_preopens()</code> calls for every <code>fd &gt;= 3</code>  <code>fd_prestat_get()</code> and internally registers directories. But if it encounters an error, like with fd 3 straight away, it bails out.</li>\n</ul>\n<p>So with a WASI change like this:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/phases/snapshot/witx/typenames.witx b/phases/snapshot/witx/typenames.witx</span><span class=\"w\"></span>\n<span class=\"gh\">index 893e5b2..6aef907 100644</span><span class=\"w\"></span>\n<span class=\"gd\">--- a/phases/snapshot/witx/typenames.witx</span><span class=\"w\"></span>\n<span class=\"gi\">+++ b/phases/snapshot/witx/typenames.witx</span><span class=\"w\"></span>\n<span class=\"gu\">@@ -730,6 +730,7 @@</span><span class=\"w\"></span>\n<span class=\"w\"> </span>  (enum (@witx tag u8)<span class=\"w\"></span>\n<span class=\"w\"> </span>    ;;; A pre-opened directory.<span class=\"w\"></span>\n<span class=\"w\"> </span>    $dir<span class=\"w\"></span>\n<span class=\"gi\">+    $listen_socket</span><span class=\"w\"></span>\n<span class=\"w\"> </span>  )<span class=\"w\"></span>\n<span class=\"w\"> </span>)<span class=\"w\"></span>\n\n<span class=\"gu\">@@ -741,10 +742,19 @@</span><span class=\"w\"></span>\n<span class=\"w\"> </span>  )<span class=\"w\"></span>\n<span class=\"w\"> </span>)<span class=\"w\"></span>\n\n<span class=\"gi\">+;;; The contents of a $prestat when type is `preopentype::listen_socket`.</span><span class=\"w\"></span>\n<span class=\"gi\">+(typename $prestat_listen_socket</span><span class=\"w\"></span>\n<span class=\"gi\">+  (record</span><span class=\"w\"></span>\n<span class=\"gi\">+    ;;; The length of the address string for use with `fd_prestat_socket_addr`.</span><span class=\"w\"></span>\n<span class=\"gi\">+    (field $pr_addr_len $size)</span><span class=\"w\"></span>\n<span class=\"gi\">+  )</span><span class=\"w\"></span>\n<span class=\"gi\">+)</span><span class=\"w\"></span>\n<span class=\"gi\">+</span><span class=\"w\"></span>\n<span class=\"w\"> </span>;;; Information about a pre-opened capability.<span class=\"w\"></span>\n<span class=\"w\"> </span>(typename $prestat<span class=\"w\"></span>\n<span class=\"w\"> </span>  (union (@witx tag $preopentype)<span class=\"w\"></span>\n<span class=\"w\"> </span>    $prestat_dir<span class=\"w\"></span>\n<span class=\"gi\">+    $prestat_listen_socket</span><span class=\"w\"></span>\n<span class=\"w\"> </span>  )<span class=\"w\"></span>\n<span class=\"w\"> </span>)<span class=\"w\"></span>\n</code></pre></div>\n<p>we could fix <code>wasmtime</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/crates/wasi-common/src/snapshots/preview_0.rs b/crates/wasi-common/src/snapshots/preview_0.rs</span><span class=\"w\"></span>\n<span class=\"gh\">index 96f86820b..8bdc2039a 100644</span><span class=\"w\"></span>\n<span class=\"gd\">--- a/crates/wasi-common/src/snapshots/preview_0.rs</span><span class=\"w\"></span>\n<span class=\"gi\">+++ b/crates/wasi-common/src/snapshots/preview_0.rs</span><span class=\"w\"></span>\n<span class=\"gu\">@@ -198,6 +198,7 @@ impl From&lt;snapshot1_types::Prestat&gt; for types::Prestat {</span><span class=\"w\"></span>\n<span class=\"w\"> </span>    fn from(p: snapshot1_types::Prestat) -&gt; types::Prestat {<span class=\"w\"></span>\n<span class=\"w\"> </span>        match p {<span class=\"w\"></span>\n<span class=\"w\"> </span>            snapshot1_types::Prestat::Dir(d) =&gt; types::Prestat::Dir(d.into()),<span class=\"w\"></span>\n<span class=\"gi\">+            snapshot1_types::Prestat::ListenSocket(_) =&gt; todo!(),</span><span class=\"w\"></span>\n<span class=\"w\"> </span>        }<span class=\"w\"></span>\n<span class=\"w\"> </span>    }<span class=\"w\"></span>\n<span class=\"w\"> </span>}<span class=\"w\"></span>\n<span class=\"gh\">diff --git a/crates/wasi-common/src/snapshots/preview_1.rs b/crates/wasi-common/src/snapshots/preview_1.rs</span><span class=\"w\"></span>\n<span class=\"gh\">index 9c6f372d3..758b9da61 100644</span><span class=\"w\"></span>\n<span class=\"gd\">--- a/crates/wasi-common/src/snapshots/preview_1.rs</span><span class=\"w\"></span>\n<span class=\"gi\">+++ b/crates/wasi-common/src/snapshots/preview_1.rs</span><span class=\"w\"></span>\n<span class=\"gu\">@@ -554,13 +554,26 @@ impl wasi_snapshot_preview1::WasiSnapshotPreview1 for WasiCtx {</span><span class=\"w\"></span>\n\n<span class=\"w\"> </span>    async fn fd_prestat_get(&amp;mut self, fd: types::Fd) -&gt; Result&lt;types::Prestat, Error&gt; {<span class=\"w\"></span>\n<span class=\"w\"> </span>        let table = self.table();<span class=\"w\"></span>\n<span class=\"gd\">-        let dir_entry: &amp;DirEntry = table.get(u32::from(fd)).map_err(|_| Error::badf())?;</span><span class=\"w\"></span>\n<span class=\"gd\">-        if let Some(ref preopen) = dir_entry.preopen_path() {</span><span class=\"w\"></span>\n<span class=\"gd\">-            let path_str = preopen.to_str().ok_or_else(|| Error::not_supported())?;</span><span class=\"w\"></span>\n<span class=\"gd\">-            let pr_name_len = u32::try_from(path_str.as_bytes().len())?;</span><span class=\"w\"></span>\n<span class=\"gd\">-            Ok(types::Prestat::Dir(types::PrestatDir { pr_name_len }))</span><span class=\"w\"></span>\n<span class=\"gi\">+        if let Ok(dir_entry) = table.get::&lt;DirEntry&gt;(u32::from(fd)) {</span><span class=\"w\"></span>\n<span class=\"gi\">+            if let Some(ref preopen) = dir_entry.preopen_path() {</span><span class=\"w\"></span>\n<span class=\"gi\">+                let path_str = preopen.to_str().ok_or_else(|| Error::not_supported())?;</span><span class=\"w\"></span>\n<span class=\"gi\">+                let pr_name_len = u32::try_from(path_str.as_bytes().len())?;</span><span class=\"w\"></span>\n<span class=\"gi\">+                Ok(types::Prestat::Dir(types::PrestatDir { pr_name_len }))</span><span class=\"w\"></span>\n<span class=\"gi\">+            } else {</span><span class=\"w\"></span>\n<span class=\"gi\">+                Err(Error::not_supported().context(\"file is not a preopen\"))</span><span class=\"w\"></span>\n<span class=\"gi\">+            }</span><span class=\"w\"></span>\n<span class=\"gi\">+        } else if let Ok(file_entry) = table.get_mut::&lt;FileEntry&gt;(u32::from(fd)) {</span><span class=\"w\"></span>\n<span class=\"gi\">+            let fdstat = file_entry.get_fdstat().await?;</span><span class=\"w\"></span>\n<span class=\"gi\">+            if matches!(fdstat.filetype, FileType::SocketStream) {</span><span class=\"w\"></span>\n<span class=\"gi\">+                let pr_addr_len = 0; // TODO</span><span class=\"w\"></span>\n<span class=\"gi\">+                Ok(types::Prestat::ListenSocket(types::PrestatListenSocket {</span><span class=\"w\"></span>\n<span class=\"gi\">+                    pr_addr_len,</span><span class=\"w\"></span>\n<span class=\"gi\">+                }))</span><span class=\"w\"></span>\n<span class=\"gi\">+            } else {</span><span class=\"w\"></span>\n<span class=\"gi\">+                Err(Error::not_supported().context(\"file is not a preopen\"))</span><span class=\"w\"></span>\n<span class=\"gi\">+            }</span><span class=\"w\"></span>\n<span class=\"w\"> </span>        } else {<span class=\"w\"></span>\n<span class=\"gd\">-            Err(Error::not_supported().context(\"file is not a preopen\"))</span><span class=\"w\"></span>\n<span class=\"gi\">+            Err(Error::badf())</span><span class=\"w\"></span>\n<span class=\"w\"> </span>        }<span class=\"w\"></span>\n<span class=\"w\"> </span>    }<span class=\"w\"></span>\n</code></pre></div>\n<p>which would fix the code of this issue.</p>\n</blockquote>",
        "id": 277689472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649055900
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088393681\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>The quick \"band-aid\" fix is <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3995\">https://github.com/bytecodealliance/wasmtime/pull/3995</a></p>\n</blockquote>",
        "id": 277840787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649145841
    },
    {
        "content": "<p>SteveSandersonMS <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088478899\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Thanks for looking into this, @haraldh!</p>\n<p>Just to clarify, how is application code meant to know which file descriptor numbers to pass to <code>sock_accept</code>? Is this a gap in the WASI spec, or does it say how they should be ordered or discovered? I could imagine two different WASI hosts might take different approaches (with this PR, wasmtime might put directory preopens first, but another runtime might put TCP listeners first). </p>\n<p>Is there a recommended pattern of calls for application code to discover the available TCP listener file descriptors?</p>\n<p>cc @sunfishcode</p>\n</blockquote>",
        "id": 277849711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649150995
    },
    {
        "content": "<p>SteveSandersonMS edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088478899\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Thanks for looking into this, @haraldh!</p>\n<p>Just to clarify, how is application code meant to know which file descriptor numbers to pass to <code>sock_accept</code>? Is this a gap in the WASI spec, or does it say how they should be ordered or discovered? I could imagine two different WASI hosts might take different approaches (with the PR, wasmtime might put directory preopens first, but another runtime might put TCP listeners first). </p>\n<p>Is there a recommended pattern of calls for application code to discover the available TCP listener file descriptors?</p>\n<p>cc @sunfishcode</p>\n</blockquote>",
        "id": 277849775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151011
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088485532\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is there a recommended pattern of calls for application code to discover the available TCP listener file descriptors?</p>\n</blockquote>\n<p>Using the <code>LISTEN_FDS</code> env var. This env var is also used by systemd socket activation. According to <code>man sd_listen_fds</code> the first socket must be at fd 3 (so preopened directories must be <em>after</em> the preopened sockets, not before) and there must be <code>$LISTEN_FDS</code> sockets passed in.</p>\n</blockquote>",
        "id": 277850552,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151422
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088490068\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>A combination of <code>fd_prestat_get()</code> for the directories and <code>fd_fdstat_get()</code> checking <code>fs_filetype == SocketStream</code>  could be used without extending the WASI spec.</p>\n</blockquote>",
        "id": 277851039,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151698
    },
    {
        "content": "<p>SteveSandersonMS <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088492333\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Thanks for the info! That's really useful.</p>\n<blockquote>\n<p>preopened directories must be after the preopened sockets, not before</p>\n</blockquote>\n<p>Does the band-aid fix satisfy this condition? I did try out the <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1087189512\">patch given above</a> and observed that it did still supply listener FDs starting from 3, even when there's also a directory preopen.</p>\n</blockquote>",
        "id": 277851392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151846
    },
    {
        "content": "<p>SteveSandersonMS edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088492333\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Thanks for the info! That's really useful.</p>\n<blockquote>\n<p>preopened directories must be after the preopened sockets, not before</p>\n</blockquote>\n<p>Does the \"band-aid\" fix (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/3995\">https://github.com/bytecodealliance/wasmtime/pull/3995</a>) satisfy this condition? I did try out the <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1087189512\">patch given above</a> and observed that it did still supply listener FDs starting from 3, even when there's also a directory preopen.</p>\n</blockquote>",
        "id": 277851428,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151871
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088492780\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Is there a recommended pattern of calls for application code to discover the available TCP listener file descriptors?</p>\n</blockquote>\n<p>Using the <code>LISTEN_FDS</code> env var. This env var is also used by systemd socket activation. According to <code>man sd_listen_fds</code> the first socket must be at fd 3 (so preopened directories must be _after_ the preopened sockets, not before) and there must be <code>$LISTEN_FDS</code> sockets passed in.</p>\n</blockquote>\n<p>Or we have to increment  the <code>LISTEN_FDS</code> env var by the number of the preopened directories (and also <code>LISTEN_FDNAMES</code>).</p>\n</blockquote>",
        "id": 277851437,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151878
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088494053\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<blockquote>\n<p>Thanks for the info! That's really useful.</p>\n<blockquote>\n<p>preopened directories must be after the preopened sockets, not before</p>\n</blockquote>\n<p>Does the \"band-aid\" fix (#3995) satisfy this condition? I did try out the <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1087189512\">patch given above</a> and observed that it did still supply listener FDs starting from 3, even when there's also a directory preopen.</p>\n</blockquote>\n<p>The \"band-aid\" fix violates this condition... The fix with the WASI spec change satisfies it.</p>\n</blockquote>",
        "id": 277851612,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649151964
    },
    {
        "content": "<p>npmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088658040\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@bjorn3 One problem with <code>LISTEN_FDS</code> is that it is only used for <code>fd &gt;= 3</code>. What if an application has fewer file descriptors?</p>\n</blockquote>",
        "id": 277871609,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649162618
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088665799\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Fds 0, 1 and 2 are reserved for stdin, stdout and stderr respectively. Wasi doesn't allow them to be absent AFAIK.</p>\n</blockquote>",
        "id": 277872839,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649163102
    },
    {
        "content": "<p>haraldh <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1088708988\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Anyway, to get into this situation, you have to deliberately use the new command line features or the new <code>WasiCtx</code> methods and as I said,</p>\n<blockquote>\n<p>A combination of <code>fd_prestat_get()</code> for the directories and <code>fd_fdstat_get()</code> checking <code>fs_filetype == SocketStream</code>  could be used without extending the WASI spec.</p>\n</blockquote>\n<p>So, instead of <code>DIR *dp = opendir (\"./\");</code> one would use <code>DIR *dp = fdopendir (fd);</code></p>\n</blockquote>",
        "id": 277878735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649165542
    },
    {
        "content": "<p>npmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1090318207\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@bjorn3 I don't see stdio in the snapshot at all.</p>\n</blockquote>",
        "id": 278028830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649254179
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1090402529\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>What snapshot?</p>\n</blockquote>",
        "id": 278040741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649258789
    },
    {
        "content": "<p>npmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1091719627\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@bjorn3 <a href=\"https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md\">https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md</a></p>\n</blockquote>",
        "id": 278161711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649337143
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1091742624\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Both the wasi impl in wasmtime and wasi-libc assume the first three fds are stdio:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/76f7cde6734ecb5b89ac122a0f91af3a7a7a04a1/crates/wasi-common/src/ctx.rs#L35-L37\">https://github.com/bytecodealliance/wasmtime/blob/76f7cde6734ecb5b89ac122a0f91af3a7a7a04a1/crates/wasi-common/src/ctx.rs#L35-L37</a></p>\n<p><a href=\"https://github.com/WebAssembly/wasi-libc/blob/079adff840032c3455eb1cb34dc9ceaa0b2bfc0c/libc-bottom-half/sources/preopens.c#L213-L215\">https://github.com/WebAssembly/wasi-libc/blob/079adff840032c3455eb1cb34dc9ceaa0b2bfc0c/libc-bottom-half/sources/preopens.c#L213-L215</a></p>\n</blockquote>",
        "id": 278163895,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1649338293
    },
    {
        "content": "<p>sdeleuze <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102346018\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Hi, thanks for raising this since I hit the same problem when implementing a web server that serve static files. I am wondering if there is a consensus on how to fix it? Could be the case based on this discussion above but I am not 100% sure.</p>\n<p>@bjorn3 said:</p>\n<blockquote>\n<p>According to man sd_listen_fds the first socket must be at fd 3 (so preopened directories must be after the preopened sockets, not before)</p>\n</blockquote>\n<p>Then @haraldh said:</p>\n<blockquote>\n<p>A combination of fd_prestat_get() for the directories and fd_fdstat_get() checking fs_filetype == SocketStream could be used without extending the WASI spec.</p>\n</blockquote>\n<p>So is it correct to assume that it is possible to fix this issue without extending the WASI spec, in a compliant way with man sd_listen_fds (preopened directories must be after the preopened sockets) just by refining how Wasmtime handles this?</p>\n<p>Happy to try crafting a PR with proper guidance.</p>\n</blockquote>",
        "id": 279381880,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650359082
    },
    {
        "content": "<p>npmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102693168\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<blockquote>\n<p>Both the wasi impl in wasmtime and wasi-libc assume the first three fds are stdio:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/76f7cde6734ecb5b89ac122a0f91af3a7a7a04a1/crates/wasi-common/src/ctx.rs#L35-L37\">https://github.com/bytecodealliance/wasmtime/blob/76f7cde6734ecb5b89ac122a0f91af3a7a7a04a1/crates/wasi-common/src/ctx.rs#L35-L37</a></p>\n<p><a href=\"https://github.com/WebAssembly/wasi-libc/blob/079adff840032c3455eb1cb34dc9ceaa0b2bfc0c/libc-bottom-half/sources/preopens.c#L213-L215\">https://github.com/WebAssembly/wasi-libc/blob/079adff840032c3455eb1cb34dc9ceaa0b2bfc0c/libc-bottom-half/sources/preopens.c#L213-L215</a></p>\n</blockquote>\n<p>But it isn't in the standard. Implementations can assume anything they want. It doesn't make it standard behavior.</p>\n</blockquote>",
        "id": 279412713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650376816
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102757163\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Anything that wants to use wasi-libc implicitly assumes this. Assemblyscript also assumes it (<a href=\"https://github.com/AssemblyScript/assemblyscript/blob/d884ac8032b2bfa0caf26d4dc11d99c5a9543c13/std/assembly/wasi/index.ts#L57\">https://github.com/AssemblyScript/assemblyscript/blob/d884ac8032b2bfa0caf26d4dc11d99c5a9543c13/std/assembly/wasi/index.ts#L57</a>) Nodejs also uses 0, 1 and 2 for stdin, stdout and stderr by default. Because of this IMO it should just be added to the actual wasi standard as it is already de-facto standard, just not de-jure.</p>\n</blockquote>",
        "id": 279420062,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650380203
    },
    {
        "content": "<p>npmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102811418\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@bjorn3 But this is an example of a host feature \"bleeding\" into the spec. In Enarx, the host stdio is untrusted and shouldn't be connected to the encrypted guest wasm instance. I do not thing we should presume that just because everyone assumes it that it should be added to WASI uncritically.</p>\n</blockquote>",
        "id": 279427653,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650383199
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102817075\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>It isn't required that the host stdio is connected to the guest stdio. The guest can have /dev/null or a file on which every operations fails as stdio if there is no stdio to pass through.</p>\n</blockquote>",
        "id": 279428482,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650383531
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1102818319\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>WASI is in the process of moving to interface types and Typed Main, at which point I expect we'll completely overhaul the way file descriptors are passed into programs. The accept feature here is about enabling certain functionality with minimal changes to the current infrastructure.</p>\n<p>Within the current infrastructure, fds 0,1,2 are effectively reserved for stdin, stdout, stderr. wasi-libc assumes this. This isn't how POSIX would do things, or how Linux would do them, but it's how the current infrastructure works, so the way to make things work with minimal changes is just to teach everything that 0,1,2 are reserved for stdin, stdout, and stderr.</p>\n</blockquote>",
        "id": 279428630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650383606
    },
    {
        "content": "<p>tiran <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1194260669\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Hi, is there any progress on this issue? I would like to use <code>--tcplisten</code> to experiment with sockets from CPython WASI port. For now Python also requires <code>--mapdir</code> or <code>--dir</code> to mount Python's stdlib.</p>\n</blockquote>",
        "id": 290777938,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658764300
    },
    {
        "content": "<p>squillace <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1741404457\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@sunfishcode is there any resolution we might work toward here? This continues to break a few things. </p>\n</blockquote>",
        "id": 393994867,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696016946
    },
    {
        "content": "<p>squillace <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1741461465\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>it appears that <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3995\">https://github.com/bytecodealliance/wasmtime/pull/3995</a> should fix it, but...</p>\n</blockquote>",
        "id": 394000735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696019839
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1741543473\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@squillace is it possible to use components instead and use the <code>wasi:sockets</code> proposal? Not much thought has gone into trying to backfill the socket APIs of preview1 with the implementations of preview2 because it was assumed that there weren't all that many users of preview1 sockets. This may be possible to get working somewhat, but in general it'd probably be best to start riding the preview2/component train if possible.</p>\n</blockquote>",
        "id": 394011989,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696025931
    },
    {
        "content": "<p>squillace <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1742487159\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>we'll have a look to see whether the wasi-sockets proposal is ready for freddy. In general, there'll be a choice that language runtimes make here, so for them this is a fork in the road, so to speak....</p>\n</blockquote>",
        "id": 394338368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696229691
    },
    {
        "content": "<p>thaystg <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1745408199\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Hi, @alexcrichton , currently we use the sock_accept importing the function like this in our C code:</p>\n<p><code>__attribute__((import_module(\"wasi_snapshot_preview1\")))\n__attribute__((import_name(\"sock_accept\")))\nint sock_accept(int fd, int fdflags, int* result_ptr);</code></p>\n<p>How should I use components to replace it? Is there any documentation that I can follow?</p>\n</blockquote>",
        "id": 394678115,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696353654
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1745798478\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>@thaystg I think that, unfortunately, the answer won't be so simple. If using the component model and/or preview 2 you wouldn't have access to that API exactly but you would have access to other <code>wasi:sockets</code> APIs. (which also support the functionality of <code>sock_accept</code> for example). To use that exact import, however, it won't work with preview2.</p>\n<p>If you're interested though it's theoretically possible to get it working. Wasmtime has an <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasi-preview1-component-adapter\">in-guest adapter</a> which translates preview1 to preview2, and this is how binaries don't have to explicitly update to preview2 yet to make use of it. The way this works is that the adapter exports functions like <code>fd_read</code> which implement preview1 in terms of preview2. This has <a href=\"https://github.com/bytecodealliance/wasmtime/blob/a6d05429f681409a8f97b864d0124261869e0748/crates/wasi-preview1-component-adapter/src/lib.rs#L1968-L1973\">not yet been done</a> for <code>sock_accept</code> and other socket-related functions. The reason for this is primarily time and/or motivation, not technical. So if you're feeling intrepid I think it would be reasonable to fill out the implementation there.</p>\n<p>To set expectations, though, I don't expect that filling out the adapter for socket-related functionality is going to be an easy task. It's god a nontrivial design component to it along with implementation concerns too. That's all surmountable in the technical sense which is why I'm mentioning this. I'm not aware of anyone else who's lined up to implement this, however, and so far I don't believe this is considered a blocker or todo item for the preview2 timeline, only a nice-to-have if someone is interested in implementing it.</p>\n</blockquote>",
        "id": 394717230,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696370665
    },
    {
        "content": "<p>squillace <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1753248462\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Hey @alexcrichton thanks; so to sum up: Re: <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1741543473\">https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1741543473</a> we should jump on the components train but in the components train we have to implement something that wasmtime experts should probably design. Do I have this correct? </p>\n<p>If so, I'd be a bit more interested hearing about <code> This may be possible to get working somewhat</code> for preview 1. Of course, it's always a question of time and resources. .NET needs the socket work to do the debugging jump into wasmtime from another location; others do, too. We can try to find resources to apply here, but I'm not clear we'd apply the same resources to each path. </p>\n<p>Your take?</p>\n</blockquote>",
        "id": 395725788,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696866101
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1753391836\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Almost yeah, although the component part doesn't require any work on Wasmtime's side, but it may require more work on y'all's side if you're not already using components.</p>\n<p>I can try to summarize as well a bit if that helps. There's more-or-less three different ways to go about solving this:</p>\n<h4>Fix this single issue in isolation</h4>\n<p>There's quite a bit of discussion on this thread, and for example I haven't reviewed the <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3995\">above possible fix mentioned</a>. Fixing this issue in isolation will require confirming that it actually works with wasi-libc which seems like a hazard given the above discussion. I haven't dug into this myself because sockets in preview1 are not something we'd like to breathe more life into at this time. Instead we're looking ideally to encourage users to use the preview2 implementation where possible. That being said from a perspective of \"I just want something working\" this is probably the easiest route since it has nothing to do with components and it's probably just taking existing stuff and wiring it together a bit differently.</p>\n<h4>Implement <code>sock_accept</code> in the preview1 adapter.</h4>\n<p>This effectively boils down to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1745798478\">my above thoughts</a> in filling out <a href=\"https://github.com/bytecodealliance/wasmtime/blob/a6d05429f681409a8f97b864d0124261869e0748/crates/wasi-preview1-component-adapter/src/lib.rs#L1968-L1973\">this function</a>. This requires writing code in the adapter which is not a trivial task. This additionally is something I'd ideally prefer to avoid if we can to again avoid breathing more life into preview1 sockets. Additionally a major snag here is that preview1 has no way to open a socket, meaning that any sockets in use today must have been supplied as a preopen. WASI preview2 has no mechanism, at this time at least, for preopened sockets. It has preopened directories but not preopened sockets. This means that even if the preview1 adapter were filled out it likely wouldn't work for your use case as-is because you'd still have no means of configuring a preopened socket on the host.</p>\n<h4>Use components</h4>\n<p>Using components in their entirety involves directly using the <code>wasi:sockets</code> APIs which gives you access to opening sockets, accepting sockets, etc. This all works as-is today and requires no changes to Wasmtime. Depending on how you're running components though this may require changes on your end which may be expansive.</p>\n<hr>\n<p>If you'd like I can also talk through some of these routes in more detail over video. Otherwise also happy to follow-up here too.</p>\n</blockquote>",
        "id": 395740539,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696872407
    },
    {
        "content": "<p>squillace <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-1754905481\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Thanks, @alexcrichton, I appreciate this. We are intending to target components directly, so skating to where the puck WILL be is better, I think, though it will require us to do more work in the shorter term that we eventually intended to do. @SteveSandersonMS and @thaystg let's understand how to tackle this and come back to the conversation.</p>\n</blockquote>",
        "id": 395851341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696933285
    },
    {
        "content": "<p>Archie3d <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936#issuecomment-2172709848\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3936\">issue #3936</a>:</p>\n<blockquote>\n<p>Is there a workaround to use <code>mapdir</code> and <code>tcplisten</code> simultaneously? <code>wasmtime</code> seems to not recognize <code>--mapdir</code> argument when any other argument is used.</p>\n</blockquote>",
        "id": 445083184,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718613893
    }
]