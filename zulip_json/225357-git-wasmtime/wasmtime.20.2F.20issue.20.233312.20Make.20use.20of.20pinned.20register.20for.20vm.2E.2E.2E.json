[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3312\">issue #3312</a>:</p>\n<blockquote>\n<p>We currently have special support for exactly one \"pinned register\" in CLIF, and this is used by the SpiderMonkey bindings to Cranelift in order to ensure that the VM context pointer always remains accessible in a register. cHowever, the Wasmtime code translation does not make use of the pinned register, or provide register-allocator hints in general, to allow the backend to handle the VM-context pointer or heap base pointer in any specially-optimized way.</p>\n<p>I was reminded in a recent conversation of this, and it is still an open opportunity. We could either use the pinned register as-is (with <code>get_pinned_reg</code> and <code>set_pinned_reg</code> instructions) or, perhaps once we've moved over to regalloc2, develop a more general sort of metadata/hint that indicates that certain values are long-lived. (Something like the <code>register</code> keyword that used to mean something to C compilers.) Perhaps the regalloc heuristics are good enough to work this out in many cases, but perhaps they aren't, and we can save some work; we should study the issue to be sure.</p>\n<p>This might make a good starter issue for someone looking to get into the codegen/backends, and can range from relatively simple (use existing pinned-reg infra) to more general; I'm happy to help describe more detail if so!</p>\n</blockquote>",
        "id": 252380750,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631053941
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3312\">issue #3312</a>:</p>\n<blockquote>\n<p>We currently have special support for exactly one \"pinned register\" in CLIF, and this is used by the SpiderMonkey bindings to Cranelift in order to ensure that the VM context pointer always remains accessible in a register. cHowever, the Wasmtime code translation does not make use of the pinned register, or provide register-allocator hints in general, to allow the backend to handle the VM-context pointer or heap base pointer in any specially-optimized way.</p>\n<p>I was reminded in a recent conversation of this, and it is still an open opportunity. We could either use the pinned register as-is (with <code>get_pinned_reg</code> and <code>set_pinned_reg</code> instructions) or, perhaps once we've moved over to regalloc2, develop a more general sort of metadata/hint that indicates that certain values are long-lived. (Something like the <code>register</code> keyword that used to mean something to C compilers.) Perhaps the regalloc heuristics are good enough to work this out in many cases, but perhaps they aren't, and we can save some work; we should study the issue to be sure.</p>\n<p>This might make a good starter issue for someone looking to get into the codegen/backends, and can range from relatively simple (use existing pinned-reg infra) to more general; I'm happy to help describe more detail if so!</p>\n</blockquote>",
        "id": 252380751,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631053941
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3312\">issue #3312</a>:</p>\n<blockquote>\n<p>We currently have special support for exactly one \"pinned register\" in CLIF, and this is used by the SpiderMonkey bindings to Cranelift in order to ensure that the VM context pointer always remains accessible in a register. However, the Wasmtime code translation does not make use of the pinned register, or provide register-allocator hints in general, to allow the backend to handle the VM-context pointer or heap base pointer in any specially-optimized way.</p>\n<p>I was reminded in a recent conversation of this, and it is still an open opportunity. We could either use the pinned register as-is (with <code>get_pinned_reg</code> and <code>set_pinned_reg</code> instructions) or, perhaps once we've moved over to regalloc2, develop a more general sort of metadata/hint that indicates that certain values are long-lived. (Something like the <code>register</code> keyword that used to mean something to C compilers.) Perhaps the regalloc heuristics are good enough to work this out in many cases, but perhaps they aren't, and we can save some work; we should study the issue to be sure.</p>\n<p>This might make a good starter issue for someone looking to get into the codegen/backends, and can range from relatively simple (use existing pinned-reg infra) to more general; I'm happy to help describe more detail if so!</p>\n</blockquote>",
        "id": 252380769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631053958
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3312#issuecomment-914994150\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3312\">issue #3312</a>:</p>\n<blockquote>\n<p>Thanks for opening an issue! I think that's a very low hanging fruit, as using the pinned register for e.g. the heap base would have a tremendous impact in terms of reducing the amount of CLIF nodes, thus the number of VCode insts, thus speeding up regalloc.</p>\n</blockquote>",
        "id": 252418536,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631086478
    }
]