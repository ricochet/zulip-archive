[
    {
        "content": "<p>SoniEx2 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>\n<h4>Feature</h4>\n<p>TODO: Brief description of the feature/improvement you'd like to see in<br>\nCranelift/Wasmtime.</p>\n<p>We want to see wasmtime use/support the leonbe addressing convention as implemented in wasm2c instead of the current lemulation addressing convention.</p>\n<h4>Benefit</h4>\n<p>TODO: What is the value of adding this in Cranelift/Wasmtime? What problems does<br>\nit solve?</p>\n<p>Consistency with another wasm implementation. Presumably easier for the JIT to optimize. Allegedly improved performance on older BE platforms without fused byteswap opcodes. (This could all be benchmarked.)</p>\n<h4>Implementation</h4>\n<p>TODO: Do you have an implementation plan, and/or ideas for data structures or<br>\nalgorithms to use?</p>\n<p>It shouldn't be too hard, mostly changing memory instructions and some other stuff.</p>\n<h4>Alternatives</h4>\n<p>TODO: What are the alternative implementation approaches or alternative ways to<br>\nsolve the problem that this feature would solve? How do these alternatives<br>\ncompare to this proposal?</p>\n<p>The main alternative is to get rid of wasm2c's leonbe and make it use lemulation, or maybe even go the extra length and make it portable to mixed-endian architectures. Unfortunately the compiler isn't allowed to entirely eliminate byteswaps with that approach.</p>\n</blockquote>",
        "id": 382661621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691420227
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1668411208\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>What does wasm2c's implementation have to do with wasmtime's? They are entirely independent wasm runtimes which can't be used together on a single wasm module.</p>\n<p>Also what is the difference between leonbe and lemulation? I can't find anything about it on the internet.</p>\n</blockquote>",
        "id": 382731338,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691434034
    },
    {
        "content": "<p>SoniEx2 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1668454793\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>lemulation (emulated LE reads on a BE host - memory values (byte reads) are LE, memory ordering (relative to <code>position</code>) is LE):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_u32</span><span class=\"p\">(</span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">position</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"c1\">// generally optimized out on little-endian to a single 32-bit unaligned read</span>\n<span class=\"w\">  </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b0</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>leonbe (observationally little-endian memory on a BE host - memory values (byte reads) are BE, memory ordering (relative to <code>position</code>) is LE):</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_u32</span><span class=\"p\">(</span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">position</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"c1\">// generally optimized out on big-endian to a single 32-bit unaligned read</span>\n<span class=\"w\">  </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b0</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 382739776,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691436304
    },
    {
        "content": "<p>SoniEx2 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1668454793\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>lemulation (emulated LE reads on a BE host - memory values (byte reads) are LE, memory ordering (relative to <code>position</code>) is LE):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_u32</span><span class=\"p\">(</span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">position</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"c1\">// generally optimized out on little-endian to a single 32-bit unaligned read</span>\n<span class=\"w\">  </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b0</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>leonbe (observationally little-endian memory on a BE host - memory values (byte reads) are BE, memory ordering (relative to <code>position</code>) is LE):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_u32</span><span class=\"p\">(</span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">position</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">position</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"c1\">// generally optimized out on big-endian to a single 32-bit unaligned read</span>\n<span class=\"w\">  </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u32</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">b0</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><del>the pain point is that wasm2c/wabt cannot implement the wasm-c-api with leonbe since wasm-c-api doesn't expect to be used this way. having more leonbe wasm engines would make standardizing a leonbe wasm-c-api easier.</del></p>\n</blockquote>",
        "id": 382740283,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691436450
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1669996359\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<blockquote>\n<p>leonbe (observationally little-endian memory on a BE host - memory values (byte reads) are BE, memory ordering (relative to position) is LE):</p>\n</blockquote>\n<p>That is a clever technique! I think for dynamic memories (which don't reserve a 4GB chunk all at once even if the actual size of the memory is still smaller) this will require copying the memory when trying to grow it much more often as you did have to grow it towards lower addresses rather than higher addresses. The fact that you have a subtraction on the critical path of computing the address may also be bad for performance, but I don't know how much effect it will have exactly.</p>\n</blockquote>",
        "id": 383025830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691514443
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>\n<h4>Feature</h4>\n<p>We want to see wasmtime use/support the leonbe addressing convention as implemented in wasm2c instead of the current lemulation addressing convention.</p>\n<h4>Benefit</h4>\n<p>Consistency with another wasm implementation. Presumably easier for the JIT to optimize. Allegedly improved performance on older BE platforms without fused byteswap opcodes. (This could all be benchmarked.)</p>\n<h4>Implementation</h4>\n<p>It shouldn't be too hard, mostly changing memory instructions and some other stuff.</p>\n<h4>Alternatives</h4>\n<p>The main alternative is to get rid of wasm2c's leonbe and make it use lemulation, or maybe even go the extra length and make it portable to mixed-endian architectures. Unfortunately the compiler isn't allowed to entirely eliminate byteswaps with that approach.</p>\n</blockquote>",
        "id": 383030685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691515661
    },
    {
        "content": "<p>SoniEx2 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1670048877\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>it's true that allocators are generally designed to enable right growth but not so much left growth, but then there are many which aren't - as an example of a real system that does this, the JVM doesn't bother, so a JVM program (like a JVM wasm runtime) has to do full copies every time - so we don't expect it to be much of an issue in practice, especially if you can move whole pages at a time (page-oriented allocators?).</p>\n<p>but the extra subtractions can be generally optimized out. (manually if the compiler can't do it for you.)</p>\n</blockquote>",
        "id": 383035787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691516952
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813#issuecomment-1670113311\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6813\">issue #6813</a>:</p>\n<blockquote>\n<p>A JVM wasm runtime has to always copy, but Wasmtime could avoid the copy. I just looked at the impl and it seems like it too always copies too though.</p>\n</blockquote>",
        "id": 383046822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691519904
    }
]