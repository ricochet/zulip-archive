[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>\n<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>\n<p>This is sort of a breadth-vs-depth situation: the \"depth\" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the \"breadth\" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>\n<p>cc @abrown @alexcrichton </p>\n</blockquote>",
        "id": 250814484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630001025
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>\n<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>\n<p>This is sort of a breadth-vs-depth situation: the \"depth\" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the \"breadth\" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>\n<p>cc @abrown @alexcrichton </p>\n</blockquote>",
        "id": 251928659,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630696258
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>\n<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>\n<p>This is sort of a breadth-vs-depth situation: the \"depth\" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the \"breadth\" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>\n<p>cc @abrown @alexcrichton </p>\n</blockquote>",
        "id": 262089162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637338872
    },
    {
        "content": "<p>alexcrichton unlabeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>\n<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>\n<p>This is sort of a breadth-vs-depth situation: the \"depth\" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the \"breadth\" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>\n<p>cc @abrown @alexcrichton </p>\n</blockquote>",
        "id": 262089163,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637338872
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974215576\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 262089515,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637339018
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974290644\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>My intuition is that combining multiple instructions, even if it is just two or three, would give us much more bang for our buck than testing single instructions.</p>\n</blockquote>",
        "id": 262104830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637345045
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-974314714\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>Ah, old issue, paging back in context (I'm not sure why the labeler decided to tag you just now on a discussion from August!)...</p>\n<p>Yup, agreed, that's the \"or a straight-line sequence with no control flow or calls\" above :-)</p>\n<p>Adding some more thought just now: IMHO we should do it only up to the max depth of our instruction combining patterns. The point of this suggestion was specifically to target the fuzz throughput in a different way, at the input-value space rather than the input-program space. As we test straightline sequences of <code>n</code> instructions we have <code>O(|wasm opcodes|^n)</code> possibilities, and cut our time spent (on exploring argument values) per individual test program exponentially.</p>\n<p>In other words, if my goal is to say that <em>all</em> cases for (say) SIMD instruction X have been covered, then separately fuzzing <code>vector_add(X(x, y, z), [1.0, 1.0, 1.0, 1.0])</code> and <code>vector_add(X(x, y, z), [2.0, 2.0, 2.0, 2.0])</code> doesn't really add any coverage. Testing <code>vector_add(X, ...)</code> and <code>vector_mul(X, ...)</code> might, if we have combining patterns that differ for those. But combining instructions may also <em>mask</em> some of the value space, for any operation that isn't bijective (e.g. extract one lane, or multiply by zero, or min/max).</p>\n<p>So, said another way, what I think would be useful is a unit-test-inspired approach where we take each individual lowering and then throw a long test-vector of argument values at it. (In other words the <code>Arbitrary</code> type is a <code>(short inst sequence, Vec&lt;ArgValues&gt;)</code>.) That gets us \"each individual lowering is good\" coverage in a way that might hide when we're testing <code>n</code> (for <code>n</code> larger) instructions at a time.</p>\n<p>cc @abrown , any interest in looking at this as a way to get the spec interpreter in active fuzzing use?<br>\n</p>\n</blockquote>",
        "id": 262109674,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637347174
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-977292607\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>I would eventually like to look into this more but if anyone else has the bandwidth feel free to jump in first (read: I'm not sure when I will get to this).</p>\n</blockquote>",
        "id": 262530465,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1637711388
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-1006171689\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>@cfallin, in a separate project I did something using <code>proptest</code> that reminded me of this. The basic idea, adapted to Wasmtime, would be to:</p>\n<ul>\n<li>construct a single-instruction WebAssembly module</li>\n<li>create random inputs using <code>proptest</code></li>\n<li>run the module's sole function in two different engines and check the results for equality</li>\n</ul>\n<p>I wasn't too concerned with multiple-instruction sequences and other things mentioned above but if we have a place to put this <code>proptest</code>-guided fuzz test then I would be happy to contribute the code.</p>\n</blockquote>",
        "id": 267009323,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641427092
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251#issuecomment-1224828398\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>I think this is closed by #4409 which is now in use by the new <code>differential</code> fuzz target (#4515).</p>\n</blockquote>",
        "id": 294941560,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661286502
    },
    {
        "content": "<p>abrown closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3251\">issue #3251</a>:</p>\n<blockquote>\n<p>In #3186 we found that the WebAssembly spec interpreter may not be suitable for high-throughput fuzzing because of certain performance characteristics. While we were able to locally patch one source of quadratic runtime, there are likely others, and the patch was not really a good fit to upstream. We are looking into other peer implementations to fuzz against for general programs (aside from existing <code>differential_wasmi</code> fuzzing).</p>\n<p>However, there is another way we could use the reference interpreter: we could validate single instructions' semantics more closely by generating short test cases that just execute an instruction (or a straight-line sequence with no control flow or calls) and return. This would be very valuable for instructions with more complex semantics, such as many of the SIMD instructions.</p>\n<p>This is sort of a breadth-vs-depth situation: the \"depth\" comes from longer-running programs and tests interactions between instructions, and a good oracle there is a more optimized implementation; while the \"breadth\" comes from exhaustive many-inputs testing of very short sequences and tests mainly that we got the instruction semantics right. The combination seems like it should give pretty good coverage.</p>\n<p>cc @abrown @alexcrichton </p>\n</blockquote>",
        "id": 294941561,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661286502
    }
]