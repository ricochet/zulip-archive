[
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the cranelift label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">Issue #9015</a>.</p>",
        "id": 454080529,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721953449
    },
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>Today Cranelift does not have a type for pointers. Instead it has <code>i32</code> and <code>i64</code> and you're supposed to use the right one for 32 and 64-bit platforms. This is a simplification over LLVM, for example, which has a <code>ptr</code> type which is required for loads/stores. The downside to this, however, is that Cranelift and its backends do not know what's a pointer and what's not.</p>\n<p>Why would Cranelift want a pointer type when it's done well enough without it? The Pulley interpreter recently added is going to add a new backend to Cranelift which emits pulley bytecode. This bytecode, when run, will violate Rust's pointer provenance rules.</p>\n<p>Rust pointer provenance basically says that you can't convert an integer into a pointer. Pulley bytecode, however, will perform an operation that looks like:</p>\n<ul>\n<li>Load a 64-bit integer from <code>VMContext</code> for the base pointer of memory</li>\n<li>Add a wasm offset to this 64-bit integer</li>\n<li>Load from this 64-bit integer something else</li>\n</ul>\n<p>The final load here is a load from a pointer which is created through an int-to-pointer conversion. Provenance in Rust does not allow that. No matter how we slice this we cannot get around it because the source of the problem is the original load. The original load of the pointer was a load of an integer, not a pointer, which means that in Rust-land the \"provenance\" of this pointer is never established. To correctly work with Rust's provenance the original load of a pointer has to map, in Rust, to a load of a pointer.</p>\n<p>Another problem for Pully is pointer arithmetic. Cranelift models pointer arithmetic as integer operations with an <code>i64</code> type for a 64-bit platform. This means that Pulley will calculate some addresses (like above) by adding two numbers together. To correctly respect provenance in Rust it must be known which of these integers is a pointer. Pulley and the Cranelift backend, however, have no knowledge of which is a pointer (and it's not valid to add two pointers together). </p>\n<p>All-in-all, if Pulley wants to respect Rust's \"strict provenance\", then the current design of Cranelift is not suitable. Cranelift will be required to have a pointer type of some kind which makes its way through to the backend so the bytecode iteslf can look different if a pointer is being loaded or a 64-bit integer is being loaded. </p>\n<h2>What would a pointer type in Cranelift look like?</h2>\n<p>A straw-proposal would be to add <code>p32</code> and <code>p64</code> types. Validation requires that the current target only uses either <code>p32</code> or <code>p64</code> depending on the bit-width of the target. This would retain the ability to easily calculate the size of a type (without the context of a <code>TargetIsa</code>).</p>\n<p>Existing instructions like <code>load</code> and <code>store</code> would change to taking a <code>pNN</code> address instead of an integral address. Existing polymorphic instructions like <code>load</code> and <code>store</code> would change to support loading/storing pointers as well.</p>\n<p>At least one new instruction would be required for pointer arithmetic, something like <code>padd</code> (or maybe <code>ptradd</code>) to byte offset forwards-and-back from a pointer. </p>\n<p>The <code>bitcast</code> instruction would need to be updated as well to support pointer-to-integer casts.</p>\n<p>The Pulley backend would not support a bitcast from an integer-to-a-pointer at all, but other backends could support this to assist transitioning backends such as the Rustc Cranelift backend.</p>\n<h2>Is this necessary?</h2>\n<p>I'm honestly not sure if this is necessary to do. It is a fact that WebAssembly modules cannot be run in MIRI through Pulley with <code>-Zmiri-strict-provenance</code>. They will run however with <code>-Zmiri-permissive-provenance</code>. What I do not fully understand is, looking into the future, whether requiring permissive provenance is going to be UB or not. Or in other words will int-to-pointer casts become UB in Rust in the future (or LLVM?)</p>\n<p>If permissive provenance is always allowed in Rust, even into the future, then it may not be worth this undertaking. It's likely going to be quite nontrivial to add a pointer type to Cranelift. If, however, permissive provenance will become UB in Rust in the future it's probably best to start thinking about this now about how it might be added to Cranelift.</p>\n</blockquote>",
        "id": 454080558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721953450
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2251650517\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>For those who aren't the most familiar with provenance, which is me included, I can also elaborate how I think about it. I believe that on CHERI pointers are 128-bits large with a 64-bit address and a 64-bit \"thing\". I don't know what this \"thing\" is but I think of it as the provenance of the pointer. This crystallizes to me how the basic operation of \"cast an integer to a pointer\" cannot work with strict provenance because there is no way to materialize the \"thing\". Additionally loads/stores from memory must understand they're operating on a pointer because the \"thing\" must be stored into memory.</p>\n<p>On other architectures, e.g. everything supported by Cranelift, the \"thing\" is actually zero-sized and pointers a 64-bits large. Nevertheless this is part of the optimization and memory model of Rust and the \"thing\" is also something known at compile-time and optimized around.</p>\n<p>Not sure if that'll help, but it's at least how I think about provenance and helps me simplify and understand a lot of MIRI issues about the lack of provenance thereof.</p>\n</blockquote>",
        "id": 454086067,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721953628
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2251743275\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I wrote a long writeup on my thoughts on pointer provenance <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5950#issuecomment-1470977598\">here</a> last year; tl;dr is that I don't think it's a good idea to add this notion to Cranelift. The key bit is:</p>\n<blockquote>\n<p>In particular, substituting a pointer with an expression that evaluates to that pointer, but is not that pointer, violates pointer provenance but I worry it may arise as emergent behavior when optimizations compose. p0 + (p1 - p0) seems silly, but mid-end rules that rewrite integer expressions are quite reasonable, and in general we consider these correct as long as they result in code that computes the same integer. In a pointer-provenance world, we now need to have a \"may be a pointer?\" analysis, and exclude any possibly-pointer SSA values from any rewrites that may \"mix in\" another pointer. (Alternately, we could come up with a set metarules around how we write our rules, such that no legal pointer manipulation can be rewritten into an illegal one. But my brain hurts just thinking about that.)</p>\n<p>It also precludes some rewrites that the producer might do. For example, in a pointer-provenance world, pointers can't be stored to memory. Or if they are, we need an escape analysis and a \"has escaped, could alias anything\" state in addition to our \"provenance is strictly tracked\" state for each storage location. One might argue that a producer should be careful about this but consider: this means that we can no longer write general code like \"write all arguments to memory and call a trampoline\". Or even write a producer that, e.g., directly compiles stack-based bytecode to use a value stack in memory: as soon as the opcode for \"get scratch space\" compiles to a stack_addr and a store of that addr, it has lost its provenance and is just bytes in memory. Again, escape analysis could catch this, but it's just more complexity.</p>\n</blockquote>\n<p>Aside from all that, adding additional types to Cranelift imposes a large and ongoing tax as we write all of our rules: we have to consider how they apply across the cross-product of types and opcodes. Already ref-types (<code>r64</code>/<code>r32</code>) are problematic and raise questions, and @fitzgen and others are making efforts to hoist stackmaps up the pipeline so we don't need Cranelift to know about them.</p>\n<p>Where does that leave Pulley wrt pointer provenance? I agree with you that the primitive that Pulley provides -- raw read/write access to the process's memory -- is fundamentally beneath the level of Rust-with-pointer-provenance; but I think that this is as it must be, as long as the rest of the engine is built assuming it is producing JIT code. Said another way: Pulley provides the same thing that other compilation targets do for Wasmtime, namely, raw load/store instructions that can access data structures, including data structures touched by runtime code. We don't have or ensure pointer provenance carefully throughout the native JIT-code that we generate; so fundamentally it would be a large rearchitecting to ensure we carry that provenance through Wasmtime's codegen. (How even does that work for something with dynamic layout like the <code>vmctx</code> struct, where there is no corresponding static Rust type with a pointer-typed field we store to and load from?)</p>\n<p>As a last note I guess I'm curious what the practical implications here are. Pointer provenance is... part of the language semantics today? Planned to be part of them tomorrow? If the idea is that eventually there might be deeper alias analysis and optimizations based on it, I would hope we would be able to find the appropriate barrier mechanisms to prevent optimization across these primitives, because we'll need the same such barriers to prevent optimizations across calls to JIT code (that similarly may lose provenance) as well!</p>\n</blockquote>",
        "id": 454128050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721955013
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2251760498\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>And as a practical example of an optimization I have personally written that violates pointer provenance (in Wasm, where pointers are also semantically just integers and perfectly well-defined as such): in weval <a href=\"https://github.com/cfallin/weval/blob/main/src/constant_offsets.rs\">here</a>, I wrote a pass that turns a bunch of constant-offset values like <code>p</code>, <code>p+k1</code>, <code>p+k1-k2</code>, ... into uses of one canonical base plus a positive offset. This came up in e.g. uses of the shadow stack with structs and sub-structs. This freely moves \"across different objects\" in memory, but as long as pointers are just integers (and in Wasm they are, and in Cranelift they are, and on the native ISA they are, sighs of relief all around) the algebra is valid.</p>\n<p>We could totally carry the caution through all our opt passes needed for provenance, but it is a <em>big</em> lift, is all I'm trying to say!</p>\n</blockquote>",
        "id": 454138126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721955659
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2251760498\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>And as a practical example of an optimization I have personally written that violates pointer provenance (in Wasm, where pointers are also semantically just integers and perfectly well-defined as such): in weval <a href=\"https://github.com/cfallin/weval/blob/main/src/constant_offsets.rs\">here</a>, I wrote a pass that turns a bunch of constant-offset values like <code>p</code>, <code>p+k1</code>, <code>p+k1-k2</code>, ... into uses of one canonical base plus a positive offset. This came up in e.g. uses of the shadow stack with structs and sub-structs, as well as uses of statically-known offsets on an operand stack. This freely moves \"across different objects\" in memory, but as long as pointers are just integers (and in Wasm they are, and in Cranelift they are, and on the native ISA they are, sighs of relief all around) the algebra is valid.</p>\n<p>We could totally carry the caution through all our opt passes needed for provenance, but it is a <em>big</em> lift, is all I'm trying to say!</p>\n</blockquote>",
        "id": 454138177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721955693
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2252349214\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I don't see how pointer types are necessary for Pulley if it is only used by Wasmtime. It can do an int2ptr cast before every memory operation and a ptr2int cast every time a pointer is put into a Pulley register. Each ptr2int cast will expose the provenance of the pointer and each int2ptr cast will pick the right exposed provenance to use. Only when you have to handle memory that itself can contain pointers with provenance (which wasm doesn't have) does this not work as loading a pointer directly as integer will never expose the provenance.</p>\n<p>For CHERI and for better optimizations for cg_clif a pointer type would be very useful though.</p>\n</blockquote>",
        "id": 454255841,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1721986426
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253193370\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I fear I may have led to some misunderstandings here. My worry is that if Rust does not allow permissive provenance, aka an int-to-ptr operation, then Pulley is impossible to work with its design today. My impressions is that strict provenance means that an int-to-ptr operation is never executed. If this is the future world of Rust then we must either (a) remove/redesign pulley or (b) add a pointer type to Cranelift. </p>\n<p>To be clear I'm not saying we should add a pointer type to Cranelift because I think it's a good idea. I'm postulating here that we will be required to do so to work with strict provenance in Rust. I see no other possible solution to the problem in a world where int-to-pointer is a non-existent operation.</p>\n<blockquote>\n<p>For example, in a pointer-provenance world, pointers can't be stored to memory.</p>\n</blockquote>\n<p>This is an example of something I don't understand. No model would work at all if you couldn't store a pointer into memory, and I'm quite certain Rust's model for provenance supports this. MIRI seems to be quite rigorous about tracking this and understands that if you store a 64-bit integer to memory and load it as a pointer then it has no provenance.</p>\n<p>This is what makes me think that there may be some misunderstanding about provenance? I think I'll put something on the next Cranelift agenda to talk more in depth about this as well. I'll continue to emphasize though that I do not know the future direction of Rust, and this entire proposal hinges on \"Rust requires strict provenance\". So if Rust doesn't require strict provenance then we're good here and Cranelift need not do anything.</p>\n<blockquote>\n<p>adding additional types to Cranelift imposes a large and ongoing tax as we write all of our rules</p>\n</blockquote>\n<p>I very much agree with this and is why I'm not saying we should do this today. I highlight this again here to emphasize that my current understanding of provenance is that we will simply not have a choice if Rust doesn't allow permissive provenance.</p>\n<blockquote>\n<p>It can do an int2ptr cast before every memory operation and a ptr2int cast every time a pointer is put into a Pulley register</p>\n</blockquote>\n<p>My current understanding is that emitting an <code>int2ptr</code> operation is a violation of strict provenance. I do not claim to be a provenance expert though so I could also be wrong in my interpretation. If this is the case though I don't think that this alternative would work?</p>\n</blockquote>",
        "id": 454344156,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722015296
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253220216\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is an example of something I don't understand. No model would work at all if you couldn't store a pointer into memory, and I'm quite certain Rust's model for provenance supports this. MIRI seems to be quite rigorous about tracking this and understands that if you store a 64-bit integer to memory and load it as a pointer then it has no provenance.</p>\n</blockquote>\n<p>Note that the quote I gave was in the context of pointer provenance in <em>Cranelift</em>. One key distinction between Cranelift and Rust is that Cranelift does not have struct types: it cannot know that <code>p</code> points to a thing that, at offset 8, stores a <code>*mut T</code>. Rust on the other hand does have this strong typing, so provenance can be checked at store time (is this a valid <code>*mut T</code> with appropriate provenance?) and assumed at load time. But from the point of view of Cranelift, memory is \"the Great Mixer\" -- bytes go in, bytes come out -- and we'd need not only pointer types but struct types to maintain appropriate provenance. Note I'm not arguing this from a \"Rust does this\" basis but from a \"this is necessary from first principles to know that the pointer came from the right place\" basis -- otherwise, resynthesizing a pointer from 4 or 8 bytes in memory at some offset is no better than casting from an integer.</p>\n<p>That led to my question around <code>vmctx</code> in particular: how do we keep miri happy with the dynamically-located fields in vmctx? Is there some sort of unsafe assert or assumption that, when we take offset K into pointer P (with some arbitrary dynamically-computed layout), and load it, we're promising the loaded bits have valid provenance? If so, there's our escape hatch. If not, it's the same problem as here.</p>\n<hr>\n<p>My question around \"how does JIT code fit into this\" remains too, or I guess around FFI boundaries in general. If Rust can call code that doesn't have the same provenance guarantees, how does it make that safe? We can use whatever solution we have for that to do Pulley's loads/stores as well. In the worst case -- this would be silly, but as an example -- we could call out to helpers written in C that do the arbitrary loads/stores; from Rust's PoV that's no different than a call to JIT code, and will have the same potential side-effects.</p>\n<p>Given that I don't think I'm seeing the link as so strong necessarily -- Rust chooses this path, we <em>must</em> change Cranelift. Definitely interested in talking more.</p>\n</blockquote>",
        "id": 454346906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722016347
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253246438\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I think it is unlikely that rust will enforce strict provenance on any platform (except maybe CHERI, which is non-conformant in other ways anyway). The exact way exposed provenance works is not yet specified and it is harder to analyze for miri, so using strict provenance in your code is a way to have something that is guaranteed to work no matter what the rules for exposed provenance will turn out to be, but exposed provenance is not something that will be removed.</p>\n<blockquote>\n<p>That led to my question around vmctx in particular: how do we keep miri happy with the dynamically-located fields in vmctx? Is there some sort of unsafe assert or assumption that, when we take offset K into pointer P (with some arbitrary dynamically-computed layout), and load it, we're promising the loaded bits have valid provenance? If so, there's our escape hatch. If not, it's the same problem as here.</p>\n</blockquote>\n<p>You can ptr2int them before storing them in the vmctx so that when you load it as integer later you can int2ptr it as the provenance was exposed by the earlier ptr2int.</p>\n<p>That is not to say I oppose the introduction of a pointer type in Cranelift. In fact I would like to have it for the purpose of better optimizations. I just don't think Pulley strictly needs it within the constrained context of Wasmtime. If Pulley were to be used with cg_clif (or some other compiler interfacing with native code that would actually benefit from Pulley), it would need pointers as cg_clif can't guarantee that every pointer that is used had a ptr2int operation applied to it before Pulley could do the int2ptr.</p>\n</blockquote>",
        "id": 454349900,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722017501
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253267107\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<blockquote>\n<p>You can ptr2int them before storing them in the vmctx so that when you load it as integer later you can int2ptr it as the provenance was exposed by the earlier ptr2int.</p>\n</blockquote>\n<p>That seems to be a reasonable answer to me then: Wasmtime itself cannot work under strict provenance without <code>ptr2int</code> and <code>int2ptr</code> because it uses structs with dynamically-computed layouts, without a corresponding static Rust type. So as long as we do that, we are already requiring the primitives that Pulley also needs to work. Does that square with your understanding @alexcrichton or am I missing a subtlety here (probably likely)?</p>\n</blockquote>",
        "id": 454351868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722018471
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253285603\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I asked on <a href=\"https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Future.20direction.20of.20pointer.20provenance.20in.20Rust/near/454344889\">Zulip</a> as well and got a similar confirmation that Rust is unlikely to ever require strict provenance, which from my perspective makes this whole issue moot since that just means that pulley will require permissive provenance which Rust will allow.</p>\n<p>I don't know how Rust's model handles FFI which Cranelift-generated code effectively is, so I can't speak much to that. What I can say though is that Wasmtime and its tests that don't use Cranelift all pass under strict provenance today. I believe the requirement is that if you load a pointer from memory you were required to store a pointer there previously. Storing a 64-bit integer isn't sufficient, it had to have been a pointer store operation. In that sense I don't believe there's any issues with the vmctx because we always view fields in memory with the same type and load/store with the same type.</p>\n<p>The strict provenance operation I'm worried about is that the Pulley backend of Cranelift will emit \"load 64-bit integer, add offset, load another integer from this pointer\". That's materializing a pointer out of thin air from an integer which works at the machine level of course but does not work with strict provenance. What I believe this means is that when we load/store from memory in the Pulley interpreter we'll have to use <a href=\"https://doc.rust-lang.org/std/ptr/fn.with_exposed_provenance.html\"><code>ptr::with_exposed_provenance</code></a> at the very least. Where exactly we would call <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.expose_provenance\"><code>ptr::expose_provenance</code></a> I'm not entirely sure, though.</p>\n</blockquote>",
        "id": 454353557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722019347
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253292629\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<blockquote>\n<p>I believe the requirement is that if you load a pointer from memory you were required to store a pointer there previously. </p>\n</blockquote>\n<p>If you want to be able to dereference a pointer, it has to have valid provenance for the address of the pointer. Integers do not have provenance.  If you load an integer value from a place where a pointer was stored or you load a pointer from a place where an integer was stored, you will get a value without provenance (that is in the integer load case just a plain address, and in the pointer load case a pointer which can't be dereferenced). If you want to load the value at the address pointed to by an integer, you have to use <code>from_exposed_provenance</code> (int2ptr), which will try to pick a random provenance which has been previously exposed, but will try to pick the provenance which avoids UB if doing so is possible. This requires the provenance to have been previously exposed using <code>expose_provenance</code> (ptr2int).</p>\n</blockquote>",
        "id": 454354109,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722019675
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>Today Cranelift does not have a type for pointers. Instead it has <code>i32</code> and <code>i64</code> and you're supposed to use the right one for 32 and 64-bit platforms. This is a simplification over LLVM, for example, which has a <code>ptr</code> type which is required for loads/stores. The downside to this, however, is that Cranelift and its backends do not know what's a pointer and what's not.</p>\n<p>Why would Cranelift want a pointer type when it's done well enough without it? The Pulley interpreter recently added is going to add a new backend to Cranelift which emits pulley bytecode. This bytecode, when run, will violate Rust's pointer provenance rules.</p>\n<p>Rust pointer provenance basically says that you can't convert an integer into a pointer. Pulley bytecode, however, will perform an operation that looks like:</p>\n<ul>\n<li>Load a 64-bit integer from <code>VMContext</code> for the base pointer of memory</li>\n<li>Add a wasm offset to this 64-bit integer</li>\n<li>Load from this 64-bit integer something else</li>\n</ul>\n<p>The final load here is a load from a pointer which is created through an int-to-pointer conversion. Provenance in Rust does not allow that. No matter how we slice this we cannot get around it because the source of the problem is the original load. The original load of the pointer was a load of an integer, not a pointer, which means that in Rust-land the \"provenance\" of this pointer is never established. To correctly work with Rust's provenance the original load of a pointer has to map, in Rust, to a load of a pointer.</p>\n<p>Another problem for Pully is pointer arithmetic. Cranelift models pointer arithmetic as integer operations with an <code>i64</code> type for a 64-bit platform. This means that Pulley will calculate some addresses (like above) by adding two numbers together. To correctly respect provenance in Rust it must be known which of these integers is a pointer. Pulley and the Cranelift backend, however, have no knowledge of which is a pointer (and it's not valid to add two pointers together). </p>\n<p>All-in-all, if Pulley wants to respect Rust's \"strict provenance\", then the current design of Cranelift is not suitable. Cranelift will be required to have a pointer type of some kind which makes its way through to the backend so the bytecode iteslf can look different if a pointer is being loaded or a 64-bit integer is being loaded. </p>\n<h2>What would a pointer type in Cranelift look like?</h2>\n<p>A straw-proposal would be to add <code>p32</code> and <code>p64</code> types. Validation requires that the current target only uses either <code>p32</code> or <code>p64</code> depending on the bit-width of the target. This would retain the ability to easily calculate the size of a type (without the context of a <code>TargetIsa</code>).</p>\n<p>Existing instructions like <code>load</code> and <code>store</code> would change to taking a <code>pNN</code> address instead of an integral address. Existing polymorphic instructions like <code>load</code> and <code>store</code> would change to support loading/storing pointers as well.</p>\n<p>At least one new instruction would be required for pointer arithmetic, something like <code>padd</code> (or maybe <code>ptradd</code>) to byte offset forwards-and-back from a pointer. </p>\n<p>The <code>bitcast</code> instruction would need to be updated as well to support pointer-to-integer casts.</p>\n<p>The Pulley backend would not support a bitcast from an integer-to-a-pointer at all, but other backends could support this to assist transitioning backends such as the Rustc Cranelift backend.</p>\n<h2>Is this necessary?</h2>\n<p>I'm honestly not sure if this is necessary to do. It is a fact that WebAssembly modules cannot be run in MIRI through Pulley with <code>-Zmiri-strict-provenance</code>. They will run however with <code>-Zmiri-permissive-provenance</code>. What I do not fully understand is, looking into the future, whether requiring permissive provenance is going to be UB or not. Or in other words will int-to-pointer casts become UB in Rust in the future (or LLVM?)</p>\n<p>If permissive provenance is always allowed in Rust, even into the future, then it may not be worth this undertaking. It's likely going to be quite nontrivial to add a pointer type to Cranelift. If, however, permissive provenance will become UB in Rust in the future it's probably best to start thinking about this now about how it might be added to Cranelift.</p>\n</blockquote>",
        "id": 454356381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722020892
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253319276\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>Ok sounds good, thanks for the clarification!</p>\n<p>So given all this I'm going to close this, but I'm going to open a separate issue for Pulley and using provenance correctly.</p>\n</blockquote>",
        "id": 454356383,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722020894
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253319472\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<blockquote>\n<p>I believe the requirement is that if you load a pointer from memory you were required to store a pointer there previously. Storing a 64-bit integer isn't sufficient, it had to have been a pointer store operation. </p>\n</blockquote>\n<p>As a meta-comment, I guess I continue to be a little baffled (coming from the experience of working with alias analysis and similar things) on the distinction between the dynamic model here -- miri can presumably keep a metadata shadow on memory and track this -- and what an ahead-of-time compiler (rustc) can actually get out of this. It seems unlikely to me (?), and impossible in the general case, to statically model memory layout to <em>prove</em> that at offset K1 we stored a pointer so a load from K2 later has a provenance that ties it to that earlier pointer. Or in other words, I see how one could do this for static struct layouts but Wasmtime is truly dynamic here and K1 and K2 may or may not be equal at runtime, so there is nothing any optimization could ever do here (it could never actually connect up the provenance) -- imagine we store p1 and p2 at different vmctx slots, then load q1 and q2, does q2 get p1's or p2's provenance? If no static compiler can prove one or the other because it depends on dynamic data coming from outside the analysis scope, then nothing can be optimized using the provenance anyway.</p>\n<p>(Said another way I guess I'm making a variant of the \"but the compiler doesn't do this in practice\" fallacy-argument that removes the fallacy by saying \"from first principles, no compiler can ever do this in our situation\"; which really points to the need to maintain the escape hatch in the language semantics)</p>\n</blockquote>",
        "id": 454356401,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722020903
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253319874\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>(ah sorry, raced with issue closing)</p>\n</blockquote>",
        "id": 454356434,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722020917
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015#issuecomment-2253322198\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9015\">issue #9015</a>:</p>\n<blockquote>\n<p>I suspect that you might be able to have a good discussion in the rust-lang/rust zulip with those questions? I don't feel confident enough to answer them myself other than what you already mention at the end of I think things are being set up for the compiler to take advantage of in the future perhaps</p>\n</blockquote>",
        "id": 454356634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1722021028
    }
]