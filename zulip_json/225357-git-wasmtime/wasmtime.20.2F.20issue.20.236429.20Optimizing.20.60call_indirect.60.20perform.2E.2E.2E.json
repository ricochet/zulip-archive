[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In cranelift-wasm, feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[ ] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 360348312,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684780242
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In cranelift-wasm, feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[ ] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 360348313,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684780242
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In cranelift-wasm, feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[ ] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 360348316,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684780243
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In cranelift-wasm, feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[ ] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 360348317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684780243
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In <code>cranelift-wasm</code>, need to feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[ ] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 360348405,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684780275
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429#issuecomment-1561931061\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>I wanted to estimate the impact any of these changes might have on real-world performance. I don't have very good ways to do that but I do have a few observations from the Sightglass spidermonkey benchmark.</p>\n<p>There are 1,903 uses of <code>call_indirect</code> in this benchmark. I don't know if any of them are hot but having that many might be a good sign for the impact of these optimizations.</p>\n<p>The function table has both minimum and maximum size set to 3,312 elements.</p>\n<ul>\n<li>\n<p>Using that constant in table bounds-checks, rather than loading the current table size from memory, should be a quick win. If we can't measure any impact from that change then I would suspect that none of these calls are hot in this benchmark.</p>\n</li>\n<li>\n<p>Storing that table directly in the vmctx is feasible since its size is known exactly.</p>\n</li>\n<li>\n<p>Is lazy table initialization worth doing for ~3k table entries?</p>\n</li>\n</ul>\n<p>There are 21 distinct types used in those 1,903 calls. We discussed, but didn't seriously consider, some ways to split function tables by type signature. If we wanted to pursue something like that then it's nice to know there aren't very many distinct signatures.</p>\n<p>Some additional ideas that I don't think we discussed the other day:</p>\n<ul>\n<li>\n<p>Do type-checking in the callee rather than the caller. This avoids loading the callee's type from the table, making it an immediate operand in the code instead.</p>\n</li>\n<li>\n<p>If the table is constant, check how many functions in the table have a given type signature. If it's smaller than some threshold, emit a \"switch\"-style sequence mapping table indices having that type to direct <code>call</code> instructions. In the special case where only one function has the right type this reduces to checking that calls of that type use the right table index.</p>\n</li>\n</ul>\n</blockquote>",
        "id": 360897934,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1684962639
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In <code>cranelift-wasm</code>, need to feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[x] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[ ] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 429547614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1711423401
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In <code>cranelift-wasm</code>, need to feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[x] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[x] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[ ] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 429547620,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1711423407
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[ ] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In <code>cranelift-wasm</code>, need to feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[x] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[x] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[x] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 429547621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1711423410
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6429\">issue #6429</a>:</p>\n<blockquote>\n<p>Ideas from a brainstorming session with some Cranelift folks:</p>\n<ul>\n<li>[x] Typed funcrefs can statically remove null checks and sig checks; but how do we use?<ul>\n<li>In <code>cranelift-wasm</code>, need to feed type info from validator to say “non-null”</li>\n</ul>\n</li>\n<li>[x] Catch calls to null via signal rather than explicit check</li>\n<li>[ ] Inline <code>VMFuncRef</code>s into table, instead of having table be a vec of pointers to <code>VMFuncRef</code>s</li>\n<li>[ ] Store defined tables directly in the vmctx, rather than indirectly<ul>\n<li>Only works for max size tables</li>\n<li>Helps with allocating multiple tables inside pooling allocator</li>\n</ul>\n</li>\n<li>[x] If min and max are equal then table size is constant, don’t load table size from memory, just use the constant</li>\n<li>[x] If table index is constant and less than minimum, skip bounds check</li>\n</ul>\n<p>And, of course, it would be nice to have some (micro) benchmarks to measure all of this.</p>\n</blockquote>",
        "id": 429547623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1711423414
    }
]