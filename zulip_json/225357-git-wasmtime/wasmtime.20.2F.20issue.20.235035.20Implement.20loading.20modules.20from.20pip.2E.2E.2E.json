[
    {
        "content": "<p>cr0sh <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1272557980\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<p>Piping tests now run on unix platforms only(as the <code>-</code> substitiution applies only on unix too). Double buffering issue is resolved.<br>\nWhat do you think about implicitly allowing access to /dev/tty on <code>wasmtime -</code> as a special case?</p>\n</blockquote>",
        "id": 303141164,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665326832
    },
    {
        "content": "<p>cr0sh <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1288127610\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<p>I simplified the strategy to detect piped files(directly invokes <code>is_fifo</code> on Unix) and fixed tests incorrectly set up.</p>\n</blockquote>",
        "id": 305671392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666535820
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1291137728\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<p>Here's the strategy I'd suggest:</p>\n<p>Add a new method to <code>wasmtime::Module</code> that accepts both precompiled binaries and wasm/wat files, and uses <code>mmap</code>. I'd call it <code>from_trusted_file</code> but I'm open to suggestions. It should probably be <code>unsafe</code>, like <code>Module::deserialize_file</code>, for the same reasons.</p>\n<p>In the CLI, if <code>allow_precompiled</code> is true, then call <code>Module::from_trusted_file</code>; otherwise, call <code>Module::from_file</code> just like it does today. Don't inspect the bytes of the file at all in the CLI, but put that logic in the <code>wasmtime</code> crate instead. I think that addresses @sunfishcode's comment on keeping the CLI as a simple demonstration of how to use the <code>wasmtime</code> public API, and improves on the current state where there's this magic ELF-header check in the CLI.</p>\n<p>In your motivating use case (<code>curl | wasmtime</code>), users shouldn't be passing <code>--allow-precompiled</code>, so the CLI would call <code>Module::from_file</code>, resulting in a single <code>fs::read</code> that consumes the piped input exactly once, which solves the original bug you encountered.</p>\n<p>This new method should read the file using <code>MmapVec::from_file</code>. Only the OS knows exactly which file types it's capable of mapping into memory, so this shouldn't check whether the file is a FIFO or anything along those lines; just let the syscall fail if someone uses <code>--allow-precompiled</code> with a pipe.</p>\n<p>Once you have an <code>MmapVec</code>, you can check whether it begins with <code>b\"\\x7fELF\"</code>. If so, pass it to <code>SerializedModule::from_mmap</code>; otherwise, pass it to <code>Module::new</code>. Neither function copies the bytes it's given, addressing @bjorn3's concern.</p>\n<p>I think the only downside to this plan is that the error message from the CLI isn't as friendly if someone tries to run a precompiled artifact without passing <code>--allow-precompiled</code>. We could make <code>Module::build_artifacts</code> return a more helpful error if the bytes it receives start with an ELF header, instead of just reporting that parsing failed.</p>\n<p>One advantage to this approach is that <code>wasmtime --allow-precompiled</code> becomes potentially faster for .wat and .wasm files, because it'll use mmap for those cases too.</p>\n</blockquote>",
        "id": 306121042,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666731680
    },
    {
        "content": "<p>cr0sh <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1292178482\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<p>@jameysharp Thanks for your detailed guidance! I didn't think fixing this would not be hard this way and admittedly I couldn't do some sort of refactoring the project(and even adding a new public API for it) never saw before, tempting myself to bring somewhat hackish way. I'll try to reimplement this way.</p>\n<blockquote>\n<p>I'd call it from_trusted_file but I'm open to suggestions.</p>\n</blockquote>\n<p>This looks good.</p>\n<blockquote>\n<p>I think the only downside to this plan is that the error message from the CLI isn't as friendly if someone tries to run a precompiled artifact without passing --allow-precompiled. We could make Module::build_artifacts return a more helpful error if the bytes it receives start with an ELF header, instead of just reporting that parsing failed.</p>\n</blockquote>\n<p>I'm not sure that I can bring an excellent solution for this; just will do my best.</p>\n<p>To recap I leave a tabular summary for your suggestion:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>no <code>--allow-precompiled</code> &lt;br /&gt; (<code>Module::from_file</code>)</th>\n<th><code>--allow-precompiled</code> &lt;br /&gt; (<code>Module::from_trusted_file</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>precompiled</td>\n<td>regular: opens OK and fails on some inner procedure but should be rejected via an additional check? TODO: better error handling &lt;br /&gt; fifo: same</td>\n<td>regular: opens OK w/ mmap &lt;br /&gt; fifo: mmap fails (intentionally left broken)</td>\n</tr>\n<tr>\n<td><code>.wasm</code>/<code>.wat</code></td>\n<td>regular: opens OK &lt;br /&gt; fifo: <strong>opens OK</strong> (major change on this PR)</td>\n<td>regular: opens OK w/mmap &lt;br /&gt; fifo: same</td>\n</tr>\n</tbody>\n</table>\n</blockquote>",
        "id": 306258949,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666796097
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1292292495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<blockquote>\n<p>should be rejected via an additional check</p>\n</blockquote>\n<p>Right, the key here is that a file that begins with the 4-byte ELF magic is not valid for .wat or .wasm format and will be rejected by those parsers. None of the characters a .wat file can start with (which I think are whitespace, <code>(</code>, or <code>;</code>) include <code>\\x7f</code>. And the binary .wasm format has its own different 4-byte magic (<code>\\0asm</code>).</p>\n<p>So <code>from_file</code> already rejects precompiled modules, but it does it by reporting a generic parse failure, which is not super friendly. We can be nicer to users by specifically checking for this case. But if you have any trouble with that, I don't think that has to be in this PR.</p>\n<p>The existing check that the CLI does for the ELF magic serves two purposes: one is to provide a helpful error message, and the other is to decide whether to use <code>deserialize_file</code> or <code>from_file</code>. So one way to look at the approach I've outlined is that it does the same things, but in a different order.</p>\n<blockquote>\n<p>I couldn't do some sort of refactoring the project(and even adding a new public API for it) never saw before, tempting myself to bring somewhat hackish way.</p>\n</blockquote>\n<p>Absolutely! I had to stare at the existing code for a long time, and think about a bunch of options that don't work, to come up with this suggestion. So of course I don't expect somebody new to the project to think of it.</p>\n<p>I think the project will be better off with this additional API. In my opinion, it would be an improvement even if it didn't help with reading from pipes: the CLI shouldn't need to know about ELF magic. But I also think having support for reading from pipes is a great idea, so I like that this fixes multiple issues at the same time.</p>\n</blockquote>",
        "id": 306278133,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666801144
    },
    {
        "content": "<p>cr0sh <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035#issuecomment-1330889522\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5035\">issue #5035</a>:</p>\n<blockquote>\n<p>Rebased and implemented the @jameysharp 's guidance. (I'll move to a new pull request as the topic has changed, so please leave this PR not reviewed) </p>\n</blockquote>",
        "id": 312877293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1669738261
    }
]