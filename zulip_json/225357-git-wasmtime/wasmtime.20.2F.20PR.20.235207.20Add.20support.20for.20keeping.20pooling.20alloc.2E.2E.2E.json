[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5207\">PR #5207</a> from <code>keep-resident-options</code> to <code>main</code>:</p>\n<blockquote>\n<p>When new wasm instances are created repeatedly in high-concurrency environments one of the largest bottlenecks is the contention on kernel-level locks having to do with the virtual memory. It's expected that usage in this environment is leveraging the pooling instance allocator with the <code>memory-init-cow</code> feature enabled which means that the kernel level VM lock is acquired in operations such as:</p>\n<ol>\n<li>Growing a heap with <code>mprotect</code> (write lock)</li>\n<li>Faulting in memory during usage (read lock)</li>\n<li>Resetting a heap's contents with <code>madvise</code> (read lock)</li>\n<li>Shrinking a heap with <code>mprotect</code> when reusing a slot (write lock)</li>\n</ol>\n<p>Rapid usage of these operations can lead to detrimental performance especially on otherwise heavily loaded systems, worsening the more frequent the above operations are. This commit is aimed at addressing the (2) case above, reducing the number of page faults that are fulfilled by the kernel.</p>\n<p>Currently these page faults happen for three reasons:</p>\n<ul>\n<li>When memory is first accessed after the heap is grown.</li>\n<li>When the initial linear memory image is accessed for the first time.</li>\n<li>When the initial zero'd heap contents, not part of the linear memory image, are accessed.</li>\n</ul>\n<p>This PR is attempting to address the latter of these cases, and to a lesser extent the first case as well. Specifically this PR provides the ability to partially reset a pooled linear memory with <code>memset</code> rather than <code>madvise</code>. This is done to have the same effect of resetting contents to zero but namely has a different effect on paging, notably keeping the pages resident in memory rather than returning them to the kernel. This means that reuse of a linear memory slot on a page that was previously <code>memset</code> will not trigger a page fault since everything remains paged into the process.</p>\n<p>The end result is that any access to linear memory which has been touched by <code>memset</code> will no longer page fault on reuse. On more recent kernels (6.0+) this also means pages which were zero'd by <code>memset</code>, made inaccessible with <code>PROT_NONE</code>, and then made accessible again with <code>PROT_READ | PROT_WRITE</code> will not page fault. This can be common when a wasm instances grows its heap slightly, uses that memory, but then it's shrunk when the memory is reused for the next instance. Note that this kernel optimization requires a 6.0+ kernel.</p>\n<p>This same optimization is furthermore applied to both async stacks with the pooling memory allocator in addition to table elements. The defaults of Wasmtime are not changing with this PR, instead knobs are being exposed for embedders to turn if they so desire. This is currently being experimented with at Fastly and I may come back and alter the defaults of Wasmtime if it seems suitable after our measurements.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;<br>\n</p>\n</blockquote>",
        "id": 308041377,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667592886
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5207#pullrequestreview-1169147824\">PR review</a>.</p>",
        "id": 308041727,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667593019
    },
    {
        "content": "<p>alexcrichton has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5207\">PR #5207</a>.</p>",
        "id": 308042284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667593244
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5207\">PR #5207</a>.</p>",
        "id": 308047715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595396
    }
]