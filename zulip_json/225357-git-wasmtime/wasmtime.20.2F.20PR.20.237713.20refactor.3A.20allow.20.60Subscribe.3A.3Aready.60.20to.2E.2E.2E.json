[
    {
        "content": "<p>rvolosatovs opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a> from <code>rvolosatovs:feat/fallible-ready</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>In the current implementation <a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#tymethod.ready\"><code>Subscribe::ready</code></a> is assumed to be infallible, which does not work in a generic case, where the implementation may require, in fact, to cause a trap in the guest.<br>\nThis is important, because implementations that require ability to trap in host <code>wasi::io::poll/pollable </code>pollable<code> would otherwise require to implement their own </code>wasi::io::poll/pollable<code>, meaning that they would not be able to reuse all the existing WASI crate implementations (https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors), potentially locking developers out of most of WASI functionality (due to the [</code>Pollable`](<a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html\">https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html</a>) concrete type being used in signatures, which cannot be externally constructed)</p>\n</blockquote>",
        "id": 409228668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703092215
    },
    {
        "content": "<p><strong>rvolosatovs</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>.</p>",
        "id": 409228669,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703092215
    },
    {
        "content": "<p><strong>rvolosatovs</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>.</p>",
        "id": 409228670,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703092215
    },
    {
        "content": "<p>rvolosatovs edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<p>In the current implementation <a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#tymethod.ready\"><code>Subscribe::ready</code></a> is assumed to be infallible, which does not work in a generic case, where the implementation may require, in fact, to cause a trap in the guest.<br>\nThis is important, because implementations that require ability to trap in host <code>wasi::io::poll/pollable</code> would otherwise require to implement their own <code>wasi::io::poll/pollable</code>, meaning that they would not be able to reuse all the existing WASI crate implementations (<a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors\">https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/trait.Subscribe.html#implementors</a>), potentially locking developers out of most of WASI functionality (due to the <a href=\"https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/preview2/struct.Pollable.html\"><code>Pollable</code></a> concrete type being used in signatures, which cannot be externally constructed)</p>\n</blockquote>",
        "id": 409228711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703092232
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>.</p>",
        "id": 409229349,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703092499
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>.</p>",
        "id": 409234845,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703094690
    },
    {
        "content": "<p><strong>rvolosatovs</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a> as ready for review.</p>",
        "id": 409234878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703094696
    },
    {
        "content": "<p>rvolosatovs updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>.</p>",
        "id": 409390276,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1703165802
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1874424261\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>\n</blockquote>",
        "id": 410891276,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704222064
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<blockquote>\n<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>\n</blockquote>\n<p>First I'll comment on this part:</p>\n<blockquote>\n<p>buffering up the error to get returned from an accessor elsewhere</p>\n</blockquote>\n<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href=\"https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461\"><code>wasi:http/types.future-trailers</code></a>, for example:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource future-trailers {\n  subscribe: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n}\n</code></pre></div>\n<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>\n<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource custom-trailers {\n  subscribe-one: func() -&gt; pollable;\n  subscribe-two: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n  foo: func() -&gt; string;\n}\n</code></pre></div>\n<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned \"ready\". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href=\"https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37\">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>\n<p>Coming back to the first part:</p>\n<p>My exact use case is a \"pollable\", which is a remote entity accessible via network:<br>\n1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>\n2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>\n3. <code>Subscribe::ready</code> unblocks</p>\n<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>\nIf, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest.</p>\n</blockquote>",
        "id": 411743926,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704722609
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<blockquote>\n<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>\n</blockquote>\n<p>First I'll comment on this part:</p>\n<blockquote>\n<p>buffering up the error to get returned from an accessor elsewhere</p>\n</blockquote>\n<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href=\"https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461\"><code>wasi:http/types.future-trailers</code></a>, for example:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource future-trailers {\n  subscribe: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n}\n</code></pre></div>\n<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>\n<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource custom-trailers {\n  subscribe-one: func() -&gt; pollable;\n  subscribe-two: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n  foo: func() -&gt; string;\n}\n</code></pre></div>\n<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned \"ready\". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href=\"https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37\">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>\n<p>Coming back to the first part:</p>\n<p>My exact use case is a \"pollable\", which is a remote entity accessible via network:<br>\n1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>\n2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>\n3. <code>Subscribe::ready</code> unblocks</p>\n<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>\nIf, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest (and such may not be available even when the interface is known at compile time).</p>\n</blockquote>",
        "id": 411744184,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704722693
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881072919\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<blockquote>\n<p>Could you describe a bit more when an embedder might want to return a trap via this method? I agree the current interface doesn't allow it, but one reason we chose to not do this is to avoid a common mistake of performing I/O and returning the error in the <code>ready</code> method instead of buffering up the error to get returned from an accessor elsewhere.</p>\n</blockquote>\n<p>First I'll comment on this part:</p>\n<blockquote>\n<p>buffering up the error to get returned from an accessor elsewhere</p>\n</blockquote>\n<p>This may not be possible in a generic case, because for this to work the host would need to know which accessor is coupled with the pollable and this relationship is not in any way encoded in WIT. In other words, the host must be aware of the executed Wasm component runtime <em>behavior</em>/<em>logic</em> in order to expose the error in the accessor. Consider <a href=\"https://github.com/WebAssembly/wasi-http/blob/7a0889a74741807b1f8b21fb50fdd73112250091/wit/types.wit#L429-L461\"><code>wasi:http/types.future-trailers</code></a>, for example:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource future-trailers {\n  subscribe: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n}\n</code></pre></div>\n<p>Because the host at compile time is aware of the behavior of <code>wasi:http/future-trailers</code>, it knows that if an error was encountered in <code>Subscribe::ready</code> implementation of the returned pollable, <code>wasi:http/future-trailers.get</code> should return it.</p>\n<p>But in case of some generic resource, which is only known at runtime, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource custom-trailers {\n  subscribe-one: func() -&gt; pollable;\n  subscribe-two: func() -&gt; pollable;\n  get: func() -&gt; option&lt;result&lt;result&lt;option&lt;trailers&gt;, error-code&gt;&gt;&gt;;\n  foo: func() -&gt; string;\n}\n</code></pre></div>\n<p>The host may not in any way know how to communicate the error (and which one) to the guest. The interface, may, in fact, not even utilize an accessor and simply rely on the fact that the <code>pollable</code> has returned \"ready\". This is precisely the behavior of <code>wasi-clocks</code> timeouts <a href=\"https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37\">https://github.com/WebAssembly/wasi-clocks/blob/52335b59451193cb36830588298085a76fc78ff1/wit/monotonic-clock.wit#L33-L37</a>.</p>\n<p>Coming back to the first part:</p>\n<p>My exact use case is a \"pollable\", which is a remote entity accessible via network:<br>\n1. <code>Subscribe::ready</code> establishes the connection to the remote peer<br>\n2. Any relevant data is communicated over the connection, an empty response is received by the caller<br>\n3. <code>Subscribe::ready</code> unblocks</p>\n<p>If network connection in 1. fails, it can just be retried, perhaps with backoff - that part works well with existing API.<br>\nIf, however, (unrecoverable) protocol error is encountered in 2. - causing a trap in the guest seems to be the only reasonable approach, since the remote entity state is not known and there is no generic way to communicate the error to the guest (and such may not be available even when the interface is known at compile time). Returning in this case could break assumptions of the Wasm component logic and blocking forever would stall execution forever (e.g. if no timeout is used in the Wasm component poll)</p>\n</blockquote>",
        "id": 411744763,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704722852
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713#issuecomment-1881430009\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7713\">PR #7713</a>:</p>\n<blockquote>\n<p>Ok makes sense, thanks for explaining. Can this be fixed though by updating the WIT-level APIs? </p>\n<p>For example in your <code>custom-trailers</code> I would say that what <code>subscribe</code> and the <code>pollable</code>s mean depends on how the WIT APIs are defined. It would be an API contract that <code>subscribe-one</code> would indicate readiness of <code>get</code> and <code>subscribe-two</code> would indicate readiness of <code>foo</code> where <code>foo</code> would have to semantically define what it means to be called before it's ready, etc.</p>\n<p>In your use case of a remote-owned resource, this is something that I'd at least personally expect to go through an error somewhere in the WIT. One option would be that when the pollable says \"ready\" any future operations on it trap (communicating the fatal error) or by updating the APIs there to surface an error instead.</p>\n</blockquote>",
        "id": 411773976,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1704731700
    }
]