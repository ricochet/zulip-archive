[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-639897139\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 199945279,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591400278
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-640052847\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Very exciting to see this! \\o/</p>\n<p>One question: does this have any implications for deterministic behavior? ISTM that as long as we don't have weak references anywhere in the system it probably doesn't, right?</p>\n</blockquote>",
        "id": 199972655,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591446474
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-640756824\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>One question: does this have any implications for deterministic behavior? ISTM that as long as we don't have weak references anywhere in the system it probably doesn't, right?</p>\n</blockquote>\n<p>This has deterministic (albeit perhaps surprising if you don't know the implementation) behavior. We only GC when either the embedder calls <code>Store::gc</code> or when the <code>VMExternRefActivationsTable</code> is full (which happens after passing in N <code>externref</code>s to Wasm).</p>\n<p>FWIW. <code>VMExternRef</code> doesn't currently support weak references. Shouldn't be too hard to add if we find we need it. It wouldn't change the determinism of GC though.</p>\n</blockquote>",
        "id": 200127783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591636063
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-640791225\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Very nice! Before I dig too closely into the internal details I wanted to get a grasp of how this is all organized and such. The main thoughts I have is that this is adding a new registry and a lot of separate points where we pass around registries and such. I'm hoping we can perhaps unify all these with existing registries and such we have? Internally it feels better if we don't have an arc and rwlock per-thing that we need to keep track of.</p>\n</blockquote>\n<p>I originally did add this to the existing global frame info, but after our discussions about not wanting implicit global context, I moved it out to its own registry.</p>\n<blockquote>\n<p>One other thing I'm remembering now which I think would be good to happen here, I think this should include an implementation of <code>WasmTy for ExternRef</code>. We'll want to enable closures with <code>Func</code> that take <code>ExternRef</code> as arguments and such, and it'd be cool to see what the monomorphize logic looks like for functions that take a number of <code>ExternRef</code> or produce them.</p>\n</blockquote>\n<p>Yeah, I have this on my TODO list for a follow up PR. Felt like this was big enough as is.</p>\n<blockquote>\n<p>Finally I wanted to write some thoughts about the GC aspect. It feels a bit weird to me that we're using reference counting but still have to have explicit GC points. To make sure I understand, GC only happens right now automatically when you call into a function, right? Or are there other auto-inserted points that GC happens? At a minimum I think we need to make sure that all long-running code is eventually GC'd, so I think both entry and exit needs GC'ing (calling into a host and returning back to wasm may already do the GC, I likely missed it!).</p>\n<p>I wanted to dig a bit more into the decision though to use deferred reference counting rather than explicit. Is it possible to somewhat easily get performance number comparisons? For example do we have a handle on what we predict the overhead will be? I'd imagine there are possible optimizations where local.get/local.set don't do reference counting but calling a function does.</p>\n</blockquote>\n<p>Regarding when GC happens see my reply to Till: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-640756824\">https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-640756824</a></p>\n<p>For long-running Wasm, in the absence of explicit <code>Store::gc</code> calls, GC will happen as the <code>VMExternRefActivationsTable</code> fills up. I don't think it makes sense to GC on entry/exit from every single host&lt;--&gt;wasm function boundary, because it will be too expensive for simple getter/setter host functions that you expect to generally be fast. It might makes sense for the embedder to call <code>Store::gc</code> after the \"main\" call into Wasm (e.g. after servicing an HTTP request, but not after each wasm -&gt; host call to read an HTTP header; however in this case there should be zero Wasm frames on the stack, so we could provide an unsafe method to just clear the <code>VMExternRefActivationsTable</code> rather than even bothering to walk the stack and do the GC).</p>\n<p>Regarding the decision to go with deferred reference counting, let's look at the alternative: we would have to do explicit reference count increments and decrements for references inside Wasm frames, rather than deferring them. First, to get this working at all, this would require extending <code>cranelift-wasm</code> to add ref count increments every time we pushed a reference onto the spec-defined Wasm execution stack (e.g. every <code>local.get</code>), and ref count decrements every time it is popped off the Wasm execution stack (e.g. every <code>local.set</code>). But doing this many reference counting operations is <em>the</em> thing kills reference counting's throughput. So to alleviate that we could either do deferred reference counting, or we could add a static analysis to <code>cranelift-wasm</code> that sums the ref count increments and decrements in a basic block and does only the final effect once (hand waving a bit, would need to think about this a bit more). Then, if coalescing ref count operations within a basic block isn't enough, this static analysis could perhaps further be generalized across basic blocks (really hand waving now).</p>\n<p>Note that we can't only do reference counting at function call boundaries because we need to handle the case where a Wasm function takes a reference and drops it. We need to decrement the reference count at the drop site, which is what instrumenting the spec stack pops does.</p>\n<p>So that is a bunch of infrastructural work on Cranelift to get something that will perform worse but at least works, followed by more work to start moving towards fewer ref count operations (but never getting as few as deferred reference counting: zero, albeit with occasional stack walking pauses).</p>\n<p>On the other hand, we already have stack maps produced by Cranelift, which are the necessary bits required for implementing deferred reference counting. We don't need to build any Cranelift infrastructure <em>and</em> Wasmtime's integration, just the latter. However, yes, this does come with occasional stack-walking pauses and reliance on <code>libunwind</code> or some other way of walking the stack (but also we already require it for unwinding host functions after traps).</p>\n<p>So that was basically the calculus: an easier path to getting a better implementation (or at least an easier path to getting a good implementation, if we are comparing against the hypothetical best version of the ref counting coalescing static analysis).</p>\n<p>Unfortunately, I don't have benchmarks or performance numbers. It would be hard to get this information without implementing both approaches. And it is hard to know how many reference counting operations we could coalesce with the hypothetical static analysis. But I don't really have any doubt that naively doing all the increments and decrements for on-stack references would be quite slow: this is Well Known(tm) in the memory management world.</p>\n</blockquote>",
        "id": 200136191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591640207
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-641219070\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>This has deterministic (albeit perhaps surprising if you don't know the implementation) behavior.</p>\n</blockquote>\n<p>Great, thank you for the explanation!</p>\n<p>One additional question: will it be possible to use the same infrastructure for stack tracing once we start implementing one of the GC proposals? Seems like that should be the case, but I might well be missing something.</p>\n</blockquote>",
        "id": 200208768,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591700930
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-641430263\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>One additional question: will it be possible to use the same infrastructure for stack tracing once we start implementing one of the GC proposals? Seems like that should be the case, but I might well be missing something.</p>\n</blockquote>\n<p>Yep, doing that should be a lot easier after this lands.</p>\n</blockquote>",
        "id": 200258114,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591721113
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642057331\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Sorry I haven't had a chance to read and fully digest your response yet @fitzgen (will do later today), but I wanted to comment here with a thought before I forget it. In <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1845\">https://github.com/bytecodealliance/wasmtime/issues/1845</a> it was found that we can't actually backtrace through other host JIT code (e.g. the CLR) on all platforms. I think that this GC implementation requires getting a full backtrace at all times, right? If, for example, a host call in the CLR triggered a GC it would get a smaller view of the world than actually exists and could cause a use-after-free?</p>\n</blockquote>",
        "id": 200425666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591800315
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642127785\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Ok now to respond in full! One thing I'm still a bit murky and/or uncomfortable on is when GC is expected to happen. I understand that it automatically happens when tables fill up or if you explicitly call it, but my question was sort of largely do we expect wasmtime to grow some other time it automatically calls it? For example if an application <em>never</em> calls <code>Store::gc</code> is it guaranteed that, regardless of what wasm runs, memory won't be leaked?</p>\n<p>Another question is how we'd document this. For embedders using anyref, what would be the recommended way to call this? I think \"call it after the 'main call'\" is pretty sound advice, but that hingest on the previous question of it should never be required to call <code>Store::gc</code> to prevent leaking unbounded amounts of memory.</p>\n<p>For alternative strategies of reference counting, to clarify I don't think that we should be reverting this and switching to explicit reference counting. I'm mostly probing because the rationale against reference counting feels a bit hand-wavy to me and given the cost of relying on stack unwinding and stack maps I'd just want to make sure we're set.</p>\n<p>To play devil's advocate a bit, I'm not convinced that function-boundary reference counting is impossible. I agree <code>local.{set,get}</code> should not do reference counting at all. What I'm imagining is that there's a set of \"live anyref\" in a function frame that cranelift keeps track of. Instructions like <code>call</code> and <code>{global,table}.{get,set}</code> will increment the reference count for received anyref values and passed away anyref values. When the function returns cranelift would then inject a decrement of the reference count for all active anyref values in the frame.</p>\n<p>I agree that this may need some intrinsic work in Cranelift, but I don't think that this would require optimizations about coalescing reference counts. The main idea would be that <code>local.{get,set}</code> are the lion's share of reference count activities so by deferring that we'd get the lion's share of the benefit.</p>\n<p>Thinking more on this though unwinds are a really important thing to account for here too. I believe the stack walking strategy perfectly handles unwinds (since you'll just gc later and realize that rooted things aren't on the stack any more), but anything with explicit code generation will still need to do <em>something</em> on unwinding. And that 'something' is arguably just as hard to get right as stack maps themselves.</p>\n<p>Again though to be clear I'm trying to get it straight in my head why we're using deferred reference counting rather than explicit reference counting. I don't mean to seem like I'm challenging the conclusion, it's mostly that I just want to feel confident that we don't hand-wave too much by accident. For me, though, the nail in the coffin is that in a world of explicit reference counting unwinding needs to be handled somehow, and the solution seems like it'd be very similar if not just stack maps in one form or another.</p>\n</blockquote>",
        "id": 200442308,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591807265
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642135502\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Again though to be clear I'm trying to get it straight in my head why we're using deferred reference counting rather than explicit reference counting.</p>\n</blockquote>\n<p>Deferred reference counting is more performant.</p>\n</blockquote>",
        "id": 200444107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591808147
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642159914\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Deferred reference counting is more performant.</p>\n</blockquote>\n<p>Being this short and this absolute is not helpful. It isn't a 100% cut and dry issue, as the lengthy discussion weighing its trade offs shows. Please engage with nuance in the future. Thanks.</p>\n</blockquote>",
        "id": 200450789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591811020
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642161493\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Ok, sorry.</p>\n</blockquote>",
        "id": 200451236,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591811194
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642204938\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>How does SpiderMonkey unwind frames within a single JitActivation? Do they have a custom unwinder which can sort of start halfway down the stack?</p>\n<p>Otherwise another possible alternative is we could perhaps have a flag in <code>Store</code> of \"am I in wasm?\" and some sort of \"blessed\" frame on the stack, where if we don't find that frame then we know the stack trace is incomplete and skip GC entirely?</p>\n</blockquote>",
        "id": 200463172,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591816540
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642229296\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>How does SpiderMonkey unwind frames within a single JitActivation? Do they have a custom unwinder which can sort of start halfway down the stack?</p>\n</blockquote>\n<p>Yes, they have their own unwinder that understands only their own JIT'd frames.</p>\n<blockquote>\n<p>Otherwise another possible alternative is we could perhaps have a flag in <code>Store</code> of \"am I in wasm?\" and some sort of \"blessed\" frame on the stack, where if we don't find that frame then we know the stack trace is incomplete and skip GC entirely?</p>\n</blockquote>\n<p>This would avoid the unsoundness, but wouldn't let us clean up the garbage, so it isn't super attractive...</p>\n</blockquote>",
        "id": 200469666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591819589
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642233318\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>For .net, presumably msft's stack walker knows how to walk CLR frames. Perhaps we could just use their stack walker on windows? It isn't clear to me how to deal with .net on linux/macos if they refuse to integrate with the standard unwinding conventions of the platform...</p>\n</blockquote>\n<p>.NET Core's walker isn't readily available to use outside of the CLR and would be burdensome to liberate.  Additionally, this actually isn't a problem on Windows because .NET Core uses the Windows unwind information format to internally represent its JIT code and hence complete walks with the system unwinder is possible (but only on Windows).  That said, there might be other JIT-based runtimes out there that don't register their code with system unwinders, so a general solution would probably be warranted.</p>\n<p>I think your other proposed solution makes the most sense, similar to SpiderMonkey, to record enough context at wasm-to-host and host-to-wasm transition points to enable a wasm-specific walk within Wasmtime itself rather than relying on a system unwinder.</p>\n<p>This would also solve the trap backtrace issue more generally such that we can then guarantee correct wasm traces regardless of encountering a frame that has no system unwind information registered.</p>\n<p>It might also be useful to enhance our trap traces so we can clearly indicate to users where such transitions occur.  For instance, that would be useful to show that a trap came from the host rather than user wasm code (e.g. show a top frame of <code>[host frames omitted]</code> rather than the wasm frame that called into the host).</p>\n</blockquote>",
        "id": 200470590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591820087
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642233318\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>For .net, presumably msft's stack walker knows how to walk CLR frames. Perhaps we could just use their stack walker on windows? It isn't clear to me how to deal with .net on linux/macos if they refuse to integrate with the standard unwinding conventions of the platform...</p>\n</blockquote>\n<p>.NET Core's walker isn't readily available to use outside of the CLR and would be burdensome to liberate.  Additionally, this actually isn't a problem on Windows because .NET Core uses the Windows unwind information format to internally represent its JIT code and hence complete walks with the system unwinder is possible (but only on Windows).  That said, there might be other JIT-based runtimes out there that don't register their code with system unwinders, so a general solution would probably be warranted.</p>\n<p>I think your other proposed solution makes the most sense, similar to SpiderMonkey, to record enough context at wasm-to-host and host-to-wasm transition points to enable a wasm-specific walk within Wasmtime itself rather than relying on a system unwinder for a complete trace (we could still rely on a system unwinder for unwinding the wasm frames as we support libunwind and Windows).</p>\n<p>This would also solve the trap backtrace issue more generally such that we can then guarantee correct wasm traces regardless of encountering a frame that has no system unwind information registered.</p>\n<p>It might also be useful to enhance our trap traces so we can clearly indicate to users where such transitions occur.  For instance, that would be useful to show that a trap came from the host rather than user wasm code (e.g. show a top frame of <code>[host frames omitted]</code> rather than the wasm frame that called into the host).</p>\n</blockquote>",
        "id": 200471142,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591820401
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642233318\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>For .net, presumably msft's stack walker knows how to walk CLR frames. Perhaps we could just use their stack walker on windows? It isn't clear to me how to deal with .net on linux/macos if they refuse to integrate with the standard unwinding conventions of the platform...</p>\n</blockquote>\n<p>.NET Core's walker isn't readily available to use outside of the CLR and would be burdensome to liberate.  Additionally, this actually isn't a problem on Windows because .NET Core uses the Windows unwind information format to internally represent its JIT code and hence complete walks with the system unwinder is possible (but only on Windows).  That said, there might be other JIT-based runtimes out there that don't register their code with system unwinders, so a general solution would probably be warranted.</p>\n<p>I think your other proposed solution makes the most sense, similar to SpiderMonkey, to record enough context at wasm-to-host and host-to-wasm transition points to enable a wasm-specific walk within Wasmtime itself rather than relying on a system unwinder for a complete trace (we could still rely on a system unwinder for walking the wasm frames as we support libunwind and Windows).</p>\n<p>This would also solve the trap backtrace issue more generally such that we can then guarantee correct wasm traces regardless of encountering a frame that has no system unwind information registered.</p>\n<p>It might also be useful to enhance our trap traces so we can clearly indicate to users where such transitions occur.  For instance, that would be useful to show that a trap came from the host rather than user wasm code (e.g. show a top frame of <code>[host frames omitted]</code> rather than the wasm frame that called into the host).</p>\n</blockquote>",
        "id": 200471236,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591820441
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642233318\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>For .net, presumably msft's stack walker knows how to walk CLR frames. Perhaps we could just use their stack walker on windows? It isn't clear to me how to deal with .net on linux/macos if they refuse to integrate with the standard unwinding conventions of the platform...</p>\n</blockquote>\n<p>.NET Core's walker isn't readily available to use outside of the CLR and would be burdensome to liberate.  Additionally, this actually isn't a problem on Windows because .NET Core uses the Windows unwind information format to internally represent its JIT code and hence complete walks with the system unwinder is possible (but only on Windows).  That said, there might be other JIT-based runtimes out there that don't register their code with system unwinders, so a general solution would probably be warranted.</p>\n<p>I think your other proposed solution makes the most sense, similar to SpiderMonkey, to record enough context at wasm-to-host and host-to-wasm transition points to enable a wasm-specific walk within Wasmtime itself rather than relying on a system unwinder for a complete trace (we could still rely on a system unwinder for walking the wasm frames as we support libunwind and Windows; on Windows this is possible with <code>RtlVritualUnwind</code>, but I'm ignorant of the libunwind equivalent).</p>\n<p>This would also solve the trap backtrace issue more generally such that we can then guarantee correct wasm traces regardless of encountering a frame that has no system unwind information registered.</p>\n<p>It might also be useful to enhance our trap traces so we can clearly indicate to users where such transitions occur.  For instance, that would be useful to show that a trap came from the host rather than user wasm code (e.g. show a top frame of <code>[host frames omitted]</code> rather than the wasm frame that called into the host).</p>\n</blockquote>",
        "id": 200471491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591820587
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642233318\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>For .net, presumably msft's stack walker knows how to walk CLR frames. Perhaps we could just use their stack walker on windows? It isn't clear to me how to deal with .net on linux/macos if they refuse to integrate with the standard unwinding conventions of the platform...</p>\n</blockquote>\n<p>.NET Core's walker isn't readily available to use outside of the CLR and would be burdensome to liberate.  Additionally, this actually isn't a problem on Windows because .NET Core uses the Windows unwind information format to internally represent its JIT code and hence complete walks with the system unwinder is possible (but only on Windows).  That said, there might be other JIT-based runtimes out there that don't register their code with system unwinders, so a general solution would probably be warranted.</p>\n<p>I think your other proposed solution makes the most sense, similar to SpiderMonkey, to record enough context at wasm-to-host and host-to-wasm transition points to enable a wasm-specific walk within Wasmtime itself rather than relying on a system unwinder for a complete trace (we could still rely on a system unwinder for walking the wasm frames as we support libunwind and Windows; on Windows this is possible with <code>RtlVirtualUnwind</code>, but I'm ignorant of the libunwind equivalent).</p>\n<p>This would also solve the trap backtrace issue more generally such that we can then guarantee correct wasm traces regardless of encountering a frame that has no system unwind information registered.</p>\n<p>It might also be useful to enhance our trap traces so we can clearly indicate to users where such transitions occur.  For instance, that would be useful to show that a trap came from the host rather than user wasm code (e.g. show a top frame of <code>[host frames omitted]</code> rather than the wasm frame that called into the host).</p>\n</blockquote>",
        "id": 200471644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591820670
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642290558\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ok now to respond in full! One thing I'm still a bit murky and/or uncomfortable on is when GC is expected to happen. I understand that it automatically happens when tables fill up or if you explicitly call it, but my question was sort of largely do we expect wasmtime to grow some other time it automatically calls it? For example if an application _never_ calls <code>Store::gc</code> is it guaranteed that, regardless of what wasm runs, memory won't be leaked?</p>\n<p>Another question is how we'd document this. For embedders using anyref, what would be the recommended way to call this? I think \"call it after the 'main call'\" is pretty sound advice, but that hingest on the previous question of it should never be required to call <code>Store::gc</code> to prevent leaking unbounded amounts of memory.</p>\n</blockquote>\n<p>We could add a timer-based GC, but this does make the timing of when destructors are called non-deterministic.</p>\n<p>The only situation where there could be long-running wasm without any GC is if the Wasm goes into a long-running loop <em>that doesn't use any references</em>. If it did use references (i.e. put them in tables/globals) then the <code>VMExternRefActivationsTable</code> would eventually fill up and trigger a GC.</p>\n<p>I don't think recommending a <code>Store::gc</code> call on exit of the \"main\" wasm call is too onerous for embedders (especially given that they may <em>not</em> want to do it that way if there isn't a single \"main\" call, and instead let it come naturally) but we could also provide an RAII class or somehow do it by default by counting number of active calls into wasm there are at any given time for the thread.</p>\n<blockquote>\n<p>To play devil's advocate a bit, I'm not convinced that function-boundary reference counting is impossible. I agree <code>local.{set,get}</code> should not do reference counting at all. What I'm imagining is that there's a set of \"live anyref\" in a function frame that cranelift keeps track of. Instructions like <code>call</code> and <code>{global,table}.{get,set}</code> will increment the reference count for received anyref values and passed away anyref values. When the function returns cranelift would then inject a decrement of the reference count for all active anyref values in the frame.</p>\n<p>I agree that this may need some intrinsic work in Cranelift, but I don't think that this would require optimizations about coalescing reference counts. The main idea would be that <code>local.{get,set}</code> are the lion's share of reference count activities so by deferring that we'd get the lion's share of the benefit.</p>\n</blockquote>\n<p>I see more where you are going with this now.</p>\n<p>Cranelift already does this to some degree when generating stack maps for safepoints: it asks the register allocator which values are still live after this point, filters for just the references, and generates a stack map for them based on their locations.</p>\n<p>This is really late in the compilation pipeline though: it requires cooperation with the register allocator. I don't think we can do exactly that same approach for ref counting operations, because it is probably too late to insert new instructions (let alone whole new blocks for checking if the refcount reached zero inline, and only calling out to a VM function if so).</p>\n<p>I think we could do something similar in <code>cranelift-wasm</code>, before the IR enters Cranelift's pipeline properly. (Once it goes into Cranelift, it is essentially \"too late\" to insert these hooks, as Cranelift doesn't ever call back out into user code at that point, and introducing it would be a bunch of work and also not necessarily wanted.) Still feel a bit hand wavy about this, and the more I think about it, the more similar it feels to the final form of the hypothetical static analysis.</p>\n<blockquote>\n<p>but anything with explicit code generation will still need to do _something_ on unwinding. And that 'something' is arguably just as hard to get right as stack maps themselves.</p>\n</blockquote>\n<p>I'm not sure what you're talking about here. What explicit code generation? What code generation do we do at all that isn't handled by Cranelift?</p>\n<blockquote>\n<p>For me, though, the nail in the coffin is that in a world of explicit reference counting unwinding needs to be handled somehow, and the solution seems like it'd be very similar if not just stack maps in one form or another.</p>\n</blockquote>\n<p>Yes, if we use non-deferred reference counting for on-stack references, traps will have to decrement reference counts as they unwind through Wasm frames. I hadn't thought about this either. This does end up looking very similar to stack maps, but also with personality routines throne into the mix. The difference is that failure to unwind stacks properly leads to leaks in this case, rather than unsafety.</p>\n<hr>\n<p>Ultimately, I'm not 100% sure whether it makes more sense to keep investing in this stack maps-based approach to deferred reference counting, or to start fresh and try non-deferred reference counting.</p>\n<p>I had been leaning towards exploring non-deferred reference counting, but I hadn't thought of the need to decrement reference counts when unwinding through wasm. When considering the effort required to do that properly, I'm less sure now.</p>\n</blockquote>",
        "id": 200482982,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591826496
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642293788\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Oh one other thing I wanted to mention: if we do keep going with this PR's approach and introduce a <code>JitActivation</code> analog, it isn't clear to me yet whether we can keep using <code>libunwind</code> (via the <code>backtrace</code> crate) for unwinding through a single <code>JitActivation</code>'s wasm frames, or if we would need to implement our own stack walker that only handles the kinds of frames generated by Cranelift.</p>\n<p>In order to keep using <code>libunwind</code>, we would need a way to initialize its unwind context manually ourselves, and not just with the current youngest stack frame's register values. We would also need to plumb that through the <code>backtrace</code> crate. I am not sure whether <code>libunwind</code> supports this or not. I'm going to look into it.</p>\n</blockquote>",
        "id": 200483928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591827003
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642290558\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ok now to respond in full! One thing I'm still a bit murky and/or uncomfortable on is when GC is expected to happen. I understand that it automatically happens when tables fill up or if you explicitly call it, but my question was sort of largely do we expect wasmtime to grow some other time it automatically calls it? For example if an application _never_ calls <code>Store::gc</code> is it guaranteed that, regardless of what wasm runs, memory won't be leaked?</p>\n<p>Another question is how we'd document this. For embedders using anyref, what would be the recommended way to call this? I think \"call it after the 'main call'\" is pretty sound advice, but that hingest on the previous question of it should never be required to call <code>Store::gc</code> to prevent leaking unbounded amounts of memory.</p>\n</blockquote>\n<p>We could add a timer-based GC, but this does make the timing of when destructors are called non-deterministic.</p>\n<p>The only situation where there could be long-running wasm without any GC is if the Wasm goes into a long-running loop <em>that doesn't use any references</em>. If it did use references (i.e. put them in tables/globals) then the <code>VMExternRefActivationsTable</code> would eventually fill up and trigger a GC.</p>\n<p>I don't think recommending a <code>Store::gc</code> call on exit of the \"main\" wasm call is too onerous for embedders (especially given that they may <em>not</em> want to do it that way if there isn't a single \"main\" call, and instead let it come naturally) but we could also provide an RAII class or somehow do it by default by counting number of active calls into wasm there are at any given time for the thread.</p>\n<blockquote>\n<p>To play devil's advocate a bit, I'm not convinced that function-boundary reference counting is impossible. I agree <code>local.{set,get}</code> should not do reference counting at all. What I'm imagining is that there's a set of \"live anyref\" in a function frame that cranelift keeps track of. Instructions like <code>call</code> and <code>{global,table}.{get,set}</code> will increment the reference count for received anyref values and passed away anyref values. When the function returns cranelift would then inject a decrement of the reference count for all active anyref values in the frame.</p>\n<p>I agree that this may need some intrinsic work in Cranelift, but I don't think that this would require optimizations about coalescing reference counts. The main idea would be that <code>local.{get,set}</code> are the lion's share of reference count activities so by deferring that we'd get the lion's share of the benefit.</p>\n</blockquote>\n<p>I see more where you are going with this now.</p>\n<p>Cranelift already does this to some degree when generating stack maps for safepoints: it asks the register allocator which values are still live after this point, filters for just the references, and generates a stack map for them based on their locations.</p>\n<p>This is really late in the compilation pipeline though: it requires cooperation with the register allocator. I don't think we can do exactly that same approach for ref counting operations, because it is probably too late to insert new instructions (let alone whole new blocks for checking if the refcount reached zero inline, and only calling out to a VM function if so).</p>\n<p>I think we could do something similar in <code>cranelift-wasm</code>, before the IR enters Cranelift's pipeline properly. (Once it goes into Cranelift, it is essentially \"too late\" to insert these hooks, as Cranelift doesn't ever call back out into user code at that point, and introducing it would be a bunch of work and also not necessarily wanted.) Still feel a bit hand wavy about this, and the more I think about it, the more similar it feels to the final form of the hypothetical static analysis.</p>\n<blockquote>\n<p>but anything with explicit code generation will still need to do _something_ on unwinding. And that 'something' is arguably just as hard to get right as stack maps themselves.</p>\n</blockquote>\n<p>I'm not sure what you're talking about here. What explicit code generation? What code generation do we do at all that isn't handled by Cranelift?</p>\n<blockquote>\n<p>For me, though, the nail in the coffin is that in a world of explicit reference counting unwinding needs to be handled somehow, and the solution seems like it'd be very similar if not just stack maps in one form or another.</p>\n</blockquote>\n<p>Yes, if we use non-deferred reference counting for on-stack references, traps will have to decrement reference counts as they unwind through Wasm frames. I hadn't thought about this either. This does end up looking very similar to stack maps, but also with personality routines thrown into the mix. The difference is that failure to unwind stacks properly leads to leaks in this case, rather than unsafety.</p>\n<hr>\n<p>Ultimately, I'm not 100% sure whether it makes more sense to keep investing in this stack maps-based approach to deferred reference counting, or to start fresh and try non-deferred reference counting.</p>\n<p>I had been leaning towards exploring non-deferred reference counting, but I hadn't thought of the need to decrement reference counts when unwinding through wasm. When considering the effort required to do that properly, I'm less sure now.</p>\n</blockquote>",
        "id": 200484364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591827276
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642303160\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context.  We could then step the cursor until we encounter a non-wasm frame.</p>\n</blockquote>",
        "id": 200486618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591828558
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642303160\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context.  We could then step the cursor until we encounter a non-wasm frame.</p>\n<p>If there are no wasm-to-host transitions (i.e. the top frame is wasm or a Wasmtime function such as the signal or GC handler), then we can assume the walk from the current context perhaps?  There shouldn't be any foreign unregistered frames that would prevent the walk in that case.</p>\n</blockquote>",
        "id": 200487137,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591828881
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642303160\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context.  We could then step the cursor until we encounter a non-wasm frame.</p>\n<p>If there are no wasm-to-host transitions (i.e. there's only Wasm frames on top or a Wasmtime function such as the signal or GC handler), then we can assume the walk from the current context perhaps?  There shouldn't be any foreign unregistered frames that would prevent the walk in that case.</p>\n</blockquote>",
        "id": 200487287,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591828992
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642303160\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context.  We could then step the cursor until we encounter a non-wasm frame.</p>\n<p>If there are no wasm-to-host transitions (i.e. there's only Wasm frames on top or a Wasmtime function such as the signal or GC handler), then we can assume the walk from the current context, skipping any initial non-wasm frames, perhaps?  There shouldn't be any foreign unregistered frames that would prevent the walk in that case.</p>\n</blockquote>",
        "id": 200487350,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591829034
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642303160\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context.  We could then step the cursor until we encounter a non-wasm frame.</p>\n<p>If the wasm-to-host transitions stack is empty (i.e. there's only Wasm frames on top or a Wasmtime function such as the signal or GC handler), then we can assume the walk from the current context, skipping any initial non-wasm frames, perhaps?  There shouldn't be any foreign unregistered frames that would prevent the walk in that case.</p>\n</blockquote>",
        "id": 200487519,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591829138
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642311806\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>I assume we can capture the context at the wasm-to-host transition and use <code>unw_init_local</code> to initialize the unwind cursor at that context. We could then step the cursor until we encounter a non-wasm frame.</p>\n</blockquote>\n<p>Yes, we could do this. Adding an out-of-line function call (<code>unw_getcontext</code>) to every wasm-&gt;host transition isn't great though. (On arm, it is actually a macro of some inline assembly, but since Rust doesn't have inline assembly, we would probably wrap that in a C function that we call anways...)</p>\n<p>AFAICT, there is no blessed way of re-initializing an existing <code>unw_context_t</code> from just a PC and SP, which is all that should really be required for stack walking in principle. On both x86-64 and arm, <code>unw_context_t</code> is just a define of a <code>ucontext_t</code>, so maybe we could just poke the <code>ucontext_t</code>'s register values directly...</p>\n</blockquote>",
        "id": 200489186,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591830248
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642312661\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Agreed, if we go with such a design, I would want to limit the context capturing only to host functions not defined by Wasmtime (and perhaps <em>only</em> via the C API, where there is a chance of another JIT runtime being used).  Perhaps it could even be something embedders opt-in to.</p>\n<p>The bottom line is that we shouldn't have to pay the cost for capturing context when calling into Wasmtime's WASI implementation especially, as we are guaranteed to be able to unwind through those frames for both libunwind and Windows.</p>\n</blockquote>",
        "id": 200489411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591830418
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642312661\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Agreed, if we go with such a design, I would want to limit the context capturing only to host functions not defined by Wasmtime (and perhaps <em>only</em> via the C API, where there is a chance of another JIT runtime being used).  Perhaps it could even be something embedders opt-in to when defining a function.</p>\n<p>The bottom line is that we shouldn't have to pay the cost for capturing context when calling into Wasmtime's WASI implementation especially, as we are guaranteed to be able to unwind through those frames for both libunwind and Windows.</p>\n</blockquote>",
        "id": 200489541,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591830509
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642313755\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>All that said, I'm comfortable with landing a stack-walking-based GC before we fix the issue that currently only affects .NET hosts.</p>\n</blockquote>",
        "id": 200489711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591830662
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642313755\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>All that said, I'm comfortable with landing a stack-walking-based GC before we fix the issue that currently only affects .NET hosts (the .NET API doesn't support reference types yet anyway).</p>\n</blockquote>",
        "id": 200490115,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591830984
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642453780\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Maybe there is some way for the .NET implementation to insert a frame whose unwind info doesn't do normal unwinding, but sets the sp to the value before entering the .NET JITtes code, such that all .NET JITted code is skipped. Or has a special personality function that invokes the .NET unwinder and then sets the register state as the .NET unwinder gives back when unwinding past the JITted code.</p>\n</blockquote>",
        "id": 200511107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591859000
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642453780\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Maybe there is some way for the .NET Wasmtime implementation to insert a frame whose unwind info doesn't do normal unwinding, but sets the sp to the value before entering the .NET JITtes code, such that all .NET JITted code is skipped. Or has a special personality function that invokes the .NET unwinder and then sets the register state as the .NET unwinder gives back when unwinding past the JITted code.</p>\n</blockquote>",
        "id": 200511123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591859036
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642521123\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>All that said, I'm comfortable with landing a stack-walking-based GC before we fix the issue that currently only affects .NET hosts (the .NET API doesn't support reference types yet anyway).</p>\n</blockquote>\n<p>While I think that <em>might</em> be fine to do, I'm actually quite glad we have this embedding and thus caught this issue.</p>\n<p>What's more, even if we find a workaround specifically for .NET, I think it might make sense to take a closer look at whether we can then have sufficient confidence in our ability to make this approach work in all cases that might become relevant. I.e., would landing this begin painting ourselves into a corner that's increasingly hard to get out of at some later time when we realize we need to?</p>\n</blockquote>",
        "id": 200520928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591866832
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642695529\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>@fitzgen </p>\n<blockquote>\n<p>I'm not sure what you're talking about here. What explicit code generation? What code generation do we do at all that isn't handled by Cranelift?</p>\n</blockquote>\n<p>Oh by \"explicit code generation\" I mean \"the thing that isn't deferred reference counting\".</p>\n<hr>\n<p>So overall I feel like <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642204938\">my thinking above</a> is still somewhat attractive. That scheme is where on a call to <code>Store::gc</code> it doesn't actually do anything if we're missing some blessed marker on the stack (or some other mechanism to detect that our stack trace is likely incomplete).</p>\n<p>The downside of that is that runtimes like .NET will GC less, but that seems like it's not really that much of an issue given that our \"GC\" here is very small. The GC'd aspect is you gave a value to wasm and then it became unreachable during the execution of wasm. If we don't eagerly clean those up it doesn't seem like it's the end of the world, especially because we'll want to eventually fix this.</p>\n<p>I think that explicit reference counting is a defunkt strategy given our unwinding strategy. I don't really see how implementing unwinding correctly with explicit reference counting is going to be any less hazardous or any less work than this already was. If that's taken as an assumption then the final appearance of this feature will be exactly this PR except with more changes to the <code>gc</code> function and codegen (to manage <code>JitActivation</code> entries and such). @fitzgen brings up a good point though that the <code>backtrace</code> crate will likely no longer be what we use.</p>\n<p>Personally I see a few directions to go from here:</p>\n<ol>\n<li>Land this PR, work afterwards to fix .NET</li>\n<li>Don't land this PR, fix .NET, then land this PR. (e.g. <code>JitActivation</code> or similar)</li>\n<li>Switch this PR to explicit reference counting.</li>\n</ol>\n<p>I don't think (3) is feasible and I think 1/2 are pretty close. I think it might be good to sketch out in more detail how <code>JitActivation</code> could work though.</p>\n</blockquote>",
        "id": 200551671,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591885736
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642773427\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Personally I see a few directions to go from here</p>\n</blockquote>\n<p>I find this convincing, and support (1), given that @peterhuene also <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642313755\">voiced support for it</a>.</p>\n</blockquote>",
        "id": 200565284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591891333
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642794505\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Ok so we talked about this in today's wasmtime meeting. The conclusion we came to was to implement a canary stack frame in this PR for now, so we can detect situations where libunwind cannot walk the full stack, and then we can skip GC rather than get potential unsoundness. But long term, we want to do the precise <code>JitActivation</code> approach (it would allow other additional benefits, such as getting wasm stack traces for .net traps, which aren't currently available).</p>\n<p>Thanks everyone for the discussion and design input!</p>\n</blockquote>",
        "id": 200569522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591893299
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642945109\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>@alexcrichton ok, I've implemented the stack canary and rebased, so this should be ready for another round of review.</p>\n<p>We will probably want a new release of <code>backtrace</code> before we merge this (or at least we'll need one before we publish again after merging this).</p>\n</blockquote>",
        "id": 200611544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591912280
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642946256\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Wow that was fast!</p>\n<p>I'll take a look tomorrow!</p>\n</blockquote>",
        "id": 200611904,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591912477
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-642964523\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 200615809,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591914805
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-643517399\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<blockquote>\n<p>Apart from the inline comments the only other thing I'd say is that I think it'd be good to look into not having two registrations per module (<code>GlobalFrameInfoRegistration</code> and <code>StackMapRegistration</code>) and trying to lump that all into one (also deduplicating the <code>BTreeMap</code> lookups and such)</p>\n</blockquote>\n<p>Ah, I just remembered why it has to be this way: the <code>GlobalFrameInfo</code> is in the <code>wasmtime</code> crate, but we need the stack map stuff inside the <code>wasmtime-runtime</code> crate, so it can't be added as part of <code>GlobalFrameInfo</code>. The split between <code>wasmtime</code> and <code>wasmtime-runtime</code> crates is a bit annoying...</p>\n</blockquote>",
        "id": 200735302,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592003570
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-644436580\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>I had to <code>cfg(target_arch = \"x86_64\")</code> the reference types-related tests because Cranelift doesn't support safepoints/stack maps for any other targets (notably aarch64).</p>\n</blockquote>",
        "id": 200956662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592262631
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-644464853\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Confused why the <code>aarch64</code> CI job is <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832/checks?check_run_id=774637548#step:10:1199\">running the reference types tests</a> despite them <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832/commits/6a88d5cbec45e325bb22900f886b448bf4a80b8a#diff-a7b0a2dee0126cddf994326e705a91eaR215\">being ignored if <code>!cfg!(target_arch = \"x86_64\")</code></a>. Feel like I must be missing some simple typo or something like that, but I just don't see it...</p>\n</blockquote>",
        "id": 200962732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592268495
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832#issuecomment-644465734\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1832\">Issue #1832</a>:</p>\n<blockquote>\n<p>Gah, its because the <code>build.rs</code> is being compiled for <code>x64</code>.</p>\n</blockquote>",
        "id": 200962903,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592268706
    }
]