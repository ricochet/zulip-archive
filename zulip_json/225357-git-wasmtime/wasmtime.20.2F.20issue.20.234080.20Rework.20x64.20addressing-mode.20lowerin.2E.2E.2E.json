[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080#issuecomment-1113822901\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080\">issue #4080</a>:</p>\n<blockquote>\n<p>@fitzgen or @abrown, this should be ready for review now. I've stacked it<br>\non top of #4091 as otherwise it's a merge conflict. Updated description:</p>\n<p>This PR refactors the x64 backend address-mode lowering to use an<br>\nincremental-build approach, where it considers each node in a tree of<br>\n<code>iadd</code>s that feed into a load/store address and, at each step, builds<br>\nthe best possible <code>Amode</code>. It will combine an arbitrary number of<br>\nconstant offsets (an extension beyond the current rules), and can<br>\ncapture a left-shifted (scaled) index in any position of the tree<br>\n(another extension).</p>\n<p>This doesn't have any measurable performance improvement on our Wasm<br>\nbenchmarks in Sightglass, unfortunately, because the IR lowered from<br>\nwasm32 will do address computation in 32 bits and then <code>uextend</code> it to<br>\nadd to the 64-bit heap base. We can't quite lift the 32-bit adds to 64<br>\nbits because this loses the wraparound semantics.</p>\n<p>(We could label adds as \"expected not to overflow\", and allow <em>those</em> to<br>\nbe lifted to 64 bit operations; wasm32 heap address computation should<br>\nfit this.  This is <code>add nuw</code> (no unsigned wrap) in LLVM IR terms. That's<br>\nlikely my next step.)</p>\n<p>Nevertheless, (i) this generalizes the cases we can handle, which should<br>\nbe a good thing, all other things being equal (and in this case, no<br>\ncompile time impact was measured); and (ii) might benefit non-Wasm<br>\nfrontends.</p>\n</blockquote>",
        "id": 280696735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651271159
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080#issuecomment-1115168018\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080\">issue #4080</a>:</p>\n<blockquote>\n<blockquote>\n<p>(We could label adds as \"expected not to overflow\", and allow _those_ to<br>\nbe lifted to 64 bit operations; wasm32 heap address computation should<br>\nfit this. This is <code>add nuw</code> (no unsigned wrap) in LLVM IR terms. That's<br>\nlikely my next step.)</p>\n</blockquote>\n<p>This is a pretty big change for CLIF: right now it is ~basically UB-free other than memory loads/stores (and invalid <code>raw_bitcast</code>s?). Division by zero, for example, is not UB and semantically raises a trap. Adding the equivalent of <code>add nuw</code> would be the first instance of UB we have in basic arithmetic instructions, and that's something we shouldn't do lightly. I think this will have subtle and far-reaching effects that aren't immediately obvious to us now. For example, verification/superoptimization would have to keep track of UB, explicitly represent it in the SMT queries they create, and then check refinement rather than equivalence.</p>\n</blockquote>",
        "id": 280908052,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651513504
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080#issuecomment-1115396081\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080\">issue #4080</a>:</p>\n<blockquote>\n<p>Updated! @abrown let me know if the additional comments make sense.</p>\n<p>In the process of tweaking priorities to try to get everything to apply in the right order, I was hitting some weird behavior and suspect there may be an issue with priorities in general. I'm going to go play with that a bit now, but it shouldn't affect correctness here (the order in which rules apply seems wrong sometimes but the rules themselves are applied correctly).</p>\n</blockquote>",
        "id": 280938087,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651527552
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080#issuecomment-1115476101\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4080\">issue #4080</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is a pretty big change for CLIF: right now it is ~basically UB-free other than memory loads/stores (and invalid raw_bitcasts?). Division by zero, for example, is not UB and semantically raises a trap. Adding the equivalent of add nuw would be the first instance of UB we have in basic arithmetic instructions, and that's something we shouldn't do lightly. I think this will have subtle and far-reaching effects that aren't immediately obvious to us now. For example, verification/superoptimization would have to keep track of UB, explicitly represent it in the SMT queries they create, and then check refinement rather than equivalence.</p>\n</blockquote>\n<p>Yeah, I've been digging into cases where I thought this might help and it seems that the adds are coming from bona fine <code>i32.add</code>s in the Wasm, not some part of the legalization of <code>heap_addr</code> with offsets; in this case we actually have to implement the wrapping behavior faithfully, so nevermind the above. I do agree as well actually that nondeterminism isn't the best answer here; if we come back to a similar issue later maybe the right answer is to just use <code>i64</code>s in the right spots (or the host pointer type) to avoid the extends.</p>\n</blockquote>",
        "id": 280949929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651535568
    }
]