[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1037\">issue #1037</a>:</p>\n<blockquote>\n<p>I know that LLVM IR is not really similar with real machine isa, but there's some advantages if we can easily translate Cretonne IR to LLVM IR.</p>\n<p>It's well-known that LLVM is awfully slow for \"bad\" code, while cretonne is fast-by-default but currently lacking deep optimizations. I saw that there's a plan to use cretonne for rustc debug mode. But why should compilers handles two different target IR? If we can generate \"pretty good\" LLVM IR by running cretonne with <code>--target=llvm</code>, not just rustc but also whole range of languages whose compiler is written in rust can benefit from it.</p>\n</blockquote>",
        "id": 281213139,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651695086
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1037\">issue #1037</a>:</p>\n<blockquote>\n<p>I know that LLVM IR is not really similar with real machine isa, but there's some advantages if we can easily translate Cretonne IR to LLVM IR.</p>\n<p>It's well-known that LLVM is awfully slow for \"bad\" code, while cretonne is fast-by-default but currently lacking deep optimizations. I saw that there's a plan to use cretonne for rustc debug mode. But why should compilers handles two different target IR? If we can generate \"pretty good\" LLVM IR by running cretonne with <code>--target=llvm</code>, not just rustc but also whole range of languages whose compiler is written in rust can benefit from it.</p>\n</blockquote>",
        "id": 281213145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651695089
    }
]