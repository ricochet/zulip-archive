[
    {
        "content": "<p>uweigand opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289053505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657388333
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289216925,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657557089
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289216926,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657557089
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289216927,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657557090
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289216928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657557090
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 289216930,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657557090
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424#issuecomment-1187716395\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>I agree that this should be fixed. This was one of my early my contributions to the project (when things were quite different, <a href=\"https://github.com/bytecodealliance/cranelift/pull/1120\">https://github.com/bytecodealliance/cranelift/pull/1120</a>); using Cranelift apart from a WebAssembly translation was not top of mind back. Since both main architectures (x64 and aarch64) needed the mod operation, it seemed reasonable then to have the translation do it. Now it makes more sense to move the extra operations down into each backend that needs them.</p>\n</blockquote>",
        "id": 289990550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658162042
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4424\">issue #4424</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, the precise semantics of handling too-large shift counts for Cranelift vector shift instructions seemed unclear to me.   In the existing aarch64 and x86_64 targets, the Cranelift instructions are mapped directly to the native instructions, which happen to treat shift counts larger than the lane width by shifting everything off the end of the lane, i.e. resulting in an all-zero (or all-sign-bit-copies) lane element.</p>\n<p>This behavior is actually explicitly verified in the simd-bitwise-run.clif runtest:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">note</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">each</span><span class=\"w\"> </span><span class=\"n\">lane</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vconst</span><span class=\"p\">.</span><span class=\"n\">i16x8</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ishl</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>However, looking at the documentation, we have this statement:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">Integer</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"w\"> </span><span class=\"n\">towards</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">MSB</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">y</span><span class=\"err\">``</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">places</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Shift</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">LSB</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">amount</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">masked</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"err\">``</span><span class=\"n\">x</span><span class=\"err\">``</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">When</span><span class=\"w\"> </span><span class=\"n\">shifting</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">-</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"n\">computes</span>:\n\n            <span class=\"nc\">s</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">&amp;</span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">cdot</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"n\">pmod</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"p\">}.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, admittedly, this does not explicitly refer to vector types either way.  However, usually the semantics for the vector operation matches the one for the scalar operation, so I would have expected that the shift count would be considered modulo the lane size.</p>\n<p>And since the s390x vector shift instruction <em>does</em> implement that exact modulo semantics, I've simply implemented the Cranelift instruction directly with the native s390x instruction - only to see a failure in the runtest.</p>\n<p>Looking at the Wasmtime as main user of Cranelift, the WebAssembly vector shifts are also specified to use modulo semantics.  And indeed, the WebAssembly to Cranelift mapping adds an explicit modulo operation there:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">Operator</span>::<span class=\"n\">I8x16Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I16x8Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I32x4Shl</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span>::<span class=\"n\">I64x2Shl</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pop2</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitcast_a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">optionally_bitcast_vector</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i64</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">).</span><span class=\"n\">lane_bits</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// The spec expects to shift with `b mod lanewidth`; so, e.g., for 16 bit lane-width</span>\n<span class=\"w\">            </span><span class=\"c1\">// we do `b AND 15`; this means fewer instructions than `iconst + urem`.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">band_imm</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bitwidth</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">push1</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">ishl</span><span class=\"p\">(</span><span class=\"n\">bitcast_a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b_mod_bitwidth</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It seems to me it would be preferable to have the Cranelift IR semantics match the WebAssembly semantics, remove that explicit modulo operation during the WebAssembly-&gt;Cranelift translation, and add it to those back ends that need it.   This would allow efficient code generation on s390x without affecting performance on the other platforms.</p>\n<p>In any case, the documentation should be updated to explicitly define the Cranelift shift count semantics for vector types.</p>\n<p>FYI @cfallin @afonso360 <br>\n</p>\n</blockquote>",
        "id": 291084790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658944442
    }
]