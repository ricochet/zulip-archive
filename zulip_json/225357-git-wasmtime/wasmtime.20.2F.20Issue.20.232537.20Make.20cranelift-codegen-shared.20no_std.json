[
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753632372\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>The CI failure looks unrelated to the PR:</p>\n<blockquote>\n<p>rust-lld: error while loading shared libraries: <a href=\"http://libLLVM-11-rust-1.49.0-stable.so\">libLLVM-11-rust-1.49.0-stable.so</a>: cannot open shared object file: No such file or director</p>\n</blockquote>\n</blockquote>",
        "id": 221455359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687010
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753633207\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>This is for <a href=\"https://github.com/tomaka/redshirt\">https://github.com/tomaka/redshirt</a>, right?</p>\n</blockquote>",
        "id": 221455596,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687401
    },
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753633981\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is for <a href=\"https://github.com/tomaka/redshirt\">https://github.com/tomaka/redshirt</a>, right?</p>\n</blockquote>\n<p>Indeed! My current plan to fork everything and add (back) <code>no-std</code> compatibility. I'm upstreaming a few changes which I think are uncontroversial.</p>\n<p>Since redshirt isn't my actual job and the holiday season coming to an end, the chances of actually implementing <code>no-std</code> compatibility any time soon are pretty low, but I wanted to get something going.<br>\n</p>\n</blockquote>",
        "id": 221455796,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687720
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753633981\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is for <a href=\"https://github.com/tomaka/redshirt\">https://github.com/tomaka/redshirt</a>, right?</p>\n</blockquote>\n<p>Indeed! My current plan to fork everything and add (back) <code>no-std</code> compatibility in hacky ways. I'm upstreaming a few changes which I think are uncontroversial.</p>\n<p>Since redshirt isn't my actual job and the holiday season coming to an end, the chances of actually implementing <code>no-std</code> compatibility any time soon are pretty low, but I wanted to get something going.<br>\n</p>\n</blockquote>",
        "id": 221455797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687732
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753633981\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is for <a href=\"https://github.com/tomaka/redshirt\">https://github.com/tomaka/redshirt</a>, right?</p>\n</blockquote>\n<p>Indeed! My current plan to fork everything and add (back) <code>no-std</code> compatibility potentially in hacky ways (e.g. the <code>thiserror</code> dependency is fundamentally incompatible with no-std, so I'm changing it). I'm upstreaming a few changes which I think are uncontroversial.</p>\n<p>Since redshirt isn't my actual job and the holiday season coming to an end, the chances of actually implementing <code>no-std</code> compatibility any time soon are pretty low, but I wanted to get something going.<br>\n</p>\n</blockquote>",
        "id": 221455804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687753
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-753633981\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is for <a href=\"https://github.com/tomaka/redshirt\">https://github.com/tomaka/redshirt</a>, right?</p>\n</blockquote>\n<p>Indeed! My current plan to fork everything and add (back) <code>no-std</code> compatibility potentially in hacky ways (e.g. the <code>thiserror</code> dependency is fundamentally incompatible with no-std, so I'm changing it). I'm upstreaming a few changes which I think are uncontroversial.</p>\n<p>Since redshirt isn't my actual job and the holiday season is coming to an end, the chances of actually implementing <code>no-std</code> compatibility any time soon are pretty low, but I wanted to get something going.<br>\n</p>\n</blockquote>",
        "id": 221455807,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609687771
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754057070\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>We have a <a href=\"https://docs.wasmtime.dev/stability-platform-support.html#what-about-no_std\">somewhat lengthy documentation section</a> about why <code>#![no_std]</code> isn't currently used, would you be able to comment as to how your use case fits into that?</p>\n</blockquote>",
        "id": 221540663,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609775764
    },
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754074450\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>The patch to switch to #![no_std] is small, why not accept it?</p>\n</blockquote>\n<p>Ah sorry, I've seen this but a long time ago, and forgot the existence of this section.</p>\n<p>I'm building (on my free time) an operating system that executes Wasm programs on bare metal, directly in ring 0.</p>\n<blockquote>\n<p>For platforms without support for the Rust standard library the JIT compiler of Wasmtime often won't run on the platform as well. The JIT compiler requires mmap (or an equivalent), and presence of mmap often implies presence of a libc which means Rust's std library works.</p>\n</blockquote>\n<p>I can somewhat easily implement mmap (assuming <code>MAP_ANONYMOUS</code>) and threads on bare metal, but implementing a shim of libc or standard library full of <code>unimplemented!()</code> expressions just for <code>wasmtime</code> to work seems kind of \"wrong\", and way more efforts than forking wasmtime and replacing the platform-specific code with my own.<br>\n</p>\n</blockquote>",
        "id": 221545199,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609777607
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754074450\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>The patch to switch to #![no_std] is small, why not accept it?</p>\n</blockquote>\n<p>Ah sorry, I've seen this but a long time ago, and forgot the existence of this section.</p>\n<p>I'm building (on my free time) an operating system that executes Wasm programs on bare metal, directly in ring 0.<br>\nIt's already functional, but terribly slow as it's using <code>wasmi</code> the interpreter.</p>\n<blockquote>\n<p>For platforms without support for the Rust standard library the JIT compiler of Wasmtime often won't run on the platform as well. The JIT compiler requires mmap (or an equivalent), and presence of mmap often implies presence of a libc which means Rust's std library works.</p>\n</blockquote>\n<p>I can somewhat easily implement mmap (assuming <code>MAP_ANONYMOUS</code>) and threads on bare metal, but implementing a shim of libc or standard library full of <code>unimplemented!()</code> expressions just for <code>wasmtime</code> to work seems kind of \"wrong\", and way more efforts than forking wasmtime and replacing the platform-specific code with my own.<br>\n</p>\n</blockquote>",
        "id": 221545355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609777677
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754081130\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>I would personally recommend for your use case that using <code>std</code> is the way to go. The standard library already has targets like wasm itself which return errors for any unsupported operations (like <code>std::thread</code>), and if you're using <code>std</code> then this and other crates (like <code>wasmparser</code>) would just work.</p>\n</blockquote>",
        "id": 221546871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778324
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754086160\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>I would personally recommend for your use case that using std is the way to go.</p>\n</blockquote>\n<p>That would require forking the standard library.</p>\n<blockquote>\n<p>The standard library already has targets like wasm itself which return errors for any unsupported operations (like std::thread), and if you're using std then this and other crates (like wasmparser) would just work.</p>\n</blockquote>\n<p>Honestly that just feels like a hack. It shouldn't be possible to call functions when the kind of action (threads, filesystem, processes) doesn't exist at all on the target. The benefit of the current core, alloc, std split is that you can somewhat guarantee that code only depends on things that they should depend on. If the target doesn't support env vars and cranelift depends on libstd it is very easy to introduce a use of an env var to for example enable debug output. This would then break running cranelift on that target. By having cranelift depend only on core and alloc, this isn't possible.</p>\n</blockquote>",
        "id": 221548096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778864
    },
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754086352\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>If the objective is for the <code>std</code> to compile for every single platform, how would <code>wasmtime</code> know that a certain feature is <code>unimplemented!</code> or not?</p>\n<p>If I'm using <code>wasmtime 0.68</code>, how can I know that <code>wasmtime 0.69</code> or one of its dependencies doesn't sometimes call <code>std::fs::File::open</code>, which is <code>unimplemented!</code> and unimplementable?</p>\n<p>When it comes to <code>wasm32-unknown-unknown</code>, which is the one platform right now whose <code>std</code> has <code>unimplemented!()</code> portions, the outcome is that half of the Rust ecosystem uses <code>#[cfg(not(target_os = \"unknown\")]]</code> and uses Cargo features like <code>wasm-bindgen</code> or <code>stdweb</code> to know what to replace the <code>std</code> with.</p>\n</blockquote>",
        "id": 221548174,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778886
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754086352\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>If the objective is for the <code>std</code> to compile for every single platform, how would <code>wasmtime</code> know that a certain feature is <code>unimplemented!</code> or not?</p>\n<p>If I'm using <code>wasmtime 0.68</code>, how can I know that <code>wasmtime 0.69</code> or one of its dependencies doesn't sometimes call <code>std::fs::File::open</code>, which is <code>unimplemented!</code> and unimplementable?</p>\n<p>When it comes to <code>wasm32-unknown-unknown</code>, which is the one platform right now whose <code>std</code> has <code>unimplemented!()</code> portions, the outcome is that half of the Rust ecosystem uses <code>#[cfg(not(target_os = \"unknown\")]]</code> and uses Cargo features like <code>wasm-bindgen</code> or <code>stdweb</code> to know what to replace the <code>std</code> with. Instead of standardizing a list of features available to all crates, putting <code>unimplemented!()</code> causes an \"un-standardization\", as people replace the <code>std</code> with an alternative.</p>\n</blockquote>",
        "id": 221548309,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778962
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754086352\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>If the objective is for the <code>std</code> to compile for every single platform, how would <code>wasmtime</code> know that a certain feature is <code>unimplemented!</code> or not?</p>\n<p>If I'm using <code>wasmtime 0.68</code>, how can I know that <code>wasmtime 0.69</code> or one of its dependencies doesn't sometimes call <code>std::fs::File::open</code>, which is <code>unimplemented!</code> and unimplementable?</p>\n<p>When it comes to <code>wasm32-unknown-unknown</code>, which is the one platform right now whose <code>std</code> has <code>unimplemented!()</code> portions, the outcome is that half of the Rust ecosystem uses <code>#[cfg(not(target_os = \"unknown\")]]</code> and uses Cargo features like <code>wasm-bindgen</code> or <code>stdweb</code> to know what to replace the <code>std</code> with. Instead of standardizing a list of features available to all crates, putting <code>unimplemented!()</code> caused an \"un-standardization\", as people replace the <code>std</code> with an alternative.</p>\n</blockquote>",
        "id": 221548319,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778968
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754086352\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>If the objective is for the <code>std</code> to compile for every single platform, how would <code>wasmtime</code> know that a certain feature is <code>unimplemented!</code> or not?</p>\n<p>If I'm using <code>wasmtime 0.68</code>, how can I know that <code>wasmtime 0.69</code> or one of its dependencies doesn't sometimes call <code>std::fs::File::open</code>, which is <code>unimplemented!</code> and unimplementable?</p>\n<p>When it comes to <code>wasm32-unknown-unknown</code>, which is the one widely-used platform right now whose <code>std</code> has <code>unimplemented!()</code> portions, the outcome is that half of the Rust ecosystem uses <code>#[cfg(not(target_os = \"unknown\")]]</code> and uses Cargo features like <code>wasm-bindgen</code> or <code>stdweb</code> to know what to replace the <code>std</code> with. Instead of standardizing a list of features available to all crates, putting <code>unimplemented!()</code> caused an \"un-standardization\", as people replace the <code>std</code> with an alternative.</p>\n</blockquote>",
        "id": 221548365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609778990
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754098389\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>Call it a hack, call it a fork, the reality is that either libstd compiles for your platform or you force literally all users of your platform to not use <code>std</code>. Not using <code>std</code> has quite a large cost because there's lots of crates that would otherwise work (like this and <code>wasmparser</code>). Additionally not using <code>std</code> is not very idiomatic, weird workarounds, imports, etc, are required to get things compiling. Nothing is guaranteed to work anyway unless you're running on the platforms itself. I do not believe there is an objectively correct answer as to whether you should be able to call a function that always returns an error. @bjorn3 you think you shouldn't be able to do that, I disagree.</p>\n<p>I don't know why <code>std</code> <em>wouldn't</em> have the objective of compiling for all platforms. How does <code>wasmtime</code> today know if a feature is unimplemented or not? Someone runs the code and sends a PR to handle their platform if it dooesn't work. You have no guarantee future versions will continue to work, but you never have a guarantee about that unless your target is added to Wasmtime's CI. In no way does using <code>no_std</code> here provide you with any degree of guarantee that things will always work into the future.</p>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime. Are all Rust ecosystem crates expected to cater to all hobbyist's whims?</p>\n</blockquote>",
        "id": 221551226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780186
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754102652\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime.</p>\n</blockquote>\n<p>Wasmtime interacts a lot with the outside world due to memory mapping, filesystem accesses and terminal accesses. Cranelift on the other hand doesn't interact with the outside world. It only requires a memory allocator because using a large fixed size chunk of memory is inefficient and would complicate code. The Cranelift embedded may or may not interact with the outside world, but Cranelift itself is a observably equivalent to a function from clif ir to bytes. (ignoring OOM's)</p>\n</blockquote>",
        "id": 221552269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780678
    },
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754103448\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime. Are all Rust ecosystem crates expected to cater to all hobbyist's whims?</p>\n</blockquote>\n<p>I mentioned \"so feel free to close this PR if it is inappropriate.\". I legitimately didn't remember that there was a guideline against small no-std-compatibility PRs.</p>\n<blockquote>\n<p>all it a hack, call it a fork, the reality is that either libstd compiles for your platform or you force literally all users of your platform to not use std. Not using std has quite a large cost because there's lots of crates that would otherwise work (like this and wasmparser). Additionally not using std is not very idiomatic, weird workarounds, imports, etc, are required to get things compiling.</p>\n</blockquote>\n<p>I'm of the complete opposite view.</p>\n<p>I have personally been some traumatised trying to make <a href=\"https://github.com/paritytech/polkadot/\">a big project</a> work for <code>wasm32-unknown-unknown</code> that I've restarted the codebase from scratch with a strict <code>no_std</code> requirement, because in practice it's what works. Going through the hundreds of direct and indirect dependencies figuring out how they use their <code>wasm-bindgen</code> features and fixing issues because they use features that aren't implemented drove me insane. I have absolutely no intention of doing the same thing for <code>wasmtime</code>.<br>\n</p>\n</blockquote>",
        "id": 221552476,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780760
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754103448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime. Are all Rust ecosystem crates expected to cater to all hobbyist's whims?</p>\n</blockquote>\n<p>I mentioned \"so feel free to close this PR if it is inappropriate.\". I legitimately didn't remember that there was a guideline against small no-std-compatibility PRs.</p>\n<blockquote>\n<p>all it a hack, call it a fork, the reality is that either libstd compiles for your platform or you force literally all users of your platform to not use std. Not using std has quite a large cost because there's lots of crates that would otherwise work (like this and wasmparser). Additionally not using std is not very idiomatic, weird workarounds, imports, etc, are required to get things compiling.</p>\n</blockquote>\n<p>I'm of the complete opposite view.</p>\n<p>I have personally been somewhat traumatised trying to make <a href=\"https://github.com/paritytech/polkadot/\">a big project</a> work for <code>wasm32-unknown-unknown</code> that I've restarted the codebase from scratch with a strict <code>no_std</code> requirement, because in practice it's what works. Going through the hundreds of direct and indirect dependencies figuring out how they use their <code>wasm-bindgen</code> features and fixing issues because they use features that aren't implemented drove me insane. I have absolutely no intention of doing the same thing for <code>wasmtime</code>.<br>\n</p>\n</blockquote>",
        "id": 221552529,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780786
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754103448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime. Are all Rust ecosystem crates expected to cater to all hobbyist's whims?</p>\n</blockquote>\n<p>I mentioned \"so feel free to close this PR if it is inappropriate.\". I legitimately didn't remember that there was a guideline against small no-std-compatibility PRs.</p>\n<blockquote>\n<p>all it a hack, call it a fork, the reality is that either libstd compiles for your platform or you force literally all users of your platform to not use std. Not using std has quite a large cost because there's lots of crates that would otherwise work (like this and wasmparser). Additionally not using std is not very idiomatic, weird workarounds, imports, etc, are required to get things compiling.</p>\n</blockquote>\n<p>I'm of the complete opposite view.</p>\n<p>I have personally been somewhat traumatised trying to make <a href=\"https://github.com/paritytech/polkadot/\">a big project</a> work for <code>wasm32-unknown-unknown</code> that I've restarted the codebase from scratch with a strict <code>no_std</code> requirement, because in practice, I cannot stress it enough, it's what works. Going through the hundreds of direct and indirect dependencies figuring out how they use their <code>wasm-bindgen</code> features and fixing issues because they use features that aren't implemented drove me insane. I have absolutely no intention of doing the same thing for <code>wasmtime</code>.<br>\n</p>\n</blockquote>",
        "id": 221552611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780806
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754103448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall I feel there's an imbalance here when a hobbyist's personal project impacts the idioms in a project like Wasmtime. Are all Rust ecosystem crates expected to cater to all hobbyist's whims?</p>\n</blockquote>\n<p>I mentioned \"so feel free to close this PR if it is inappropriate.\". I legitimately didn't remember that there was a guideline against small no-std-compatibility PRs.</p>\n<blockquote>\n<p>all it a hack, call it a fork, the reality is that either libstd compiles for your platform or you force literally all users of your platform to not use std. Not using std has quite a large cost because there's lots of crates that would otherwise work (like this and wasmparser). Additionally not using std is not very idiomatic, weird workarounds, imports, etc, are required to get things compiling.</p>\n</blockquote>\n<p>I'm of the complete opposite view.</p>\n<p>I have personally been somewhat traumatised trying to make <a href=\"https://github.com/paritytech/polkadot/\">a big project</a> work for <code>wasm32-unknown-unknown</code> that I've restarted the codebase from scratch with a strict <code>no_std</code> requirement, because in practice, I cannot stress this enough, it's what works. Going through the hundreds of direct and indirect dependencies figuring out how they use their <code>wasm-bindgen</code> features and fixing issues because they use features that aren't implemented drove me insane. I have absolutely no intention of doing the same thing for <code>wasmtime</code>.<br>\n</p>\n</blockquote>",
        "id": 221552662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609780829
    },
    {
        "content": "<p>tomaka <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754105634\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>To repeat my opinion, as someone who now has a lot of experience in <code>no_std</code> compatibility, forking <code>wasmtime</code> to make it no-std-compatible seems tremendously easier and more sane than writing a custom <code>std</code> implementation full of shim functions.</p>\n</blockquote>",
        "id": 221553046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609781019
    },
    {
        "content": "<p>tomaka edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754105634\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>To repeat my opinion, as someone who now has a lot of experience in <code>no_std</code> compatibility, forking <code>wasmtime</code> to make it no-std-compatible (and, I guess, without upstreaming patches) seems tremendously easier and more sane than writing a custom <code>std</code> implementation full of shim functions.</p>\n</blockquote>",
        "id": 221553137,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609781046
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754117484\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>To be clear, I'm speaking my personal opinions here, I don't represent all contributors to this project. I would recommend you prototype the <code>std</code>-based solution to get an idea for how hard it might be, there's been upstream work to make new targets very easy to add to <code>std</code>. There's also nothing set in stone for how hobbyist targets are handled in libstd, I'm happy to have a conversation about how to best support that if you'd like, but if you'd rather not have such a conversation that's ok too.</p>\n</blockquote>",
        "id": 221556155,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609782415
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537#issuecomment-754121326\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2537\">Issue #2537</a>:</p>\n<blockquote>\n<p>Speaking only about Cranelift, the effort to make the core compiler crates no_std (and keep them that way) does not seem <em>too</em> bad -- swap/add some <code>use</code> statements and maybe add a CI job to grep for <code>std::</code> in certain directories -- and I'd be happy to review such a thing if others in the project were onboard. (This would need changes in the <code>regalloc</code> crate as well.) I can certainly see the value in having a nice, portable, minimal-dependencies JIT compiler library (as @bjorn3 says, in theory a compiler should need nothing other than memory allocation). I'd defer to others on the rest of Wasmtime; the runtime portability issue seems like a much more difficult question.</p>\n</blockquote>",
        "id": 221557063,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609782867
    }
]