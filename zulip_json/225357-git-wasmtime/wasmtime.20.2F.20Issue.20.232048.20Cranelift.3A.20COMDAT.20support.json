[
    {
        "content": "<p>carlokok opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048\">Issue #2048</a>:</p>\n<blockquote>\n<p>COMDAT can be used for two purposes:</p>\n<ul>\n<li>Allow multiple symbols with the same name without linking failures(pick largest, pick any, etc)</li>\n<li>Bind symbols together </li>\n</ul>\n<p>This is very useful for using Cranelift as a compiler backend (for example any c++ implementation requires comdat). Can easily be done now that object supports comdat too: <a href=\"https://github.com/gimli-rs/object/pull/243\">https://github.com/gimli-rs/object/pull/243</a></p>\n<h4>Feature</h4>\n<p>&lt;!-- What is the feature or code improvement you would like to do in<br>\nCranelift/Wasmtime? --&gt;</p>\n<h4>Benefit</h4>\n<p>It's currently not possible to do COMDAT at all, thus any duplicate symbol will fail.</p>\n<h4>Implementation</h4>\n<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>\nalgorithms to use? --&gt;</p>\n<p>Open for suggestions, but was thinking something like how LLVM does it:</p>\n<p>Module gets a list of comdat records consisting of a name + mode:</p>\n<p>any<br>\nThe linker may choose any COMDAT key, the choice is arbitrary.<br>\nexactmatch<br>\nThe linker may choose any COMDAT key but the sections must contain the same data.<br>\nlargest<br>\nThe linker will choose the section containing the largest COMDAT key.<br>\nnoduplicates<br>\nThe linker requires that only section with this COMDAT key exist.<br>\nsamesize<br>\nThe linker may choose any COMDAT key but the sections must contain the same amount of data.</p>\n<p>Then for data and for function symbols, an associated comdat recordid can be set (without changing the public interface, so something like set_comdat on DataSection/Context.</p>\n<p>For Mach-O and Wasm this should fail, for COFF the name should match 1 of the functions or data by name. For ELF the mode much be any. When emitting, Fairie should fail or ignore when set, Object should work, and jit should probably ignore it all together.</p>\n<h4>Alternatives</h4>\n<p>None really.</p>\n</blockquote>",
        "id": 204461491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595271505
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048#issuecomment-661277777\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048\">Issue #2048</a>:</p>\n<blockquote>\n<blockquote>\n<p>When emitting, Fairie should fail or ignore when set, Object should work, and jit should probably ignore it all together.</p>\n</blockquote>\n<p>I think it should fail for both fairie and jit. It should not silently ignore it when you didn't explicitly say that it is okay to ignore it, as that could cause (relatively) hard to debug problems.</p>\n</blockquote>",
        "id": 204462614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595271976
    },
    {
        "content": "<p>carlokok <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048#issuecomment-669041583\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048\">Issue #2048</a>:</p>\n<blockquote>\n<p>Api wise I was thinking something like:</p>\n<p>add_comdat(&amp;Self, main: FuncOrVarRef, mode: ComdatMode, symbols: &amp;[FuncOrVarRef])</p>\n<p>(is there a FuncRef or GlobalVariableRef I can use for this?)</p>\n<p>Any suggestions?</p>\n<p>Technically, comdat binds a symbol of an existing global (func or var) to 1 or more extra sections. Not 100% sure this is the best design for that.</p>\n</blockquote>",
        "id": 205996603,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1596613994
    },
    {
        "content": "<p>bnjbvr labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048\">Issue #2048</a>:</p>\n<blockquote>\n<p>COMDAT can be used for two purposes:</p>\n<ul>\n<li>Allow multiple symbols with the same name without linking failures(pick largest, pick any, etc)</li>\n<li>Bind symbols together </li>\n</ul>\n<p>This is very useful for using Cranelift as a compiler backend (for example any c++ implementation requires comdat). Can easily be done now that object supports comdat too: <a href=\"https://github.com/gimli-rs/object/pull/243\">https://github.com/gimli-rs/object/pull/243</a></p>\n<h4>Feature</h4>\n<p>&lt;!-- What is the feature or code improvement you would like to do in<br>\nCranelift/Wasmtime? --&gt;</p>\n<h4>Benefit</h4>\n<p>It's currently not possible to do COMDAT at all, thus any duplicate symbol will fail.</p>\n<h4>Implementation</h4>\n<p>&lt;!-- Do you have an implementation plan, and/or ideas for data structures or<br>\nalgorithms to use? --&gt;</p>\n<p>Open for suggestions, but was thinking something like how LLVM does it:</p>\n<p>Module gets a list of comdat records consisting of a name + mode:</p>\n<p>any<br>\nThe linker may choose any COMDAT key, the choice is arbitrary.<br>\nexactmatch<br>\nThe linker may choose any COMDAT key but the sections must contain the same data.<br>\nlargest<br>\nThe linker will choose the section containing the largest COMDAT key.<br>\nnoduplicates<br>\nThe linker requires that only section with this COMDAT key exist.<br>\nsamesize<br>\nThe linker may choose any COMDAT key but the sections must contain the same amount of data.</p>\n<p>Then for data and for function symbols, an associated comdat recordid can be set (without changing the public interface, so something like set_comdat on DataSection/Context.</p>\n<p>For Mach-O and Wasm this should fail, for COFF the name should match 1 of the functions or data by name. For ELF the mode much be any. When emitting, Fairie should fail or ignore when set, Object should work, and jit should probably ignore it all together.</p>\n<h4>Alternatives</h4>\n<p>None really.</p>\n</blockquote>",
        "id": 211140513,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1600958330
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048#issuecomment-698387655\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2048\">Issue #2048</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 211140553,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1600958347
    }
]