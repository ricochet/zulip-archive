[
    {
        "content": "<p>avanhatt opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5700\">issue #5700</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>In verification conversations, it’s come up that we don’t have a precise semantics for the underlying <code>u64</code> when a CLIF <code>iconst</code> has a narrow type (i.e., <code>i8</code>). Should the narrow constant be sign-extended, should it be zero-extended, or should the upper bits be semantically unspecified?</p>\n<p>For example, for rules that use <code>Imm12</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"c1\">;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">imm12_from_value</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Imm12</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"nv\">imm12_from_value</span><span class=\"w\"> </span><span class=\"nv\">n</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"nv\">def_inst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">iconst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">u64_from_imm64</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">imm12_from_u64</span><span class=\"w\"> </span><span class=\"nv\">n</span><span class=\"p\">)))))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This external extractor is called:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"sd\">/// Compute a Imm12 from raw bits, if possible.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">maybe_from_u64</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Imm12</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// …</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mh\">0xfff</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// …</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mh\">0xfff_000</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mh\">0xfff</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// …</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This seems to assume that constants are sign-extended, since we're comparing against 64-wide constants and because immediate arithmetic instructions do not sign extend (or, at minimum, this assumes the upper bits are not unspecified). </p>\n<p>However, <a href=\"https://github.com/bytecodealliance/wasmtime/commit/244dce93f67b717cb6e77dc8d74d92052be165d8\">this bug fix</a> for constant propagation in the midend implies that upper bits are unspecified and that bugs can occur from interpreting them: “this was producing iconsts with set high bits beyond their types' width, which is not legal.”</p>\n<p>Because the verifier essentially models these <code>iconsts</code> as zero-extended, the verifier _does not_ find a bug on the code before the bug fix for #5405. That is, <a href=\"https://github.com/avanhatt/wasmtime/blob/cprop/cranelift/isle/veri/veri_engine/examples/midend/old_cprop.isle\">this code</a> verifies successfully even using <code>imm64</code> and not <code>imm64_masked </code>. If using <code>imm64</code> here without masking is a bug, we need to update our the verifier's modeling to find it. </p>\n<h4>Benefit</h4>\n<p>We need precise semantics for verification. :) </p>\n<p>We can also use this as a chance to audit for other bugs where there might be missing masking behavior.</p>\n<h4>Implementation</h4>\n<p>This doesn’t strictly need to change the implementation; but might be wise to add assertions of this behavior. </p>\n<h4>Alternatives</h4>\n<p><code>iconst</code> could have a more complicated backing Rust type where different widths are modeled with the correct type (e.g., <code>u8</code>), this is probably infeasible for performance reasons.<br>\n</p>\n</blockquote>",
        "id": 325701042,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675449790
    }
]