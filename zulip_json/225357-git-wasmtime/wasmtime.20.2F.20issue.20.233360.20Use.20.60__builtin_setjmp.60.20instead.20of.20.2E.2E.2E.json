[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921110484\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<blockquote>\n<p>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make __builtin_setjmp and __builtin_longjmp more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</p>\n</blockquote>\n<p>This has me worried. What are the exact conditions in which this causes incorrect behavior?</p>\n</blockquote>",
        "id": 253622460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631814841
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921157941\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<blockquote>\n<p>This has me worried. What are the exact conditions in which this causes incorrect behavior?</p>\n</blockquote>\n<p>Suppose one of the hardware architectures we support added a new register, and decides to have a convention that it's compiler-managed, and callee-saved. The host compiler doesn't use the new register, because it's targeting the generic architecture family, but Cranelift does use the new register, because cranelift-native.</p>\n<p>Then we could get into a situation like this:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"c1\">// compiled by cranelift</span>\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">outer</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">write_the_new_register</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">catcher</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">read_the_new_register</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// compiled by the host compiler</span>\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">catcher</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">__builtin_setjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">inner</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// compiled by cranelift</span>\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">auto</span><span class=\"w\"> </span><span class=\"n\">save</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">read_the_new_register</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">clobber_the_new_register</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">condition</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">jumper</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">write_the_new_register</span><span class=\"p\">(</span><span class=\"n\">save</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// compiled by the host compiler</span>\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">jumper</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">__builtin_longjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In practice, this should be rare, because the major architectures don't add new registers very often, and when they do, it's usually not compiler-managed, and when it is, it's usually call-clobbered. New compiler-managed callee-saved state also breaks many existing <code>libc</code>-implemented <code>setjmp</code> functions in the same way, so it's not often done.<br>\n</p>\n</blockquote>",
        "id": 253631447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631818313
    },
    {
        "content": "<p>froydnj <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921158575\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make __builtin_setjmp and __builtin_longjmp more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</p>\n</blockquote>\n<p>This has me worried. What are the exact conditions in which this causes incorrect behavior?</p>\n</blockquote>\n<p>It doesn't require mixing and matching with the full register set.  You run into problems like <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98997\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98997</a> for instance (clang has the same problem).</p>\n<p>This particular case is not a problem for wasmtime, because all access to <code>__builtin_{set,long}jmp</code> should be within wasmtime itself (and you shouldn't be able to mix-and-match wasmtime runtimes...)</p>\n</blockquote>",
        "id": 253631608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631818370
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921165880\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<blockquote>\n<p>In practice, this should be rare, because the major architectures don't add new registers very often</p>\n</blockquote>\n<p>ymm/zmm for avx/avx512 are by default unknown to the compiled wasmtime as only SSE2 is enabled by default for most x86_64 targets.</p>\n<blockquote>\n<p>and when it is, it's usually call-clobbered.</p>\n</blockquote>\n<p>I see. The x86_64 SystemV does indeed list xmm, ymm and zmm as being clobbered.</p>\n</blockquote>",
        "id": 253633510,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631819033
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921166204\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<p>Thanks for that link! Yes, in our case, we know that <code>__builtin_setjmp</code> and <code>__builtin_longjmp</code> are compiled by the same compiler with the same flags&mdash;they're in the same source file, so we're safe from that particular hazard at least.</p>\n<p>We do have a hazard though, in the case of a mismatch between Cranelift's and the host compiler's callee-saved registers. I've added a comment about this to the PR; I'm open to ideas for what else we can do here.</p>\n</blockquote>",
        "id": 253633625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631819061
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921168530\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<p>For completeness, a form of this hazard is already present in Wasmtime; if someone statically links Wasmtime, the statically-linked-in <code>sigsetjmp</code> will hard-code the registers to save, and if Cranelift at runtime detects and uses more registers and relies on them being callee-saved, it'll also trigger UB.</p>\n</blockquote>",
        "id": 253634196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631819280
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-921231309\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<p>We may need to disable this for AArch64 with <code>clang</code>, locally when I try to compile it spits out:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">c</span>:<span class=\"mi\">34</span>:<span class=\"mi\">7</span>: <span class=\"nc\">error</span>: <span class=\"nc\">__builtin_setjmp</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">supported</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">platform_setjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"o\">^~~~~~~~~~~~~~~~~~~~</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">c</span>:<span class=\"mi\">23</span>:<span class=\"mi\">30</span>: <span class=\"nc\">note</span>: <span class=\"nc\">expanded</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">platform_setjmp</span><span class=\"o\">'</span><span class=\"w\"></span>\n#<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">platform_setjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">__builtin_setjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">                             </span><span class=\"o\">^~~~~~~~~~~~~~~~~~~~~</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">c</span>:<span class=\"mi\">44</span>:<span class=\"mi\">3</span>: <span class=\"nc\">error</span>: <span class=\"nc\">__builtin_longjmp</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">supported</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">platform_longjmp</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">^~~~~~~~~~~~~~~~~~~~~~~~~</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">c</span>:<span class=\"mi\">24</span>:<span class=\"mi\">36</span>: <span class=\"nc\">note</span>: <span class=\"nc\">expanded</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">platform_longjmp</span><span class=\"o\">'</span><span class=\"w\"></span>\n#<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">platform_longjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">__builtin_longjmp</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">                                   </span><span class=\"o\">^~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span class=\"w\"></span>\n<span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">errors</span><span class=\"w\"> </span><span class=\"n\">generated</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Poking around in clang it looks like this is gated on <code>hasSjLjLowering</code> which is true for x86 and arm but not for AArch64</p>\n</blockquote>",
        "id": 253647732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631825014
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360#issuecomment-922107817\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3360\">issue #3360</a>:</p>\n<blockquote>\n<p>I fixed the code to compile on clang on aarch64, where <code>__builtin_setmp</code> isn't supported. If there are other architectures/compilers that don't support it, we can add them as needed.</p>\n<p>Talking about this with @cfallin offline, adding new callee-saved registers to cranelift amounts to adding a new ABI, and there are lots of considerations, including calls to and from host code, the register save/restore code in wasmtime-fiber, the <code>__builtin_setjmp</code> issue here, trampolines, and possibly other things, so we'll need to carefully think through the design at that time. I've added a comment to the code added in this PR, which seems to be the main useful thing we can do for now.<br>\n</p>\n</blockquote>",
        "id": 253814171,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631916538
    }
]