[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1033715813\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"cranelift:area:aarch64\", \"cranelift:area:machinst\", \"cranelift:area:x64\", \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 271269850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1644410194
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1040264854\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>So I think a <code>lower_zero</code>, <code>lower_one</code>, maybe a special <code>lower_two</code> for instructions that statically produce exactly two results (e.g. <code>iadd_ifcout</code>-alikes) and <code>lower_variable</code> for calls (even if they produce 0, 1, or 2 results, this is known only at compile time) would make sense. Thoughts?</p>\n</blockquote>\n<p>I guess what's not quite clear about this to me is just where that distinction would be introduced.   If we have different lowering functions with different return types, we won't be able to handle all of them with a single <code>lower_common</code> handler, as the latter depends on the particular return type.</p>\n<p>So should we have a <code>lower_common</code> that takes four different lower routines, and then internally decides which of them to use (based on the opcode, I guess?), and then handles each of them separately according to their return value?</p>\n<p>Or should <code>lower_common</code> be modified to handle different return types, based on some template magic I guess, and then the various back-ends could use different instantiations, and chose by themselves which version to use (again based on the opcode, but now probably in the already-existing switch statements in the back-ends?)?<br>\n</p>\n</blockquote>",
        "id": 271972232,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1644931231
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1042495022\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>I guess what's not quite clear about this to me is just where that distinction would be introduced. If we have different lowering functions with different return types, we won't be able to handle all of them with a single <code>lower_common</code> handler, as the latter depends on the particular return type.</p>\n<p>So should we have a <code>lower_common</code> that takes four different lower routines, and then internally decides which of them to use (based on the opcode, I guess?), and then handles each of them separately according to their return value?</p>\n<p>Or should <code>lower_common</code> be modified to handle different return types, based on some template magic I guess, and then the various back-ends could use different instantiations, and chose by themselves which version to use (again based on the opcode, but now probably in the already-existing switch statements in the back-ends?)?</p>\n</blockquote>\n<p>This is a good question; the general principle would be to dispatch somewhere before we enter ISLE code so we end up with the type-safety once we get to specific rules. My first instinct is to have something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">IsleEntrypoints</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lower_zero</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lower_one</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">ValueRegs</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lower_two</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">ValueRegs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ValueRegs</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lower_variable</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">SmallVec</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">ValueRegs</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to replace the <code>IF</code> closure we currently parameterize <code>lower_common</code> on, and then</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Arity (number of result values) for an instruction. Note that we make special distinctions</span>\n<span class=\"sd\">/// for:</span>\n<span class=\"sd\">/// - zero-result instructions: these are used for their side-effects only;</span>\n<span class=\"sd\">/// - one-result instructions: the most common kind, computing one new value;</span>\n<span class=\"sd\">/// - two-result instructions: some instructions produce two fixed outputs, like addend and carry;</span>\n<span class=\"sd\">/// - variable-result instructions: instructions like calls that produce some number of results different</span>\n<span class=\"sd\">///   for each instance of the instruction. Note that even a call with 0/1/2 results, dynamically, is still</span>\n<span class=\"sd\">///   `Variable`.</span>\n<span class=\"k\">enum</span> <span class=\"nc\">InstArity</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Zero</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">One</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Two</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Variable</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">InstData</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">arity</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">InstArity</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now that I've sketched that out, though, I'm wavering a bit on whether this is really better than just a <code>SmallVec</code> at the <code>lower_common</code> level (as long as the <code>SmallVec</code> is properly sized; 2 <code>ValueRegs</code> is probably optimal, since multivalue calls are rare and a too-large inline vec will cause measurable memcpy cost?), and then let each backend dispatch into specialized entry points as desired. @fitzgen any thoughts here?</p>\n</blockquote>",
        "id": 272205628,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645063595
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043271039\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<p>Don't we already know the number of expected results, and therefore don't need the <code>InstArity</code> that you've sketched?</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/37b0fd482d5ba2fafa3c8f73ab366e739116c58d/cranelift/codegen/src/isa/x64/lower.rs#L1189-L1191\">https://github.com/bytecodealliance/wasmtime/blob/37b0fd482d5ba2fafa3c8f73ab366e739116c58d/cranelift/codegen/src/isa/x64/lower.rs#L1189-L1191</a></p>\n</blockquote>",
        "id": 272301972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645122231
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043284888\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<p>The additional information needed is whether the number of outputs is fixed or variable; e.g. for <code>call</code> it may happen to have one result in this (and most) instances of the instruction, but it still needs the variable path.</p>\n<p>The idea with the <code>Arity</code> enum was to allow a clean one-to-one <code>match</code> that dispatches into the trait but I suppose we could also have something like <code>has_variable_results()</code>. (Curiously, we do have <code>inst_variable_args</code> that allows this fixed/variable distinction on the inputs side, but nothing equivalent for results.)</p>\n<p>Diving further into this rabbithole though I'm starting to think that just dispatching in the platform-specific glue into its ISLE toplevel is maybe a better answer: match on op, do a special entrypoint for calls (calls are special anyway in lots of ways), nothing else should be variable so then invoke <code>lower_{zero,one,two}</code> based on actual result count as you suggest; and return a <code>SmallVec</code> to <code>lower_common</code>...</p>\n</blockquote>",
        "id": 272303635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645122945
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043287841\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>Diving further into this rabbithole though I'm starting to think that just dispatching in the platform-specific glue into its ISLE toplevel is maybe a better answer: match on op, do a special entrypoint for calls (calls are special anyway in lots of ways), nothing else should be variable so then invoke <code>lower_{zero,one,two}</code> based on actual result count as you suggest; and return a <code>SmallVec</code> to <code>lower_common</code>...</p>\n</blockquote>\n<p>SGTM <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 272304058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645123129
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043294886\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>Diving further into this rabbithole though I'm starting to think that just dispatching in the platform-specific glue into its ISLE toplevel is maybe a better answer: match on op, do a special entrypoint for calls (calls are special anyway in lots of ways), nothing else should be variable so then invoke <code>lower_{zero,one,two}</code> based on actual result count as you suggest; and return a <code>SmallVec</code> to <code>lower_common</code>...</p>\n</blockquote>\n<p>If you always return a <code>SmallVec</code> to <code>lower_common</code>, then what's even the benefit of multiple lower constructors?   Can't we then just go back to my approach (except with <code>SmallVec</code> instead of <code>Vec</code>) plus (the upcoming) default conversions?</p>\n</blockquote>",
        "id": 272305054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645123576
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043300516\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>If you always return a <code>SmallVec</code> to <code>lower_common</code>, then what's even the benefit of multiple lower constructors? Can't we then just go back to my approach (except with <code>SmallVec</code> instead of <code>Vec</code>) plus (the upcoming) default conversions?</p>\n</blockquote>\n<p>The advantage of at least having the distinction at the ISLE layer is type safety, mainly -- we can at least encode the restriction that, say, <code>iadd</code> should result in just one Value in the lowering rules, even if the toplevel driver is generic. It also keeps the rules in a form that is easier to invoke in a more efficient way if we do want/need to do something better than the generic approach in the future.</p>\n<p>I'm not completely tied to this of course, and the way we're thinking of doing this now it would be a per-backend decision, so IMHO at least it'sOK to do the fully generic thing in s390x if you feel really strongly here.</p>\n</blockquote>",
        "id": 272305833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645123945
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043300516\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>If you always return a <code>SmallVec</code> to <code>lower_common</code>, then what's even the benefit of multiple lower constructors? Can't we then just go back to my approach (except with <code>SmallVec</code> instead of <code>Vec</code>) plus (the upcoming) default conversions?</p>\n</blockquote>\n<p>The advantage of at least having the distinction at the ISLE layer is type safety, mainly -- we can at least encode the restriction that, say, <code>iadd</code> should result in just one Value in the lowering rules, even if the toplevel driver is generic. It also keeps the rules in a form that is easier to invoke in a more efficient way if we do want/need to do something better than the generic approach in the future.</p>\n<p>I'm not completely tied to this of course, and the way we're thinking of doing this now it would be a per-backend decision, so IMHO at least it's OK to do the fully generic thing in s390x if you feel really strongly here.</p>\n</blockquote>",
        "id": 272305883,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645123974
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043308163\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>The advantage of at least having the distinction at the ISLE layer is type safety, mainly -- we can at least encode the restriction that, say, <code>iadd</code> should result in just one Value in the lowering rules, even if the toplevel driver is generic. </p>\n</blockquote>\n<p>But <code>lower_common</code> would continue to verify that it got the correct number of outputs, so I'm sure I see what additional benefit this provides?   If you have multiple constructors, you instead have the potential source of error of calling the wrong constructor for some opcode ...</p>\n<blockquote>\n<p>It also keeps the rules in a form that is easier to invoke in a more efficient way if we do want/need to do something better than the generic approach in the future.</p>\n<p>I'm not completely tied to this of course, and the way we're thinking of doing this now it would be a per-backend decision, so IMHO at least it's OK to do the fully generic thing in s390x if you feel really strongly here.</p>\n</blockquote>\n<p>I don't really feel strongly either ...    I guess once the default conversion patch is in, I can update this PR to use those (and switch to a <code>SmallVec</code>), then we can see how it looks.</p>\n</blockquote>",
        "id": 272306904,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645124448
    },
    {
        "content": "<p>uweigand edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1043308163\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>The advantage of at least having the distinction at the ISLE layer is type safety, mainly -- we can at least encode the restriction that, say, <code>iadd</code> should result in just one Value in the lowering rules, even if the toplevel driver is generic. </p>\n</blockquote>\n<p>But <code>lower_common</code> would continue to verify that it got the correct number of outputs, so I'm not sure I see what additional benefit this provides?   If you have multiple constructors, you instead have the potential source of error of calling the wrong constructor for some opcode ...</p>\n<blockquote>\n<p>It also keeps the rules in a form that is easier to invoke in a more efficient way if we do want/need to do something better than the generic approach in the future.</p>\n<p>I'm not completely tied to this of course, and the way we're thinking of doing this now it would be a per-backend decision, so IMHO at least it's OK to do the fully generic thing in s390x if you feel really strongly here.</p>\n</blockquote>\n<p>I don't really feel strongly either ...    I guess once the default conversion patch is in, I can update this PR to use those (and switch to a <code>SmallVec</code>), then we can see how it looks.</p>\n</blockquote>",
        "id": 272307208,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645124572
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783#issuecomment-1049781724\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3783\">issue #3783</a>:</p>\n<blockquote>\n<blockquote>\n<p>I guess once the default conversion patch is in, I can update this PR to use those (and switch to a <code>SmallVec</code>), then we can see how it looks.</p>\n</blockquote>\n<p>OK, just pushed an updated version.   The changes to the platform lower.isle files actually look very reasonable to me now, the default conversions can indeed handle nearly everything.  The only nontrival changes are about <code>iadd_ifcout</code> (which is an improvement anyway), and replacing <code>value_regs_none</code> by <code>side_effect</code> (only used by s390x, and I think also an improvement).</p>\n<p>What do you think?<br>\n</p>\n</blockquote>",
        "id": 273078863,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645703509
    }
]