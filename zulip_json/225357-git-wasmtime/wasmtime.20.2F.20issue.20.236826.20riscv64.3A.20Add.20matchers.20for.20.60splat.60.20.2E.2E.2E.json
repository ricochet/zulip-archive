[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6826\">issue #6826</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>In the RISC-V backend we have a bunch of lowering rules that match for example <code>(iadd x (splat y))</code>, this is a byproduct of some opcodes reading from an F or X register as their source and using that on each operation. (Every <code>.vx</code> or <code>.vf</code> opcode essentially).</p>\n<p>We have a lot of these opcodes and rules. However, we also have a mid-end rule that transforms <code>(splat (iconst _))</code> into <code>(vconst _)</code> (#6148), which is a reasonable thing to have and should lets us const propagate further. But in our case that causes us to materialize the entire <code>vconst</code> when we could avoid it.</p>\n<p>We can do better and materialize each element into a register, and use that with the special opcodes.</p>\n<h4>Benefit</h4>\n<p>This would allow us to more broadly use <code>.vx</code> and <code>.vf</code> opcodes when the splatted argument is a constant. Which would hopefully reduce the amount of constant generation instructions / memory bandwidth.</p>\n<p>This is only relevant for optimized builds which run the mid-end, on unoptimized builds we may actually currently generate better code!</p>\n<h4>Implementation</h4>\n<p>Essentially I would like to have an extractor that would match either a <code>splat</code>, or a <code>vconst</code> that repeats the elements. This is very similar to  #6527 but slightly more applicable since it works for <code>.vx</code> and <code>.vf</code> instead of only <code>.vi</code> opcodes.</p>\n<p>One of the issues here is that we actually still have to materialize the constant into a X or F register using the regular materialization rules. But extractors should be pure and not have side effects (AFAIK).</p>\n<p>I'm not sure if we are allowed to have extractors that have side effects when they are guaranteed to match? That would be the best in terms of ergonomics, since we could use it like any other extractor and pretend that the source X or F register was always there.</p>\n<p>Otherwise I'm not entirely sure, we could split it into an extractor that just matches when this is possible and a separate rule that actually materializes the register. This would definitely work but would just have slightly worse ergonomics. (However it would be less surprising, which is a big positive)</p>\n<h4>Alternatives</h4>\n<p>I don't  think removing the mid end rules is a very good idea. I don't think we do any other const propagation on <code>vconst</code> yet, but it would be nice not to regress that.</p>\n<p>We also don't have to do this, most likely this will save one <code>vmv.v.x</code> instruction that would do the splat which may or may not be a big deal depending on the exact uArch. In the best case this prevents us from loading 16 bytes instead loading only 8 bytes, which is a slight improvement. (4 or fewer byte constants should always be materialized with 2 instructions and would fall into <code>vmv.v.x</code> territory)<br>\n</p>\n</blockquote>",
        "id": 383419943,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691615997
    },
    {
        "content": "<p><a href=\"https://github.com/afonso360\">afonso360</a> added the cranelift label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6826\">Issue #6826</a>.</p>",
        "id": 383419945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691615997
    },
    {
        "content": "<p><a href=\"https://github.com/afonso360\">afonso360</a> added the cranelift:area:riscv64 label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6826\">Issue #6826</a>.</p>",
        "id": 383419946,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691615997
    }
]