[
    {
        "content": "<p>autodidaddict opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As of 0.13.0, host functions are no longer supported via the <code>Callable</code> trait, and instead with functions that accept a <code>Caller</code> as a parameter. Because of this, we _lost_ a lot of functionality that we can't easily replicate, such as the ability to create an instance of a struct that would be the target of the invocation. These instances were capable of storing per-module unique metadata, which we can no longer do. </p>\n<h4>Benefit</h4>\n<p>Something like this is _crucial_ for being able to support running multiple modules within the same Rust process that do not interfere with each other's execution. Uniquely identifying them gives our host functions the ability to store per-module call state, metadata, and properly segment/isolate host resources.</p>\n<h4>Implementation</h4>\n<p>The simplest approach would be to just assign a monotonically increasing number to each module created within a given runtime, and then expose that same identity as a field/function on the <code>Caller</code> struct. </p>\n<h4>Alternatives</h4>\n<p>For more flexibility, you could alternatively expose a hashmap that stores arbitrary per-module metadata. This would let the consumers of wasmtime decide what they want to do with the metadata (e.g. manage an atomic counter for module identity) rather than wasmtime itself.</p>\n</blockquote>",
        "id": 194811279,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587479990
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617296822\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617296822\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p>Thanks for the report! I'm not sure I fully understand how functionality was lost, though, can you elaborate a bit more on what worked previously but doesn't work any more?</p>\n</blockquote>",
        "id": 194834067,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587489422
    },
    {
        "content": "<p>autodidaddict <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617315593\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617315593\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p>Use case is for <a href=\"https://github.com/wapc/wapc-rust\" title=\"https://github.com/wapc/wapc-rust\">wapc</a> and, by extension, <a href=\"https://github.com/wascc/wascc-host\" title=\"https://github.com/wascc/wascc-host\">wascc</a>. In both of these projects, we load multiple webassembly modules at once. These modules are able to make host calls wherein the \"call state\" has fields like the current error, if there is one, the current result, etc. tl;dr this \"RPC\" contract requires the host call to access data that only belongs to a specific module.</p>\n<p>In 0.12.0, with the <code>Callable</code> trait, I was able to drop an <code>Rc&lt;RefCell&lt;State&gt;&gt;</code> into each of my callables, which allowed me to do things like grab the unique ID that I'd assigned to the module and the fields like current error, etc. </p>\n<p>In 0.13.0+, the host imports are no longer <code>Callable</code>, they're just bare functions. This means that I cannot bind any state or metadata to that function, so that function has no way of knowing _which fields_ it needs to use in order to satisfy requests from the guest.</p>\n<p>A concrete example is we provide an import called <code>host_response</code>. This function lets the guest wasm module obtain a binary blob containing the host's reply to the last function call. We do this to avoid exposing memory allocation patterns in the RPC contract. So, when the guest module calls <code>host_response</code>, we need a way to determine _which response_ to give back to the wasm module, because the assumption is that the host is holding multiple modules, all of which can be executing in parallel via threads.</p>\n<p>To recap - in the current version of waPC, we can maintain per-module call state because we have structs that implement <code>Callable</code>. In 0.15.0, we don't have a way to maintain per-module call state because we're running bare functions now, and these bare functions have no \"key\" with which to look up per-module call state in a static.</p>\n</blockquote>",
        "id": 194838286,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587491364
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617352546\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617352546\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p>Hm sorry I'm still not sure I fully understand. Each <code>Func</code> is created with an <code>Fn</code> which can capture any state that it wants, which means you can still create per-<code>Func</code> state which can be passed on to host implementations. Do you have some code I could perhaps peek at which might illustrate the problem?</p>\n</blockquote>",
        "id": 194847062,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587495567
    },
    {
        "content": "<p>autodidaddict <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617356802\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617356802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/wapc/wapc-rust/blob/master/src/callbacks.rs#L169\" title=\"https://github.com/wapc/wapc-rust/blob/master/src/callbacks.rs#L169\">https://github.com/wapc/wapc-rust/blob/master/src/callbacks.rs#L169</a></p>\n<p>here's a function that uses the old <code>Callable</code> trait. It requires access to a <code>ModuleState</code> in order to satisfy the request.</p>\n<p>The parameter you pass to <code>Func::new()</code> needs to be <code>impl Fn(Caller, &amp;[Val], &amp;mut [Val])</code> .. so this is where I can't figure out how to give that function access to module-specific state.</p>\n</blockquote>",
        "id": 194848060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587496087
    },
    {
        "content": "<p>autodidaddict <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617371739\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617371739\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p>I think I might have figured it out. From the documentation on Func::new(), it didn't look like it would take the kind of closure I needed. I'm going to try and create a function that captures state in the closure...</p>\n</blockquote>",
        "id": 194851399,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587497882
    },
    {
        "content": "<p>autodidaddict <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617404530\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567#issuecomment-617404530\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<p>Confirmed... I was able to convert everything to closures and it all works now. Sorry for wasting your time with an issue - I just didn't realize I could satisfy that function requirement with a closure. This has given me some ideas on how to optimize my own library :) </p>\n</blockquote>",
        "id": 194858952,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587501881
    },
    {
        "content": "<p>autodidaddict closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1567\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1567\">Issue #1567</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As of 0.13.0, host functions are no longer supported via the <code>Callable</code> trait, and instead with functions that accept a <code>Caller</code> as a parameter. Because of this, we _lost_ a lot of functionality that we can't easily replicate, such as the ability to create an instance of a struct that would be the target of the invocation. These instances were capable of storing per-module unique metadata, which we can no longer do. </p>\n<h4>Benefit</h4>\n<p>Something like this is _crucial_ for being able to support running multiple modules within the same Rust process that do not interfere with each other's execution. Uniquely identifying them gives our host functions the ability to store per-module call state, metadata, and properly segment/isolate host resources.</p>\n<h4>Implementation</h4>\n<p>The simplest approach would be to just assign a monotonically increasing number to each module created within a given runtime, and then expose that same identity as a field/function on the <code>Caller</code> struct. </p>\n<h4>Alternatives</h4>\n<p>For more flexibility, you could alternatively expose a hashmap that stores arbitrary per-module metadata. This would let the consumers of wasmtime decide what they want to do with the metadata (e.g. manage an atomic counter for module identity) rather than wasmtime itself.</p>\n</blockquote>",
        "id": 194858953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587501881
    }
]