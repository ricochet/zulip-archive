[
    {
        "content": "<p>yuyang-ok edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110\">issue #4110</a>:</p>\n<p>running 1 test<br>\nTRACE - ABI: func signature Signature { params: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }, AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], returns: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], call_conv: SystemV }<br>\nTRACE - ABISig: sig Signature { params: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }, AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], returns: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], call_conv: SystemV } =&gt; args = [Slots { slots: [Reg { reg: p10f, ty: types::F32, extension: None }], purpose: Normal }, Slots { slots: [Reg { reg: p11f, ty: types::F32, extension: None }], purpose: Normal }] rets = [Slots { slots: [Reg { reg: p10f, ty: types::F32, extension: None }], purpose: Normal }] arg stack = 0 ret stack = 0 stack_ret_arg = None<br>\nTRACE - BlockLoweringOrder: function body function %test0(f32, f32) -&gt; f32 system_v {<br>\nblock0(v0: f32, v1: f32):<br>\n    v2 = fcmp gt v0, v1<br>\n    brnz v2, block1<br>\n    jump block2</p>\n<p>block1:<br>\n    return v0</p>\n<p>block2:<br>\n    return v1<br>\n}</p>\n<p>TRACE - BlockLoweringOrder: BlockLoweringOrder { lowered_order: [Orig { block: block0 }, EdgeAndOrig { pred: block0, edge_inst: inst1, succ_idx: 0, block: block1 }, EdgeAndOrig { pred: block0, edge_inst: inst2, succ_idx: 1, block: block2 }], lowered_succs: [(inst1, EdgeAndOrig { pred: block0, edge_inst: inst1, succ_idx: 0, block: block1 }), (inst2, EdgeAndOrig { pred: block0, edge_inst: inst2, succ_idx: 1, block: block2 })], lowered_succ_indices: [(inst1, Block(1)), (inst2, Block(2))], lowered_succ_ranges: [(0, 2), (2, 2), (2, 2)], orig_map: SecondaryMap { elems: [Some(Block(0)), Some(Block(1)), Some(Block(2))], default: None, unused: PhantomData }, cold_blocks: {} }<br>\nTRACE - bb block0 param v0: regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - bb block0 param v1: regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - bb block0 inst inst0 (FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }): result v2 regs ValueRegs { parts: [v130, v2097151] }<br>\nTRACE - retval gets regs ValueRegs { parts: [v131, v2097151] }<br>\nTRACE - bb block0 inst inst0 has color 1<br>\nTRACE - bb block0 inst inst1 has color 1<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block0 inst inst2 has color 2<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block1 inst inst3 has color 4<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block2 inst inst4 has color 6<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - arg v0 used, old state Unused, new Once<br>\nTRACE - arg v1 used, old state Unused, new Once<br>\nTRACE - arg v2 used, old state Unused, new Once<br>\nTRACE - arg v0 used, old state Once, new Multiple<br>\nTRACE -  -&gt; pushing args for v0 onto stack<br>\nTRACE - arg v1 used, old state Once, new Multiple<br>\nTRACE -  -&gt; pushing args for v1 onto stack<br>\nDEBUG - timing: Starting VCode lowering, (during &lt;no pass&gt;)<br>\nTRACE - about to lower function: function %test0(f32, f32) -&gt; f32 system_v {<br>\nblock0(v0: f32, v1: f32):<br>\n    v2 = fcmp gt v0, v1<br>\n    brnz v2, block1<br>\n    jump block2</p>\n<p>block1:<br>\n    return v0</p>\n<p>block2:<br>\n    return v1<br>\n}</p>\n<p>TRACE - lower_clif_block: block block2 inst inst4 (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData } }) is_branch false side_effect true value_needed false<br>\nTRACE - lowering: inst inst4: MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData } }<br>\nTRACE - get_input_for_val: val v1 at cur_inst Some(inst4) cur_scan_entry_color Some(InstColor(6))<br>\nTRACE - put_value_in_regs: val v1<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - emit: Mov { rd: Writable { reg: v131 }, rm: v129, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: p10f }, rm: v131, ty: types::F32 }<br>\nTRACE - emit: Ret<br>\nTRACE - lower_clif_block: block block1 inst inst3 (MultiAry { opcode: Return, args: EntityList { index: 13, unused: PhantomData } }) is_branch false side_effect true value_needed false<br>\nTRACE - lowering: inst inst3: MultiAry { opcode: Return, args: EntityList { index: 13, unused: PhantomData } }<br>\nTRACE - get_input_for_val: val v0 at cur_inst Some(inst3) cur_scan_entry_color Some(InstColor(4))<br>\nTRACE - put_value_in_regs: val v0<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - emit: Mov { rd: Writable { reg: v131 }, rm: v128, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: p10f }, rm: v131, ty: types::F32 }<br>\nTRACE - emit: Ret<br>\nTRACE - lower_clif_branches: block block0 branches [inst1, inst2] targets [MachLabel(1), MachLabel(2)]<br>\nTRACE - put_value_in_regs: val v2<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v130, v2097151] }<br>\nTRACE - emit: CondBr { taken: Label(MachLabel(1)), not_taken: Label(MachLabel(2)), kind: IntegerCompare { kind: NotEqual, rs1: v130, rs2: p0i } }<br>\nTRACE - lower_clif_block: block block0 inst inst2 (Jump { opcode: Jump, args: EntityList { index: 0, unused: PhantomData }, destination: block2 }) is_branch true side_effect true value_needed false<br>\nTRACE - lower_clif_block: block block0 inst inst1 (Branch { opcode: Brnz, args: EntityList { index: 9, unused: PhantomData }, destination: block1 }) is_branch true side_effect true value_needed false<br>\nTRACE - lower_clif_block: block block0 inst inst0 (FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }) is_branch false side_effect false value_needed true<br>\nTRACE - lowering: inst inst0: FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }<br>\nTRACE - get_input_for_val: val v0 at cur_inst Some(inst0) cur_scan_entry_color Some(InstColor(1))<br>\nTRACE - put_value_in_regs: val v0<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - get_input_for_val: val v1 at cur_inst Some(inst0) cur_scan_entry_color Some(InstColor(1))<br>\nTRACE - put_value_in_regs: val v1<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - emit: Ffcmp { rd: Writable { reg: v130 }, cc: GreaterThan, ty: types::F32, rs1: v128, rs2: v129 }<br>\nTRACE - gen_arg_setup: entry BB block0 args are:<br>\n[v0, v1]<br>\nTRACE - emit: Mov { rd: Writable { reg: v128 }, rm: p10f, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: v129 }, rm: p11f, ty: types::F32 }<br>\nTRACE - gen_retval_area_setup: not needed<br>\nTRACE - built vcode: VCode {<br>\n  Entry block: 0<br>\nBlock 0:<br>\n    (original IR block: block0)<br>\n    (successor: Block 1)<br>\n    (successor: Block 2)<br>\n    (instruction range: 0 .. 4)<br>\n  Inst 0: fmv.s v128,fa0<br>\n  Inst 1: fmv.s v129,fa1<br>\n  Inst 2: fgt v130,v128,v129<br>\n  Inst 3: bne v130,zero,taken(label1),not_taken(label2)<br>\nBlock 1:<br>\n    (original IR block: block1)<br>\n    (instruction range: 4 .. 7)<br>\n  Inst 4: fmv.s v131,v128<br>\n  Inst 5: fmv.s fa0,v131<br>\n  Inst 6: ret<br>\nBlock 2:<br>\n    (original IR block: block2)<br>\n    (instruction range: 7 .. 10)<br>\n  Inst 7: fmv.s v131,v129<br>\n  Inst 8: fmv.s fa0,v131<br>\n  Inst 9: ret<br>\n}</p>\n<p>DEBUG - timing: Ending VCode lowering<br>\nTRACE - vcode from lowering:<br>\nVCode {<br>\n  Entry block: 0<br>\nBlock 0:<br>\n    (original IR block: block0)<br>\n    (successor: Block 1)<br>\n    (successor: Block 2)<br>\n    (instruction range: 0 .. 4)<br>\n  Inst 0: fmv.s v128,fa0<br>\n  Inst 1: fmv.s v129,fa1<br>\n  Inst 2: fgt v130,v128,v129<br>\n  Inst 3: bne v130,zero,taken(label1),not_taken(label2)<br>\nBlock 1:<br>\n    (original IR block: block1)<br>\n    (instruction range: 4 .. 7)<br>\n  Inst 4: fmv.s v131,v128<br>\n  Inst 5: fmv.s fa0,v131<br>\n  Inst 6: ret<br>\nBlock 2:<br>\n    (original IR block: block2)<br>\n    (instruction range: 7 .. 10)<br>\n  Inst 7: fmv.s v131,v129<br>\n  Inst 8: fmv.s fa0,v131<br>\n  Inst 9: ret<br>\n}</p>\n<p>DEBUG - timing: Starting Register allocation, (during &lt;no pass&gt;)<br>\nINFO - === REGALLOC RESULTS ===<br>\nINFO - block0: [succs [1, 2] preds []]<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v0 in p0i (range6) (bundle4294967295)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v75 in p11f (range7) (bundle4294967295)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v128 in p10f (range3) (bundle0)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v129 in p5f (range8) (bundle5)<br>\nINFO -   inst0: op Def: v128f reg [none], Use: v74f reg [none]<br>\nINFO -   inst0-post:      end   v129 in p5f (range8) (bundle5) &gt;&gt;&gt;<br>\nINFO -   inst1-pre:      end   v75 in p11f (range7) (bundle4294967295) &gt;&gt;&gt;<br>\nINFO -   inst1: op Def: v129f reg [none], Use: v75f reg [none]<br>\nINFO -   inst1-post:  &lt;&lt;&lt; start v129 in p11f (range4) (bundle4)<br>\nINFO -   inst2: op Def: v130i reg [p11i], Use: v128f reg [p10f], Use: v129f reg [p11f]<br>\nINFO -   inst2-post:  &lt;&lt;&lt; start v130 in p11i (range5) (bundle2)<br>\nINFO -   inst3: br Use: v130i reg [p11i], Use: v0i reg [p0i]<br>\nINFO -   inst3-post:      end   v0 in p0i (range6) (bundle4294967295) &gt;&gt;&gt;<br>\nINFO -   inst3-post:      end   v130 in p11i (range5) (bundle2) &gt;&gt;&gt;<br>\nINFO - block1: [succs [] preds [0]]<br>\nINFO -   inst4-pre:      end   v129 in p11f (range4) (bundle4) &gt;&gt;&gt;<br>\nINFO -   inst4: op Def: v131f reg [none], Use: v128f reg [none]<br>\nINFO -   inst4-post:  prog-move v128 (Any) -&gt; v131 (Any)<br>\nINFO -   inst5-pre:      end   v128 in p10f (range3) (bundle0) &gt;&gt;&gt;<br>\nINFO -   inst5-pre:  &lt;&lt;&lt; start v131 in p10f (range2) (bundle0)<br>\nINFO -   inst5: op Def: v74f reg [none], Use: v131f reg [none]<br>\nINFO -   inst6-pre:      end   v131 in p10f (range2) (bundle0) &gt;&gt;&gt;<br>\nINFO -   inst6: ret<br>\nINFO - block2: [succs [] preds [0]]<br>\nINFO -   inst7-pre:  &lt;&lt;&lt; start v129 in p11f (range1) (bundle4)<br>\nINFO -   inst7: op Def: v131f reg [none], Use: v129f reg [none]<br>\nINFO -   inst7-post:  prog-move v129 (Any) -&gt; v131 (Any)<br>\nINFO -   inst8-pre:      end   v129 in p11f (range1) (bundle4) &gt;&gt;&gt;<br>\nINFO -   inst8-pre:  &lt;&lt;&lt; start v131 in p10f (range0) (bundle0)<br>\nINFO -   inst8-pre: move p11f -&gt; p10f)<br>\nINFO -   inst8: op Def: v74f reg [none], Use: v131f reg [none]<br>\nINFO -<br>\n[message truncated]</p>",
        "id": 281592169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652005833
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110#issuecomment-1120431276\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110\">issue #4110</a>:</p>\n<blockquote>\n<blockquote>\n<p>you need integer register to implement float mov , and move single-precision an double precesion use different instruction.</p>\n</blockquote>\n<p>You can move a double precision float in both cases, right? The riscv specification explicitly allows this AFAICT:</p>\n<blockquote>\n<p>Software might not know the current type of data stored in a floating-point register but has to be able to save and restore the register values, hence the result of using wider operations to transfer narrower values has to be defined.</p>\n</blockquote>\n</blockquote>",
        "id": 281602336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652021011
    },
    {
        "content": "<p>yuyang-ok <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110#issuecomment-1120501070\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110\">issue #4110</a>:</p>\n<blockquote>\n<p>thanks , I did not notice that , I will try.</p>\n</blockquote>",
        "id": 281622310,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652050404
    },
    {
        "content": "<p>yuyang-ok closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110\">issue #4110</a>:</p>\n<p>running 1 test<br>\nTRACE - ABI: func signature Signature { params: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }, AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], returns: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], call_conv: SystemV }<br>\nTRACE - ABISig: sig Signature { params: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }, AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], returns: [AbiParam { value_type: types::F32, purpose: Normal, extension: None, legalized_to_pointer: false }], call_conv: SystemV } =&gt; args = [Slots { slots: [Reg { reg: p10f, ty: types::F32, extension: None }], purpose: Normal }, Slots { slots: [Reg { reg: p11f, ty: types::F32, extension: None }], purpose: Normal }] rets = [Slots { slots: [Reg { reg: p10f, ty: types::F32, extension: None }], purpose: Normal }] arg stack = 0 ret stack = 0 stack_ret_arg = None<br>\nTRACE - BlockLoweringOrder: function body function %test0(f32, f32) -&gt; f32 system_v {<br>\nblock0(v0: f32, v1: f32):<br>\n    v2 = fcmp gt v0, v1<br>\n    brnz v2, block1<br>\n    jump block2</p>\n<p>block1:<br>\n    return v0</p>\n<p>block2:<br>\n    return v1<br>\n}</p>\n<p>TRACE - BlockLoweringOrder: BlockLoweringOrder { lowered_order: [Orig { block: block0 }, EdgeAndOrig { pred: block0, edge_inst: inst1, succ_idx: 0, block: block1 }, EdgeAndOrig { pred: block0, edge_inst: inst2, succ_idx: 1, block: block2 }], lowered_succs: [(inst1, EdgeAndOrig { pred: block0, edge_inst: inst1, succ_idx: 0, block: block1 }), (inst2, EdgeAndOrig { pred: block0, edge_inst: inst2, succ_idx: 1, block: block2 })], lowered_succ_indices: [(inst1, Block(1)), (inst2, Block(2))], lowered_succ_ranges: [(0, 2), (2, 2), (2, 2)], orig_map: SecondaryMap { elems: [Some(Block(0)), Some(Block(1)), Some(Block(2))], default: None, unused: PhantomData }, cold_blocks: {} }<br>\nTRACE - bb block0 param v0: regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - bb block0 param v1: regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - bb block0 inst inst0 (FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }): result v2 regs ValueRegs { parts: [v130, v2097151] }<br>\nTRACE - retval gets regs ValueRegs { parts: [v131, v2097151] }<br>\nTRACE - bb block0 inst inst0 has color 1<br>\nTRACE - bb block0 inst inst1 has color 1<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block0 inst inst2 has color 2<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block1 inst inst3 has color 4<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - bb block2 inst inst4 has color 6<br>\nTRACE -  -&gt; side-effecting; incrementing color for next inst<br>\nTRACE - arg v0 used, old state Unused, new Once<br>\nTRACE - arg v1 used, old state Unused, new Once<br>\nTRACE - arg v2 used, old state Unused, new Once<br>\nTRACE - arg v0 used, old state Once, new Multiple<br>\nTRACE -  -&gt; pushing args for v0 onto stack<br>\nTRACE - arg v1 used, old state Once, new Multiple<br>\nTRACE -  -&gt; pushing args for v1 onto stack<br>\nDEBUG - timing: Starting VCode lowering, (during &lt;no pass&gt;)<br>\nTRACE - about to lower function: function %test0(f32, f32) -&gt; f32 system_v {<br>\nblock0(v0: f32, v1: f32):<br>\n    v2 = fcmp gt v0, v1<br>\n    brnz v2, block1<br>\n    jump block2</p>\n<p>block1:<br>\n    return v0</p>\n<p>block2:<br>\n    return v1<br>\n}</p>\n<p>TRACE - lower_clif_block: block block2 inst inst4 (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData } }) is_branch false side_effect true value_needed false<br>\nTRACE - lowering: inst inst4: MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData } }<br>\nTRACE - get_input_for_val: val v1 at cur_inst Some(inst4) cur_scan_entry_color Some(InstColor(6))<br>\nTRACE - put_value_in_regs: val v1<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - emit: Mov { rd: Writable { reg: v131 }, rm: v129, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: p10f }, rm: v131, ty: types::F32 }<br>\nTRACE - emit: Ret<br>\nTRACE - lower_clif_block: block block1 inst inst3 (MultiAry { opcode: Return, args: EntityList { index: 13, unused: PhantomData } }) is_branch false side_effect true value_needed false<br>\nTRACE - lowering: inst inst3: MultiAry { opcode: Return, args: EntityList { index: 13, unused: PhantomData } }<br>\nTRACE - get_input_for_val: val v0 at cur_inst Some(inst3) cur_scan_entry_color Some(InstColor(4))<br>\nTRACE - put_value_in_regs: val v0<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - emit: Mov { rd: Writable { reg: v131 }, rm: v128, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: p10f }, rm: v131, ty: types::F32 }<br>\nTRACE - emit: Ret<br>\nTRACE - lower_clif_branches: block block0 branches [inst1, inst2] targets [MachLabel(1), MachLabel(2)]<br>\nTRACE - put_value_in_regs: val v2<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v130, v2097151] }<br>\nTRACE - emit: CondBr { taken: Label(MachLabel(1)), not_taken: Label(MachLabel(2)), kind: IntegerCompare { kind: NotEqual, rs1: v130, rs2: p0i } }<br>\nTRACE - lower_clif_block: block block0 inst inst2 (Jump { opcode: Jump, args: EntityList { index: 0, unused: PhantomData }, destination: block2 }) is_branch true side_effect true value_needed false<br>\nTRACE - lower_clif_block: block block0 inst inst1 (Branch { opcode: Brnz, args: EntityList { index: 9, unused: PhantomData }, destination: block1 }) is_branch true side_effect true value_needed false<br>\nTRACE - lower_clif_block: block block0 inst inst0 (FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }) is_branch false side_effect false value_needed true<br>\nTRACE - lowering: inst inst0: FloatCompare { opcode: Fcmp, args: [v0, v1], cond: GreaterThan }<br>\nTRACE - get_input_for_val: val v0 at cur_inst Some(inst0) cur_scan_entry_color Some(InstColor(1))<br>\nTRACE - put_value_in_regs: val v0<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v128, v2097151] }<br>\nTRACE - get_input_for_val: val v1 at cur_inst Some(inst0) cur_scan_entry_color Some(InstColor(1))<br>\nTRACE - put_value_in_regs: val v1<br>\nTRACE -  -&gt; regs ValueRegs { parts: [v129, v2097151] }<br>\nTRACE - emit: Ffcmp { rd: Writable { reg: v130 }, cc: GreaterThan, ty: types::F32, rs1: v128, rs2: v129 }<br>\nTRACE - gen_arg_setup: entry BB block0 args are:<br>\n[v0, v1]<br>\nTRACE - emit: Mov { rd: Writable { reg: v128 }, rm: p10f, ty: types::F32 }<br>\nTRACE - emit: Mov { rd: Writable { reg: v129 }, rm: p11f, ty: types::F32 }<br>\nTRACE - gen_retval_area_setup: not needed<br>\nTRACE - built vcode: VCode {<br>\n  Entry block: 0<br>\nBlock 0:<br>\n    (original IR block: block0)<br>\n    (successor: Block 1)<br>\n    (successor: Block 2)<br>\n    (instruction range: 0 .. 4)<br>\n  Inst 0: fmv.s v128,fa0<br>\n  Inst 1: fmv.s v129,fa1<br>\n  Inst 2: fgt v130,v128,v129<br>\n  Inst 3: bne v130,zero,taken(label1),not_taken(label2)<br>\nBlock 1:<br>\n    (original IR block: block1)<br>\n    (instruction range: 4 .. 7)<br>\n  Inst 4: fmv.s v131,v128<br>\n  Inst 5: fmv.s fa0,v131<br>\n  Inst 6: ret<br>\nBlock 2:<br>\n    (original IR block: block2)<br>\n    (instruction range: 7 .. 10)<br>\n  Inst 7: fmv.s v131,v129<br>\n  Inst 8: fmv.s fa0,v131<br>\n  Inst 9: ret<br>\n}</p>\n<p>DEBUG - timing: Ending VCode lowering<br>\nTRACE - vcode from lowering:<br>\nVCode {<br>\n  Entry block: 0<br>\nBlock 0:<br>\n    (original IR block: block0)<br>\n    (successor: Block 1)<br>\n    (successor: Block 2)<br>\n    (instruction range: 0 .. 4)<br>\n  Inst 0: fmv.s v128,fa0<br>\n  Inst 1: fmv.s v129,fa1<br>\n  Inst 2: fgt v130,v128,v129<br>\n  Inst 3: bne v130,zero,taken(label1),not_taken(label2)<br>\nBlock 1:<br>\n    (original IR block: block1)<br>\n    (instruction range: 4 .. 7)<br>\n  Inst 4: fmv.s v131,v128<br>\n  Inst 5: fmv.s fa0,v131<br>\n  Inst 6: ret<br>\nBlock 2:<br>\n    (original IR block: block2)<br>\n    (instruction range: 7 .. 10)<br>\n  Inst 7: fmv.s v131,v129<br>\n  Inst 8: fmv.s fa0,v131<br>\n  Inst 9: ret<br>\n}</p>\n<p>DEBUG - timing: Starting Register allocation, (during &lt;no pass&gt;)<br>\nINFO - === REGALLOC RESULTS ===<br>\nINFO - block0: [succs [1, 2] preds []]<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v0 in p0i (range6) (bundle4294967295)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v75 in p11f (range7) (bundle4294967295)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v128 in p10f (range3) (bundle0)<br>\nINFO -   inst0-pre:  &lt;&lt;&lt; start v129 in p5f (range8) (bundle5)<br>\nINFO -   inst0: op Def: v128f reg [none], Use: v74f reg [none]<br>\nINFO -   inst0-post:      end   v129 in p5f (range8) (bundle5) &gt;&gt;&gt;<br>\nINFO -   inst1-pre:      end   v75 in p11f (range7) (bundle4294967295) &gt;&gt;&gt;<br>\nINFO -   inst1: op Def: v129f reg [none], Use: v75f reg [none]<br>\nINFO -   inst1-post:  &lt;&lt;&lt; start v129 in p11f (range4) (bundle4)<br>\nINFO -   inst2: op Def: v130i reg [p11i], Use: v128f reg [p10f], Use: v129f reg [p11f]<br>\nINFO -   inst2-post:  &lt;&lt;&lt; start v130 in p11i (range5) (bundle2)<br>\nINFO -   inst3: br Use: v130i reg [p11i], Use: v0i reg [p0i]<br>\nINFO -   inst3-post:      end   v0 in p0i (range6) (bundle4294967295) &gt;&gt;&gt;<br>\nINFO -   inst3-post:      end   v130 in p11i (range5) (bundle2) &gt;&gt;&gt;<br>\nINFO - block1: [succs [] preds [0]]<br>\nINFO -   inst4-pre:      end   v129 in p11f (range4) (bundle4) &gt;&gt;&gt;<br>\nINFO -   inst4: op Def: v131f reg [none], Use: v128f reg [none]<br>\nINFO -   inst4-post:  prog-move v128 (Any) -&gt; v131 (Any)<br>\nINFO -   inst5-pre:      end   v128 in p10f (range3) (bundle0) &gt;&gt;&gt;<br>\nINFO -   inst5-pre:  &lt;&lt;&lt; start v131 in p10f (range2) (bundle0)<br>\nINFO -   inst5: op Def: v74f reg [none], Use: v131f reg [none]<br>\nINFO -   inst6-pre:      end   v131 in p10f (range2) (bundle0) &gt;&gt;&gt;<br>\nINFO -   inst6: ret<br>\nINFO - block2: [succs [] preds [0]]<br>\nINFO -   inst7-pre:  &lt;&lt;&lt; start v129 in p11f (range1) (bundle4)<br>\nINFO -   inst7: op Def: v131f reg [none], Use: v129f reg [none]<br>\nINFO -   inst7-post:  prog-move v129 (Any) -&gt; v131 (Any)<br>\nINFO -   inst8-pre:      end   v129 in p11f (range1) (bundle4) &gt;&gt;&gt;<br>\nINFO -   inst8-pre:  &lt;&lt;&lt; start v131 in p10f (range0) (bundle0)<br>\nINFO -   inst8-pre: move p11f -&gt; p10f)<br>\nINFO -   inst8: op Def: v74f reg [none], Use: v131f reg [none]<br>\nINFO -<br>\n[message truncated]</p>",
        "id": 281622373,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652050502
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110#issuecomment-1121429018\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4110\">issue #4110</a>:</p>\n<blockquote>\n<p>@yuyang-ok to add a little more detail: the idea is that at regalloc time, we only deal with registers, not the types of values within registers. This is to prevent bugs: otherwise we need to track the type and get it right in all cases, we haven't historically done a perfect job of that when dealing with certain optimizations, and bugs are catastrophic (causing CVEs) when this is wrong.</p>\n<p>So, loads, spills, and moves always deal with the whole register value. I'm surprised that RISC-V doesn't have an FP-reg-to-FP-reg move without going through an integer register; but you should be able to synthesize this by using the scratch integer register.</p>\n<p>Also, one more thing to note: in the future, it is probably best not to copy the entire <code>trace</code> output of the compiler into an issue, especially without an introduction at the top; it makes it hard for contributors to see what the actual problem is and help you :-)</p>\n</blockquote>",
        "id": 281724966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652120504
    }
]