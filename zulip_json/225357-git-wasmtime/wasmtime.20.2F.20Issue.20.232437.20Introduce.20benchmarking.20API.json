[
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437#issuecomment-731377279\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437\">Issue #2437</a>:</p>\n<blockquote>\n<p>I created a draft based on @fitzgen's <a href=\"https://github.com/bytecodealliance/rfcs/pull/3#issuecomment-729836212\">comment re: a Wasmtime benchmark dylib</a>. I don't really expect this to be the final product but I wanted to make sure that I could use the API we discussed over in sightglass (and what better way to know than to actually build it?). I am not quite sure about:</p>\n<ul>\n<li>there are a lot of unsafe bits here due to the C FFI and I would appreciate someone verifying that I didn't miss something</li>\n<li>having the <code>\"bench\" \"start\"/\"end\"</code> functions have a signature of <code>fn()</code> is very convenient for the benchmarks but I will need to be very careful in Sightglass that the measurement state, e.g. the start time, is handled safely.</li>\n</ul>\n</blockquote>",
        "id": 217451081,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605902111
    },
    {
        "content": "<p>jlb6740 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437#issuecomment-736305012\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437\">Issue #2437</a>:</p>\n<blockquote>\n<blockquote>\n<p>The new crate introduced here, <code>wasmtime-bench-api</code>, creates a shared library, e.g. <code>wasmtime_bench_api.so</code>, for executing Wasm benchmarks using Wasmtime. It allows us to measure several phases separately by exposing <code>engine_compile_module</code>, <code>engine_instantiate_module</code>, and <code>engine_execute_module</code>, which pass around an opaque pointer to the internally initialized state. This state is initialized and freed by <code>engine_create</code> and <code>engine_free</code>, respectively. The API also introduces a way of passing in functions to satisfy the <code>\"bench\" \"start\"</code> and <code>\"bench\" \"end\"</code> symbols that we expect Wasm benchmarks to import. The API is exposed in a C-compatible way so that we can dynamically load it (carefully) in our benchmark runner.</p>\n</blockquote>\n<p>Hi @abrown, to be clear, so this is adding a crate that when built will build a shared library that includes everything for embedding enough of the wasmtime runtime into whatever (sightglass for example) for instantiating and running a wasm file? Doesn't the c-api already expose api's to load and instantiate and execute modules? If so, what are the notable differences with what's here? Also the bench_start and bench_end .. if someone has a C program or rust files and want to add these markers around a specific function and recompile to wasm .. how is this shared library that is produced here used in that process?</p>\n</blockquote>",
        "id": 218391250,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606810897
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437#issuecomment-736805536\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437\">Issue #2437</a>:</p>\n<blockquote>\n<blockquote>\n<p>this is adding a crate that when built will build a shared library that includes everything for embedding enough of the wasmtime runtime into whatever (sightglass for example) for instantiating and running a wasm file?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>Doesn't the c-api already expose api's to load and instantiate and execute modules? If so, what are the notable differences with what's here?</p>\n</blockquote>\n<p>It does, but this is quite a bit simpler. I did create bindings to use the Wasm C API from Rust but this was quite a bit more work than this approach (a lot of unsafe things are yet to be figured out there). Either way is fine with me.</p>\n<blockquote>\n<p>Also the bench_start and bench_end .. if someone has a C program or rust files and want to add these markers around a specific function and recompile to wasm .. how is this shared library that is produced here used in that process?</p>\n</blockquote>\n<p>This shared library is decoupled from that completely. That way benchmarks can be created apart from how they are run. There is an example of how this works <a href=\"https://github.com/abrown/sightglass-next/blob/main/crates/artifact/tests/benchmark.c\">here</a></p>\n</blockquote>",
        "id": 218478117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606855107
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437#issuecomment-736805536\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2437\">Issue #2437</a>:</p>\n<blockquote>\n<blockquote>\n<p>this is adding a crate that when built will build a shared library that includes everything for embedding enough of the wasmtime runtime into whatever (sightglass for example) for instantiating and running a wasm file?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>Doesn't the c-api already expose api's to load and instantiate and execute modules? If so, what are the notable differences with what's here?</p>\n</blockquote>\n<p>It does, but this is quite a bit simpler. I did create bindings to use the Wasm C API from Rust but this was quite a bit more work than this approach (a lot of unsafe things are yet to be figured out there). Either way is fine with me.</p>\n<blockquote>\n<p>Also the bench_start and bench_end .. if someone has a C program or rust files and want to add these markers around a specific function and recompile to wasm .. how is this shared library that is produced here used in that process?</p>\n</blockquote>\n<p>This shared library is decoupled from that completely. That way benchmark artifacts can be created apart from how they are run. There is an example of how this works <a href=\"https://github.com/abrown/sightglass-next/blob/main/crates/artifact/tests/benchmark.c\">here</a></p>\n</blockquote>",
        "id": 218478151,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606855126
    }
]