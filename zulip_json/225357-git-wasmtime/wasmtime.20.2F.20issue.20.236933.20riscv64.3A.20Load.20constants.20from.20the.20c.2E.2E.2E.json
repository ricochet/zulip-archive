[
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933#issuecomment-1699345359\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933\">issue #6933</a>:</p>\n<blockquote>\n<blockquote>\n<p>My guess is that if possible it'd be best to break up the macro-instruction into its components to handle this. That way instead of using macro-instructions the helpers in ISLE can be used. This may not always be applicable though.</p>\n<p>I did look at a few of these in <a href=\"http://emit.rs\">emit.rs</a> though and they were related to things like sp adjustments and stack probe loops which I think could also reasonably be switched over to asserting that the constant fits in an instruction rather than requiring a pool. (so long as the range matches what one would reasonably expect for these situations)</p>\n</blockquote>\n<p>We already sort of do this. We have <code>Inst::load_constant_u64</code> that tries to pattern match either a single <code>addi</code> or a <code>addi+lui</code> before falling back to the <code>LoadInlineConst</code> instruction as a last resort.</p>\n<p>I'd eventually like to try and fully merge the load constant logic with some ISLE rules, but I'm not entirely sure how to do that.</p>\n</blockquote>",
        "id": 388131711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1693407494
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933#issuecomment-1699345359\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933\">issue #6933</a>:</p>\n<blockquote>\n<blockquote>\n<p>My guess is that if possible it'd be best to break up the macro-instruction into its components to handle this. That way instead of using macro-instructions the helpers in ISLE can be used. This may not always be applicable though.</p>\n<p>I did look at a few of these in <a href=\"http://emit.rs\">emit.rs</a> though and they were related to things like sp adjustments and stack probe loops which I think could also reasonably be switched over to asserting that the constant fits in an instruction rather than requiring a pool. (so long as the range matches what one would reasonably expect for these situations)</p>\n</blockquote>\n<p>We already sort of do this. We have <code>Inst::load_constant_u64</code> that tries to pattern match either a single <code>addi</code> or a <code>addi+lui</code> before falling back to the <code>LoadInlineConst</code> instruction as a last resort.</p>\n<p>I'd eventually like to try and fully merge the load constant logic with some ISLE rules, but I'm not entirely sure how to do that. </p>\n<p>Right now both <code>Inst::load_constant_u64</code> and ISLE call into <code>Inst::generate_imm</code>, but I'd like to build some more complex pattern matching in ISLE and still have it available in <code>emit.rs</code></p>\n</blockquote>",
        "id": 388132063,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1693407570
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933#issuecomment-1699360059\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6933\">issue #6933</a>:</p>\n<blockquote>\n<p>Makes sense! I was thinking that the \"solution\" there is to slowly whittle away at callers to <code>Inst::load_constant_u64</code> as opposed to refactoring the internals of that to use ISLE (which would probably be different given the required contexts), but that's naturally much easier said than done</p>\n</blockquote>",
        "id": 388134361,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1693408039
    }
]