[
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1258837231\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<blockquote>\n<p><strong>lacking toolchain support</strong>: in the absence of any other feasible path, the WebAssembly bytes of the kernel code to be executed in parallel are embedded in the host WebAssembly module itself. This is problematic for many reasons, not least of which is the ability for the host WebAssembly module to tamper with the kernel (on the flip side: an intra-module JIT compiler feature!). But that is not the end of it: toolchain support is also lacking simply to produce modules that use atomics and shared memory. For C programs: <a href=\"https://github.com/WebAssembly/wasi-libc/issues/326\">How to distribute <code>THREAD_MODEL=posix</code> builds? WebAssembly/wasi-libc#326</a>. For Rust programs: <a href=\"https://github.com/rust-lang/rust/issues/102157\">Fail to compile with WebAssembly atomics and shared memory rust-lang/rust#102157</a>. Due to all this, most tests and examples in this crate are meticulously hand-crafted WAT files — once toolchain support improves these difficult-to-maintain files should be replaced.</p>\n</blockquote>\n<p>I think it is important to note that this PR does not depend on toolchain - implementing an API in consumer should not require a particular producer to be on board; multiple memories are a a different example of this. Also keep in mind that <code>libc</code> support is already implemented, <a href=\"https://github.com/WebAssembly/wasi-libc/issues/326\">WebAssembly/wasi-libc#326</a> is strictly about packaging and detecting it.</p>\n</blockquote>",
        "id": 300923141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664240532
    },
    {
        "content": "<p>penzn edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1258837231\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<blockquote>\n<p><strong>lacking toolchain support</strong>: in the absence of any other feasible path, the WebAssembly bytes of the kernel code to be executed in parallel are embedded in the host WebAssembly module itself. This is problematic for many reasons, not least of which is the ability for the host WebAssembly module to tamper with the kernel (on the flip side: an intra-module JIT compiler feature!). But that is not the end of it: toolchain support is also lacking simply to produce modules that use atomics and shared memory. For C programs: <a href=\"https://github.com/WebAssembly/wasi-libc/issues/326\">How to distribute <code>THREAD_MODEL=posix</code> builds? WebAssembly/wasi-libc#326</a>. For Rust programs: <a href=\"https://github.com/rust-lang/rust/issues/102157\">Fail to compile with WebAssembly atomics and shared memory rust-lang/rust#102157</a>. Due to all this, most tests and examples in this crate are meticulously hand-crafted WAT files — once toolchain support improves these difficult-to-maintain files should be replaced.</p>\n</blockquote>\n<p>I think it is important to note that this PR does not depend on toolchain - implementing an API in consumer should not require a particular producer to be on board; multiple memories are a a different example of this. Also keep in mind that <code>libc</code> support is already implemented, <a href=\"https://github.com/WebAssembly/wasi-libc/issues/326\">WebAssembly/wasi-libc#326</a> is strictly about packaging and detecting it and we should be able to fix that before this PR gets merged.</p>\n</blockquote>",
        "id": 300926470,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664243501
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267337082\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<blockquote>\n<p>That's in contrast with this WASI proposal which I don't think has any path forward into the component model.</p>\n</blockquote>\n<p>Probably worth re-iterating the point @abrown made above, that this would block potential implementation of <code>wasi-threads</code> as well.</p>\n</blockquote>",
        "id": 302312730,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664904969
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267361495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>That's true, yes, and I feel pretty similarly to the <code>wasi-threads</code> proposal as what's here as well. I also don't see a future for the <code>wasi-threads</code> proposal as-is in the component model right now. If these proposals want to integrate with the component model I think work needs to happen in the component model itself rather than assuming the functionality can be implemented with special host functions.<br>\n</p>\n</blockquote>",
        "id": 302316741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664906385
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267377177\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Just out of curiosity, as I haven't been following wasi meetings very closely, what is the background of the requirement that wasi interfaces only use component model?</p>\n</blockquote>",
        "id": 302319784,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664907330
    },
    {
        "content": "<p>penzn edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267377177\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Just out of curiosity, as I haven't been following wasi meetings very closely, what is the background of the requirement that wasi interfaces only use component model? And does this only apply to wasmtime?</p>\n</blockquote>",
        "id": 302320208,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664907480
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267415894\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>I, too, don't follow wasi meetings closely so I won't pretend to speak authoritatively on this, but I believe that the intention is to define WASI APIs with <code>*.wit</code> files which is a component-model level abstraction. At that layer of abstraction there's no way to talk about a shared linear memory or something like that which must be imported/exported with a particular name or such.</p>\n<p>I'm not sure what you mean though by if this only applies to wasmtime. The component model should look the same irrespective of where it's implemented, so it's not a wasmtime-specific limitation that <code>wasi-{parallel,threads}</code> can't be implemented in the component-model as-is, that's a component-model limitation. To be clear though the component model is in no way final by any stretch of the imagination so it's not like it can never support the underlying goals of <code>wasi-{parallel,threads}</code>, I'm instead commenting that as-is there's no way to implement this.</p>\n<p>If you're instead asking if <code>wasi-{parallel,threads}</code> can be implemented at all in Wasmtime, this PR is certainly proof-enough that it's possible to do that. I don't doubt that this PR works as intended but my comments are taking a more long-term vision about how I believe as WASI, <code>*.wit</code>, and the component model all converge this implementation will cease to work, specifically around the workarounds here to get access to the shared memory through the host function implementation of <code>parallel-exec</code>. The <code>parallel-exec</code> function cannot be implemented in the component-model as-is.</p>\n</blockquote>",
        "id": 302322819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664908365
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267466686\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>My understanding of how wasi-parallel is expected to fit into the component model is that it could be packaged as an import of a core-module, with the core-module importing the linear memory and exporting functions that operate on it directly. That isn't supported in wit or wit-bindgen today, so we'll need interim approaches, but eventually we should be able to pull these into the wit framework.</p>\n</blockquote>",
        "id": 302329811,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664910783
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1267727525\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>@alexcrichton thank you for the detailed answers.</p>\n<blockquote>\n<p>I'm not sure what you mean though by if this only applies to wasmtime.</p>\n</blockquote>\n<p>I meant to ask whether this is the approach adopted specifically by wasmtime or by component model, but you have answered that.</p>\n<blockquote>\n<p>My understanding of how wasi-parallel is expected to fit into the component model is that it could be packaged as an import of a core-module, with the core-module importing the linear memory and exporting functions that operate on it directly. That isn't supported in wit or wit-bindgen today, so we'll need interim approaches, but eventually we should be able to pull these into the wit framework.</p>\n</blockquote>\n<p>Does component model allow this yet? What can the interim approaches be? Maybe we should take it the component-model repo though.<br>\n</p>\n</blockquote>",
        "id": 302364952,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664926943
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1268513163\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>The component model does support importing a core wasm module, but that's not reflected in the <code>*.wit</code> textual description of APIs at this time. For interim things I suspect that'd be good to bring up on the component model repo yeah.</p>\n</blockquote>",
        "id": 302471694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664980811
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1268699278\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>@alexcrichton, I think there are several points you should reconsider:</p>\n<blockquote>\n<p>In the component model the hack you've implemented here with getting the shared memory to work will not work and has no way of working, there's no escape hatch to implement as you've done here.</p>\n</blockquote>\n<p>Then there's a bug in the component model specification. If there is no way to support multiple WASI proposals (<code>wasi-parallel</code>, <code>wasi-threads</code>), no way to satisfy the recurring requests for access to the host (latest of which is <a href=\"https://github.com/bytecodealliance/wit-bindgen/issues/313\">https://github.com/bytecodealliance/wit-bindgen/issues/313</a>), and no way to then make use of the core WebAssembly <code>threads</code> proposal, then the WIT specification is not complete enough. If there isn't an escape hatch, then one should be built.</p>\n<blockquote>\n<p>Additionally the existing wasi-common, wasi-nn, and wasi-crypto will likely all need to get removed or refactored or something with a transition away from wiggle</p>\n</blockquote>\n<p>Sure, but that should not block progress. The issue you point out is not with those WASI contributions but rather with the unstable state of <code>wit-bindgen</code>. I tried to refactor <code>wasi-nn</code> to use WIT a month or two ago and the tools were simply not ready. If the spec is not ready and the tools are not ready, it seems unreasonable to block all other work on that. I think the more productive approach would be to allow WASI proposals to continue and ensure that both the WIT spec and tooling can do everything wiggle could.</p>\n<blockquote>\n<p>I am not sure how useful it's been to have wasi-nn and wasi-crypto in this repository, I am not aware of how much usage they're getting and feedback they're providing to the upstream proposals.</p>\n</blockquote>\n<p>You should talk to @geekbeast, also a Fastly employee. He was attempting to use wasi-nn in Viceroy and was able to do so based on the reference implementation here.</p>\n<blockquote>\n<p>I also don't see a future for the wasi-threads proposal as-is in the component model right now. If these proposals want to integrate with the component model I think work needs to happen in the component model itself rather than assuming the functionality can be implemented with special host functions.</p>\n</blockquote>\n<p>I am not involved in component model design... but you are <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>. This PR &mdash; along with <a href=\"https://github.com/WebAssembly/wasi-parallel/issues/4\">https://github.com/WebAssembly/wasi-parallel/issues/4</a>, <a href=\"https://github.com/bytecodealliance/wit-bindgen/issues/130\">https://github.com/bytecodealliance/wit-bindgen/issues/130</a>, <a href=\"https://github.com/bytecodealliance/wit-bindgen/issues/313\">https://github.com/bytecodealliance/wit-bindgen/issues/313</a> &mdash; should be great feedback for a component model issue that you would know how to craft but I would not. I don't understand all of the component model requirements, history, etc. so my ability to contribute there is limited. Why not just take this PR as feedback to the component model and propose a solution so that these WASI proposals _can_ have a future?</p>\n</blockquote>",
        "id": 302503522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664989505
    },
    {
        "content": "<p>lukewagner <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1268840327\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Agreed with @sunfishcode above that the right way to support various kinds of shared-memory multi-threading in WASI in a component-model world is by expressing the imported threading functionality as core module imports, which are then instantiated by the component to explicitly share core memory with the other core modules inside the component.  When core wasm eventually gets a <a href=\"https://dl.acm.org/doi/10.1145/3360559\"><code>fork</code></a> instruction for creating threads purely from within core wasm, then these core module imports would even be virtualizable from core wasm, satisfying WASI's general goal to specify virtualizable interfaces.</p>\n<p>This does raise the question of how to write the interface of a core module in Wit, since there currently isn't any syntactic support for this.  But it's easy to imagine a Wit-like syntax for <code>core:moduletype</code> with a new top-level <code>module</code> keyword that can then be mentioned via <code>import</code> in a <code>world</code>.  IIUC, this same Wit syntax would be independently useful for reflecting the types of components that import <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/examples/SharedEverythingDynamicLinking.md\">shared-everything dynamically-linked libraries</a>, like a <code>libc</code> or <code>libspidermonkey</code>, using <code>CanonicalABI.md</code> saying how things get linked up by default, which is something @sunfishcode have also been talking about recently.  So it's good to have 2 rather-symmetric motivating use cases for this new Wit functionality.</p>\n<p>I don't have enough understanding (particularly around Wiggle) to say what we should do in the right-now term before the above Wit functionality gets implemented.  But switching out Wiggle for Wit does seem like it should be our goal state.</p>\n</blockquote>",
        "id": 302526076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664996894
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270309543\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Thanks @sunfishcode and @lukewagner for pointing out that the shared memory import/export will be expressible with WIT core modules. I still have questions on this (When and how can the core module syntax be implemented? Is help needed there and, if so, what? Should that block this PR?) but it seems like long term there should not be a problem with <code>wasi-parallel</code> moving to WIT related to shared memory import/export.</p>\n<p>But, to take up what I think is @alexcrichton's point, the issue is actually about host access. Proposals like this one and <code>wasi-threads</code> and other use cases (like the ones linked above) want to touch the host itself, e.g., Wasmtime APIs like <code>Caller</code>, <code>Module</code>, <code>Store</code>, <code>Engine</code>. In <code>wasi-threads</code>, e.g., <code>wasi_thread_spawn</code> will need access to the <code>Module</code> of the parent thread in order to create new instances of it and access to the <code>SharedMemory</code> in the <code>Store</code> to import that in each new child thread. I think what @alexcrichton is saying is that the WIT syntax and tooling do not support this and never will (?), which I was asking him to reconsider.</p>\n<p>I actually see several possibilities along a continuum:</p>\n<p>a. __dead in the water__: the WIT syntax never has knowledge of \"host access,\" the tools don't support it, and this class of proposal is dead in the water (from @alexcrichton's argument that engines like Wasmtime will not want to support non-WIT-able proposals)<br>\nb. __hack__: the WIT syntax still has no knowledge of \"host access,\" the tools still don't support it, but this class of proposal can be implemented as a core module with some hacking on the linker (as done in this PR) to get access to the host (I don't understand how this would look in WIT!)<br>\nc. __escape hatch__: the WIT syntax still has no knowledge of \"host access,\" the tools do support it as an escape hatch (e.g., an additional parameter to the WIT macros like <code>host_access_functions: [\"...\"]</code>), and this class of proposal can be more cleanly implemented<br>\nd. __full support__: the WIT syntax _does_ gain knowledge of \"host access\" (perhaps with a new <code>host</code> keyword in the signature of functions, e.g., <code>wasi_foo(host, x: i32, y: i32)</code>), then the tools would support it, etc.</p>\n<p>I've implemented \"b\" and I believe @alexcrichton was suggesting \"a.\" I would prefer \"c.\" @lukewagner, @sunfishcode: I can't tell from your comments but I think you are not saying \"a\"?</p>\n</blockquote>",
        "id": 302684402,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665071472
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270326898\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>(Also, please prefix every sentence above with \"IIUC\" since I am not too familiar with the details of the component model and I'm reading into some of @alexcrichton's comments).</p>\n</blockquote>",
        "id": 302686741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665072094
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270354002\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>To some degree I'm trying really hard here to be an impartial messenger, along the lines of \"please don't shoot the messenger\". I'm pretty intimately aware of all the constraints here ranging from the <code>threads</code> proposal to the desire for WASI threads to the component model itself, but I am trying to not take on the design myself and leave that to others. To that end I don't have great responses to comments such as:</p>\n<blockquote>\n<p>If there isn't an escape hatch, then one should be built.</p>\n</blockquote>\n<p>I'm pointing out the systems that are in play and their various designs, and all of these systems have intentional design behind them. I am not personally going to go to the component model repository and open a \"please add a small escape hatch\" issue because I'm aware of why one hasn't been added yet. Furthermore I'm not going to go to the <code>wasi-parallel</code> proposal and open an issue saying \"you will never work with the component model\" because I'm aware of the strong motivations for such a proposal. I'm trying to ideally state impartial facts here without trying to solve everything myself.</p>\n<p>That being said I naturally have a lot of opinions about how this should all work. If a parallelism story for wasm requires an \"escape hatch\" that seems like a fundamental problem because parallelism is such a foundational part of any runtime environment that if it's not designed for from day one it seems to me like it has little chance of gaining any amount of larger traction. For example just because Wasmtime is capable of implementing escape hatches like this in no way means other runtimes can do so. The <code>Caller</code> context is not available on the web, for example, meaning that if the <code>wasi-parallel</code> proposal crucially relies on such an escape hatch then that would be unimplementable or otherwise problematic for the web.</p>\n<p>Personally I even have hesitation about the whole kernel model in <code>wasi-parallel</code>. I don't understand how anyone could productively write a kernel that literally only imports shared memory and nothing else. Virtually no language can target a world where nothing is imported and if nothing is imported then a language can't even do something like print a line to standard out. While it's theoretically possible and technically possible to get something working here I feel that this is a far cry from a productive developer experience.</p>\n<p>Again though I'm trying hard to not insert myself into the design here. These are some thoughts of mine but honestly I don't consider them relevant since I'm not the one championing or being involved in the proposal. At the same time though I feel like someone has to point out the actual limitations of the systems that are being built at some point as otherwise it feels like things are carried on as everyone's just blindly merging everyone else's work without thought to the consequences.</p>\n<blockquote>\n<p>Why not just take this PR as feedback to the component model and propose a solution so that these WASI proposals can have a future?</p>\n</blockquote>\n<p>My hope is that design issues like running <code>wasi-parallel</code> in the component model would have come up much earlier in the design process long before a PR came to Wasmtime here. This isn't really the right place to discuss deep design details of the proposal or modifications to the component model. Otherwise though I don't really think it's a productive developer process to create a proof of concept and then turn around to the component model and say \"you figure out how to get this working it can't regress\". The design here should be a collaborative process of all parties involved which doesn't just shove all the work onto one person to figure out everything.</p>\n<hr>\n<p>Sorry for the long post, I have a lot of thoughts on this but now's probably not the time or the place. I'll reiterate that I personally would like to see threads-on-wasm via a standard like WASI. I don't think that the component model and WASI are in a state where things can be plucked off the shelf, mashed together, and a workable standard created. I feel there are deeper designs that need to be implemented and accounted for before moving forward with this iteration of <code>wasi-parallel</code>. For example the import-a-core-wasm-module idea seems plausible, but AFAIK the <code>wasi-parallel</code> proposal has not been designed with this in mind, runtime support in Wasmtime has not been implemented with this in mind, and support in developer tooling (a la <code>*.wit</code>) has not been designed with this in mind. That's a lot of hypothetical work to leave on the table while asking to merge this as an interim solution.</p>\n</blockquote>",
        "id": 302690539,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665073088
    },
    {
        "content": "<p>mingqiusun <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270488492\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'd be curious to see how others feel about this though. I am not sure how useful it's been to have <code>wasi-nn</code> and <code>wasi-crypto</code> in this repository, I am not aware of how much usage they're getting and feedback they're providing to the upstream proposals. In that sense I'm not sure how beneficial it will be to land this here vs have it externally.</p>\n</blockquote>\n<p>Is there a good mechanism to track usage of various features in Wasmtime? Usually I have no knowledge of certain features being used by a customer until they contact us with some issues, or they present/publish their usage somewhere. And these are probably a subset of total user base. For example, I know a big device manufacturer is in the process of embedding wasi-nn into their products. For wasi-crypto, it is an essential function for a Wasm runtime to be selected for a SASE project we are involved.</p>\n<p>Here are a few links of wasi-nn usages from googling (not all on Wasmtime):<br>\n<a href=\"https://deislabs.io/posts/wasi-nn-onnx/\">https://deislabs.io/posts/wasi-nn-onnx/</a><br>\n<a href=\"https://www.secondstate.io/articles/openvino-inferencing-using-wasmedge-wasi-nn/\">https://www.secondstate.io/articles/openvino-inferencing-using-wasmedge-wasi-nn/</a><br>\n<a href=\"https://wasmedge.org/book/en/write_wasm/rust/wasinn.html\">https://wasmedge.org/book/en/write_wasm/rust/wasinn.html</a><br>\n<a href=\"https://cfp.cloud-native.rejekts.io/cloud-native-rejekts-eu-valencia-2022/talk/NXLTRQ/\">https://cfp.cloud-native.rejekts.io/cloud-native-rejekts-eu-valencia-2022/talk/NXLTRQ/</a><br>\n<a href=\"https://www.youtube.com/watch?v=48ORmla7mak&amp;list=PLj6h78yzYM2Ni0u-ONljTkv4uOutyjwq9&amp;index=11\">https://www.youtube.com/watch?v=48ORmla7mak&amp;list=PLj6h78yzYM2Ni0u-ONljTkv4uOutyjwq9&amp;index=11</a></p>\n</blockquote>",
        "id": 302712111,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665079794
    },
    {
        "content": "<p>lukewagner <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270756679\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Just as an update: I realized my comment above was forgetting that we're talking about the core-instance-per-thread approach to multi-threading, for which the core module import approach I suggested above would need the imported core module to <em>itself</em> have a module import (the module to be instantiated for each new thread), which is not yet possible in core wasm.  So that might not be the right approach here.</p>\n<p>It does really seem like the best approach to exposing multi-threading to core wasm <em>in a standard way</em> is as proposed by <a href=\"https://dl.acm.org/doi/10.1145/3360559\">Watt &amp; Rossberg</a>, as a core wasm feature.  Although what we do to allow short-term experimentation and prototyping in Wasmtime is a different question.</p>\n</blockquote>",
        "id": 302750791,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665094643
    },
    {
        "content": "<p>penzn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1270930763\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<blockquote>\n<p>For example just because Wasmtime is capable of implementing escape hatches like this in no way means other runtimes can do so. The <code>Caller</code> context is not available on the web, for example, meaning that if the <code>wasi-parallel</code> proposal crucially relies on such an escape hatch then that would be unimplementable or otherwise problematic for the web.</p>\n</blockquote>\n<p>Web engines support this via a JavaScript callback which creates another copy of the instance. Web polyfill was part of the motivation for <code>wasi-threads</code> proposal, the other part being the fact that at least one more standalone engine supports it as well. Core spec supports multiple instance executing in parallel, this isn't an unknown either.</p>\n</blockquote>",
        "id": 302765126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665103774
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1272029329\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>@mingqiusun for sure yeah, I don't mean to say definitively whether or not those proposal should be removed from the repository, and it's great to hear that <code>wasi-nn</code> is getting such usage!</p>\n<p>@penzn indeed you are correct. There are a huge number of caveats with the support on the web for threading, however, including:</p>\n<ul>\n<li>The <code>threads</code> proposal is not offically merged into the wasm spec yet</li>\n<li>I'm not aware of any general purpose \"spawn a thread library\" due to the instance-per-thread model which requires somehow getting a module's instance imports onto web workers. All solutions I know of are very runtime-specific or specific to the shape of module and what it imports. Everything I'm aware of at least is very far from \"just call <code>pthread_create</code> and it all works\"</li>\n<li>The web's abstraction layer is not components, which I believe <code>wasi-{parallel,threads}</code> want to target at this time. The component abstraction layer, at this time, does not allow for precisely the same capabilities of what core wasm allows.</li>\n</ul>\n<p>One point that's probably worth clarifying is that it's not like I think Wasmtime shouldn't be able to implement a web-style threading scenario. In fact you can, already today, implement \"threading\" with Wasmtime since you as the host can spawn threads and figure out how to instantiate modules on new threads and share host state. There's nothing inherent to Wasmtime preventing this with Wasmtime's core wasm embedding API.</p>\n<hr>\n<p>I talked with @abrown at great length yesterday about this and we're going to try to allocate time next week to discuss what it might look like for <code>wasi-parallel</code> to get integrated into the component model more completely. In the meantime my personal feelings on this PR is that I would like to make sure that this iteration of <code>wasi-parallel</code> and <code>wasi-threads</code> can be implemented with Wasmtime's embedding API, but otherwise this implementation I think might be best to reside in a different repository than the main Wasmtime repository.</p>\n</blockquote>",
        "id": 302923084,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665171759
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1282975456\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>@abrown, @lukewagner, @sunfishcode, and I talked last week at great length about this PR and the various issues here, zooming out mostly to threads in the component model. We concluded a number of things that I hope to summarize here, and please correct me y'all if I miss anything.</p>\n<p>Our general topic was what to do with threads, the component model, and having the two work in harmony with each other. To that end we broke down a possible plan of action in to three \"stages\" ordered from shorest-time-to-implement to longest-time-to-impelment.</p>\n<h2>Stage 1</h2>\n<p>The first thing for Wasmtime and threads is to get anything working all. The goal here would effectively, through some wasm-defined API using Wasmtime's embedding API, achieving the functionality proposed by <code>wasi-{threads,parallel}</code> today (I'm going to say only <code>wasi-threads</code> from now on but I mean both). There's a lot of things even here that need implementing/deciding such as:</p>\n<ul>\n<li>How are existing WASI hostcalls synchronized?</li>\n<li>How is a <code>Store&lt;T&gt;</code> created on the new thread?</li>\n<li>How does the new thread acquire a <code>Module</code> to instantiate?</li>\n<li>How does the new thread acquire a <code>Linker&lt;T&gt;</code> to create a new instance on this thread?</li>\n</ul>\n<p>This is all just the bare bones of getting anything working, but should hopefully provide valuable implementation feedback to Wasmtime, the component model, and the <code>wasi-threads</code> proposal. All of this is likely design work that needs to be done anyway for any eventual formal <code>wasi-threads</code> proposal is the hope.</p>\n<p>This local maximum, however, is not immediately compatible with the component model. Some of the fundamental abstractions here, such as importing a shared linear memory, do not work the same way in the component model (components can't import a linear memory). This means that this stage does not have access to host APIs defined by the component model, such as a hypothetical <code>wasi-snapshot-preview2</code>. </p>\n<h2>Stage 2</h2>\n<p>This stage is intended to be sequenced after the prior stage with the goal of hooking up component-model-level host definitions into a core wasm module that wants to use threads. As a base assumption the idea here is that the user-supplied \"thing\" is still a core wasm module. The high-level idea is that host-defined component-model definitions are \"automatically lowered\" into the corresponding core wasm functions to get imported into a core wasm module.</p>\n<p>This sort of means that a <code>wasmtime::Linker</code> could be blended with a <code>wasmtime::component::Linker</code> to instantiate a <code>wasmtime::Module</code>. The thinking is that the work from stage 1, probably mostly present in a <code>wasmtime::Linker</code>, could pull in definitions from a <code>wasmtime::component::Linker</code> to get access to all host APIs while still retaining access to the abstraction layer of threads.</p>\n<p>The main body of work in this stage would be to figure out how to robustly take a component-model level API and translate it into a core wasm API. This is roughly already done with the canonical ABI but I personally believe there's a lot of fiddly bits to work out such as how to reuse the lifting/lowering in Wasmtime without duplicating it. For example somehow a <code>VMContext</code> and a <code>VMComponentContext</code> need to be bridged between one another or ... something like that.</p>\n<p>In discussing this though we wondered but weren't sure of how important such feature would be for migrating from wasi preview1 to preview2. There will, for a long time, be binaries that import <code>wasi_snapshot_preview1</code> and there's a number of strategies to load that into a preview2-supporting runtime, but something it might be quite useful to allow merging of newly-defined and implemented APIs into older modules.</p>\n<p>The downside of this stage is that there still isn't full integration with the component model. Everything is still working at the level of abstraction of a core wasm module and inherently continues to be incompatible with components. The main distinction from stage 1 is that component-model-level functionality, which is the presumed path that WASI is going, can still be imported into the module.</p>\n<h2>Stage 3</h2>\n<p>The next stage of evolution for support here would be to integrate threads into the component model proposal itself. This is a far-in-the-future vision though where there's a difference between a <code>func</code> and a <code>shared func</code> for example. there's a ton of design questions here that (at least to me) don't have obvious answers. There's quite a lot of design work here not only for core wasm but also the component model. This is the hypothetical end goal of components that support threads, but I'm mostly listing this here for completeness as the timescale for implementing this in in the many-numbers-of-years.</p>\n<hr>\n<p>Given the possible staging here I concluded that my original stance of \"we probably don't want to merge this\" is no longer true. The staging here would explicitly continue to work at the core wasm layer and not the component layer. Furthermore for the time  being there would be no path forward to implement this in the component layer but there would be a path to taking some of the major benefits of the component layer and bringing them to core wasm. I'd revise my previous stance, then, to it's ok to merge this into the main Wasmtime repository along the lines of all other WASI proposals.</p>\n<p>That's not to discount the technical review here, however. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5054#issuecomment-1280985863\">This is an example</a> of a fundamental issue in <code>wiggle</code> which will need to get ironed out before landing. Furthermore I personally at least feel that <code>wasi-parallel</code> may not be a best fit for the first proposal implemented here (the kernel feels a bit odd, it's JIT compiled so doesn't work with AOT compilation, the kernel itself can't import anything useful, unclear how toolchains will produce this kernel from \"real\" source code, etc). @abrown what would you think of implementing <code>wasi-threads</code> first? That feels like a more low-level proposal which would, for now at least, subsume the functionality implemented here for <code>wasi-parallel</code> I think?</p>\n</blockquote>",
        "id": 304836404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666125470
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1289726589\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Thanks @alexcrichton for the detailed write-up; I think it's a pretty accurate reflection of what we discussed and a decent high-level vision for how to move forward. I agree that <code>wasi-threads</code> is a more foundational proposal and, actually, I think it highlights some of the issues to overcome to get to stage 1 better than <code>wasi-parallel</code> does. <code>wasi-parallel</code> side steps a few things with its \"bag of bytes\" paradigm. I'll see if there's a way to get <code>wasi-threads</code> done first.</p>\n<p>The current issues to get to stage 1 that @alexcrichton describes above are many and span multiple repositories (this one, <code>wasi-libc</code>, LLVM, Rust, etc.). For anyone else interested in progress on getting <code>wasi-threads</code> to the stage 1, this <a href=\"#narrow/stream/349267-wasi-threads\">Zulip channel</a> has the latest discussion. @haraldh has taken some of the pieces I and others have been working and has a working PoC! I will post my take on the remaining items to upstream, probably in an issue on the <code>wasi-threads</code> spec repository.</p>\n</blockquote>",
        "id": 305925573,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666651530
    },
    {
        "content": "<p>abrown edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949#issuecomment-1289726589\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">issue #4949</a>:</p>\n<blockquote>\n<p>Thanks @alexcrichton for the detailed write-up; I think it's a pretty accurate reflection of what we discussed and a decent high-level vision for how to move forward. I agree that <code>wasi-threads</code> is a more foundational proposal and, actually, I think it highlights some of the issues to overcome to get to stage 1 better than <code>wasi-parallel</code> does. <code>wasi-parallel</code> sidesteps a few things with its \"bag of bytes\" paradigm. I'll see if there's a way to get <code>wasi-threads</code> done first.</p>\n<p>The current issues to get to stage 1 that @alexcrichton describes above are many and span multiple repositories (this one, <code>wasi-libc</code>, LLVM, Rust, etc.). For anyone else interested in progress on getting <code>wasi-threads</code> to the stage 1, this <a href=\"#narrow/stream/349267-wasi-threads\">Zulip channel</a> has the latest discussion. @haraldh has taken some of the pieces I and others have been working on and has build a working PoC! I will post my take on the remaining items to upstream, probably in an issue on the <code>wasi-threads</code> spec repository.</p>\n</blockquote>",
        "id": 305925711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1666651586
    }
]