[
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-617883381\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-617883381\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>cc @lostman, I wanted to ping you here about per-instance custom signal handlers (added in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/620\" title=\"https://github.com/bytecodealliance/wasmtime/pull/620\">https://github.com/bytecodealliance/wasmtime/pull/620</a>). There's a bit of a refactoring here to avoid some unsafe <code>transmute</code> calls, but it's not required as part of this PR itself. As a question, though, I was wondering if you could elaborate a bit on y'all's usage of signal handlers? Do you catch signals originating in wasm code itself? Or only in your host code? Additionally, does a per-<code>Store</code> signal handler work for you as opposed to a per-instance signal handler?</p>\n</blockquote>",
        "id": 194956032,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587572580
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-617891802\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-617891802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\" title=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 194957806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587573425
    },
    {
        "content": "<p>lostman <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619805126\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619805126\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>@alexcrichton we are using the custom signal handler for memory access tracking using sigsegv+mprotect.</p>\n<p>Setting the signal handler per-store will also work but at first glance seems less clean.</p>\n<p>Each handler has an instance specific behavior. So we could set the handler once and add some sort of registry to map segfaults to instances.</p>\n<p>Or we could set the handler before running each instance, as I see you've done in the <code>tests/all/custom_signal_handler.hs</code>. Given that there might be many instances created using a single store, is that the right way to do it though?</p>\n</blockquote>",
        "id": 195383598,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587974348
    },
    {
        "content": "<p>lostman edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619805126\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619805126\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>@alexcrichton we are using the custom signal handler for memory access tracking using sigsegv+mprotect.</p>\n<p>Setting the signal handler per-store will also work but at first glance seems less clean.</p>\n<p>Each handler has an instance specific behavior. So we could set the handler once and add some sort of registry to map segfaults to instances.</p>\n<p>Or we could set the handler before running each instance, as I see you've done in the <code>tests/all/custom_signal_handler.hs</code>. Given that there might be many instances created using a single store, is that the right way to do it though?</p>\n<p>In any case we're happy to adapt to whatever makes the code simpler/better!</p>\n</blockquote>",
        "id": 195383755,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587974436
    },
    {
        "content": "<p>eust-dfinity <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619967984\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-619967984\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>@alexcrichton There are some other things I'd like to add, which might give us headache:</p>\n<ol>\n<li>\n<p>This commit affects not just SIGSEGV/SIGBUS but other signals as well. Notably division by zero in host code will now trigger panic instead of producing a Trap (maybe this is fully intended - I'm just pointing it out in case it's not). My feeling is that life would be simpler to end users if they got consistent behavior, that is always Trap on attempt to div by zero no matter where the trap originated. In our case, we can probably catch it in our custom signal handler and make the whole system respond properly though...</p>\n</li>\n<li>\n<p>My quick tests indicate, that after these changes signals raised manually get completely ignored (this concerns SIGSEGV, SIGILL, SIGBUS, SIGFPE), e.g. executing libc::raise(libc::SIGFPE) in a host call has no effect.</p>\n</li>\n<li>\n<p>We are actually using raise(SIGILL) to terminate wasmtime's execution (similar as the killswitch in lucet). Is there any other way in wasmtime to terminate? (the newly added interrupt functionality won't work, because we want to terminate on the spot, with guarantee that no other instruction will get executed)</p>\n</li>\n</ol>\n</blockquote>",
        "id": 195411995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587992147
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620061985\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620061985\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>@lostman thanks for taking a look! One thing I think that's a bit surprising about the instance behavior is that you're not actually guaranteed to run the per-instance signal handler if a signal happens while that instance's code is running. The way it's all set up today only if you <em>enter</em> with a particular instance do you get the signal handler registered, but with how wasm modules are linked you're not guaranteed that a signal handler runs. That was one simplification I was hoping to apply here where a per-store signal handler is actually what the implementation is providing because it's the only granularity at which we can guarantee it's run.</p>\n<p>I think it's probably best from an API-point-of-view that if your usage of wasmtime can guarantee that within a particular scope there's only one instance involved then it'd be encoded into your signal handler. (largely because it's not something we can guarantee in wasmtime itself)</p>\n<p>@eust-dfinity oh so recovering from signals in host code is something we never intended to do. It's not memory safe to arbitrarily longjmp out of the middle of a Rust function, so this is a case where wasmtime isn't quite memory safe today and we're trying to fix it. In general if you want to map things like divide-by-zero in the host to a trap in wasm it's something that will need to explicitly be done rather than relying on the signal handler.</p>\n<p>For termination, you're asking how to terminate host code? Note that if longjmp out of your host code is safe for your application you should be able to register your own signal handler to jump out. Wasmtime should defer to it once it realizes that the fault didn't happen in wasm. Otherwise I would recommend using <code>Result</code>-propagation in Rust code to \"quickly\" return back to wasm, although it doesn't have the \"zero extra instructions executed\" property.</p>\n</blockquote>",
        "id": 195434692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588001683
    },
    {
        "content": "<p>eust-dfinity <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620539841\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620539841\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>Thanks for the explanation! Makes sense.</p>\n<p>Putting our problems aside, I still don't understand why libc::raise(SIGSEGV) gets ignored. I tried looking at the execution and it seems to be going through wasmtime's signal handler through \"not handled\" path, while true segfault or division by zero seem to be not triggering the handler at all.</p>\n</blockquote>",
        "id": 195548104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588072258
    },
    {
        "content": "<p>eust-dfinity edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620539841\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620539841\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>Thanks for the explanation! Makes sense.</p>\n<p>Putting our problems aside, I still don't understand why libc::raise(SIGSEGV) gets ignored. I tried looking at the execution and it seems to be going through wasmtime's signal handler through \"not handled\" path, while true segfault or division by zero seem to be not triggering the handler at all.</p>\n<p>EDIT: Ok, I got confused there for a moment. To be precise real segfault does trigger the handler as it should. It's just division by zero which doesn't, but instead results in regular rust panic, so I guess it must by rust's thing and this part is OK. However I still can't get libc::raise() to abort the execution.</p>\n</blockquote>",
        "id": 195564656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588080925
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620662057\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620662057\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>Ah yeah so division by zero doesn't raise a signal in Rust because it's defined across all platforms to panic, (otherwise I think it's UB). For <code>libc::raise(libc::SIGSEGV)</code> I think I see what's happening. When wasmtime decides to ignore a signal it <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9d13871bd4d09a2e883ee4122bdd7099a1e7e2d3/crates/runtime/src/traphandlers.rs#L128-L136\" title=\"https://github.com/bytecodealliance/wasmtime/blob/9d13871bd4d09a2e883ee4122bdd7099a1e7e2d3/crates/runtime/src/traphandlers.rs#L128-L136\">returns from the signal handler</a> thinking it will reexecute the faulting instruction, but in this case there's no faulting instruction so presumably it ends up normally returning from the <code>raise</code> syscall. </p>\n<p>I'm not actually sure that there's a way to handle <em>some</em> segfaults but still abort with <code>libc::raise(libc::SIGSEGV)</code>. I do think though that you can use other non-<code>SIGSEGV</code> signals to abort the process.</p>\n</blockquote>",
        "id": 195576716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588086063
    },
    {
        "content": "<p>eust-dfinity <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620912462\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#issuecomment-620912462\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">Issue #1577</a>:</p>\n<blockquote>\n<p>Right, it all makes sense now. Thanks again for the explanation!</p>\n</blockquote>",
        "id": 195643193,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588117745
    }
]