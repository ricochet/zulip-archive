[
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/871#issuecomment-601991148\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/871#issuecomment-601991148\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/871\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/871\">Issue #871</a>:</p>\n<blockquote>\n<p>Hello! I recently started adding some content to the <a href=\"https://bytecodealliance.github.io/wasmtime/security-sandboxing.html#webassembly-core\" target=\"_blank\" title=\"https://bytecodealliance.github.io/wasmtime/security-sandboxing.html#webassembly-core\">security-sandboxing</a> document, and it answers this question, at least at a high level.</p>\n<p>All \"pointers\" in C are compiled into wasm as indices into linear memory, which you can think of as just an array of bytes, with bounds checking. So while your vulnerable C code may store beyond the ends of the nominal array, it can't access any memory outside the wasm instance's memory.</p>\n<p>Also, all control transfers in wasm are checked, at compile time or runtime, to ensure they go to known branch/jump destinations. Among other things, this means that even if you load a machine-code payload, you can't make the program jump to it.</p>\n<p>Does this clarify things? If not, please let us know as we're interested in expanding the documentation to answer questions people have!</p>\n</blockquote>",
        "id": 191327265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584763706
    },
    {
        "content": "<p>bluescreen303 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/871#issuecomment-791921436\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/871\">Issue #871</a>:</p>\n<blockquote>\n<p>better late than never :)</p>\n<p>Yes, that document clarifies things a lot. Many thanks!<br>\n</p>\n</blockquote>",
        "id": 229091362,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615031109
    },
    {
        "content": "<p>bluescreen303 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/871\">Issue #871</a>:</p>\n<blockquote>\n<p>I noticed the documentation for how the sandbox works is just a stub currently. I would really like to know more about it, so this issue is just to track progress.</p>\n<ul>\n<li>I read <a href=\"https://bytecodealliance.org/articles/announcing-the-bytecode-alliance\">https://bytecodealliance.org/articles/announcing-the-bytecode-alliance</a> and am enthousiastic</li>\n<li>I played around with rust / wasmpack before and tried the hello world and capabilities system in wasmtime.</li>\n<li>I understand how proper wasm modules only get access to certain resources and capabilities their parent gives them</li>\n<li>However, compiled(jitted) code all runs in 1 (operating system) process so it can <em>potentially</em> do system calls and access all memory in the process</li>\n</ul>\n<p>One thing I would really like to get clarified is how the sandbox (and possibly the just-in-time compilation of wasm to machine code) will protect against the following scenario:</p>\n<ul>\n<li>I create a bit of c code that has a buffer overflow in a function</li>\n<li>I compile this c code to wasm</li>\n<li>I say my wasm module doesn't need any capabilities and only expose a string -&gt; string function</li>\n<li>I create an additional module that will call the vulnerable module with a payload that overflows the buffer with some machine code for the target architecture</li>\n<li>this machine code isn't generated by the jit, didn't come from a valid wasm module</li>\n<li>so it can do things like memory access and syscalls and isn't bound to what the wasm module received as inputs</li>\n<li>I somehow find a way to have the instruction pointer jump to this malicious code (as I would be able to do in c)</li>\n</ul>\n<p>My guess is that either the overflowing wouldn't work (how is this protected given that c is compilable into wasm), or there is no way to get the overflowed malicious code to execute (how would wasmtime protect against this?), but I would like some nice documentation explaining this.</p>\n</blockquote>",
        "id": 229091363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615031109
    }
]