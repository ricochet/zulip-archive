[
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 370579911,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1687987856
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370584188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1687989239
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> mechanisms are the extension mechanism for <code>wasmtime_wasi</code>, as well as other crates, to provide implementations of the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<p>Wasmtime-wasi provides a built in <code>AsyncReadStream</code> to wrap any <code>tokio::io::AsyncRead</code> to impl <code>HostInputStream</code>, <code>AsyncWriteStream</code> to adapt <code>AsyncWrite</code> to <code>HostOutputStream</code>, and a <code>AsyncFdStream</code> wrapper for <code>AsynFd</code> that provides both stream impls (only available for <code>cfg(unix)</code>).</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readines s</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that it was too challenging</p>\n</blockquote>",
        "id": 370610445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688002991
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> mechanisms are the extension mechanism for <code>wasmtime_wasi</code>, as well as other crates, to provide implementations of the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<p>Wasmtime-wasi provides a built in <code>AsyncReadStream</code> to wrap any <code>tokio::io::AsyncRead</code> to impl <code>HostInputStream</code>, <code>AsyncWriteStream</code> to adapt <code>AsyncWrite</code> to <code>HostOutputStream</code>, and a <code>AsyncFdStream</code> wrapper for <code>AsynFd</code> that provides both stream impls (only available for <code>cfg(unix)</code>).</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readines s</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n</blockquote>",
        "id": 370610489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688003039
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> traits are used to implement the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<h2><code>Host{Input, Output}Stream</code> design</h2>\n<h2><code>HostPollable</code> design</h2>\n<h2>Implementations</h2>\n<p><code>wasmtime-wasi</code> provides a struct <code>AsyncReadStream</code> which wraps a <code>tokio::io::AsyncRead</code> to provide an impl of <code>HostInputStream</code>, <code>AsyncWriteStream</code> to wraps <code>AsyncWrite</code> to provide <code>HostOutputStream</code>, and, in <code>cfg(unix)</code>, <code>AsyncFdStream</code> wraps <code>tokio::io::unix::AsynFd</code> to provide both read and write stream impls.</p>\n<p><code>AsyncReadStream</code> and <code>AsyncWriteStream</code> will manage their own buffer in order for the <code>HostInputStream::read</code> and <code>HostOutputStream::write</code> methods to be non-blocking. These methods call the  <code>AsyncRead::poll_read</code> and <code>AsyncWrite::poll_write</code> methods with a noop-waker Context (for now, this trivial implementation has been copied out of <code>std</code> sources until it becomes available in stable Rust) as a mechanism for providing a non-blocking read/write from synchronous code - @alexcrichton showed us that design.</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readiness on both windows and unix. In Unix, this is built on top of <code>AsyncFdStream</code>, allows tokio to register stdin with <code>epoll(7)</code>. Because stdin is a process-wide singleton, and also because epoll will return an error if the same fd is registered multiple times, the stdin resource is a global singleton, created lazily and guarded by a mutex. <code>wasmtime_wasi::preview2::stdio::stdin()</code> returns a <code>struct Stdin</code> which takes a lock on that singleton in the <code>HostImputStream::{read, ready}</code> methods. This means that, if for some reason you have granted the process stdin to multiple wasi streams (in the same, or different, stores) you can get all sorts of strange behavior because the same global resource backs them all behind the scenes - but this is always the case, the implementation in wasmtime_wasi just allows you to do so without hanging or panicking.</p>\n<p>On Windows, we use the same approach as in the wasi-common preview 1 scheduler implementation - a (global singleton, lazily created, guarded by a mutex) worker thread running <code>std::io::stdin().lock().fill_buf()</code> as a blocking function. The communication scheme from the old implementation was changed up to use tokio::sync as the messaging primitives. This implementation has never been executed outside of CI because I don't have a windows machine, and I don't think our test coverage of this code is particularly great, so I basically expect someone who tries this on windows to report bugs.</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n</blockquote>",
        "id": 370612025,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688004177
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1246705813\">PR review comment</a>:</p>\n<blockquote>\n<p>I wonder if there's a way to optimize this by reusing <a href=\"https://docs.rs/futures/latest/futures/stream/struct.FuturesUnordered.html\">FuturesUnordered</a> here.  From the docs:</p>\n<blockquote>\n<p>This structure is optimized to manage a large number of futures. Futures managed by <a href=\"https://docs.rs/futures/latest/futures/stream/struct.FuturesUnordered.html\">FuturesUnordered</a> will only be polled when they generate wake-up notifications. This reduces the required amount of work needed to poll large numbers of futures.</p>\n</blockquote>\n<p>The implementation of <code>FuturesUnordered</code> interposes a custom waker which precisely tracks which futures have been woken, queuing them up to be polled at the next opportunity, and not wasting time polling the futures which haven't been woken.  This can make a big difference when the number of pollables is large.</p>\n</blockquote>",
        "id": 370806617,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688049076
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1246723896\">PR review comment</a>:</p>\n<blockquote>\n<p>I should mention that we wouldn't get the full benefit of <code>FuturesUnordered</code> here given the one-off nature of <code>poll-oneoff</code>, so it might not be worth it until/unless we replace <code>poll-oneoff</code> with a resource that's intended to be polled repeatedly.</p>\n</blockquote>",
        "id": 370811489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688049873
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1246785404\">PR review comment</a>:</p>\n<blockquote>\n<p>I definitely don't disagree about the benefits of <code>FuturesUnordered</code>, but I would personally say we should start off simpler here and see how things go. My guess is that a large number of futures would have many other inefficiencies other than the polling behavior here, and in the meantime, at least to me personally, I feel that a manual \"poll the list\" is easier to understand than the <code>FuturesUnordered</code> abstraction</p>\n</blockquote>",
        "id": 370825364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688052246
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370836014,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688054091
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370913348,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688069515
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370925059,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688072736
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370927346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688073314
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370938840,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688077486
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370940091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688078029
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370943422,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079555
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite. Most of this was pair-programmed with @elliottt.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> traits are used to implement the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<h2><code>Host{Input, Output}Stream</code> design</h2>\n<p><code>input-stream</code> and <code>output-stream</code> resources have a significant number of methods. For the host traits, we managed to boil this down to two required methods, as well as some optional methods to cover vectored IO, splice, and write-zeroes. The default implementations provide an unoptimized but correct implementation - the user may override them if an optimization is desired.</p>\n<p><code>HostInputStream</code> has just two methods: <code>fn read(&amp;mut self, ...)</code> and <code>async fn ready(&amp;mut self)</code>. The most important invariant is that <code>read</code> must be non-blocking, and <code>ready</code> must block until the stream is ready for reading.</p>\n<h2><code>HostPollable</code> design</h2>\n<p>The trick to <code>HostPollable</code> is to create a Rust <code>Future</code> indicating whether a stream (or some other resource, e.g. http bodies) is ready without requiring both the stream and pollable hold some <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> to the resource itself. @alexcrichton pointed out the right design here: <code>HostPollable</code> is an enum with two variants:</p>\n<ul>\n<li><code>TableEntry { index: u32, make_future: for&lt;'a&gt; fn(&amp;'a mut dyn Any) -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'a&gt;}</code> means, get a mutable reference to some (still dynamically-typed) other entry in the table, and apply this fn to create a Future from that entry, which has the same lifetime as the mutable reference. For the streams, we use this variant, and make_future is just a call to the <code>Host{Input,Output}Stream::ready</code> method.</li>\n<li><code>Closure( Box&lt;Fn() -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'static&gt;&gt; + Send + Sync + 'static&gt; )</code> means, use this owned closure to create a Future with a static lifetime. This is used for creating timers from the monotonic and wall clocks, which are ambient and therefore do not have table entries.</li>\n</ul>\n<h2>Implementations</h2>\n<p><code>wasmtime-wasi</code> provides a struct <code>AsyncReadStream</code> which wraps a <code>tokio::io::AsyncRead</code> to provide an impl of <code>HostInputStream</code>, <code>AsyncWriteStream</code> to wraps <code>AsyncWrite</code> to provide <code>HostOutputStream</code>, and, in <code>cfg(unix)</code>, <code>AsyncFdStream</code> wraps <code>tokio::io::unix::AsynFd</code> to provide both read and write stream impls.</p>\n<p><code>AsyncReadStream</code> and <code>AsyncWriteStream</code> will manage their own buffer in order for the <code>HostInputStream::read</code> and <code>HostOutputStream::write</code> methods to be non-blocking. These methods call the  <code>AsyncRead::poll_read</code> and <code>AsyncWrite::poll_write</code> methods with a noop-waker Context (for now, this trivial implementation has been copied out of <code>std</code> sources until it becomes available in stable Rust) as a mechanism for providing a non-blocking read/write from synchronous code - @alexcrichton showed us that design.</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readiness on both windows and unix. In Unix, this is built on top of <code>AsyncFdStream</code>, allows tokio to register stdin with <code>epoll(7)</code>. Because stdin is a process-wide singleton, and also because epoll will return an error if the same fd is registered multiple times, the stdin resource is a global singleton, created lazily and guarded by a mutex. <code>wasmtime_wasi::preview2::stdio::stdin()</code> returns a <code>struct Stdin</code> which takes a lock on that singleton in the <code>HostImputStream::{read, ready}</code> methods. This means that, if for some reason you have granted the process stdin to multiple wasi streams (in the same, or different, stores) you can get all sorts of strange behavior because the same global resource backs them all behind the scenes - but this is always the case, the implementation in wasmtime_wasi just allows you to do so without hanging or panicking.</p>\n<p>On Windows, we use the same approach as in the wasi-common preview 1 scheduler implementation - a (global singleton, lazily created, guarded by a mutex) worker thread running <code>std::io::stdin().lock().fill_buf()</code> as a blocking function. The communication scheme from the old implementation was changed up to use tokio::sync as the messaging primitives. This implementation has never been executed outside of CI because I don't have a windows machine, and I don't think our test coverage of this code is particularly great, so I basically expect someone who tries this on windows to report bugs.</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n</blockquote>",
        "id": 370944346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079941
    },
    {
        "content": "<p><strong>pchickey</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a> as ready for review.</p>",
        "id": 370944353,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079945
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370944356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079946
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370944358,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079946
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370944359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688079946
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370944574,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688080030
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/dicej\">dicej</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 370968851,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688090878
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite. Most of this was pair-programmed with @elliottt.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> traits are used to implement the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<h2><code>Host{Input, Output}Stream</code> design</h2>\n<p><code>input-stream</code> and <code>output-stream</code> resources have a significant number of methods. For the host traits, we managed to boil this down to two required methods, as well as some optional methods to cover vectored IO, splice, and write-zeroes. The default implementations provide an unoptimized but correct implementation - the user may override them if an optimization is desired.</p>\n<p><code>HostInputStream</code> has just two methods: <code>fn read(&amp;mut self, ...)</code> and <code>async fn ready(&amp;mut self)</code>. The most important invariant is that <code>read</code> must be non-blocking, and <code>ready</code> must block until the stream is ready for reading.</p>\n<h2><code>HostPollable</code> design</h2>\n<p>The trick to <code>HostPollable</code> is to create a Rust <code>Future</code> indicating whether a stream (or some other resource, e.g. http bodies) is ready without requiring both the stream and pollable hold some <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> to the resource itself. @alexcrichton pointed out the right design here: <code>HostPollable</code> is an enum with two variants:</p>\n<ul>\n<li><code>TableEntry { index: u32, make_future: for&lt;'a&gt; fn(&amp;'a mut dyn Any) -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'a&gt;}</code> means, get a mutable reference to some (still dynamically-typed) other entry in the table, and apply this fn to create a Future from that entry, which has the same lifetime as the mutable reference. For the streams, we use this variant, and make_future is just a call to the <code>Host{Input,Output}Stream::ready</code> method.</li>\n<li><code>Closure( Box&lt;Fn() -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'static&gt;&gt; + Send + Sync + 'static&gt; )</code> means, use this owned closure to create a Future with a static lifetime. This is used for creating timers from the monotonic and wall clocks, which are ambient and therefore do not have table entries.</li>\n</ul>\n<h2>Implementations</h2>\n<p><code>wasmtime-wasi</code> provides a struct <code>AsyncReadStream</code> which wraps a <code>tokio::io::AsyncRead</code> to provide an impl of <code>HostInputStream</code>, <code>AsyncWriteStream</code> to wraps <code>AsyncWrite</code> to provide <code>HostOutputStream</code>, and, in <code>cfg(unix)</code>, <code>AsyncFdStream</code> wraps <code>tokio::io::unix::AsynFd</code> to provide both read and write stream impls.</p>\n<p><code>AsyncReadStream</code> and <code>AsyncWriteStream</code> will manage their own buffer in order for the <code>HostInputStream::read</code> and <code>HostOutputStream::write</code> methods to be non-blocking. These methods call the  <code>AsyncRead::poll_read</code> and <code>AsyncWrite::poll_write</code> methods with a noop-waker Context (for now, this trivial implementation has been copied out of <code>std</code> sources until it becomes available in stable Rust) as a mechanism for providing a non-blocking read/write from synchronous code - @alexcrichton showed us that design.</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readiness on both windows and unix. In Unix, this is built on top of <code>AsyncFdStream</code>, allows tokio to register stdin with <code>epoll(7)</code>. Because stdin is a process-wide singleton, and also because epoll will return an error if the same fd is registered multiple times, the stdin resource is a global singleton, created lazily and guarded by a mutex. <code>wasmtime_wasi::preview2::stdio::stdin()</code> returns a <code>struct Stdin</code> which takes a lock on that singleton in the <code>HostImputStream::{read, ready}</code> methods. This means that, if for some reason you have granted the process stdin to multiple wasi streams (in the same, or different, stores) you can get all sorts of strange behavior because the same global resource backs them all behind the scenes - but this is always the case, the implementation in wasmtime_wasi just allows you to do so without hanging or panicking.</p>\n<p>On Windows, we use the same approach as in the wasi-common preview 1 scheduler implementation - a (global singleton, lazily created, guarded by a mutex) worker thread running <code>std::io::stdin().lock().fill_buf()</code> as a blocking function. The communication scheme from the old implementation was changed up to use tokio::sync as the messaging primitives. This implementation has never been executed outside of CI because I don't have a windows machine, and I don't think our test coverage of this code is particularly great, so I basically expect someone who tries this on windows to report bugs.</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n<h1>Bindings traits</h1>\n<p>After living with the bindings generated underneath <code>crate::preview2::wasi</code> and <code>crate::preview2::wasi::command</code> for a while, I decided that the interface traits belong under <code>crate::preview2::bindings</code> and command belongs under <code>crate::preview2::command</code>.</p>\n<p>Beyond that code motion, we now generate async traits for the <code>wasi:io/streams</code> and <code>wasi:poll/poll</code> interfaces, and sync traits for everything else. If you want to use the bindings from an async embedding (i.e. with an async Config), the <code>crate::preview2::bindings::{interface}::add_to_linker</code> will do it, and if you want to use them from a synchronous embedding, use <code>crate::preview2::bindings::sync::{interface}::add_to_linker</code>.</p>\n</blockquote>",
        "id": 370969269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688091098
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1507460880\">PR review</a>:</p>\n<blockquote>\n<p>Looking reasonable so far, but the high level things which I think need more looking into are:</p>\n<ul>\n<li>The <code>block_in_place</code> place function I don't think can ever be used correctly since it's used in contexts that shouldn't block for the express purpose of blocking.</li>\n<li>Buffering internally I think needs to all be \"capped\" so it doesn't buffer up too much data on repeated non-blocking calls to write/read</li>\n<li>I only realized this later in review, but all <code>ready</code> futures need to be \"cancel safe\" where the internal objects are all left in a consistent state if the operation is cancelled.</li>\n</ul>\n</blockquote>",
        "id": 371263624,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149183
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1507460880\">PR review</a>:</p>\n<blockquote>\n<p>Looking reasonable so far, but the high level things which I think need more looking into are:</p>\n<ul>\n<li>The <code>block_in_place</code> place function I don't think can ever be used correctly since it's used in contexts that shouldn't block for the express purpose of blocking.</li>\n<li>Buffering internally I think needs to all be \"capped\" so it doesn't buffer up too much data on repeated non-blocking calls to write/read</li>\n<li>I only realized this later in review, but all <code>ready</code> futures need to be \"cancel safe\" where the internal objects are all left in a consistent state if the operation is cancelled.</li>\n</ul>\n</blockquote>",
        "id": 371263627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248039904\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this'd be good to have a doc-block explaining when it's intended to be used, basically exclusively as a bridge between the async implementation and the desire to have a synchronous implementation instead.</p>\n</blockquote>",
        "id": 371263628,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248042151\">PR review comment</a>:</p>\n<blockquote>\n<p>One possible update in the future is to use <code>bytes::Bytes</code> here since we're already buying in tokio stuff, but this also may not be used that heavily in which case it wouldn't matter too too much.</p>\n</blockquote>",
        "id": 371263629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248025172\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this is fine for now, but this I think is violating the contract of <code>read</code> where it should be non-blocking right? I think that <code>block_in_place</code> will correctly not block other tasks but from the point of view of wasm this will still be blocking and \"possibly taking awhile\" since the host call is blocked in reading.</p>\n<p>Fixing this though I think will be somewhat involved and require similar adapters for async read/write where a <code>read</code> queues up a request for a read and then during <code>async fn ready</code> it asynchronously blocks on a thread performing the read.</p>\n<p>That gets sort of funky though because then you have to say that a file is ready for reading but not actually queue up a read until a read is requested (or something like that). </p>\n<p>Anyway that's just an idea, but probably not a good one. Something will need to change here though I think either at the WASI spec level or here or something though to ensure it's all consistent.</p>\n</blockquote>",
        "id": 371263630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248037293\">PR review comment</a>:</p>\n<blockquote>\n<p>If you get a chance I think it'd be good to open an issue for avoiding this <code>_internal_io</code> wrapper module in the future. It seems like it's probably here to avoid clashes in two <code>bindgen!</code> macros or you're hiding stuff generated by <code>bindgen!</code>, but we can probably add more options to the macro in the future to fix that and avoid the need.</p>\n</blockquote>",
        "id": 371263631,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248042774\">PR review comment</a>:</p>\n<blockquote>\n<p>I might recommend <code>self.buffer.drain(..read_from_buffer)</code> for this perhaps</p>\n</blockquote>",
        "id": 371263632,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248043767\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this'll want to check the length of <code>self.buffer</code> and only block in <code>await</code> if it's zero</p>\n</blockquote>",
        "id": 371263633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248041017\">PR review comment</a>:</p>\n<blockquote>\n<p>Like above I think this would be good to have a doc block, but this ties in with my concerns on the file implementation in that I'm not sure we can actually support a function such as this since it's used in context which aren't supposed to block but this causes them to block?</p>\n</blockquote>",
        "id": 371263634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248057728\">PR review comment</a>:</p>\n<blockquote>\n<p>I think the \"fix\" here might be to ignore this error actually? If an error happens I think the only error is disconnection, which means that all future attempts to write will also continue to see the same error, so this is otherwise swallowing the bytes that were previously written and reported as written but they ended up not being received in the end.</p>\n</blockquote>",
        "id": 371263635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248054147\">PR review comment</a>:</p>\n<blockquote>\n<p>One thing I might recommend to simplify this a bit is to remove the <code>Writable</code> state since because this is a spsc channel once a reservation is done to acquire an <code>OwnedPermit</code> then it'll forever be writable immediately by the <code>InputStream</code>. Effectively in <code>ready</code> after <code>reserve_owned</code> I think it can call <code>release</code> to avoid the need to store channel-or-permit.</p>\n</blockquote>",
        "id": 371263636,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248060538\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this may not be quite right because technically <code>read</code> always succeeds, right? </p>\n</blockquote>",
        "id": 371263637,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248058528\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it'd be worth mirroring what files/sockets do in this case. Well ok not files since they just extend the file but for sockets I think it's an EPIPE return (or equivalent thereof)</p>\n</blockquote>",
        "id": 371263639,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248047712\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it'd be good to document what <code>bound</code> here is perhaps? I think that this ends up being a bound on \"chunks\" though rather than bytes which is probably what would be expected? I think it's ok to switch from chunks-to-bytes as a follow-up though.</p>\n</blockquote>",
        "id": 371263641,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248059385\">PR review comment</a>:</p>\n<blockquote>\n<p>I think that this is the method where the <code>bound</code> should be checked from above because otherwise this can infinitely be called and it'll never return \"wouldblock\" and it'll just keep buffering data.</p>\n</blockquote>",
        "id": 371263642,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248065486\">PR review comment</a>:</p>\n<blockquote>\n<p>One way to get rid of <code>Clone</code>, <code>Arc</code>, and <code>Mutex</code> here might be to require users of this to lookup the pipe from within the original table that it was inserted into? Although I suppose that runs afoul of WASI closing it which would then drop this, so perhaps not. It feels a bit weird though to have <code>Clone</code> for this type which shouldn't really be cloned and rather it's intended to be more of a \"one end writes one end reads\" sort of style.</p>\n<p>Anyway fine to handle this later.</p>\n</blockquote>",
        "id": 371263643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248066916\">PR review comment</a>:</p>\n<blockquote>\n<p>Could you have a comment for why there's a hash map involved here? </p>\n<p>(basically we can only mutably borrow each table entry at most once so all requests for the same table entry must be \"canonicalized\")</p>\n</blockquote>",
        "id": 371263644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248076719\">PR review comment</a>:</p>\n<blockquote>\n<p>Unlike my thinking way up above about <code>block_in_place</code> for read/write on files I do think that it's the correct API to use here. This is fundamentally a blocking API (even as WASI defines it) so this is saying \"hey tokio go do something as necessary as I'm about to block\". </p>\n<p>In the context of an async server though since it locks up a whole thread where the \"correct\" thing would be to leave this as an <code>async fn</code> which does a <code>spawn_blocking</code>. Given that I'm not sure how best to handle this. From a CLI point of view either way works, and from an async server point of view the actual real filesystem probably isn't used at all.</p>\n<p>Although are the underlying file objects here trait-objects as opposed to \"always <code>cap_std::fs::File</code>\"? If that's the case then the trait-object I would presume wants async methods, so the async-ness would need to be propagated here to the bindings?</p>\n<p>Hm ok I started out this comment thinking \"ok <code>block_in_place</code> is right here\" but now I'm less certain...</p>\n</blockquote>",
        "id": 371263645,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149184
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248062502\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think that this is quite right for a few reasons:</p>\n<ul>\n<li>I think the main intention here is that if <code>read_from_buffer</code> is 0 that this method returns EWOULDBLOCK instead of success.</li>\n<li>Also a read succeeding with 0 typically means EOF, right? So this shouldn't ever return 0 unless it also returns <code>StreamState::Closed</code>?</li>\n</ul>\n</blockquote>",
        "id": 371263646,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248070739\">PR review comment</a>:</p>\n<blockquote>\n<p>Thinking about this again, I'm not sure that this is actually the desired semantics of <code>poll_oneoff</code> that we want? At least with systems like epoll/select/poll/etc when you wait for a set of operations the wait doesn't fail if one of the operations fails, but rather the wait says \"that operation is ready\" and when you got to get the result it returns the failure. </p>\n<p>In that sense this may actually want to change the <code>ready</code> function to be <code>async fn ready(&amp;self) { ... }</code> with no return value and then if an error is to be returned it's buffered up within the object to get returned by <code>read</code> or <code>write</code> afterwards?</p>\n</blockquote>",
        "id": 371263647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248079825\">PR review comment</a>:</p>\n<blockquote>\n<p>Hm ok so this makes me realize that my idea for \"just record the table index\" is wrong, although subtly so. Basically what you can do is create a <code>pollable</code> and then close the original stream and that would probably cause a panic here.</p>\n<p>One possible solution would be to prevent closure while there are active <code>pollable</code> objects. Looking into a resource-based future though that's not going to work since there's no hook to prevent <code>resource.drop</code> on resources.</p>\n<p>Instead this may need to record \"this is being polled on\" so when it's closed we don't actually fully close the object but instead put it in an area of \"this is only here for pollable\" and then that gets cleaned up when the pollable is closed. (or something like that, not entirely sure)</p>\n</blockquote>",
        "id": 371263648,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248085049\">PR review comment</a>:</p>\n<blockquote>\n<p>I commented on this above for something else as well, but I think the implementation here should be <code>Ok(())</code> instead of pending</p>\n</blockquote>",
        "id": 371263649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248086003\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it might be good to split this impl block to a \"sink\" type rather than hanging it on <code>EmptyStream</code> since for writing I think it's reasonable to say that either all writes are eaten without doing anything or no writes are accepted and it always returns <code>Ok(0)</code></p>\n</blockquote>",
        "id": 371263650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248085255\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this return <code>StreamState::Closed</code>?</p>\n</blockquote>",
        "id": 371263651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248087120\">PR review comment</a>:</p>\n<blockquote>\n<p>Same comments as way above, but I think this which is supposed to be non-blocking is actually blocking now?</p>\n</blockquote>",
        "id": 371263652,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248092369\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah this is where I think the I/O split I mentioned above would work better. For example bytes may have been successfully written into the buffer but then ignored due to this error happening. I think it'd be better to split apart the operations so that if any bytes are ever succesfully read they're guaranteed to be read from this stream.</p>\n</blockquote>",
        "id": 371263653,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248090370\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this may not be required due to the usage of <code>dest.write</code> above? I think that may update the buffer in-place to be shorter.</p>\n</blockquote>",
        "id": 371263654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248152793\">PR review comment</a>:</p>\n<blockquote>\n<p>This doesn't feel quite right to me in that this shouldn't continuously ressize the buffer but instead if the buffer is non-empty then it's always ready for reading but a read is only done if the buffer is empty (in which case we could for example know it's already been initialized)</p>\n</blockquote>",
        "id": 371263656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248154079\">PR review comment</a>:</p>\n<blockquote>\n<p>This is a bit tricky because the futures returned from <code>ready</code> need to all be \"cancel safe\", so if there's pending data in this buffer then it'll get lost if the <code>await</code> point below is cancelled.</p>\n</blockquote>",
        "id": 371263657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248155100\">PR review comment</a>:</p>\n<blockquote>\n<p>Sort of like above with pipes but I think this'll want a form of backpressure to avoid the internal buffer from growing too large</p>\n</blockquote>",
        "id": 371263658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248155782\">PR review comment</a>:</p>\n<blockquote>\n<p>The error here is tricky to handle because data has been buffered up from the beginning of the function but this is also reporting an error, so if the application re-wrote the data then it'd be written twice</p>\n</blockquote>",
        "id": 371263659,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248156757\">PR review comment</a>:</p>\n<blockquote>\n<p>In terms of \"cancel-safety\" this needs to be aware of partial writes that succeed, so I don't think this will be able to use <code>write_all</code> but instead will have to <code>loop</code> and incrementally update the internal buffer.</p>\n</blockquote>",
        "id": 371263660,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248059877\">PR review comment</a>:</p>\n<blockquote>\n<p>Or put another way, each <code>buf</code> provided to this method I think should become a separate message on the channel and then at most one <code>Vec&lt;u8&gt;</code> is buffered internally.</p>\n</blockquote>",
        "id": 371263661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248029141\">PR review comment</a>:</p>\n<blockquote>\n<p>Alternatively files here might need <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> or something similar. For example a <code>read</code> would spawn a task to do the actual read and then the non-blocking <code>read</code> is basically checking if the task is done, and <code>ready</code> is additionally checking if the task is done. That I think would make the append stream below make more sense since an append would spawn a task doing the write and then further writes/ready would wait for that first task to be done.</p>\n</blockquote>",
        "id": 371263662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248044404\">PR review comment</a>:</p>\n<blockquote>\n<p>(also perhaps check <code>self.state</code> and skip the <code>recv</code> if it's closed already, but that's more minor since it'll still work otherwise without that)</p>\n</blockquote>",
        "id": 371263663,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248060844\">PR review comment</a>:</p>\n<blockquote>\n<p>Or put another way, I would expec this type to be \"always ready\"</p>\n</blockquote>",
        "id": 371263664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248091179\">PR review comment</a>:</p>\n<blockquote>\n<p>Although personally I think it's also reasonable to instead structure this entire method as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// do I/O</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// do buffer stuff but no I/O</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>to avoid mixing and matching the I/O branches</p>\n</blockquote>",
        "id": 371263665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1248061419\">PR review comment</a>:</p>\n<blockquote>\n<p>Or put another way (again, sorry), the <code>TrySendError::Full</code> case I think should return EWOULDBLOCK so callers know to go call <code>poll_oneoff</code> afterwards.</p>\n</blockquote>",
        "id": 371263666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688149185
    },
    {
        "content": "<p>dicej submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1519126618\">PR review</a>:</p>\n<blockquote>\n<p>Looks like a great start overall.</p>\n<p>Echoing Alex's concerns about <code>block_in_place</code>:</p>\n<ul>\n<li>We should never use it in any function which must be non-blocking from the guest's perspective.</li>\n<li>We should probably also not use it in any function which _is_ blocking from the guest's perspective since it blocks the Wasmtime fiber, silently inhibits the composition of futures (e.g. for timeouts), and also blocks the embedder in a way it might not expect.</li>\n</ul>\n<p>So we can use <code>spawn_blocking</code> instead, and store the future as part of the stream, but at that point we're kind of reinventing <code>tokio::fs</code>.  The <code>tokio</code> folks have already provided a battle-tested implementation, and <code>tokio::fs::File</code> implements <code>AsyncRead</code> and <code>AsyncWrite</code>, so I think we should reuse it wherever possible.  I realize there are some cases where we need to use <code>cap-std</code> to enforce sandboxing, but once <code>cap-std</code> gives us a file handle, we should be able to convert it to a <code>tokio::fs::File</code> and use that to handle the details of bridging the async and sync worlds.  Does that sounds plausible?</p>\n<p>Regarding buffers: I don't think we should ever need to grow buffers beyond their original sizes (and certainly not without bound).  I would expect that we would flush (for writes) or fill (for reads) a buffer before moving on to the next one (or reusing it without necessarily changing its size).  If you believe there's a scenario where extending a buffer is unavoidable (or at least desirable), I'd like to have a conversation to understand that better.</p>\n<p>Generally speaking, I would expect that neither <code>HostInputStream::read</code> nor <code>HostOutputStream::write</code> implementations would do _any_ I/O and would instead leave that to <code>ready</code>, which would fill or drain <code>self.buffer</code>, respectively.  That would avoid the need for the no-op waker and any kind of <code>block_in_place</code> trickery.  Or put another way, I/O should only be done in an async context where a real waker is available, thus guaranteeing wake events make it back to <code>poll_oneoff</code>.</p>\n<p>Hope that's somewhat clear.  Happy to discuss in more detail as necessary.</p>\n</blockquote>",
        "id": 373299217,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>dicej submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1519126618\">PR review</a>:</p>\n<blockquote>\n<p>Looks like a great start overall.</p>\n<p>Echoing Alex's concerns about <code>block_in_place</code>:</p>\n<ul>\n<li>We should never use it in any function which must be non-blocking from the guest's perspective.</li>\n<li>We should probably also not use it in any function which _is_ blocking from the guest's perspective since it blocks the Wasmtime fiber, silently inhibits the composition of futures (e.g. for timeouts), and also blocks the embedder in a way it might not expect.</li>\n</ul>\n<p>So we can use <code>spawn_blocking</code> instead, and store the future as part of the stream, but at that point we're kind of reinventing <code>tokio::fs</code>.  The <code>tokio</code> folks have already provided a battle-tested implementation, and <code>tokio::fs::File</code> implements <code>AsyncRead</code> and <code>AsyncWrite</code>, so I think we should reuse it wherever possible.  I realize there are some cases where we need to use <code>cap-std</code> to enforce sandboxing, but once <code>cap-std</code> gives us a file handle, we should be able to convert it to a <code>tokio::fs::File</code> and use that to handle the details of bridging the async and sync worlds.  Does that sounds plausible?</p>\n<p>Regarding buffers: I don't think we should ever need to grow buffers beyond their original sizes (and certainly not without bound).  I would expect that we would flush (for writes) or fill (for reads) a buffer before moving on to the next one (or reusing it without necessarily changing its size).  If you believe there's a scenario where extending a buffer is unavoidable (or at least desirable), I'd like to have a conversation to understand that better.</p>\n<p>Generally speaking, I would expect that neither <code>HostInputStream::read</code> nor <code>HostOutputStream::write</code> implementations would do _any_ I/O and would instead leave that to <code>ready</code>, which would fill or drain <code>self.buffer</code>, respectively.  That would avoid the need for the no-op waker and any kind of <code>block_in_place</code> trickery.  Or put another way, I/O should only be done in an async context where a real waker is available, thus guaranteeing wake events make it back to <code>poll_oneoff</code>.</p>\n<p>Hope that's somewhat clear.  Happy to discuss in more detail as necessary.</p>\n</blockquote>",
        "id": 373299218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1256036555\">PR review comment</a>:</p>\n<blockquote>\n<p>According to the <a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read\">docs</a>, it should be considered closed when <code>read</code> returns 0 when <code>dest.len() &gt; 0</code>.</p>\n</blockquote>",
        "id": 373299219,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1255973406\">PR review comment</a>:</p>\n<blockquote>\n<p>Nits: \"poisoned\" is misspelled, and per <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#recommended-message-style\">https://doc.rust-lang.org/std/result/enum.Result.html#recommended-message-style</a>, this should probably read \"mutex should not be poisoned\".</p>\n</blockquote>",
        "id": 373299220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1256016661\">PR review comment</a>:</p>\n<blockquote>\n<p>In addition to separating the buffer and I/O cases, you can put the whole thing in a loop that runs until either <code>dest</code> is full or the buffer is empty and I/O would block.</p>\n</blockquote>",
        "id": 373299221,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>dicej created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1256021454\">PR review comment</a>:</p>\n<blockquote>\n<p>This comment doesn't seem to be relevant anymore.</p>\n</blockquote>",
        "id": 373299222,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1688754683
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 374768911,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689207304
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375076102,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689287559
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375091567,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689293969
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375370618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689363493
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375370747,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689363539
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375400379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689373350
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 375412613,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689379679
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376474275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689714552
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376482012,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689717743
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376486157,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689719525
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1535989606\">PR review</a>.</p>",
        "id": 376486231,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689719579
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1267360269\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, we'd have to do some challenging stuff to destroy the ctx, which is harder because the methods need both the ctx and table via WasiView, so we decided against changing this now.</p>\n<p>We really only expect this impl to be used for tests.</p>\n</blockquote>",
        "id": 376486232,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689719580
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1535990126\">PR review</a>.</p>",
        "id": 376486303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689719623
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1267360627\">PR review comment</a>:</p>\n<blockquote>\n<p>An io error that occurs is buffered up, but we wanted to leave it open for <code>ready()</code> to trap execution if something is horribly wrong.</p>\n</blockquote>",
        "id": 376486304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689719624
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376487420,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689720241
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1535998946\">PR review</a>.</p>",
        "id": 376487692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689720369
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1267366618\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes this is a pretty significant complication. Right now we have decided to punt on it by adding a big warning in the source code, land this PR, then see if any of the assumptions involved change as we switch over to resources, and then fix it. It would be a crash vector for the whole runtime, but it would also require some pretty major work, so I want to defer it to a future PR. We will fix it before we mark the preview2 implementation as production ready.</p>\n</blockquote>",
        "id": 376487695,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689720369
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376497293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689724979
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376724081,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689783678
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376766966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689793779
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376771128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689794877
    },
    {
        "content": "<p>dicej submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1519126618\">PR review</a>:</p>\n<blockquote>\n<p>Looks like a great start overall.</p>\n<p>Echoing Alex's concerns about <code>block_in_place</code>:</p>\n<ul>\n<li>We should never use it in any function which must be non-blocking from the guest's perspective.</li>\n<li>We should probably also not use it in any function which _is_ blocking from the guest's perspective since it blocks the Wasmtime fiber, silently inhibits the composition of futures (e.g. for timeouts), and also blocks the embedder in a way it might not expect.</li>\n</ul>\n<p>So we can use <code>spawn_blocking</code> instead, and store the future as part of the stream, but at that point we're kind of reinventing <code>tokio::fs</code>.  The <code>tokio</code> folks have already provided a battle-tested implementation, and <code>tokio::fs::File</code> implements <code>AsyncRead</code> and <code>AsyncWrite</code>, so I think we should reuse it wherever possible.  I realize there are some cases where we need to use <code>cap-std</code> to enforce sandboxing, but once <code>cap-std</code> gives us a file handle, we should be able to convert it to a <code>tokio::fs::File</code> and use that to handle the details of bridging the async and sync worlds.  Does that sound plausible?</p>\n<p>Regarding buffers: I don't think we should ever need to grow buffers beyond their original sizes (and certainly not without bound).  I would expect that we would flush (for writes) or fill (for reads) a buffer before moving on to the next one (or reusing it without necessarily changing its size).  If you believe there's a scenario where extending a buffer is unavoidable (or at least desirable), I'd like to have a conversation to understand that better.</p>\n<p>Generally speaking, I would expect that neither <code>HostInputStream::read</code> nor <code>HostOutputStream::write</code> implementations would do _any_ I/O and would instead leave that to <code>ready</code>, which would fill or drain <code>self.buffer</code>, respectively.  That would avoid the need for the no-op waker and any kind of <code>block_in_place</code> trickery.  Or put another way, I/O should only be done in an async context where a real waker is available, thus guaranteeing wake events make it back to <code>poll_oneoff</code>.</p>\n<p>Hope that's somewhat clear.  Happy to discuss in more detail as necessary.</p>\n</blockquote>",
        "id": 376787029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689799488
    },
    {
        "content": "<p>elliottt updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376787287,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689799576
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376792887,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689801575
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376799886,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689804253
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376804190,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689806280
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376804738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689806536
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376805740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689807089
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376806566,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689807508
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 376812876,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689811384
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377097854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689882961
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377116764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689888964
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377117666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689889208
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377133618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689896206
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377134164,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689896535
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377134521,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689896766
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541613298\">PR review</a>:</p>\n<blockquote>\n<p>Nice <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n<p>For the WIT changes, those are from the upstream proposals? Or local changes made temporarily for this PR?</p>\n</blockquote>",
        "id": 377394254,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541613298\">PR review</a>:</p>\n<blockquote>\n<p>Nice <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n<p>For the WIT changes, those are from the upstream proposals? Or local changes made temporarily for this PR?</p>\n</blockquote>",
        "id": 377394258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270963873\">PR review comment</a>:</p>\n<blockquote>\n<p>I find the semantics of this type a bit dubious, but is this necessary? Would it be possible to remove this?</p>\n</blockquote>",
        "id": 377394260,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270963317\">PR review comment</a>:</p>\n<blockquote>\n<p>Given the semantics of that this stream is never ready for reading, would a better default be the <code>ClosedInputStream</code>?</p>\n</blockquote>",
        "id": 377394261,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270965063\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this case be <code>unreachable!</code> since if the state is \"ready\" then the task should always be trying to receive one buffer?</p>\n</blockquote>",
        "id": 377394266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270965700\">PR review comment</a>:</p>\n<blockquote>\n<p>Instead of an <code>Option</code> here perhaps add <code>Closed</code> to <code>WriteState</code>?</p>\n</blockquote>",
        "id": 377394268,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270956576\">PR review comment</a>:</p>\n<blockquote>\n<p>I think that this may always want to be <code>Ok(())</code> since <code>read</code> never blocks?</p>\n</blockquote>",
        "id": 377394271,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1270969547\">PR review comment</a>:</p>\n<blockquote>\n<p>Had a good chuckle reading this :)</p>\n<p>Regardless I agree we can't make this truly async and sync close here is the right thing to do IMO</p>\n</blockquote>",
        "id": 377394276,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689964324
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541781454\">PR review</a>.</p>",
        "id": 377415934,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689969884
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271048239\">PR review comment</a>:</p>\n<blockquote>\n<p>Correct.</p>\n</blockquote>",
        "id": 377415938,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689969884
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541782194\">PR review</a>.</p>",
        "id": 377416111,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689969927
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271049005\">PR review comment</a>:</p>\n<blockquote>\n<p>yeah, we did it because it corresponded to one of the output streams but now that you point it out, its really not necessary at all</p>\n</blockquote>",
        "id": 377416112,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689969927
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271049005\">PR review comment</a>.</p>",
        "id": 377416592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970051
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271049005\">PR review comment</a>.</p>",
        "id": 377416647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970067
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377417587,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970347
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541790188\">PR review</a>.</p>",
        "id": 377417781,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970411
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271057321\">PR review comment</a>:</p>\n<blockquote>\n<p>correct- that was left over from a prior factoring of this code, but its unreachable now</p>\n</blockquote>",
        "id": 377417784,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970411
    },
    {
        "content": "<p>pchickey submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#pullrequestreview-1541791751\">PR review</a>.</p>",
        "id": 377418206,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970517
    },
    {
        "content": "<p>pchickey created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271059042\">PR review comment</a>:</p>\n<blockquote>\n<p>we had it factored that way, then we were taking advantage of Option::take() so changing the repr made sense, but now I think I can switch it back...</p>\n</blockquote>",
        "id": 377418209,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970517
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556#discussion_r1271059042\">PR review comment</a>.</p>",
        "id": 377418468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970588
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377418531,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689970605
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite. Most of this was pair-programmed with @elliottt.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> traits are used to implement the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<h2><code>Host{Input, Output}Stream</code> design</h2>\n<p><code>input-stream</code> and <code>output-stream</code> resources have a significant number of methods. For the host traits, we managed to boil this down to two required methods, as well as some optional methods to cover vectored IO, splice, and write-zeroes. The default implementations provide an unoptimized but correct implementation - the user may override them if an optimization is desired.</p>\n<p><code>HostInputStream</code> has just two methods: <code>fn read(&amp;mut self, ...)</code> and <code>async fn ready(&amp;mut self)</code>. The most important invariant is that <code>read</code> must be non-blocking, and <code>ready</code> must block until the stream is ready for reading.</p>\n<h2><code>HostPollable</code> design</h2>\n<p>The trick to <code>HostPollable</code> is to create a Rust <code>Future</code> indicating whether a stream (or some other resource, e.g. http bodies) is ready without requiring both the stream and pollable hold some <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> to the resource itself. @alexcrichton pointed out the right design here: <code>HostPollable</code> is an enum with two variants:</p>\n<ul>\n<li><code>TableEntry { index: u32, make_future: for&lt;'a&gt; fn(&amp;'a mut dyn Any) -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'a&gt;}</code> means, get a mutable reference to some (still dynamically-typed) other entry in the table, and apply this fn to create a Future from that entry, which has the same lifetime as the mutable reference. For the streams, we use this variant, and make_future is just a call to the <code>Host{Input,Output}Stream::ready</code> method.</li>\n<li><code>Closure( Box&lt;Fn() -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'static&gt;&gt; + Send + Sync + 'static&gt; )</code> means, use this owned closure to create a Future with a static lifetime. This is used for creating timers from the monotonic and wall clocks, which are ambient and therefore do not have table entries.</li>\n</ul>\n<h2>Implementations</h2>\n<p><code>wasmtime-wasi</code> provides a struct <code>AsyncReadStream</code> which wraps a <code>tokio::io::AsyncRead</code> to provide an impl of <code>HostInputStream</code>, <code>AsyncWriteStream</code> to wraps <code>AsyncWrite</code> to provide <code>HostOutputStream</code>, and, in <code>cfg(unix)</code>, <code>AsyncFdStream</code> wraps <code>tokio::io::unix::AsynFd</code> to provide both read and write stream impls.</p>\n<p><code>AsyncReadStream</code> and <code>AsyncWriteStream</code> will manage their own buffer in order for the <code>HostInputStream::read</code> and <code>HostOutputStream::write</code> methods to be non-blocking. These methods call the  <code>AsyncRead::poll_read</code> and <code>AsyncWrite::poll_write</code> methods with a noop-waker Context (for now, this trivial implementation has been copied out of <code>std</code> sources until it becomes available in stable Rust) as a mechanism for providing a non-blocking read/write from synchronous code - @alexcrichton showed us that design.</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readiness on both windows and unix. In Unix, this is built on top of <code>AsyncFdStream</code>, allows tokio to register stdin with <code>epoll(7)</code>. Because stdin is a process-wide singleton, and also because epoll will return an error if the same fd is registered multiple times, the stdin resource is a global singleton, created lazily and guarded by a mutex. <code>wasmtime_wasi::preview2::stdio::stdin()</code> returns a <code>struct Stdin</code> which takes a lock on that singleton in the <code>HostImputStream::{read, ready}</code> methods. This means that, if for some reason you have granted the process stdin to multiple wasi streams (in the same, or different, stores) you can get all sorts of strange behavior because the same global resource backs them all behind the scenes - but this is always the case, the implementation in wasmtime_wasi just allows you to do so without hanging or panicking.</p>\n<p>On Windows, we use the same approach as in the wasi-common preview 1 scheduler implementation - a (global singleton, lazily created, guarded by a mutex) worker thread running <code>std::io::stdin().lock().fill_buf()</code> as a blocking function. The communication scheme from the old implementation was changed up to use tokio::sync as the messaging primitives. This implementation has never been executed outside of CI because I don't have a windows machine, and I don't think our test coverage of this code is particularly great, so I basically expect someone who tries this on windows to report bugs.</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n<h1>Bindings traits</h1>\n<p>After living with the bindings generated underneath <code>crate::preview2::wasi</code> and <code>crate::preview2::wasi::command</code> for a while, I decided that the interface traits belong under <code>crate::preview2::bindings</code> and command belongs under <code>crate::preview2::command</code>.</p>\n<p>Beyond that code motion, we now generate async traits for the <code>wasi:io/streams</code>, <code>wasi:poll/poll</code>, and <code>wasi:filesystem/filesystem</code> interfaces, and sync traits for everything else. If you want to use the bindings from an async embedding (i.e. with an async Config), the <code>crate::preview2::bindings::{interface}::add_to_linker</code> will do it, and if you want to use them from a synchronous embedding, use <code>crate::preview2::bindings::sync::{interface}::add_to_linker</code>.</p>\n</blockquote>",
        "id": 377421419,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689971514
    },
    {
        "content": "<p>pchickey edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>:</p>\n<blockquote>\n<p>When we landed the WASI Preview 2 support in <code>wasmtime-wasi</code> we knew the streams/poll/scheduler implementation was going to get torn out and rewritten: see task 4 in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6370\">https://github.com/bytecodealliance/wasmtime/issues/6370</a>. This is that rewrite. Most of this was pair-programmed with @elliottt.</p>\n<h1>Features</h1>\n<p><code>wasmtime-wasi</code> Preview 2 support is now built on top of <code>tokio</code>, and the host implementations for streams and pollable always use <code>async</code> Rust. It now passes all of the poll_oneoff tests, including on windows.</p>\n<p>The new <code>HostInputStream</code>, <code>HostOutputStream</code>, and <code>HostPollable</code> traits are used to implement the <code>wasi:io/streams.{input-stream,output-stream}</code> and <code>wasi:poll/poll.pollable</code> resources.</p>\n<h2><code>Host{Input, Output}Stream</code> design</h2>\n<p><code>input-stream</code> and <code>output-stream</code> resources have a significant number of methods. For the host traits, we managed to boil this down to two required methods, as well as some optional methods to cover vectored IO, splice, and write-zeroes. The default implementations provide an unoptimized but correct implementation - the user may override them if an optimization is desired.</p>\n<p><code>HostInputStream</code> has just two methods: <code>fn read(&amp;mut self, ...)</code> and <code>async fn ready(&amp;mut self)</code>. The most important invariant is that <code>read</code> must be non-blocking, and <code>ready</code> must block until the stream is ready for reading.</p>\n<h2>Nonblocking IO is actually impossible on regular files, but we hide that detail from WASI programs</h2>\n<p>There's a huge lie in the description above: internally, wasmtime_wasi uses <code>InternalHost{Input,Output}Stream</code>, which are enums that contain either a <code>Host{Input,Output}Stream</code>, or a private <code>File{Input,Output}Stream</code>. These file streams always perform a blocking read/write, whether or not the WASI program has called the nonblocking <code>read</code> or the blocking <code>blocking_read</code> method. And, any pollable associated with file read or write readiness always returns ready immediately.</p>\n<p>This is required because there is no way to implement streams on files with <code>epoll(7)</code> (or on macos or windows using mio, afaik) based readiness - <code>poll(2)</code> will lie and always tell you files are ready for reading of writing, but the actual syscall may end up blocking the thread due to disk IO. And, rather than stick the work on a background task, we must wait until the OS <code>read(2)</code> or <code>write(2)</code> for a file has completed before returning from wasi stream (nonblocking) read or write, because the userlands in WASI expect (reasonably!) that any errors in regular file IO are reported synchronously.</p>\n<p>So, we put an escape hatch into wasmtime-wasi which is just for regular file IO. It <code>awaits</code> for a tokio <code>spawn_blocking</code> to complete in both the blocking and non-blocking implementations of the stream reads and writes. Like all the other syscalls in the filesystem implementation, we need the <code>async</code> rust to put any blocking syscalls in a <code>spawn_blocking</code>, in order to not block the executor.</p>\n<p>We spent a the better part of a week trying to square this circle and this is the best we could come up to make files work like we expect, but also expose the right interfaces from wasmtime-wasi so that all other streams have the proper non-blocking semantics.</p>\n<h2><code>HostPollable</code> design</h2>\n<p>The trick to <code>HostPollable</code> is to create a Rust <code>Future</code> indicating whether a stream (or some other resource, e.g. http bodies) is ready without requiring both the stream and pollable hold some <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> to the resource itself. @alexcrichton pointed out the right design here: <code>HostPollable</code> is an enum with two variants:</p>\n<ul>\n<li><code>TableEntry { index: u32, make_future: for&lt;'a&gt; fn(&amp;'a mut dyn Any) -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'a&gt;}</code> means, get a mutable reference to some (still dynamically-typed) other entry in the table, and apply this fn to create a Future from that entry, which has the same lifetime as the mutable reference. For the streams, we use this variant, and make_future is just a call to the <code>Host{Input,Output}Stream::ready</code> method.</li>\n<li><code>Closure( Box&lt;Fn() -&gt; Pin&lt;Box&lt;dyn Future = Result&lt;()&gt;&gt; + Send + 'static&gt;&gt; + Send + Sync + 'static&gt; )</code> means, use this owned closure to create a Future with a static lifetime. This is used for creating timers from the monotonic and wall clocks, which are ambient and therefore do not have table entries.</li>\n</ul>\n<p>Note that we discovered a major design problem with the <code>TableEntry</code> variant that exposes a crash vector if the parent resource of a pollable is destroyed before the pollable itself. This is a big enough problem that we are setting it aside to be solved in a follow-up PR.</p>\n<h2>Implementations</h2>\n<p><code>wasmtime-wasi</code> provides a struct <code>AsyncReadStream</code> which wraps a <code>tokio::io::AsyncRead</code> to provide an impl of <code>HostInputStream</code>, <code>AsyncWriteStream</code> to wraps <code>AsyncWrite</code> to provide <code>HostOutputStream</code>.</p>\n<p><code>AsyncReadStream</code> and <code>AsyncWriteStream</code> will manage their own buffer in order for the <code>HostInputStream::read</code> and <code>HostOutputStream::write</code> methods to be non-blocking.  Each spawns a helper tokio::task to perform async operations in the background. This requires some buffering.</p>\n<p>Note, we discussed ensuring these background tasks are reaped properly - right now we believe that the implementations are correct and they will exit on their own when the foreground side gets dropped. However, in the future to implement e.g. splice and forward correctly, we may need to allow these tasks to (optionally!) live longer than the WASI program's execution.</p>\n<p>Additionally, we have provided an implementation that correctly handles waiting on <code>stdin</code> readiness on both windows and unix. In Unix, this is built on top of <code>tokio::os::unix::AsyncFd</code>, allows tokio to register stdin with <code>epoll(7)</code>. Because stdin is a process-wide singleton, and also because epoll will return an error if the same fd is registered multiple times, the stdin resource is a global singleton, created lazily and guarded by a mutex. <code>wasmtime_wasi::preview2::stdio::stdin()</code> returns a <code>struct Stdin</code> which takes a lock on that singleton in the <code>HostInputStream::{read, ready}</code> methods. This means that, if for some reason you have granted the process stdin to multiple wasi streams (in the same, or different, stores) you can get all sorts of strange behavior because the same global resource backs them all behind the scenes - but this is always the case, the implementation in wasmtime_wasi just allows you to do so without hanging or panicking.</p>\n<p>On Windows, the implementation of stdin is broken, and inheriting stdin will panic. We have a path to fixing it, but we are leaving that out of this PR, because it has been open for far too long, and far too much work is predicated on landing it.</p>\n<h1>Sync and Async uses</h1>\n<p>Despite using async for its implementation, <code>wasmtime-wasi</code> will still work for synchronous Wasmtime embeddings. A new <code>test-programs</code> suite <code>wasi-preview2-components-sync</code> is identical to <code>wasi-preview2-components</code> in all regards except that it uses wasmtime's synchronous APIs, and the appropriate <code>wasmtime_wasi::command::sync::add_to_linker</code>, rather than <code>wasmtime_wasi::command::add_to_linker</code> which requires an async Config. The synchronous implementation creates its own Tokio runtime (if one does not already exist) and then invokes the async implementation inside of a <code>block_on</code>.</p>\n<p>The <code>wasi-common</code> Preview 1 <code>poll_oneoff</code> implementation allowed for a synchronous implementation to work without any sort of dependency on tokio, by abstracting it behind a pluggable <code>WasiSched</code>. This PR eliminates that option for our Preview 2 users. If there is a compelling need, and labor available to implement and maintain it, we could collaborate on re-introducing a fully synchronous tokio-free option in the future. For this implementation, I decided that we just need a tokio backend in order to build a path towards supporting both wasi-sockets and wasi-http with the same modular stream and pollable host traits.</p>\n<h1>Bindings traits</h1>\n<p>After living with the bindings generated underneath <code>crate::preview2::wasi</code> and <code>crate::preview2::wasi::command</code> for a while, I decided that the interface traits belong under <code>crate::preview2::bindings</code> and command belongs under <code>crate::preview2::command</code>.</p>\n<p>Beyond that code motion, we now generate async traits for the <code>wasi:io/streams</code>, <code>wasi:poll/poll</code>, and <code>wasi:filesystem/filesystem</code> interfaces, and sync traits for everything else. If you want to use the bindings from an async embedding (i.e. with an async Config), the <code>crate::preview2::bindings::{interface}::add_to_linker</code> will do it, and if you want to use them from a synchronous embedding, use <code>crate::preview2::bindings::sync::{interface}::add_to_linker</code>.</p>\n</blockquote>",
        "id": 377425776,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689972812
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377427412,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689973379
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377433141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689975371
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377438417,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689977420
    },
    {
        "content": "<p>pchickey has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377439411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689977799
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377442791,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689979336
    },
    {
        "content": "<p>pchickey updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377453078,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1689984651
    },
    {
        "content": "<p>pchickey merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6556\">PR #6556</a>.</p>",
        "id": 377985346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690172798
    }
]