[
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/958\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/issues/958\">Issue #958</a>:</p>\n<blockquote>\n<p>In reviewing some code today I started wondering what would happen if you started mixing <code>Store</code> values and instances together. For example you can create two <code>Instance</code> objects in two <code>Store</code> objects, what would happen when they're linked?</p>\n<p>The concrete things I know of today we have to worry about are:</p>\n<ul>\n<li>Mainly the <code>Compiler</code> shared state in a <code>Store</code>. This notably contains two fields:<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/b69a061d23a108e2f25be9a7c86ea164aad4c08f/crates/jit/src/compiler.rs#L56\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/blob/b69a061d23a108e2f25be9a7c86ea164aad4c08f/crates/jit/src/compiler.rs#L56\"><code>signatures</code></a> is a <code>Store</code>-local registry of all known wasm signatures, mapping them to an index for signature checks during <code>call_indirect</code>. This is actually <strong>memory unsafe</strong> today because if you mix two <code>Store</code> objects then two different signatures could get the same shared index, meaning <code>call_indirect</code> could call the wrong thing.</li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/b69a061d23a108e2f25be9a7c86ea164aad4c08f/crates/jit/src/compiler.rs#L54\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/blob/b69a061d23a108e2f25be9a7c86ea164aad4c08f/crates/jit/src/compiler.rs#L54\"><code>trap_registry</code></a> is also a <code>Store</code>-local registry of information about traps. While I don't think this is related to memory safety it does mean that if you're calling code in one instance but started in another the trap in the second instance won't be resolved correctly and we'll get the wrong trap information out of it.</li>\n</ul>\n</li>\n<li>There's also maybe issues with the cache but I suspect not, it's not shared state across instances in a <code>Store</code> that I've looked at too too deeply.</li>\n</ul>\n<p>I started implementing a fix where we'd simply reject linking instances together if they come from two different <code>Store</code> values, but this is also a problem with any <code>Val::FuncRef</code> getting stored in a table across instances. Especially with reference types this gets really hairy to guard, so I don't think it'll be easy to simply block access at all entry points.</p>\n<p>The only fix I can think of is to have a truly global map for all this, but it feels bad to have a truly global ever-expanding map that's never deallocated from. I think we'll want to figure out a way to remove items from the map at least when a <code>Store</code> is dropped (maybe sooner?). In any case wanted to make sure there was an open issue for this!</p>\n</blockquote>",
        "id": 190177912,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583850512
    }
]