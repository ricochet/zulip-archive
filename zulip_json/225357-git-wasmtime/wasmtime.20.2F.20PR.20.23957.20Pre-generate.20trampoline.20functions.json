[
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190325027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583956958
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373142558\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373142558\">PR Review</a>.</p>",
        "id": 190334409,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583962614
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373142558\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373142558\">PR Review</a>.</p>",
        "id": 190334410,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583962615
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#discussion_r391282410\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#discussion_r391282410\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Here and in the other <code>load</code> implementations, it looks like this is dereferencing the wrong thing.</p>\n</blockquote>",
        "id": 190334411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583962615
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190337536,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583964679
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373162983\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373162983\">PR Review</a>.</p>",
        "id": 190337625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583964730
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#discussion_r391297618\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#discussion_r391297618\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh dear good catch! Made sure to add tests to catch this</p>\n</blockquote>",
        "id": 190337626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583964730
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190404416,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584027586
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190432489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584040616
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373845654\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957#pullrequestreview-373845654\">PR Review</a>.</p>",
        "id": 190434611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584041753
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190435299,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584042098
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190435459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584042170
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a> from <code>local-trampolines</code> to <code>master</code>:</p>\n<blockquote>\n<p>The <code>wasmtime</code> crate supports calling arbitrary function signatures in<br>\nwasm code, and to do this it generates \"trampoline functions\" which have<br>\na known ABI that then internally convert to a particular signature's ABI<br>\nand call it. These trampoline functions are currently generated<br>\non-the-fly and are cached in the global <code>Store</code> structure. This,<br>\nhowever, is suboptimal for a few reasons:</p>\n<ul>\n<li>\n<p>Due to how code memory is managed each trampoline resides in its own<br>\n  64kb allocation of memory. This means if you have N trampolines you're<br>\n  using N * 64kb of memory, which is quite a lot of overhead!</p>\n</li>\n<li>\n<p>Trampolines are never free'd, even if the referencing module goes<br>\n  away. This is similar to #925.</p>\n</li>\n<li>\n<p>Trampolines are a source of shared state which prevents <code>Store</code> from<br>\n  being easily thread safe.</p>\n</li>\n</ul>\n<p>This commit refactors how trampolines are managed inside of the<br>\n<code>wasmtime</code> crate and jit/runtime internals. All trampolines are now<br>\nallocated in the same pass of <code>CodeMemory</code> that the main module is<br>\nallocated into. A trampoline is generated per-signature in a module as<br>\nwell, instead of per-function. This cache of trampolines is stored<br>\ndirectly inside of an <code>Instance</code>. Trampolines are stored based on<br>\n<code>VMSharedSignatureIndex</code> so they can be looked up from the internals of<br>\nthe <code>ExportFunction</code> value.</p>\n<p>The <code>Func</code> API has been updated with various bits and pieces to ensure<br>\nthe right trampolines are registered in the right places. Overall this<br>\nshould ensure that all trampolines necessary are generated up-front<br>\nrather than lazily. This allows us to remove the trampoline cache from<br>\nthe <code>Compiler</code> type, and move one step closer to making <code>Compiler</code><br>\nthreadsafe for usage across multiple threads.</p>\n<p>Note that as one small caveat the <code>Func::wrap*</code> family of functions<br>\ndon't need to generate a trampoline at runtime, they actually generate<br>\nthe trampoline at compile time which gets passed in.</p>\n<p>Also in addition to shuffling a lot of code around this fixes one minor<br>\nbug found in <code>code_memory.rs</code>, where <code>self.position</code> was loaded before<br>\nallocation, but the allocation may push a new chunk which would cause<br>\n<code>self.position</code> to be zero instead.</p>\n</blockquote>",
        "id": 190438623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584043815
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/957\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/957\">PR #957</a>.</p>",
        "id": 190446384,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584047870
    }
]