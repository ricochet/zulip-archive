[
    {
        "content": "<p>elliottt opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>While working on finishing the migration of the x64 backend to ISLE, I encountered a case where guarding a rule on specific ISA features being enabled caused the rule to never fire. The problem was that the rule I added overlapped with another rule except in the ISA feature check, and the other rule took precedence. Here's an example from elsewhere in the codebase:        <br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809\">https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809</a>    </p>\n<p>The LHS of the two rules only differs in the patterns to the first argument of <code>(has_type)</code>: both rules match <code>(ty_32_or_64 ty)</code> while the rule on line 1799 also matches <code>(use_bmi1)</code>. The rule on line 1799 has been given a priority of <code>1</code> to ensure that it's checked before the rule on line 1806, but ideally we wouldn't need to give this annotation here.        </p>\n<p>My proposal is that we switch to compiling rules by matching rules top-down, left-to-right.    </p>\n<h4>Benefit</h4>\n<p>The benefit of this change would be that we could tell statically when a rule was not reachable, and raise an error when it would never fire.    </p>\n<h4>Implementation</h4>\n<p>For matching on <code>enum</code> values we could take the approach outlined in <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf</a>. For handling extractors we could take inspiration from GHC's implementation of <a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns#compilation\">view patterns</a>.        </p>\n<h4>Alternatives</h4>\n<p>We could continue to develop heuristics to determine when rules might be unconditionally shadowed, and inform the programmer through an error or warning.</p>\n</blockquote>",
        "id": 293641454,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660609251
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1216014041\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>Thanks @elliottt for bringing this up. I have some thoughts on this inspired by our conversations over the past week, together with our experience with this aspect of ISLE over the past year, that I've written up on the subject below.</p>\n<h1>ISLE rule-ordering semantics simplification</h1>\n<p>This issue proposes to simplify the ISLE rule-ordering semantics to<br>\n\"first matching rule wins\", as a result of a year of experience with<br>\nthe language as it currently stands (a more complex ordering<br>\nheuristic) and the issues that this causes.</p>\n<h2>Overview: Current Design</h2>\n<p>ISLE currently has semantics for rule ordering that generally follow<br>\nthe \"most specific rule wins\" principle. The goal is that the user, or<br>\na tool, should be able to write rules in any order and the resulting<br>\ncompiler backend should be the same no matter how these rules are<br>\nordered.</p>\n<p>Inside the ISLE compiler, this is implemented by sorting edges when<br>\ninserting into the match trie. The sort-order is implied by the<br>\n<code>PatternInst</code> enum and the order of its arms: lower-ordered ops come<br>\nfirst at any given node in the tree.</p>\n<p>The ISLE language contains a concession to allow for manual ordering:<br>\nany rule can be annotated with an explicit numeric priority, and rules<br>\nare sorted by priority first before being merged into a match trie.</p>\n<h2>Reasons for Current Design</h2>\n<h3>Intuitive \"More-Specific-First\" Matching</h3>\n<p>The first reason given for the current design is that it allows for a<br>\nnatural \"general case then more specific cases\" ordering of rule<br>\ncases. One can start a group of rules with the most basic handling,<br>\nand then get into trickier cases later. This aids reading<br>\ncomprehension.</p>\n<h3>Compatibility with Rule-Generating Tools</h3>\n<p>One might build a tool that generates a large body of lowering rules<br>\nfrom some algorithm that finds equivalences (as in<br>\nsuperoptimization). For such a tool, it is convenient to be able to<br>\n(i) just dump the list of rules, without sorting first; and (ii) allow<br>\nthe user to include these rules without having to think about how they<br>\norder with respect to handwritten rules.</p>\n<h3>Independence of Rules for Verification</h3>\n<p>When verifying the correctness of ISLE lowering rules against<br>\nsemantics of the input and output language, it is useful if the<br>\nsemantics of the language are as-if a rule could fire when the<br>\nleft-hand side matches at all, regardless of other rules that<br>\nexist. An \"unordered\" / \"unspecified\" semantics is closer to this than<br>\n\"first rule wins\".</p>\n<h2>Issues</h2>\n<h3>Unclear mental model</h3>\n<p>THe primary issue is that the mental model required to be held by the<br>\nISLE programmer is unclear. If the ISLE programmer <em>truly</em> does not<br>\ncare which rule applies, then all is well. But in real development of<br>\ncompiler backends, one does very much care: one needs to make sure<br>\nthat some special cases are actually handled (or else they are useless<br>\ndead code that, worse, may be untested); and sometimes one rule that<br>\nis shadowed by another is actually incorrect in the shadowed case, so<br>\none <em>relies</em> on the ordering heuristic for <em>correctness</em>.</p>\n<p>In general, development of ISLE rules requires the programmer to<br>\nunderstand how the language operates so that they can control which<br>\nrule fires. If the ordering rules are complex and subtle, or worse are<br>\n\"unspecified\", then we get a body of rules that either has silent<br>\nshadowing, or brittle reliance on particular ordering heuristics that<br>\nmay change. Even if we attempt to clearly specify the semantics, there<br>\nare subtleties that arise because of the way that external Rust code<br>\ncan be invoked: we don't know when some conditions are disjoint or<br>\nnot, fallible or infallible, and a set of prioritization rules that<br>\nrelies on \"fallible before infallible\" and disjointness thus requires,<br>\nin the limit, a full and complete understanding of our helpers'<br>\nsemantics (via explicit specification or some other method).</p>\n<p>One can make an argument that wen building a complex artifact, one<br>\nneeds one's tools to be as <em>predictable</em> as possible. Complexity is<br>\nfine, if it is in service of a well-understood goal (e.g., compiling<br>\nRust code to x86 machine code). But <em>unclear semantics</em> are not.</p>\n<h3>\"Experimental nature\" of Priority Usage</h3>\n<p>The clearest extraction of the issue here comes in our standard advice<br>\nfor getting proper lowering output: just write the rules, and if the<br>\nordering is wrong, apply some priorities.</p>\n<p>Consider what this is implying: it is saying that the DSL's semantics<br>\nare unknowable, or at least it's not worth knowing ahead of time what<br>\nwill happen; instead, one must <em>experiment</em> and then apply corrective<br>\naction if the heuristic gets it wrong.</p>\n<p>This is problematic because the developer may not always take the time<br>\nto do so (\"I'm just adding a quick lowering case, it will probably be<br>\nhit\") -- and because in cases where the metacompiler <em>does</em> get it<br>\nright without priorities, an implicit dependence on the current<br>\nheuristics is baked in at that point and must be frozen (see below).</p>\n<p>In my opinion, it is not feasible to write high-reliability software<br>\nif one's tools are unpredictable. Predictable and repeatable behavior<br>\nis the cornerstone of writing correct lowerings.</p>\n<h3>\"Most specific first\" is not simple or unambiguous</h3>\n<p>But isn't \"most specific first\" a predictable design point?</p>\n<p>It turns out, empirically, the answer is \"no\". We have had a number of<br>\nbugs where the heuristics do not do what we would expect, mostly<br>\nbecause fallible and infallible extractors are not properly ordered<br>\n(see e.g. #4685), and the interaction of explicit priorites with<br>\nimplicit ones is complex (#4093, #4117). We have a pending issue to<br>\nexplicitly define what the ordering even <em>is</em> (#3575) but we haven't<br>\nbeen able to do so in a simple way (and it is changing as we fix the<br>\nabove bugs).</p>\n<p>The basic issue is that because we are doing more than simple<br>\ntree-matching -- because we can invoke arbitrary Rust code and we have<br>\nwritten helpers that check predicates and conditions in various ways,<br>\nand because some checks are fallible and some are not -- \"specific\" is<br>\nunclear. This is aside from the general issue (noted<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/isle/isle/src/trie.rs#L42-L50\">here</a>)<br>\nthat when one has a tree-shaped rather than list-shaped pattern match,<br>\nspecificity is a <em>partial order</em>. (Two patterns can both subsume a<br>\ngeneral one by being specific in different dimensions.) One can break<br>\nthat tie arbitrarily, but that just adds more complexity.</p>\n<p>In general, humans (other than those who hack on <code>islec</code>) seem not to<br>\nthink in terms of these complex heuristics, or at least seem to<br>\nsometimes have a different expectation than what the compiler really<br>\ndoes.</p>\n<h3>Empirical evidence of mental-model mismatch</h3>\n<p>To add some evidence to this claim, see the following code reviews: </p>\n<ul>\n<li>#3706 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/3706#pullrequestreview-858875849\">link</a>)</li>\n<li>#4401 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4401#discussion_r916124277\">link</a>)</li>\n<li>#4399 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4399#discussion_r916122904\">link</a>)</li>\n<li>#3561: aarch64 backend fix to already-committed issue</li>\n<li>\n<p>#3560: a documentation change to add a note that rule-ordering is<br>\n  just a heuristic and not to rely on it (note that the first three<br>\n  examples above came after this update!)</p>\n</li>\n<li>\n<p>#3751: a proposal for a \"locally ordered list of rules\", as a<br>\n  stopgap fix for some cases, and general agreement that this would<br>\n  reduce confusion</p>\n</li>\n<li>\n<p>and more I have likely missed.</p>\n</li>\n</ul>\n<p>Developers working in ISLE seem to have a mental model that rules are<br>\nevaluated top-down. This is likely for several reasons. First, it is<br>\nthe natural \"reading order\"; thinking in terms of parallel,<br>\nreorderable conditions is not natural for most programmers. Second,<br>\nexisting languages <em>with match facilities</em> condition programmers this<br>\nway, <em>including Rust</em> (as well as ML, Haskell, Scala, etc). Third, it<br>\nis clear that there must be <em>some</em> order, and if the ordering<br>\nheuristic is otherwise muddy or badly specified, or sometimes changing<br>\n(see above), then a programmer will likely fall back on \"first rule<br>\nfirst\".</p>\n<p>In general we want to follow the Principle of Least Surprise: we<br>\nshould have a simple, predictable tool that behaves like most people<br>\nwho pick it up think it should.</p>\n<p>The task at hand (writing a correct compiler) is hard enough; any<br>\ncomplexity in the tool that is not necessary should be<br>\ndiscarded. Explicitness is a strong principle that results in tools<br>\none can trust and do precise work with.</p>\n<h3>Subtle bugs in heuristics, and heuristics as load-bearing for correctness</h3>\n<p>Finally, as seen in several of the above-linked issues and PRs, we<br>\nhave had multiple bugs in the ordering heuristics and have had to make<br>\nchanges to get them right.</p>\n<p>If a hard-to-understand heuristic is difficult for an ISLE developer<br>\nto keep track of, a hard-to-understand heuristic *that sometimes<br>\nchanges* is even worse.</p>\n<p>The \"experimental answer\" to rule ordering -- try it out, add a<br>\npriority if needed -- implicitly creates dependencies on the current<br>\nheuristics. If we do so, and then change the heuristics to fix <em>other</em><br>\ncases to behave as we expect they would, we are liable to silently<br>\nalter how rules apply (action-at-a-distance) and subtly break parts of<br>\nthe compiler. Test coverage can hedge against this, but relying on<br>\ntest coverage to patch over footguns in the language is a game that<br>\ndynamically-typed languages play; we don't want to do that if we can<br>\nhelp it.</p>\n<p>This potential for latent correctness bugs is <em>terrifying</em> and is<br>\nitself a strong reason to migrate away from this status quo, <br>\n[message truncated]</p>\n</blockquote>",
        "id": 293642134,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660609844
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1216014041\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>Thanks @elliottt for bringing this up. I have some thoughts on this inspired by our conversations over the past week, together with our experience with this aspect of ISLE over the past year, that I've written up on the subject below.</p>\n<h1>ISLE rule-ordering semantics simplification</h1>\n<p>This issue proposes to simplify the ISLE rule-ordering semantics to<br>\n\"first matching rule wins\", as a result of a year of experience with<br>\nthe language as it currently stands (a more complex ordering<br>\nheuristic) and the issues that this causes.</p>\n<h2>Overview: Current Design</h2>\n<p>ISLE currently has semantics for rule ordering that generally follow<br>\nthe \"most specific rule wins\" principle. The goal is that the user, or<br>\na tool, should be able to write rules in any order and the resulting<br>\ncompiler backend should be the same no matter how these rules are<br>\nordered.</p>\n<p>Inside the ISLE compiler, this is implemented by sorting edges when<br>\ninserting into the match trie. The sort-order is implied by the<br>\n<code>PatternInst</code> enum and the order of its arms: lower-ordered ops come<br>\nfirst at any given node in the tree.</p>\n<p>The ISLE language contains a concession to allow for manual ordering:<br>\nany rule can be annotated with an explicit numeric priority, and rules<br>\nare sorted by priority first before being merged into a match trie.</p>\n<h2>Reasons for Current Design</h2>\n<h3>Intuitive \"More-Specific-First\" Matching</h3>\n<p>The first reason given for the current design is that it allows for a<br>\nnatural \"general case then more specific cases\" ordering of rule<br>\ncases. One can start a group of rules with the most basic handling,<br>\nand then get into trickier cases later. This aids reading<br>\ncomprehension.</p>\n<h3>Compatibility with Rule-Generating Tools</h3>\n<p>One might build a tool that generates a large body of lowering rules<br>\nfrom some algorithm that finds equivalences (as in<br>\nsuperoptimization). For such a tool, it is convenient to be able to<br>\n(i) just dump the list of rules, without sorting first; and (ii) allow<br>\nthe user to include these rules without having to think about how they<br>\norder with respect to handwritten rules.</p>\n<h3>Independence of Rules for Verification</h3>\n<p>When verifying the correctness of ISLE lowering rules against<br>\nsemantics of the input and output language, it is useful if the<br>\nsemantics of the language are as-if a rule could fire when the<br>\nleft-hand side matches at all, regardless of other rules that<br>\nexist. An \"unordered\" / \"unspecified\" semantics is closer to this than<br>\n\"first rule wins\".</p>\n<h2>Issues</h2>\n<h3>Unclear mental model</h3>\n<p>The primary issue is that the mental model required to be held by the<br>\nISLE programmer is unclear. If the ISLE programmer <em>truly</em> does not<br>\ncare which rule applies, then all is well. But in real development of<br>\ncompiler backends, one does very much care: one needs to make sure<br>\nthat some special cases are actually handled (or else they are useless<br>\ndead code that, worse, may be untested); and sometimes one rule that<br>\nis shadowed by another is actually incorrect in the shadowed case, so<br>\none <em>relies</em> on the ordering heuristic for <em>correctness</em>.</p>\n<p>In general, development of ISLE rules requires the programmer to<br>\nunderstand how the language operates so that they can control which<br>\nrule fires. If the ordering rules are complex and subtle, or worse are<br>\n\"unspecified\", then we get a body of rules that either has silent<br>\nshadowing, or brittle reliance on particular ordering heuristics that<br>\nmay change. Even if we attempt to clearly specify the semantics, there<br>\nare subtleties that arise because of the way that external Rust code<br>\ncan be invoked: we don't know when some conditions are disjoint or<br>\nnot, fallible or infallible, and a set of prioritization rules that<br>\nrelies on \"fallible before infallible\" and disjointness thus requires,<br>\nin the limit, a full and complete understanding of our helpers'<br>\nsemantics (via explicit specification or some other method).</p>\n<p>One can make an argument that wen building a complex artifact, one<br>\nneeds one's tools to be as <em>predictable</em> as possible. Complexity is<br>\nfine, if it is in service of a well-understood goal (e.g., compiling<br>\nRust code to x86 machine code). But <em>unclear semantics</em> are not.</p>\n<h3>\"Experimental nature\" of Priority Usage</h3>\n<p>The clearest extraction of the issue here comes in our standard advice<br>\nfor getting proper lowering output: just write the rules, and if the<br>\nordering is wrong, apply some priorities.</p>\n<p>Consider what this is implying: it is saying that the DSL's semantics<br>\nare unknowable, or at least it's not worth knowing ahead of time what<br>\nwill happen; instead, one must <em>experiment</em> and then apply corrective<br>\naction if the heuristic gets it wrong.</p>\n<p>This is problematic because the developer may not always take the time<br>\nto do so (\"I'm just adding a quick lowering case, it will probably be<br>\nhit\") -- and because in cases where the metacompiler <em>does</em> get it<br>\nright without priorities, an implicit dependence on the current<br>\nheuristics is baked in at that point and must be frozen (see below).</p>\n<p>In my opinion, it is not feasible to write high-reliability software<br>\nif one's tools are unpredictable. Predictable and repeatable behavior<br>\nis the cornerstone of writing correct lowerings.</p>\n<h3>\"Most specific first\" is not simple or unambiguous</h3>\n<p>But isn't \"most specific first\" a predictable design point?</p>\n<p>It turns out, empirically, the answer is \"no\". We have had a number of<br>\nbugs where the heuristics do not do what we would expect, mostly<br>\nbecause fallible and infallible extractors are not properly ordered<br>\n(see e.g. #4685), and the interaction of explicit priorites with<br>\nimplicit ones is complex (#4093, #4117). We have a pending issue to<br>\nexplicitly define what the ordering even <em>is</em> (#3575) but we haven't<br>\nbeen able to do so in a simple way (and it is changing as we fix the<br>\nabove bugs).</p>\n<p>The basic issue is that because we are doing more than simple<br>\ntree-matching -- because we can invoke arbitrary Rust code and we have<br>\nwritten helpers that check predicates and conditions in various ways,<br>\nand because some checks are fallible and some are not -- \"specific\" is<br>\nunclear. This is aside from the general issue (noted<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/isle/isle/src/trie.rs#L42-L50\">here</a>)<br>\nthat when one has a tree-shaped rather than list-shaped pattern match,<br>\nspecificity is a <em>partial order</em>. (Two patterns can both subsume a<br>\ngeneral one by being specific in different dimensions.) One can break<br>\nthat tie arbitrarily, but that just adds more complexity.</p>\n<p>In general, humans (other than those who hack on <code>islec</code>) seem not to<br>\nthink in terms of these complex heuristics, or at least seem to<br>\nsometimes have a different expectation than what the compiler really<br>\ndoes.</p>\n<h3>Empirical evidence of mental-model mismatch</h3>\n<p>To add some evidence to this claim, see the following code reviews: </p>\n<ul>\n<li>#3706 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/3706#pullrequestreview-858875849\">link</a>)</li>\n<li>#4401 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4401#discussion_r916124277\">link</a>)</li>\n<li>#4399 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4399#discussion_r916122904\">link</a>)</li>\n<li>#3561: aarch64 backend fix to already-committed issue</li>\n<li>\n<p>#3560: a documentation change to add a note that rule-ordering is<br>\n  just a heuristic and not to rely on it (note that the first three<br>\n  examples above came after this update!)</p>\n</li>\n<li>\n<p>#3751: a proposal for a \"locally ordered list of rules\", as a<br>\n  stopgap fix for some cases, and general agreement that this would<br>\n  reduce confusion</p>\n</li>\n<li>\n<p>and more I have likely missed.</p>\n</li>\n</ul>\n<p>Developers working in ISLE seem to have a mental model that rules are<br>\nevaluated top-down. This is likely for several reasons. First, it is<br>\nthe natural \"reading order\"; thinking in terms of parallel,<br>\nreorderable conditions is not natural for most programmers. Second,<br>\nexisting languages <em>with match facilities</em> condition programmers this<br>\nway, <em>including Rust</em> (as well as ML, Haskell, Scala, etc). Third, it<br>\nis clear that there must be <em>some</em> order, and if the ordering<br>\nheuristic is otherwise muddy or badly specified, or sometimes changing<br>\n(see above), then a programmer will likely fall back on \"first rule<br>\nfirst\".</p>\n<p>In general we want to follow the Principle of Least Surprise: we<br>\nshould have a simple, predictable tool that behaves like most people<br>\nwho pick it up think it should.</p>\n<p>The task at hand (writing a correct compiler) is hard enough; any<br>\ncomplexity in the tool that is not necessary should be<br>\ndiscarded. Explicitness is a strong principle that results in tools<br>\none can trust and do precise work with.</p>\n<h3>Subtle bugs in heuristics, and heuristics as load-bearing for correctness</h3>\n<p>Finally, as seen in several of the above-linked issues and PRs, we<br>\nhave had multiple bugs in the ordering heuristics and have had to make<br>\nchanges to get them right.</p>\n<p>If a hard-to-understand heuristic is difficult for an ISLE developer<br>\nto keep track of, a hard-to-understand heuristic *that sometimes<br>\nchanges* is even worse.</p>\n<p>The \"experimental answer\" to rule ordering -- try it out, add a<br>\npriority if needed -- implicitly creates dependencies on the current<br>\nheuristics. If we do so, and then change the heuristics to fix <em>other</em><br>\ncases to behave as we expect they would, we are liable to silently<br>\nalter how rules apply (action-at-a-distance) and subtly break parts of<br>\nthe compiler. Test coverage can hedge against this, but relying on<br>\ntest coverage to patch over footguns in the language is a game that<br>\ndynamically-typed languages play; we don't want to do that if we can<br>\nhelp it.</p>\n<p>This potential for latent correctness bugs is <em>terrifying</em> and is<br>\nitself a strong reason to migrate away from this statu<br>\n[message truncated]</p>\n</blockquote>",
        "id": 293642190,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660609906
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1216014041\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>Thanks @elliottt for bringing this up. I have some thoughts on this inspired by our conversations over the past week, together with our experience with this aspect of ISLE over the past year, that I've written up on the subject below.</p>\n<h1>ISLE rule-ordering semantics simplification</h1>\n<p>This issue proposes to simplify the ISLE rule-ordering semantics to<br>\n\"first matching rule wins\", as a result of a year of experience with<br>\nthe language as it currently stands (a more complex ordering<br>\nheuristic) and the issues that this causes.</p>\n<h2>Overview: Current Design</h2>\n<p>ISLE currently has semantics for rule ordering that generally follow<br>\nthe \"most specific rule wins\" principle. The goal is that the user, or<br>\na tool, should be able to write rules in any order and the resulting<br>\ncompiler backend should be the same no matter how these rules are<br>\nordered.</p>\n<p>Inside the ISLE compiler, this is implemented by sorting edges when<br>\ninserting into the match trie. The sort-order is implied by the<br>\n<code>PatternInst</code> enum and the order of its arms: lower-ordered ops come<br>\nfirst at any given node in the tree.</p>\n<p>The ISLE language contains a concession to allow for manual ordering:<br>\nany rule can be annotated with an explicit numeric priority, and rules<br>\nare sorted by priority first before being merged into a match trie.</p>\n<h2>Reasons for Current Design</h2>\n<h3>Intuitive \"More-Specific-First\" Matching</h3>\n<p>The first reason given for the current design is that it allows for a<br>\nnatural \"general case then more specific cases\" ordering of rule<br>\ncases. One can start a group of rules with the most basic handling,<br>\nand then get into trickier cases later. This aids reading<br>\ncomprehension.</p>\n<h3>Compatibility with Rule-Generating Tools</h3>\n<p>One might build a tool that generates a large body of lowering rules<br>\nfrom some algorithm that finds equivalences (as in<br>\nsuperoptimization). For such a tool, it is convenient to be able to<br>\n(i) just dump the list of rules, without sorting first; and (ii) allow<br>\nthe user to include these rules without having to think about how they<br>\norder with respect to handwritten rules.</p>\n<h3>Independence of Rules for Verification</h3>\n<p>When verifying the correctness of ISLE lowering rules against<br>\nsemantics of the input and output language, it is useful if the<br>\nsemantics of the language are as-if a rule could fire when the<br>\nleft-hand side matches at all, regardless of other rules that<br>\nexist. An \"unordered\" / \"unspecified\" semantics is closer to this than<br>\n\"first rule wins\".</p>\n<h2>Issues</h2>\n<h3>Unclear mental model</h3>\n<p>The primary issue is that the mental model required to be held by the<br>\nISLE programmer is unclear. If the ISLE programmer <em>truly</em> does not<br>\ncare which rule applies, then all is well. But in real development of<br>\ncompiler backends, one does very much care: one needs to make sure<br>\nthat some special cases are actually handled (or else they are useless<br>\ndead code that, worse, may be untested); and sometimes one rule that<br>\nis shadowed by another is actually incorrect in the shadowed case, so<br>\none <em>relies</em> on the ordering heuristic for <em>correctness</em>.</p>\n<p>In general, development of ISLE rules requires the programmer to<br>\nunderstand how the language operates so that they can control which<br>\nrule fires. If the ordering rules are complex and subtle, or worse are<br>\n\"unspecified\", then we get a body of rules that either has silent<br>\nshadowing, or brittle reliance on particular ordering heuristics that<br>\nmay change. Even if we attempt to clearly specify the semantics, there<br>\nare subtleties that arise because of the way that external Rust code<br>\ncan be invoked: we don't know when some conditions are disjoint or<br>\nnot, fallible or infallible, and a set of prioritization rules that<br>\nrelies on \"fallible before infallible\" and disjointness thus requires,<br>\nin the limit, a full and complete understanding of our helpers'<br>\nsemantics (via explicit specification or some other method).</p>\n<p>One can make an argument that when building a complex artifact, one<br>\nneeds one's tools to be as <em>predictable</em> as possible. Complexity is<br>\nfine, if it is in service of a well-understood goal (e.g., compiling<br>\nRust code to x86 machine code). But <em>unclear semantics</em> are not.</p>\n<h3>\"Experimental nature\" of Priority Usage</h3>\n<p>The clearest extraction of the issue here comes in our standard advice<br>\nfor getting proper lowering output: just write the rules, and if the<br>\nordering is wrong, apply some priorities.</p>\n<p>Consider what this is implying: it is saying that the DSL's semantics<br>\nare unknowable, or at least it's not worth knowing ahead of time what<br>\nwill happen; instead, one must <em>experiment</em> and then apply corrective<br>\naction if the heuristic gets it wrong.</p>\n<p>This is problematic because the developer may not always take the time<br>\nto do so (\"I'm just adding a quick lowering case, it will probably be<br>\nhit\") -- and because in cases where the metacompiler <em>does</em> get it<br>\nright without priorities, an implicit dependence on the current<br>\nheuristics is baked in at that point and must be frozen (see below).</p>\n<p>In my opinion, it is not feasible to write high-reliability software<br>\nif one's tools are unpredictable. Predictable and repeatable behavior<br>\nis the cornerstone of writing correct lowerings.</p>\n<h3>\"Most specific first\" is not simple or unambiguous</h3>\n<p>But isn't \"most specific first\" a predictable design point?</p>\n<p>It turns out, empirically, the answer is \"no\". We have had a number of<br>\nbugs where the heuristics do not do what we would expect, mostly<br>\nbecause fallible and infallible extractors are not properly ordered<br>\n(see e.g. #4685), and the interaction of explicit priorites with<br>\nimplicit ones is complex (#4093, #4117). We have a pending issue to<br>\nexplicitly define what the ordering even <em>is</em> (#3575) but we haven't<br>\nbeen able to do so in a simple way (and it is changing as we fix the<br>\nabove bugs).</p>\n<p>The basic issue is that because we are doing more than simple<br>\ntree-matching -- because we can invoke arbitrary Rust code and we have<br>\nwritten helpers that check predicates and conditions in various ways,<br>\nand because some checks are fallible and some are not -- \"specific\" is<br>\nunclear. This is aside from the general issue (noted<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/isle/isle/src/trie.rs#L42-L50\">here</a>)<br>\nthat when one has a tree-shaped rather than list-shaped pattern match,<br>\nspecificity is a <em>partial order</em>. (Two patterns can both subsume a<br>\ngeneral one by being specific in different dimensions.) One can break<br>\nthat tie arbitrarily, but that just adds more complexity.</p>\n<p>In general, humans (other than those who hack on <code>islec</code>) seem not to<br>\nthink in terms of these complex heuristics, or at least seem to<br>\nsometimes have a different expectation than what the compiler really<br>\ndoes.</p>\n<h3>Empirical evidence of mental-model mismatch</h3>\n<p>To add some evidence to this claim, see the following code reviews: </p>\n<ul>\n<li>#3706 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/3706#pullrequestreview-858875849\">link</a>)</li>\n<li>#4401 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4401#discussion_r916124277\">link</a>)</li>\n<li>#4399 (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4399#discussion_r916122904\">link</a>)</li>\n<li>#3561: aarch64 backend fix to already-committed issue</li>\n<li>\n<p>#3560: a documentation change to add a note that rule-ordering is<br>\n  just a heuristic and not to rely on it (note that the first three<br>\n  examples above came after this update!)</p>\n</li>\n<li>\n<p>#3751: a proposal for a \"locally ordered list of rules\", as a<br>\n  stopgap fix for some cases, and general agreement that this would<br>\n  reduce confusion</p>\n</li>\n<li>\n<p>and more I have likely missed.</p>\n</li>\n</ul>\n<p>Developers working in ISLE seem to have a mental model that rules are<br>\nevaluated top-down. This is likely for several reasons. First, it is<br>\nthe natural \"reading order\"; thinking in terms of parallel,<br>\nreorderable conditions is not natural for most programmers. Second,<br>\nexisting languages <em>with match facilities</em> condition programmers this<br>\nway, <em>including Rust</em> (as well as ML, Haskell, Scala, etc). Third, it<br>\nis clear that there must be <em>some</em> order, and if the ordering<br>\nheuristic is otherwise muddy or badly specified, or sometimes changing<br>\n(see above), then a programmer will likely fall back on \"first rule<br>\nfirst\".</p>\n<p>In general we want to follow the Principle of Least Surprise: we<br>\nshould have a simple, predictable tool that behaves like most people<br>\nwho pick it up think it should.</p>\n<p>The task at hand (writing a correct compiler) is hard enough; any<br>\ncomplexity in the tool that is not necessary should be<br>\ndiscarded. Explicitness is a strong principle that results in tools<br>\none can trust and do precise work with.</p>\n<h3>Subtle bugs in heuristics, and heuristics as load-bearing for correctness</h3>\n<p>Finally, as seen in several of the above-linked issues and PRs, we<br>\nhave had multiple bugs in the ordering heuristics and have had to make<br>\nchanges to get them right.</p>\n<p>If a hard-to-understand heuristic is difficult for an ISLE developer<br>\nto keep track of, a hard-to-understand heuristic *that sometimes<br>\nchanges* is even worse.</p>\n<p>The \"experimental answer\" to rule ordering -- try it out, add a<br>\npriority if needed -- implicitly creates dependencies on the current<br>\nheuristics. If we do so, and then change the heuristics to fix <em>other</em><br>\ncases to behave as we expect they would, we are liable to silently<br>\nalter how rules apply (action-at-a-distance) and subtly break parts of<br>\nthe compiler. Test coverage can hedge against this, but relying on<br>\ntest coverage to patch over footguns in the language is a game that<br>\ndynamically-typed languages play; we don't want to do that if we can<br>\nhelp it.</p>\n<p>This potential for latent correctness bugs is <em>terrifying</em> and is<br>\nitself a strong reason to migrate away from this stat<br>\n[message truncated]</p>\n</blockquote>",
        "id": 293642646,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660610322
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1216031661\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>For another source on compiling pattern-match constructs with these top-down left-to-right semantics, Simon Peyton Jones' 1987 book, \"<a href=\"https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/\">The Implementation of Functional Programming Languages</a>\", is available as a free PDF. Chapter 5 covers a reasonably straight-forward implementation.</p>\n</blockquote>",
        "id": 293644390,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660611924
    },
    {
        "content": "<p>elliottt edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>While working on finishing the migration of the x64 backend to ISLE, I encountered a case where guarding a rule on specific ISA features being enabled caused the rule to never fire. The problem was that the rule I added overlapped with another rule except in the ISA feature check, and the other rule took precedence. Here's an example from elsewhere in the codebase:        <br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809\">https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809</a>    </p>\n<p>The LHS of the two rules only differs in the patterns to the first argument of <code>(has_type)</code>: both rules match <code>(ty_32_or_64 ty)</code> while the rule on line 1799 also matches <code>(use_bmi1)</code>. The rule on line 1799 has been given a priority of <code>1</code> to ensure that it's checked before the rule on line 1806, but ideally we wouldn't need to give this annotation here.        </p>\n<p>My proposal is that we switch to compiling ISLE by matching rules top-down, left-to-right.    </p>\n<h4>Benefit</h4>\n<p>The benefit of this change would be that we could tell statically when a rule was not reachable, and raise an error when it would never fire.    </p>\n<h4>Implementation</h4>\n<p>For matching on <code>enum</code> values we could take the approach outlined in <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf</a>. For handling extractors we could take inspiration from GHC's implementation of <a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns#compilation\">view patterns</a>.        </p>\n<h4>Alternatives</h4>\n<p>We could continue to develop heuristics to determine when rules might be unconditionally shadowed, and inform the programmer through an error or warning.</p>\n</blockquote>",
        "id": 293647047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660614825
    },
    {
        "content": "<p>elliottt <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1217308075\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>I ran into another instance of this today: the <code>sse_cmp_op</code> rule in the x64 lowering has overlapping cases for vectored floating point types. The rules on lines on 1504 and 1505 overlap with the rules on 1506 and 1507 respectively:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1499-L1507\">https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1499-L1507</a></p>\n<p>Any change in the heuristic that put the constant patterns before the fallible extractors would cause a panic during instruction emission, as the <code>vector_all_ones</code> rule uses the result of <code>sse_cmp_op</code> as the op for an <code>XmmRmR</code> instruction:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1520-L1527\">https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1520-L1527</a></p>\n</blockquote>",
        "id": 293821796,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660696395
    },
    {
        "content": "<p>elliottt edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1217308075\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>I ran into another instance of this today: the <code>sse_cmp_op</code> rule in the x64 lowering has overlapping cases for vectored floating point types. The rules on lines on 1504 and 1505 overlap with the rules on 1506 and 1507 respectively:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1499-L1507\">https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1499-L1507</a></p>\n<p>Any change in the heuristic that put the constant patterns before the fallible extractors would cause a panic during instruction emission, as the <code>vector_all_ones</code> rule uses the result of <code>sse_cmp_op</code> as the op for an <code>XmmRmR</code> instruction, and the <code>cmpps</code> and <code>cmppd</code> instructions require an immediate argument:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1520-L1527\">https://github.com/bytecodealliance/wasmtime/blob/c569e7bea5ab9c2f9a617aa1ba7de3d926d880be/cranelift/codegen/src/isa/x64/inst.isle#L1520-L1527</a></p>\n</blockquote>",
        "id": 293821859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660696445
    },
    {
        "content": "<p>elliottt <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1218279571\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>It's worth pointing out that for the example in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1217308075\">https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1217308075</a> we would still not be able to raise shadowing errors: the patterns that shadow the constant patterns are made up of fallible external extractors, and we don't have any insight into what will cause them to succeed or fail. This is the same situation that comes up in haskell with view patterns.</p>\n<p>However, we would benefit from predictable rule matching order, as the problematic rules on lines 1506 and 1507 would not suddenly fire due to heuristic changes.</p>\n</blockquote>",
        "id": 293938200,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660755825
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1221547832\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>It's occurred to me that we're trying to solve two different issues which might benefit from being treated separately. We're currently using priorities and heuristics to express validity preconditions as well as preferences between multiple valid rules. In other words, a key part of the optimizer's cost model is implicit in the ISLE rules for the backend. Changing the matching order to top-down doesn't change that.</p>\n<p>We could instead require every rule to express all of its preconditions, and have a separate way of expressing the cost model. That might mean that for usability we need new ISLE constructs for concisely expressing preconditions, I dunno. Ideally we'd let the user choose between several cost models when running Cranelift.</p>\n<p>In that approach, the order of rules doesn't matter, just like today. Formal verification is especially important then because, like today, if you get the preconditions wrong in some rule, it may happen to work a lot of the time due to other rules getting selected first; and like today, you can't tell if that's happening just by looking at the ISLE rules.</p>\n<p>One way to use a cost model is to impose a total ordering on rules. Different cost models impose different orderings so you can build different instruction selectors from the same rules. This can be done while building the compiler so there's no compile-time cost for that flexibility.</p>\n<p>But where it really helps to keep ISLE rules independent of cost model is if you start using e-graphs in the backend. The general idea is to take the full e-graph from mid-end optimization, apply all valid lowering rules at all e-nodes, and combine the results in a new e-graph. Now you can use the cost model in a way that takes dynamic context into account when there are partially overlapping rules, during extraction instead of during lowering. I think this subsumes peephole optimization.</p>\n<p>I've hand-waved away a lot of important details. The main thing is that I think it's worth thinking about other ways to let the consumer of ISLE rules decide what priority to give each rule, or even to find all matching rules. At the same time, backend developers do need to be able to control those priorities based on their knowledge of the ISA. I'm just no longer convinced that control should be expressed in the ISLE rules.</p>\n</blockquote>",
        "id": 294545365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661088969
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1221715061\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>Thanks @jameysharp for your thoughts here!</p>\n<blockquote>\n<p>We could instead require every rule to express all of its preconditions, and have a separate way of expressing the cost model. That might mean that for usability we need new ISLE constructs for concisely expressing preconditions, I dunno. Ideally we'd let the user choose between several cost models when running Cranelift.</p>\n</blockquote>\n<p>Unfortunately, this proposal is basically the status quo today already. A <em>correct</em> rule should express all conditions necessary for it to fire. And the priority mechanism is a way for the user to provide a cost model. It's possible I'm not understanding some subtlety of your proposal, but to me it reduces more or less to: keep the current design, but do it without bugs (or add some unspecified other mechanism to help do it without bugs, but then... let's talk about that other mechanism, if we have one).</p>\n<p>The main body of my argument is that, in practice, this isn't working. The difficulty is not coming up with a working abstraction -- rules that explicitly encode all conditions needed for them to fire -- but the way that that requirement plays out in practice as compared to developers' working mental models. See the \"Empirical evidence of mental-model mismatch\" section in my comment above.</p>\n<p>Concretely: how do we ensure that this \"all preconditions included\" is the case? I already very carefully review for this, and (i) I have still missed some cases, leading to the bugs linked above, and (ii) we shouldn't have to rely on \"think really hard and never make a mistake\" to uphold such a property. Formal verification is one answer, but this too feels wrong: we shouldn't stick with an empirically difficult-to-use abstraction early in the pipeline just because we can catch it with a very heavyweight technique later. Bugs cheaper to catch the earlier one catches them and all that.</p>\n<blockquote>\n<p>But where it really helps to keep ISLE rules independent of cost model is if you start using e-graphs in the backend. The general idea is to take the full e-graph from mid-end optimization, apply all valid lowering rules at all e-nodes, and combine the results in a new e-graph. Now you can use the cost model in a way that takes dynamic context into account when there are partially overlapping rules, during extraction instead of during lowering. I think this subsumes peephole optimization.</p>\n</blockquote>\n<p>This I think deserves a largely separate discussion, and I do agree that it's interesting to think about a \"late extraction\" approach, but really quickly, I think that the proper way to approach this while designing for correctness would be to provide an explicit \"multiple options\" (\"unordered rules\") mechanism that works within a broader context of nailed-down, simple-to-understand total ordering, not the other way around. This is because I want the programmer to have to opt into considering all options and testing them.</p>\n<p>That I think leads to another way of expressing my broad concerns here, related to the \"experimental approach\" concerns above: if the default is any-rule-could-fire with some unknowable (and explicitly reconfigurable, under your proposal!) heuristic driving it, then the user has to consider how all possible rule firing orders could result in correct or incorrect lowerings. Human brains mostly aren't built (or mine isn't anyway) for considering combinatorial possibilities at every step. (This is why unstructured pthreads programming is so much harder than structured concurrency; ordered by default, explicitly unordered where specified, is far easier than the opposite.) The analogy to structured concurrency tells us how to proceed here as well: we want well-specified combinators that say \"I really do mean that these three different rules are all equally valid and I have thought about the implications\", rather than \"I happened upon a bug experimentally in the everything-parallel world and want to serialize just this bit as a likely fix\".</p>\n<p>Does that make some sense at least? Happy to talk further in the Cranelift meeting tomorrow; I really am curious how others feel about this, especially folks with more scars from real ISLE programming and debugging :-)</p>\n</blockquote>",
        "id": 294597705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661134878
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1221931478\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<blockquote>\n<p>Concretely: how do we ensure that this \"all preconditions included\" is the case?</p>\n</blockquote>\n<p>Maybe by having a fuzzer which changes rule priority and disables rules at random and then doing differential fuzzing of the program execution with the rule set used for regular compilation where failure to codegen won't be considered a crash?</p>\n</blockquote>",
        "id": 294616608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661151548
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1222495727\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<blockquote>\n<p>Maybe by having a fuzzer which changes rule priority and disables rules at random and then doing differential fuzzing of the program execution with the rule set used for regular compilation where failure to codegen won't be considered a crash?</p>\n</blockquote>\n<p>That's certainly an option (actually it's even an item in the 2022 Cranelift roadmap, IIRC); but I think that it sort of sits in a similar place to verification in this regard: it would catch issues but I think at a higher cost than simplifying semantics and making it easier to avoid bugs in the first place.</p>\n<p>In other words may main concern at the moment is that we have a tool whose behavior is hard to understand and predict, and whose behavior seems to differ from many peoples' intuitions, and hence the tool is hard to use; if we fix that then we can still do all sorts of fuzzing and verification but the need to lean on it will be less, and it can spend its time finding other interesting bugs.</p>\n</blockquote>",
        "id": 294707396,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661181043
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1222754143\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>We had a good discussion on this issue today in the Cranelift meeting; thanks all for the input!</p>\n<p>I unfortunately didn't take detailed comment-by-comment notes but by the end of the discussion we had emerging a consensus that the overlap checking is actually the most interesting part; and if we got that right, the ordering of the rules themselves in textual order is actually not as important. There is still the question of whether we have \"locally unordered\" groups of rules, allowing for the flexibility of some sort of cost model, or whether we have a total order, but overlap checking and explicit opt-in to overlap lets us solve the high-order correctness+explicitness issue.</p>\n<p>Basically the idea is: by default it is an error for one rule to shadow another. Shadowing should be clearly semantically defined at the language level, not just \"engine can't prove disjoint\": for example, we could say that any two rules are disjoint if they match a different enum arm or different constant against the same value (same expression from root arguments). Conversely we should probably say that external extractors have <em>no</em> disjointness at the language-semantics level, and allow for negation <em>at the language level</em> (\"this extractor did not match\") rather than building ad-hoc pairs of \"A\" and \"not A\" extractors.</p>\n<p>Then we make the existing rules we have \"disjoint-clean\" by adding in \"not the earlier rule R, <em>and</em> ...\" prefixes to their left-hand sides. This becomes easier if we can name rules explicitly (thanks @avanhatt for this idea).</p>\n<p>Then we can allow explicit \"overlap with unconstrained priority\" if/when we want: rather than \"not R, and ...\" as a left hand side, we can say \"either R or ...\"; or perhaps group R1 and R2 (with overlapping left-hand sides) in one syntactic \"unordered group\" (but there are reasons why this may not be practical when generated code is involved); or perhaps a separate out-of-band declaration that R1 and R2 are overlapping.</p>\n<p>I think that captures most of what we settled on, but I am probably forgetting some details; my apologies if so; please do add anything I've missed.</p>\n</blockquote>",
        "id": 294743987,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1661192686
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>While working on finishing the migration of the x64 backend to ISLE, I encountered a case where guarding a rule on specific ISA features being enabled caused the rule to never fire. The problem was that the rule I added overlapped with another rule except in the ISA feature check, and the other rule took precedence. Here's an example from elsewhere in the codebase:        <br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809\">https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809</a>    </p>\n<p>The LHS of the two rules only differs in the patterns to the first argument of <code>(has_type)</code>: both rules match <code>(ty_32_or_64 ty)</code> while the rule on line 1799 also matches <code>(use_bmi1)</code>. The rule on line 1799 has been given a priority of <code>1</code> to ensure that it's checked before the rule on line 1806, but ideally we wouldn't need to give this annotation here.        </p>\n<p>My proposal is that we switch to compiling ISLE by matching rules top-down, left-to-right.    </p>\n<h4>Benefit</h4>\n<p>The benefit of this change would be that we could tell statically when a rule was not reachable, and raise an error when it would never fire.    </p>\n<h4>Implementation</h4>\n<p>For matching on <code>enum</code> values we could take the approach outlined in <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf</a>. For handling extractors we could take inspiration from GHC's implementation of <a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns#compilation\">view patterns</a>.        </p>\n<h4>Alternatives</h4>\n<p>We could continue to develop heuristics to determine when rules might be unconditionally shadowed, and inform the programmer through an error or warning.</p>\n</blockquote>",
        "id": 296847822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1662133875
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-1235659045\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 296847999,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1662133921
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>While working on finishing the migration of the x64 backend to ISLE, I encountered a case where guarding a rule on specific ISA features being enabled caused the rule to never fire. The problem was that the rule I added overlapped with another rule except in the ISA feature check, and the other rule took precedence. Here's an example from elsewhere in the codebase:        <br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809\">https://github.com/bytecodealliance/wasmtime/blob/0f944937c0c3d90946eaa6199f0baa5ed991c80d/cranelift/codegen/src/isa/x64/lower.isle#L1799-L1809</a>    </p>\n<p>The LHS of the two rules only differs in the patterns to the first argument of <code>(has_type)</code>: both rules match <code>(ty_32_or_64 ty)</code> while the rule on line 1799 also matches <code>(use_bmi1)</code>. The rule on line 1799 has been given a priority of <code>1</code> to ensure that it's checked before the rule on line 1806, but ideally we wouldn't need to give this annotation here.        </p>\n<p>My proposal is that we switch to compiling ISLE by matching rules top-down, left-to-right.    </p>\n<h4>Benefit</h4>\n<p>The benefit of this change would be that we could tell statically when a rule was not reachable, and raise an error when it would never fire.    </p>\n<h4>Implementation</h4>\n<p>For matching on <code>enum</code> values we could take the approach outlined in <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/luc-maranget/jun08.pdf</a>. For handling extractors we could take inspiration from GHC's implementation of <a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns#compilation\">view patterns</a>.        </p>\n<h4>Alternatives</h4>\n<p>We could continue to develop heuristics to determine when rules might be unconditionally shadowed, and inform the programmer through an error or warning.</p>\n</blockquote>",
        "id": 438144923,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715474926
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717#issuecomment-2106074280\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4717\">issue #4717</a>:</p>\n<blockquote>\n<p>I think this issue has largely been resolved by the overlap checker and trie-again work. Explicit rule priorities are obnoxious sometimes but it seems to be pretty clear to people how they work.</p>\n</blockquote>",
        "id": 438144924,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715474926
    }
]