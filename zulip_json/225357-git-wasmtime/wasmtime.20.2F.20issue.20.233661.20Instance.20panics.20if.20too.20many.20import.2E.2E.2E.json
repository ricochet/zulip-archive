[
    {
        "content": "<p>andyherbert opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently wasmtime panics if too many imports are provided to an instance, however in a warm module imports may be optimised away (for example with AssemblyScript), if calls to these imports are unreachable or not present.</p>\n<h4>Benefit</h4>\n<p>My particular use case is that I am embedding wasmtime in a Rust application and providing hooks to the host application, in the very likely event that someone writing the wasm module decides not to use one or more of the hooks then my application fails as I would be providing too many imports.</p>\n<h4>Implementation</h4>\n<h4>Alternatives</h4>\n</blockquote>",
        "id": 267185636,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641560299
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661#issuecomment-1007501453\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<p>Can you provide example code and/or an example module that triggers this? Excessive imports can theoretically reach a validation error if there's too many but that shouldn't result in a panic, that's definitely a bug in Wasmtime.</p>\n</blockquote>",
        "id": 267202671,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641569697
    },
    {
        "content": "<p>andyherbert <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661#issuecomment-1007541228\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<p>The problem isn't because of an excessive amount of imports, it's due to the import being optimised away by (in this case) binaryen.</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"kr\">declare</span> <span class=\"nx\">namespace</span> <span class=\"nx\">env</span> <span class=\"p\">{</span>\n    <span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">foo</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"ow\">void</span>\n    <span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">bar</span><span class=\"p\">()</span><span class=\"o\">:</span> <span class=\"ow\">void</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">foo</span><span class=\"p\">();</span>\n<span class=\"c1\">// env.bar();</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Func</span>::<span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">_</span>: <span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">{});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Func</span>::<span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">_</span>: <span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">{});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Instance</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()]).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"instance\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>thread 'main' panicked at 'instance: expected 1 imports, found 2'</code></p>\n</blockquote>",
        "id": 267208622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641572519
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661#issuecomment-1007565977\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<p>Ah ok, thanks for the clarification. This is not a panic in Wasmtime but rather a panic in your code (the <code>expect</code>). This is also due to the low-level nature of <code>Instance::new</code>. For your use case I'd recommend using <code>Linker</code> to instantiate modules which does name-based resolution which is probably what you want.</p>\n</blockquote>",
        "id": 267212643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641574452
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently wasmtime panics if too many imports are provided to an instance, however in a warm module imports may be optimised away (for example with AssemblyScript), if calls to these imports are unreachable or not present.</p>\n<h4>Benefit</h4>\n<p>My particular use case is that I am embedding wasmtime in a Rust application and providing hooks to the host application, in the very likely event that someone writing the wasm module decides not to use one or more of the hooks then my application fails as I would be providing too many imports.</p>\n<h4>Implementation</h4>\n<h4>Alternatives</h4>\n</blockquote>",
        "id": 267212644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641574452
    },
    {
        "content": "<p>andyherbert <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661#issuecomment-1007569514\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3661\">issue #3661</a>:</p>\n<blockquote>\n<p>Ah okay, I must have missed the Linker, many thanks.</p>\n</blockquote>",
        "id": 267213195,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641574711
    }
]