[
    {
        "content": "<p>willygroup <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-906602975\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Hi!<br>\nThere are any progress on shared memory between linked modules?<br>\nI'm trying to create a \"WasmMachine\" that links an \"sdk module\" that contains some wrapper to host_functions and a secondary module that calls the sdk functions.</p>\n<p>I would like call from a the secondary wasm (sources in rust) the sdk functions passing just pointers to a shared linear memory.<br>\nSomething like this (is basically the linker example):</p>\n<p>`<br>\n    let engine = Engine::default();<br>\n    let mut linker = Linker::new(&amp;engine);<br>\n    let mut store = Store::new(&amp;engine, ());</p>\n<div class=\"codehilite\"><pre><span></span><code>let wasm_module = Module::from_file(&amp;engine, MODULE_WASM)?;\nlet sdk_module = Module::from_file(&amp;engine, SDK_WASM)?;\n\nlinker.func_wrap(&quot;host&quot;, &quot;log&quot;, host_log)?;\n\n// Memory from host\n// let mem = Memory::new(&amp;mut store, MemoryType::new(Limits::new(17, None)))?;\n// linker.define(&quot;env&quot;, &quot;memory&quot;, mem)?;\n\nlet sdk_module = linker.instantiate(&amp;mut store, &amp;sdk_module)?;\n\n// Using the sdk-memory\nlet mem = sdk_module\n    .get_memory(&amp;mut store, &quot;memory&quot;)\n    .expect(&quot;Expected &#39;memory&#39; not found&quot;);\nlinker.define(&quot;env&quot;, &quot;memory&quot;, mem)?;\n\nlinker.instance(&amp;mut store, &quot;wasm-sdk&quot;, sdk_module)?;\n\nlet wasm_module = linker.instantiate(&amp;mut store, &amp;wasm_module)?;\n\nlet add = wasm_module.get_typed_func::&lt;(i32, i32), i32, _&gt;(&amp;mut store, &quot;add&quot;)?;\n\nlet res = add.call(&amp;mut store, (41, 1))?;\n\nprintln!(&quot;res_add: {}&quot;, res);`\n</code></pre></div>\n\n<p>I'm trying in two ways:</p>\n<ol>\n<li>\n<p>Compiling the wasm module with the flag <code>--import-memory\"</code> and then creating a host memory like this:<br>\n<code>let mem = Memory::new(&amp;mut store, MemoryType::new(Limits::new(17, None)))?;</code></p>\n</li>\n<li>\n<p>Compiling just the secondary module with the flag <code>--import-memory\"</code> and then export the memory from the sdk_module and using it for the secondary module.<br>\n<code>let mem = sdk_module\n            .get_memory(&amp;mut store, \"memory\")\n            .expect(\"Expected 'memory' not found\");</code></p>\n</li>\n</ol>\n<ul>\n<li>Always  obtaining the error <code>Error: failed to get caller's exported memory</code> at  <code>add.call</code> <br>\n</li>\n</ul>\n</blockquote>",
        "id": 250809442,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629998954
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-906608853\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>While I am not sure why wasmtime gives an error, even if it doesn't <code>--import-memory</code> is not enough to make this work. <code>--import-memory</code> only causes the wasm module to import an externally provided memory. It will still overwrite part of it with it's data segment. This is almost guaranteed to overwrite the part of the linear memory to which the exporting wasm module has written it's data segment, causing corruption. I am not sure if the LLVM toolchain has an option to move the location where the data segment is imported to ensure that it doesn't conflict between the wasm modules. In addition the heap allocator of each wasm module likely expects to be the only allocator operating on the linear memory which may cause both allocators to give the same part of the memory to callers in both wasm modules.</p>\n</blockquote>",
        "id": 250810778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629999496
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-906602975\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Hi!<br>\nThere are any progress on shared memory between linked modules?<br>\nI'm trying to create a \"WasmMachine\" that links an \"sdk module\" that contains some wrapper to host_functions and a secondary module that calls the sdk functions.</p>\n<p>I would like call from a the secondary wasm (sources in rust) the sdk functions passing just pointers to a shared linear memory.<br>\nSomething like this (is basically the linker example):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">engine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Engine</span>::<span class=\"n\">default</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Linker</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">());</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wasm_module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Module</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MODULE_WASM</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sdk_module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Module</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SDK_WASM</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap</span><span class=\"p\">(</span><span class=\"s\">\"host\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"log\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">host_log</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Memory from host</span>\n<span class=\"w\">    </span><span class=\"c1\">// let mem = Memory::new(&amp;mut store, MemoryType::new(Limits::new(17, None)))?;</span>\n<span class=\"w\">    </span><span class=\"c1\">// linker.define(\"env\", \"memory\", mem)?;</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sdk_module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">sdk_module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Using the sdk-memory</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sdk_module</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">get_memory</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">\"Expected 'memory' not found\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instance</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"wasm-sdk\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sdk_module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wasm_module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">wasm_module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasm_module</span><span class=\"p\">.</span><span class=\"n\">get_typed_func</span>::<span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">41</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"res_add: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'm trying in two ways:</p>\n<ol>\n<li>\n<p>Compiling the wasm module with the flag <code>--import-memory\"</code> and then creating a host memory like this:<br>\n<code>let mem = Memory::new(&amp;mut store, MemoryType::new(Limits::new(17, None)))?;</code></p>\n</li>\n<li>\n<p>Compiling just the secondary module with the flag <code>--import-memory\"</code> and then export the memory from the sdk_module and using it for the secondary module.<br>\n<code>let mem = sdk_module\n            .get_memory(&amp;mut store, \"memory\")\n            .expect(\"Expected 'memory' not found\");</code></p>\n</li>\n</ol>\n<ul>\n<li>Always  obtaining the error <code>Error: failed to get caller's exported memory</code> at  <code>add.call</code> <br>\n</li>\n</ul>\n</blockquote>",
        "id": 250859441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630022657
    },
    {
        "content": "<p>willygroup <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-908078279\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Thanks for the reply.<br>\nI managed to import the same memory for both modules and this looks \"almost\" to work if I don't mess too much with the memory allocation :D <br>\nThere is no way to tell a module to use the allocator from another module?<br>\nLike this is not very useful linking modules for my project <span aria-label=\"disappointed\" class=\"emoji emoji-1f61e\" role=\"img\" title=\"disappointed\">:disappointed:</span> </p>\n</blockquote>",
        "id": 251189826,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630306120
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-908108581\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<blockquote>\n<p>There is no way to tell a module to use the allocator from another module?</p>\n</blockquote>\n<p>Maybe if you only link a single wasm module against the allocator and then let the other link against the allocator functions of the first? As for how to achieve this, I have no idea.</p>\n</blockquote>",
        "id": 251193779,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630309030
    },
    {
        "content": "<p>davxy <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-909041679\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Hi there. I'm interested as well :)</p>\n<p>Preamble: </p>\n<ul>\n<li>I have a two modules, A and B, and I like to use B as a shared library.</li>\n<li>A is tiny and contains only the code that implements the application business logic.</li>\n<li>B is huge and contains all the std library functions and utilities</li>\n</ul>\n<p>In particular, I'm trying to:</p>\n<ul>\n<li>\n<ol>\n<li>share the memory between two modules =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>call a function of module A from module B =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>prevent A from statically link the std library stuff, eg. allocator code =&gt; NOT DONE (how we can do that?)</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>prevent that an allocation in module A clash with an allocation in module B =&gt; NOT DOVE (I suppose that can be resolved by the point 3 by letting B using the allocator in A.</li>\n</ol>\n</li>\n</ul>\n<p>Any ideas?</p>\n<p>Thanks for you awesome work, David</p>\n</blockquote>",
        "id": 251352725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630400390
    },
    {
        "content": "<p>davxy edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-909041679\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Hi there. I'm interested as well :)</p>\n<p>Preamble: </p>\n<ul>\n<li>I have two modules, A and B, and I like to use B as a shared library.</li>\n<li>A is tiny and contains only the code that implements the application business logic.</li>\n<li>B is huge and contains all the std library functions and utilities</li>\n</ul>\n<p>In particular, I'm trying to:</p>\n<ul>\n<li>\n<ol>\n<li>share the memory between two modules =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>call a function of module A from module B =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>prevent A from statically link the std library stuff, eg. allocator code =&gt; NOT DONE (how we can do that?)</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>prevent that an allocation in module A clash with an allocation in module B =&gt; NOT DOVE (I suppose that can be resolved by the point 3 by letting B using the allocator in A.</li>\n</ol>\n</li>\n</ul>\n<p>Any ideas?</p>\n<p>Thanks for you awesome work, David</p>\n</blockquote>",
        "id": 251352799,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630400410
    },
    {
        "content": "<p>davxy edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-909041679\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>Hi there. I'm interested as well :)</p>\n<p>Preamble: </p>\n<ul>\n<li>I have two modules, A and B, and I like to use B as a shared library.</li>\n<li>A is tiny and contains only the code that implements the application business logic.</li>\n<li>B is huge and contains all the std library functions and utilities</li>\n</ul>\n<p>In particular, I'm trying to:</p>\n<ul>\n<li>\n<ol>\n<li>share the memory between two modules =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>call a function of module A from module B =&gt; DONE</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>prevent A from statically link the std library stuff, eg. allocator code =&gt; NOT DONE (how we can do that?)</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>prevent that an allocation in module A clash with an allocation in module B =&gt; NOT DONE (I suppose that can be resolved by the point 3 by letting B using the allocator in A.</li>\n</ol>\n</li>\n</ul>\n<p>Any ideas?</p>\n<p>Thanks for you awesome work, David</p>\n</blockquote>",
        "id": 251352847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630400423
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-909050627\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>It seems that there is a tool convention for dynamic libraries&lt;sup&gt;[1]&lt;/sup&gt;, but it is a work in progress and requires either using emscripten, which only runs on the web, or parsing a \"dylink\" section when loading to determine which dynamic libraries to load and then some additional code to actually link them. [2] gives some more information on how to make it work. At the time of writing of that article there were a couple of bugs in LLVM and lld. I don't know if they are all fixed yet.</p>\n<p>[1]: <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\">https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md</a><br>\n[2]: <a href=\"https://iandouglasscott.com/2019/07/18/experimenting-with-webassembly-dynamic-linking-with-clang/\">https://iandouglasscott.com/2019/07/18/experimenting-with-webassembly-dynamic-linking-with-clang/</a></p>\n</blockquote>",
        "id": 251353945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1630401072
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934#issuecomment-1118827944\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>I'm going to close this since this issue is quite old at this point and in general the problems here are toolchain-related rather than Wasmtime related. </p>\n</blockquote>",
        "id": 281327216,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651769646
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1934\">issue #1934</a>:</p>\n<blockquote>\n<p>I've tried to experiment with linking several wasm modules together (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/examples/linking.rs\">https://github.com/bytecodealliance/wasmtime/blob/master/examples/linking.rs</a>). It works but it seems the memory isn't \"shared\". For instance it is impossible to send a string between modules. Am I missing something? Thanks!</p>\n</blockquote>",
        "id": 281327217,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651769646
    }
]