[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>As part of a general push to improve the quality of generated code, we want to extend the set of optimizations that we perform on the IR (CLIF) beyond the current set of GVN, LICM, DCE, etc passes, and develop some general analyses to support these and the CLIF-to-MachInst lowering pass. For example, we may want:</p>\n<ul>\n<li>Alias analysis, and redundant load elimination, store-to-load forwarding, and dead store elimination using its results;</li>\n<li>More general constant propagation and folding (compile-time evaluation) using the CLIF interpreter;</li>\n<li>Bounds-check elimination, finding when one check dominates another and makes it unnecessary;</li>\n<li>Integer range analysis, to help with bounds-check elimination;</li>\n<li>Demanded-bits and defined-bits analyses, either over the CLIF or in concert with the lowering (since at least defined-bits may depend on the instructions chosen);</li>\n<li>and others.</li>\n</ul>\n<p>We should generally strive to write these analyses and transforms with the pass-specific bits in ISLE. This will bring both short- and long-term benefits:</p>\n<ul>\n<li>Pattern-matching is a very good fit for the sorts of transfer/meet functions that many analyses require, allowing for concise and less error-prone expression of the ideas;</li>\n<li>The optimizations that allow for efficient merging of many different matching rules during lowering would also bring benefits to any complex transfer function in an analysis;</li>\n<li>Building passes out of ISLE rules that analyze CLIF and transform CLIF to CLIF lets us eventually <em>fuse</em> this mid-end with the CLIF-to-MachInst lowering pass;</li>\n<li>Putting everything into the DSL in which we express our backend lowering rewrites allows us to reuse whatever formal-verification machinery we build around it.</li>\n</ul>\n<p>The main steps of this work will be:</p>\n<ul>\n<li>[ ] Develop a lazy analysis framework over CLIF, with transfer/meet functions in ISLE;</li>\n<li>[ ] Develop a toplevel generic transform pass driver that edits CLIF in-place, using logic written in ISLE with the same CLIF extractors and constructors as for backends;</li>\n<li>[ ] Co-develop, with the above, several initial passes (e.g. alias analysis and redundant-load elimination).</li>\n</ul>\n<p>Possibly, if we can, it may be interesting to also:</p>\n<ul>\n<li>[ ] Find ways to fuse analyses and passes in the mid-end, possibly enabling a lightweight combination of mid-end passes that stream over CLIF once and emit new CLIF, rather than editing in place;</li>\n<li>[ ] Investigate whether we can fuse the above with the backend lowering.</li>\n</ul>\n<p>Theese last two steps are intentionally vague and bring up questions of pass direction and pass ordering; but I <em>suspect</em> that we may be able to do something to get down to a handful of passes if we are careful. In any case, finding a way to make this work would be a bonus, and the main benefit provided by the work in this issue overall is ease of development, better likelihood of correctness, and compatibility with verification efforts.</p>\n</blockquote>",
        "id": 281898593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652224551
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>As part of a general push to improve the quality of generated code, we want to extend the set of optimizations that we perform on the IR (CLIF) beyond the current set of GVN, LICM, DCE, etc passes, and develop some general analyses to support these and the CLIF-to-MachInst lowering pass. For example, we may want:</p>\n<ul>\n<li>Alias analysis, and redundant load elimination, store-to-load forwarding, and dead store elimination using its results;</li>\n<li>More general constant propagation and folding (compile-time evaluation) using the CLIF interpreter;</li>\n<li>Bounds-check elimination, finding when one check dominates another and makes it unnecessary;</li>\n<li>Integer range analysis, to help with bounds-check elimination;</li>\n<li>Demanded-bits and defined-bits analyses, either over the CLIF or in concert with the lowering (since at least defined-bits may depend on the instructions chosen);</li>\n<li>and others.</li>\n</ul>\n<p>We should generally strive to write these analyses and transforms with the pass-specific bits in ISLE. This will bring both short- and long-term benefits:</p>\n<ul>\n<li>Pattern-matching is a very good fit for the sorts of transfer/meet functions that many analyses require, allowing for concise and less error-prone expression of the ideas;</li>\n<li>The optimizations that allow for efficient merging of many different matching rules during lowering would also bring benefits to any complex transfer function in an analysis;</li>\n<li>Building passes out of ISLE rules that analyze CLIF and transform CLIF to CLIF lets us eventually <em>fuse</em> this mid-end with the CLIF-to-MachInst lowering pass;</li>\n<li>Putting everything into the DSL in which we express our backend lowering rewrites allows us to reuse whatever formal-verification machinery we build around it.</li>\n</ul>\n<p>The main steps of this work will be:</p>\n<ul>\n<li>[ ] Develop a lazy analysis framework over CLIF, with transfer/meet functions in ISLE;</li>\n<li>[ ] Develop a toplevel generic transform pass driver that edits CLIF in-place, using logic written in ISLE with the same CLIF extractors and constructors as for backends;</li>\n<li>[ ] Co-develop, with the above, several initial passes (e.g. alias analysis and redundant-load elimination).</li>\n</ul>\n<p>Possibly, if we can, it may be interesting to also:</p>\n<ul>\n<li>[ ] Find ways to fuse analyses and passes in the mid-end, possibly enabling a lightweight combination of mid-end passes that stream over CLIF once and emit new CLIF, rather than editing in place;</li>\n<li>[ ] Investigate whether we can fuse the above with the backend lowering.</li>\n</ul>\n<p>Theese last two steps are intentionally vague and bring up questions of pass direction and pass ordering; but I <em>suspect</em> that we may be able to do something to get down to a handful of passes if we are careful. In any case, finding a way to make this work would be a bonus, and the main benefit provided by the work in this issue overall is ease of development, better likelihood of correctness, and compatibility with verification efforts.</p>\n</blockquote>",
        "id": 281898594,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652224551
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>As part of a general push to improve the quality of generated code, we want to extend the set of optimizations that we perform on the IR (CLIF) beyond the current set of GVN, LICM, DCE, etc passes, and develop some general analyses to support these and the CLIF-to-MachInst lowering pass. For example, we may want:</p>\n<ul>\n<li>Alias analysis, and redundant load elimination, store-to-load forwarding, and dead store elimination using its results;</li>\n<li>More general constant propagation and folding (compile-time evaluation) using the CLIF interpreter;</li>\n<li>Bounds-check elimination, finding when one check dominates another and makes it unnecessary;</li>\n<li>Integer range analysis, to help with bounds-check elimination;</li>\n<li>Demanded-bits and defined-bits analyses, either over the CLIF or in concert with the lowering (since at least defined-bits may depend on the instructions chosen);</li>\n<li>and others.</li>\n</ul>\n<p>We should generally strive to write these analyses and transforms with the pass-specific bits in ISLE. This will bring both short- and long-term benefits:</p>\n<ul>\n<li>Pattern-matching is a very good fit for the sorts of transfer/meet functions that many analyses require, allowing for concise and less error-prone expression of the ideas;</li>\n<li>The optimizations that allow for efficient merging of many different matching rules during lowering would also bring benefits to any complex transfer function in an analysis;</li>\n<li>Building passes out of ISLE rules that analyze CLIF and transform CLIF to CLIF lets us eventually <em>fuse</em> this mid-end with the CLIF-to-MachInst lowering pass;</li>\n<li>Putting everything into the DSL in which we express our backend lowering rewrites allows us to reuse whatever formal-verification machinery we build around it.</li>\n</ul>\n<p>The main steps of this work will be:</p>\n<ul>\n<li>[ ] Develop a lazy analysis framework over CLIF, with transfer/meet functions in ISLE;</li>\n<li>[ ] Develop a toplevel generic transform pass driver that edits CLIF in-place, using logic written in ISLE with the same CLIF extractors and constructors as for backends;</li>\n<li>[ ] Co-develop, with the above, several initial passes (e.g. alias analysis and redundant-load elimination).</li>\n</ul>\n<p>Possibly, if we can, it may be interesting to also:</p>\n<ul>\n<li>[ ] Find ways to fuse analyses and passes in the mid-end, possibly enabling a lightweight combination of mid-end passes that stream over CLIF once and emit new CLIF, rather than editing in place;</li>\n<li>[ ] Investigate whether we can fuse the above with the backend lowering.</li>\n</ul>\n<p>Theese last two steps are intentionally vague and bring up questions of pass direction and pass ordering; but I <em>suspect</em> that we may be able to do something to get down to a handful of passes if we are careful. In any case, finding a way to make this work would be a bonus, and the main benefit provided by the work in this issue overall is ease of development, better likelihood of correctness, and compatibility with verification efforts.</p>\n</blockquote>",
        "id": 281898595,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652224551
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>As part of a general push to improve the quality of generated code, we want to extend the set of optimizations that we perform on the IR (CLIF) beyond the current set of GVN, LICM, DCE, etc passes, and develop some general analyses to support these and the CLIF-to-MachInst lowering pass. For example, we may want:</p>\n<ul>\n<li>Alias analysis, and redundant load elimination, store-to-load forwarding, and dead store elimination using its results;</li>\n<li>More general constant propagation and folding (compile-time evaluation) using the CLIF interpreter;</li>\n<li>Bounds-check elimination, finding when one check dominates another and makes it unnecessary;</li>\n<li>Integer range analysis, to help with bounds-check elimination;</li>\n<li>Demanded-bits and defined-bits analyses, either over the CLIF or in concert with the lowering (since at least defined-bits may depend on the instructions chosen);</li>\n<li>and others.</li>\n</ul>\n<p>We should generally strive to write these analyses and transforms with the pass-specific bits in ISLE. This will bring both short- and long-term benefits:</p>\n<ul>\n<li>Pattern-matching is a very good fit for the sorts of transfer/meet functions that many analyses require, allowing for concise and less error-prone expression of the ideas;</li>\n<li>The optimizations that allow for efficient merging of many different matching rules during lowering would also bring benefits to any complex transfer function in an analysis;</li>\n<li>Building passes out of ISLE rules that analyze CLIF and transform CLIF to CLIF lets us eventually <em>fuse</em> this mid-end with the CLIF-to-MachInst lowering pass;</li>\n<li>Putting everything into the DSL in which we express our backend lowering rewrites allows us to reuse whatever formal-verification machinery we build around it.</li>\n</ul>\n<p>The main steps of this work will be:</p>\n<ul>\n<li>[ ] Develop a lazy analysis framework over CLIF, with transfer/meet functions in ISLE;<ul>\n<li>#4129 </li>\n</ul>\n</li>\n<li>[ ] Develop a toplevel generic transform pass driver that edits CLIF in-place, using logic written in ISLE with the same CLIF extractors and constructors as for backends;<ul>\n<li>#4130</li>\n</ul>\n</li>\n<li>[ ] Co-develop, with the above, several initial passes (e.g. alias analysis and redundant-load elimination).<ul>\n<li>#4131</li>\n</ul>\n</li>\n</ul>\n<p>Possibly, if we can, it may be interesting to also:</p>\n<ul>\n<li>[ ] Find ways to fuse analyses and passes in the mid-end, possibly enabling a lightweight combination of mid-end passes that stream over CLIF once and emit new CLIF, rather than editing in place;</li>\n<li>[ ] Investigate whether we can fuse the above with the backend lowering.</li>\n</ul>\n<p>Theese last two steps are intentionally vague and bring up questions of pass direction and pass ordering; but I <em>suspect</em> that we may be able to do something to get down to a handful of passes if we are careful. In any case, finding a way to make this work would be a bonus, and the main benefit provided by the work in this issue overall is ease of development, better likelihood of correctness, and compatibility with verification efforts.</p>\n</blockquote>",
        "id": 281900203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652225777
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128#issuecomment-1123217592\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<blockquote>\n<p>Investigate whether we can fuse the above with the backend lowering.</p>\n</blockquote>\n<p>That would prevent optimizations that can't be streamed from running after these streamable optimizations, right?</p>\n</blockquote>",
        "id": 281921964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652248767
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128#issuecomment-1124022476\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>Right, it would be a particular configuration when compilation speed is more important. I don't think we would unconditionally build the backend in this way, as long as we also want to support higher optimization levels.</p>\n</blockquote>",
        "id": 281996758,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652288604
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128#issuecomment-1140014559\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>For anyone curious, I've been doing a lot of thinking and reading trying to work out a good approach here, with several toplevel goals: (i) enable rewrites in ISLE, (ii) solve the phase-ordering problem in a better way.</p>\n<p>Briefly, after introducing alias analysis in #4163, it became apparent to me that we need a more uniform approach to interleaving optimizations and allowing them to interact. That had already been the idea to a large degree with the desire to use ISLE to express transforms (the DSL compiler could combine rules from all kinds of analyses/transforms into a uniform rewrite step iterated until fixpoint); but it had become apparent that adding alias analysis (depending on GVN/alias/cprop/const-folding to prove equal addresses) sort of pushed the problem over the edge. Previously we had few enough rewrites that running simple_preopt once, then GVN once, pretty much was OK; not anymore.</p>\n<p>So I've been looking seriously into <a href=\"https://en.wikipedia.org/wiki/E-graph\">e-graphs</a> as an IR between CLIF and VCode lowering, with the idea that we could use the excellent <a href=\"https://egraphs-good.github.io/\">egg</a> library, probably with integration to ISLE (or rather with ISLE integration to egg: generating slightly different code that can match on the egraph).</p>\n<p>The reason I've been thinking that rewriting from CLIF into an egraph, then the egraph straight to VCode, is that adapting the <code>Lower</code> infrastructure to query an egraph directly is actually probably simpler than trying to lower back to CLIF, in addition to the efficiency gained from removing a step. Furthermore our CLIF optimizations can then be shifted later in the pipeline, to become egraph rewrite rules instead; and we could subsume GVN and LICM entirely by implicit invariants and hashconsing/merging in the process of building the egraph and lowering out of it.</p>\n<p>One can represent control flow by creating explicit nodes for \"block predicates\" and edges for \"state flow\", akin to a <a href=\"https://en.wikipedia.org/wiki/Program_dependence_graph\">PDG</a> or <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-705.pdf\">VSDG</a>. The hard part is actually coming <em>out</em> of the egraph representation back to linearized code; in other words, deciding when to compute each node.</p>\n<p>I've gone through a few iterations here and will go ahead and link my <a href=\"https://gist.github.com/cfallin/e95ff168c429a4011dea645b805aabb5\">braindump/notes</a> of my explorations to date, but in brief have discovered that there is a reason for multiple PhD theses to exist on just this topic, and at least my latest formulation reduces to a weighted set cover problem, which excitingly enough is one of the canonical NP-complete problems. So, I'm starting to think that there may be an intermediate design point where we retain some information about the original program order in CLIF in the egraph nodes, but introduce targetted rewrites/merging steps that explicitly do something like GVN. That would give us the best of both worlds, namely the expression visibility across the function body for rewrite rules to work, without exciting exponential blowups in compile time.</p>\n<p>I'll note for completeness too that all of this I envision being used only in an \"optimizations enabled\" compilation; Cranelfit-without-opts would skip all of this, and continue to lower straight from CLIF to VCode. (Whether that implies two parameterizations/monomorphizations of each backend, I'm not sure yet; details TBD.)</p>\n<p>Anyway, that's my update to keep folks posted; hopefully more soon!</p>\n</blockquote>",
        "id": 284181836,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1653683634
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128#issuecomment-1300810915\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>This is implemented in the recent e-graphs work. Closing.</p>\n</blockquote>",
        "id": 307563633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667405908
    },
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4128\">issue #4128</a>:</p>\n<blockquote>\n<p>As part of a general push to improve the quality of generated code, we want to extend the set of optimizations that we perform on the IR (CLIF) beyond the current set of GVN, LICM, DCE, etc passes, and develop some general analyses to support these and the CLIF-to-MachInst lowering pass. For example, we may want:</p>\n<ul>\n<li>Alias analysis, and redundant load elimination, store-to-load forwarding, and dead store elimination using its results;</li>\n<li>More general constant propagation and folding (compile-time evaluation) using the CLIF interpreter;</li>\n<li>Bounds-check elimination, finding when one check dominates another and makes it unnecessary;</li>\n<li>Integer range analysis, to help with bounds-check elimination;</li>\n<li>Demanded-bits and defined-bits analyses, either over the CLIF or in concert with the lowering (since at least defined-bits may depend on the instructions chosen);</li>\n<li>and others.</li>\n</ul>\n<p>We should generally strive to write these analyses and transforms with the pass-specific bits in ISLE. This will bring both short- and long-term benefits:</p>\n<ul>\n<li>Pattern-matching is a very good fit for the sorts of transfer/meet functions that many analyses require, allowing for concise and less error-prone expression of the ideas;</li>\n<li>The optimizations that allow for efficient merging of many different matching rules during lowering would also bring benefits to any complex transfer function in an analysis;</li>\n<li>Building passes out of ISLE rules that analyze CLIF and transform CLIF to CLIF lets us eventually <em>fuse</em> this mid-end with the CLIF-to-MachInst lowering pass;</li>\n<li>Putting everything into the DSL in which we express our backend lowering rewrites allows us to reuse whatever formal-verification machinery we build around it.</li>\n</ul>\n<p>The main steps of this work will be:</p>\n<ul>\n<li>[ ] Develop a lazy analysis framework over CLIF, with transfer/meet functions in ISLE;<ul>\n<li>#4129 </li>\n</ul>\n</li>\n<li>[ ] Develop a toplevel generic transform pass driver that edits CLIF in-place, using logic written in ISLE with the same CLIF extractors and constructors as for backends;<ul>\n<li>#4130</li>\n</ul>\n</li>\n<li>[ ] Co-develop, with the above, several initial passes (e.g. alias analysis and redundant-load elimination).<ul>\n<li>#4131</li>\n</ul>\n</li>\n</ul>\n<p>Possibly, if we can, it may be interesting to also:</p>\n<ul>\n<li>[ ] Find ways to fuse analyses and passes in the mid-end, possibly enabling a lightweight combination of mid-end passes that stream over CLIF once and emit new CLIF, rather than editing in place;</li>\n<li>[ ] Investigate whether we can fuse the above with the backend lowering.</li>\n</ul>\n<p>Theese last two steps are intentionally vague and bring up questions of pass direction and pass ordering; but I <em>suspect</em> that we may be able to do something to get down to a handful of passes if we are careful. In any case, finding a way to make this work would be a bonus, and the main benefit provided by the work in this issue overall is ease of development, better likelihood of correctness, and compatibility with verification efforts.</p>\n</blockquote>",
        "id": 307563634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667405908
    }
]