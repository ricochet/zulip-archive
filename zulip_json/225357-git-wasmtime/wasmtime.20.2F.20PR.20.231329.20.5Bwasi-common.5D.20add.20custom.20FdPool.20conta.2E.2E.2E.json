[
    {
        "content": "<p>kubkon edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190822048,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584436220
    },
    {
        "content": "<p>kubkon edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190822121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584436266
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376100515\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376100515\">PR Review</a>.</p>",
        "id": 190858004,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584456568
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393735228\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393735228\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think we can probably avoid a literal list-of-indices here perhaps? We could have a <code>Vec</code> of available indices, as well as a \"next index to hand out\" stored as <code>Option&lt;Fd&gt;</code>. Allocation would pop from the <code>Vec</code> or otherwise <code>.take()</code> the next index. If the next index was taken we store the result of <code>.next()</code> back in there. </p>\n<p>Later during <code>deallocate</code> we'd just push the entry onto the <code>Vec</code>.</p>\n<p>I think that may simplify a bit here and make it a bit more lightweight in terms of overhead?</p>\n</blockquote>",
        "id": 190858005,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584456568
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393730700\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393730700\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Instead of <code>.replace</code> I think this could be <code>self.stdin = Some(...)</code>, right?</p>\n</blockquote>",
        "id": 190858007,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584456568
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376100515\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376100515\">PR Review</a>.</p>",
        "id": 190858008,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584456569
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393735546\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393735546\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this file reexport from the current snapshot to avoid duplication?</p>\n</blockquote>",
        "id": 190858009,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584456569
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376128516\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376128516\">PR Review</a>.</p>",
        "id": 190861618,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584457912
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393752074\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393752074\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So basically, you suggest to skip the preallocation step, did I get it right? If so, this is what I originally had, just thought we could preallocate a couple upfront as means of optimisation but I guess that might have been somewhat premature ;-)</p>\n</blockquote>",
        "id": 190861621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584457912
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376130116\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376130116\">PR Review</a>.</p>",
        "id": 190861864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458009
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393753269\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393753269\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Right yeah I think the preallocation can largely be skipped. We can always continue to optimize it more though if necessary!</p>\n</blockquote>",
        "id": 190861865,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458010
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376130607\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376130607\">PR Review</a>.</p>",
        "id": 190861997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458044
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393753689\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393753689\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Excellent question! I thought about this myself, and in principle, I'd love if we could. The problem is with type aliasing between the two snapshots. The compiler gets confused which <code>wasi::__wasi_fd_t as Fd</code> to use. Do you think there's a way to overcome this? Would perhaps type aliasing work here?</p>\n</blockquote>",
        "id": 190861998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458044
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376131067\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376131067\">PR Review</a>.</p>",
        "id": 190862070,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458073
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393754055\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393754055\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Agreed! Let me roll it back then!</p>\n</blockquote>",
        "id": 190862072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458073
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376134018\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376134018\">PR Review</a>.</p>",
        "id": 190862604,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458265
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393756345\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393756345\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hm I'm not sure I understand the compiler error, wanna push up a branch I can poke at?</p>\n</blockquote>",
        "id": 190862606,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584458265
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190866897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584459772
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376168555\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376168555\">PR Review</a>.</p>",
        "id": 190868668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584460414
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393783727\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393783727\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Right, I now remembered what the issue was. Since <code>__wasi_fd_t</code> is a type alias to <code>u32</code> in both snapshots, we obviously cannot define two implementations of the form</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// this one is in snapshot1, in wasi.rs</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">fdpool</span>::<span class=\"n\">Fd</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">__wasi_fd_t</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// this one is in snapshot0, in old/snapshot0/wasi.rs</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"k\">crate</span>::<span class=\"n\">fdpool</span>::<span class=\"n\">Fd</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">__wasi_fd_t</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>I guess given that there is virtually no ABI difference between the two types across both snapshots, we could simply ignore implementing it in snapshot0. Would that be acceptable? I mean given that soon-ish we'd want to use <code>wiggle</code> to completely rethink how we handle multiple snapshots with as little code duplication as possible, this seems fair to me.</p>\n</blockquote>",
        "id": 190868669,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584460415
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376187388\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376187388\">PR Review</a>.</p>",
        "id": 190871902,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461610
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393798393\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393798393\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah I think that'll be alright!</p>\n</blockquote>",
        "id": 190871903,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461610
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376187901\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376187901\">PR Review</a>.</p>",
        "id": 190872028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461645
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393798820\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393798820\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This could use <code>?</code> I think if you wanted to be super nifty</p>\n</blockquote>",
        "id": 190872029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461645
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190872347,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461783
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376190633\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376190633\">PR Review</a>.</p>",
        "id": 190872444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461821
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393800952\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393800952\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Of course, well spotted, thanks!</p>\n</blockquote>",
        "id": 190872445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461821
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190872682,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584461905
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a>, and <a href=\"https://github.com/sunfishcode\" target=\"_blank\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190873117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584462075
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376210956\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376210956\">PR Review</a>.</p>",
        "id": 190876123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584463200
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376212900\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376212900\">PR Review</a>.</p>",
        "id": 190880375,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376212900\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376212900\">PR Review</a>.</p>",
        "id": 190880376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393818209\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393818209\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This can use a slice literal, <code>&amp;[ ... ]</code>, instead of a temporary <code>vec!</code>.</p>\n</blockquote>",
        "id": 190880378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393829284\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393829284\">PR Review Comment</a>:</p>\n<blockquote>\n<p>In place of the <code>claimed</code> check (which I propose removing above), this can instead <code>assert</code> that <code>fd</code> is not greater than <code>next_alloc</code>, and <code>debug_assert</code> that it's not in <code>available</code> (<code>debug_assert</code> because it could be slow in some cases).</p>\n</blockquote>",
        "id": 190880379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393818571\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393818571\">PR Review Comment</a>:</p>\n<blockquote>\n<p>As above, this can use a slice literal instead of a temporary <code>vec!</code>.</p>\n</blockquote>",
        "id": 190880380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393824177\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393824177\">PR Review Comment</a>:</p>\n<blockquote>\n<p>For tidiness, we should do the <code>entries.remove</code> before doing the <code>fds.deallocate</code>, so that we remove things in reverse order from how we add them, so that we maintain an invariant that at any time a <code>fd</code> is in <code>entries</code>, it's allocated in <code>fds</code> too.</p>\n<p>With that, we can remove the <code>claimed</code> field of <code>FdPool</code>, and assume that removal always succeeds.</p>\n</blockquote>",
        "id": 190880381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584464810
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376260158\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376260158\">PR Review</a>.</p>",
        "id": 190884994,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466669
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393854900\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393854900\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The reason I didn't use slice literal here is due to the dereferencing rules. In <code>PendingEntry::File</code> arm we use <code>OsHandle::from</code> which requires <code>std::fs::File</code>, and with slice literal we provide a ref instead.</p>\n</blockquote>",
        "id": 190884995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466669
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376260290\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376260290\">PR Review</a>.</p>",
        "id": 190885015,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466680
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393855000\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393855000\">PR Review Comment</a>:</p>\n<blockquote>\n<p>See above.</p>\n</blockquote>",
        "id": 190885016,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466680
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376262528\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376262528\">PR Review</a>.</p>",
        "id": 190885497,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466846
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393856760\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393856760\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hmm, I'm fine with asserts. However, the reason I've designed <code>deallocate</code> return <code>bool</code> was to mimic the behaviour of <code>HashSet::remove</code> which returns a <code>bool</code> to signal if removal worked or not (i.e., if any element was actually removed in the end). In this case, I guess you're right that if we try removing from the <code>claimed</code> <code>HashSet</code> and it actually fails, then something went horribly wrong as it shouldn't ever happen.</p>\n</blockquote>",
        "id": 190885498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466846
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376262672\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376262672\">PR Review</a>.</p>",
        "id": 190885524,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466855
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393856888\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393856888\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah, good call, thanks!</p>\n</blockquote>",
        "id": 190885525,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466855
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376264556\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376264556\">PR Review</a>.</p>",
        "id": 190885878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466998
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393858348\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393858348\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah, makes sense!</p>\n</blockquote>",
        "id": 190885879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584466999
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393858815\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393858815\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh, after re-reading your comment again, checking whether <code>fd</code> is not greater than <code>next_alloc</code> will require an <code>if</code> anyway since <code>next_alloc</code> is wrapped in an <code>Option</code> and it will not always be guaranteed to be <code>Some</code> (in particular, when we exceed all possible allocs for instance, e.g., <code>std::u32::MAX</code>).</p>\n</blockquote>",
        "id": 190885971,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467041
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376265128\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376265128\">PR Review</a>.</p>",
        "id": 190885972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467041
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376266161\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376266161\">PR Review</a>.</p>",
        "id": 190886161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467118
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393859582\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393859582\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Given the above, unless you can think of a cleaner way of doing it, I guess I'd be in favour of the original approach. What do you think?</p>\n</blockquote>",
        "id": 190886162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467118
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190886896,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467433
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393863454\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393863454\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done in 647cc1f. I'm still a little bit unclear how to address <code>FdPool::deallocate</code> though. Would you mind giving it another look after re-reading my comments please?</p>\n</blockquote>",
        "id": 190886984,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467491
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376271005\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376271005\">PR Review</a>.</p>",
        "id": 190886985,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467492
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393865518\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#discussion_r393865518\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Perhaps we could <code>assert!</code> on <code>self.claimed.remove</code> instead? This would ensure we <code>panic!</code> if the client code ever provides an illegal <code>fd</code> value?</p>\n</blockquote>",
        "id": 190887391,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467688
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376273604\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376273604\">PR Review</a>.</p>",
        "id": 190887392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584467688
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdPool</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdPool::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdPool::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdPool::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdPool::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdPool::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdPool</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdPool</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190904317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584475701
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, and <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190904953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584476013
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a>, and <a href=\"https://github.com/sunfishcode\" target=\"_blank\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190904957,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584476015
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376375203\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376375203\">PR Review</a>.</p>",
        "id": 190905689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584476416
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376378417\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329#pullrequestreview-376378417\">PR Review</a>.</p>",
        "id": 190906211,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584476708
    },
    {
        "content": "<p>kubkon merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190916317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584482331
    }
]