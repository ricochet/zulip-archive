[
    {
        "content": "<p>peterhuene opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case,<br>\n  ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>repro.clif</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>set opt_level=speed_and_size\nset is_pic\ntarget x86_64 haswell\n\nfunction %foo() windows_fastcall {\n    fn0 = %bar(i64)\n    ss0 = explicit_slot 8\nblock0:\n    v1 = stack_addr.i64 ss0\n    call fn0(v1)\n    return\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>$ clif-util compile -D repro.clif\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>Actual output:</p>\n<div class=\"codehilite\"><pre><span></span><code>.byte 85, 72, 137, 229, 87, 72, 131, 236, 40, 72, 141, 132, 36, 0, 0, 0, 0, 72, 137, 199, 232, 0, 0, 0, 0, 72, 131, 196, 40, 95, 93, 195\n\nDisassembly of 32 bytes:\n   0:   55                      push    rbp\n   1:   48 89 e5                mov     rbp, rsp\n   4:   57                      push    rdi\n   5:   48 83 ec 28             sub     rsp, 0x28\n   9:   48 8d 84 24 00 00 00 00 lea     rax, [rsp]\n  11:   48 89 c7                mov     rdi, rax\n  14:   e8 00 00 00 00          call    0x19\n  19:   48 83 c4 28             add     rsp, 0x28\n  1d:   5f                      pop     rdi\n  1e:   5d                      pop     rbp\n  1f:   c3                      ret\n</code></pre></div>\n\n\n<p>Note the instruction at <strong>offset 9</strong> that is loading the address of the explicit stack slot: <code>lea rax, [rsp]</code>.  The address loaded is actually <em>inside</em> the callee's 32 bytes of shadow space. </p>\n<p>I expect this instruction to actually account for the calling convention's shadow space: <code>lea rax, [rsp+0x20]</code>.</p>\n<p>Because of how we're currently saving callee-saved FPRs, we're actually saving the FPRs into this area of the stack as well, meaning that the callee might trash the caller's saved FPRs as they're allowed to use this space freely.</p>\n<p>Because Cranelift itself doesn't make use of the caller-provided shadow space, this won't happen for Cranelift-to-Cranelift calls; however, calling into external functions will certainly make use of the shadow space.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p>26e06297957bbc06b3244bc96d2e92b4246e8d9b</p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>Rust: 1.43.1<br>\nOperating system: Arch Linux<br>\nArch: x86-64</p>\n</blockquote>",
        "id": 198135040,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927315
    },
    {
        "content": "<p>peterhuene labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case,<br>\n  ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>repro.clif</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>set opt_level=speed_and_size\nset is_pic\ntarget x86_64 haswell\n\nfunction %foo() windows_fastcall {\n    fn0 = %bar(i64)\n    ss0 = explicit_slot 8\nblock0:\n    v1 = stack_addr.i64 ss0\n    call fn0(v1)\n    return\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>$ clif-util compile -D repro.clif\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>Actual output:</p>\n<div class=\"codehilite\"><pre><span></span><code>.byte 85, 72, 137, 229, 87, 72, 131, 236, 40, 72, 141, 132, 36, 0, 0, 0, 0, 72, 137, 199, 232, 0, 0, 0, 0, 72, 131, 196, 40, 95, 93, 195\n\nDisassembly of 32 bytes:\n   0:   55                      push    rbp\n   1:   48 89 e5                mov     rbp, rsp\n   4:   57                      push    rdi\n   5:   48 83 ec 28             sub     rsp, 0x28\n   9:   48 8d 84 24 00 00 00 00 lea     rax, [rsp]\n  11:   48 89 c7                mov     rdi, rax\n  14:   e8 00 00 00 00          call    0x19\n  19:   48 83 c4 28             add     rsp, 0x28\n  1d:   5f                      pop     rdi\n  1e:   5d                      pop     rbp\n  1f:   c3                      ret\n</code></pre></div>\n\n\n<p>Note the instruction at <strong>offset 9</strong> that is loading the address of the explicit stack slot: <code>lea rax, [rsp]</code>.  The address loaded is actually <em>inside</em> the callee's 32 bytes of shadow space. </p>\n<p>I expect this instruction to actually account for the calling convention's shadow space: <code>lea rax, [rsp+0x20]</code>.</p>\n<p>Because of how we're currently saving callee-saved FPRs, we're actually saving the FPRs into this area of the stack as well, meaning that the callee might trash the caller's saved FPRs as they're allowed to use this space freely.</p>\n<p>Because Cranelift itself doesn't make use of the caller-provided shadow space, this won't happen for Cranelift-to-Cranelift calls; however, calling into external functions will certainly make use of the shadow space.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p>26e06297957bbc06b3244bc96d2e92b4246e8d9b</p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>Rust: 1.43.1<br>\nOperating system: Arch Linux<br>\nArch: x86-64</p>\n</blockquote>",
        "id": 198135041,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927315
    },
    {
        "content": "<p>peterhuene labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case,<br>\n  ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>repro.clif</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>set opt_level=speed_and_size\nset is_pic\ntarget x86_64 haswell\n\nfunction %foo() windows_fastcall {\n    fn0 = %bar(i64)\n    ss0 = explicit_slot 8\nblock0:\n    v1 = stack_addr.i64 ss0\n    call fn0(v1)\n    return\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>$ clif-util compile -D repro.clif\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>Actual output:</p>\n<div class=\"codehilite\"><pre><span></span><code>.byte 85, 72, 137, 229, 87, 72, 131, 236, 40, 72, 141, 132, 36, 0, 0, 0, 0, 72, 137, 199, 232, 0, 0, 0, 0, 72, 131, 196, 40, 95, 93, 195\n\nDisassembly of 32 bytes:\n   0:   55                      push    rbp\n   1:   48 89 e5                mov     rbp, rsp\n   4:   57                      push    rdi\n   5:   48 83 ec 28             sub     rsp, 0x28\n   9:   48 8d 84 24 00 00 00 00 lea     rax, [rsp]\n  11:   48 89 c7                mov     rdi, rax\n  14:   e8 00 00 00 00          call    0x19\n  19:   48 83 c4 28             add     rsp, 0x28\n  1d:   5f                      pop     rdi\n  1e:   5d                      pop     rbp\n  1f:   c3                      ret\n</code></pre></div>\n\n\n<p>Note the instruction at <strong>offset 9</strong> that is loading the address of the explicit stack slot: <code>lea rax, [rsp]</code>.  The address loaded is actually <em>inside</em> the callee's 32 bytes of shadow space. </p>\n<p>I expect this instruction to actually account for the calling convention's shadow space: <code>lea rax, [rsp+0x20]</code>.</p>\n<p>Because of how we're currently saving callee-saved FPRs, we're actually saving the FPRs into this area of the stack as well, meaning that the callee might trash the caller's saved FPRs as they're allowed to use this space freely.</p>\n<p>Because Cranelift itself doesn't make use of the caller-provided shadow space, this won't happen for Cranelift-to-Cranelift calls; however, calling into external functions will certainly make use of the shadow space.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p>26e06297957bbc06b3244bc96d2e92b4246e8d9b</p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>Rust: 1.43.1<br>\nOperating system: Arch Linux<br>\nArch: x86-64</p>\n</blockquote>",
        "id": 198135042,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927315
    },
    {
        "content": "<p>peterhuene assigned <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case,<br>\n  ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>repro.clif</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>set opt_level=speed_and_size\nset is_pic\ntarget x86_64 haswell\n\nfunction %foo() windows_fastcall {\n    fn0 = %bar(i64)\n    ss0 = explicit_slot 8\nblock0:\n    v1 = stack_addr.i64 ss0\n    call fn0(v1)\n    return\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>$ clif-util compile -D repro.clif\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>Actual output:</p>\n<div class=\"codehilite\"><pre><span></span><code>.byte 85, 72, 137, 229, 87, 72, 131, 236, 40, 72, 141, 132, 36, 0, 0, 0, 0, 72, 137, 199, 232, 0, 0, 0, 0, 72, 131, 196, 40, 95, 93, 195\n\nDisassembly of 32 bytes:\n   0:   55                      push    rbp\n   1:   48 89 e5                mov     rbp, rsp\n   4:   57                      push    rdi\n   5:   48 83 ec 28             sub     rsp, 0x28\n   9:   48 8d 84 24 00 00 00 00 lea     rax, [rsp]\n  11:   48 89 c7                mov     rdi, rax\n  14:   e8 00 00 00 00          call    0x19\n  19:   48 83 c4 28             add     rsp, 0x28\n  1d:   5f                      pop     rdi\n  1e:   5d                      pop     rbp\n  1f:   c3                      ret\n</code></pre></div>\n\n\n<p>Note the instruction at <strong>offset 9</strong> that is loading the address of the explicit stack slot: <code>lea rax, [rsp]</code>.  The address loaded is actually <em>inside</em> the callee's 32 bytes of shadow space. </p>\n<p>I expect this instruction to actually account for the calling convention's shadow space: <code>lea rax, [rsp+0x20]</code>.</p>\n<p>Because of how we're currently saving callee-saved FPRs, we're actually saving the FPRs into this area of the stack as well, meaning that the callee might trash the caller's saved FPRs as they're allowed to use this space freely.</p>\n<p>Because Cranelift itself doesn't make use of the caller-provided shadow space, this won't happen for Cranelift-to-Cranelift calls; however, calling into external functions will certainly make use of the shadow space.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p>26e06297957bbc06b3244bc96d2e92b4246e8d9b</p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>Rust: 1.43.1<br>\nOperating system: Arch Linux<br>\nArch: x86-64</p>\n</blockquote>",
        "id": 198135044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927318
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728#issuecomment-631117595\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 198135055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927326
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728#issuecomment-631121380\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a>:</p>\n<blockquote>\n<p>Note that I'm currently in the process of fixing where we store callee saved FPRs as they should not be stored as explicit slots.</p>\n</blockquote>",
        "id": 198135557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589927669
    },
    {
        "content": "<p>peterhuene closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1728\">Issue #1728</a> (assigned to peterhuene):</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue? Can you include a CLIF test case,<br>\n  ideally reduced with the <code>bugpoint</code> clif-util command?</li>\n</ul>\n<p><code>repro.clif</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>set opt_level=speed_and_size\nset is_pic\ntarget x86_64 haswell\n\nfunction %foo() windows_fastcall {\n    fn0 = %bar(i64)\n    ss0 = explicit_slot 8\nblock0:\n    v1 = stack_addr.i64 ss0\n    call fn0(v1)\n    return\n}\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>$ clif-util compile -D repro.clif\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>Actual output:</p>\n<div class=\"codehilite\"><pre><span></span><code>.byte 85, 72, 137, 229, 87, 72, 131, 236, 40, 72, 141, 132, 36, 0, 0, 0, 0, 72, 137, 199, 232, 0, 0, 0, 0, 72, 131, 196, 40, 95, 93, 195\n\nDisassembly of 32 bytes:\n   0:   55                      push    rbp\n   1:   48 89 e5                mov     rbp, rsp\n   4:   57                      push    rdi\n   5:   48 83 ec 28             sub     rsp, 0x28\n   9:   48 8d 84 24 00 00 00 00 lea     rax, [rsp]\n  11:   48 89 c7                mov     rdi, rax\n  14:   e8 00 00 00 00          call    0x19\n  19:   48 83 c4 28             add     rsp, 0x28\n  1d:   5f                      pop     rdi\n  1e:   5d                      pop     rbp\n  1f:   c3                      ret\n</code></pre></div>\n\n\n<p>Note the instruction at <strong>offset 9</strong> that is loading the address of the explicit stack slot: <code>lea rax, [rsp]</code>.  The address loaded is actually <em>inside</em> the callee's 32 bytes of shadow space. </p>\n<p>I expect this instruction to actually account for the calling convention's shadow space: <code>lea rax, [rsp+0x20]</code>.</p>\n<p>Because of how we're currently saving callee-saved FPRs, we're actually saving the FPRs into this area of the stack as well, meaning that the callee might trash the caller's saved FPRs as they're allowed to use this space freely.</p>\n<p>Because Cranelift itself doesn't make use of the caller-provided shadow space, this won't happen for Cranelift-to-Cranelift calls; however, calling into external functions will certainly make use of the shadow space.</p>\n<ul>\n<li>Which Cranelift version / commit hash / branch are you using?</li>\n</ul>\n<p>26e06297957bbc06b3244bc96d2e92b4246e8d9b</p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>Rust: 1.43.1<br>\nOperating system: Arch Linux<br>\nArch: x86-64</p>\n</blockquote>",
        "id": 198482113,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590174399
    }
]