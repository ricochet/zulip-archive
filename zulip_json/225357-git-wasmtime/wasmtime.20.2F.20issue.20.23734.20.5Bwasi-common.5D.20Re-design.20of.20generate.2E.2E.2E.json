[
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/734#issuecomment-862517300\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/734\">issue #734</a>:</p>\n<blockquote>\n<p>wiggle exists now! its neat to go back and remember the bad old days</p>\n</blockquote>",
        "id": 242904429,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623860245
    },
    {
        "content": "<p>pchickey closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/734\">issue #734</a>:</p>\n<blockquote>\n<p><code>wig</code> presently generates <code>wasi-common</code> types from <code>witx</code> descriptions of the standard. This is a great start, but there are a handful of ways in which the design of <code>wasi-common</code> is difficult to automatically generate more code for. I want to generate as much of the boilerplate for each hostcall as I can, but before we get there, we need to sort out some difficulties with datatypes.</p>\n<p>This proposal seeks to redesign we manage 1. validating and chasing pointers into guest memory, ensuring that all references into guest memory are safe, and 2. validating enum and flag values.</p>\n<p>We currently depend on some hand-written <code>enc_</code>/<code>dec_</code> functions to serialize and deserialize some types to and from guest memory. I want to replace those with automatically generated implementations without losing any of the zero-copy optimizations we currently have.</p>\n<h1>Generated Types</h1>\n<p>There are two purposes for generated types:</p>\n<ul>\n<li>\n<p>Using a value that resides in guest memory. This includes reading a value<br>\n  from the guest memory (via a pointer), or writing a value into guest memory.<br>\n  These should only be used in the host calls, and not by any business logic,<br>\n  except for logic that determines if a value has a valid encoding (memory<br>\n  out-of-bounds, memory alignment, or value out-of-range).</p>\n<ul>\n<li>\n<p><code>struct GuestMemory&lt;'a&gt;</code> encapsulates a Linear Memory and ensures all<br>\n  borrows of that memory are safe Rust - there can be multiple immutable borrows of the same memory, but at most one mutable borrow. Constructed from a <code>*mut u8</code> pointer<br>\n  to the start of linear memory, and <code>usize</code> length. The base pointer for linear <br>\n  memory be pointer-aligned to simplify alignment checks for pointers to structs<br>\n  in this memory, but this can be relaxed in the future. Lifetime parameter<br>\n  ensures that use of memory doesn't survive longer than the host call.</p>\n<p>* The biggest problem that <code>GuestMemory</code> needs to solve is to track<br>\n    all of the mutable and immutable borrows at run-time to make sure they<br>\n    do not cause UB. It will keep a map of the immutable and mutable<br>\n    borrows, and use the drop impls on <code>GuestPtr</code> and friends to remove<br>\n    those borrows from the map.</p>\n</li>\n<li>\n<p><code>MemoryError</code> describes an out-of-bounds memory access or misaligned pointer.</p>\n</li>\n<li>\n<p><code>struct GuestPtr&lt;'a, T&gt;</code> is a pointer to a read-only T in guest memory.<br>\n  Constructed from <code>GuestMemory&lt;'a&gt;::ptr(&amp;self, ptr: i32) -&gt;\n  Result&lt;GuestPtr&lt;'a, T&gt;, MemoryError&gt;</code></p>\n</li>\n<li>\n<p><code>struct GuestPtrMut&lt;'a, T&gt;</code> is a pointer to a writable T in guest memory.<br>\n  Constructed from <code>GuestMemory&lt;'a&gt;::ptr_mut(&amp;self, ptr: i32) -&gt;\n  Result&lt;GuestPtrMut&lt;'a, T&gt;, MemoryError&gt;</code></p>\n</li>\n<li>\n<p><code>struct GuestArray&lt;'a, T&gt;</code> is an array of read-only T in guest memory.<br>\n  Constructed from <code>GuestMemory&lt;'a&gt;::array(&amp;self, ptr: i32, len: i32) -&gt;\n  Result&lt;GuestArray&lt;'a, T&gt;, MemoryError&gt;</code></p>\n</li>\n<li>\n<p>All <code>T</code> above have a <code>GuestValue</code> trait constraint. This trait describes<br>\n  the memory layout of the value.</p>\n</li>\n<li>\n<p>Construction of the above are only possible if they point to a valid guest<br>\n  memory location.</p>\n</li>\n<li>\n<p>GuestPtr and GuestPtrMut each have a <code>fn offset(&amp;self, elems: i32) -&gt;\n  Result&lt;GuestPtr{Mut}&lt;'a, T&gt;, MemoryError&gt;</code> for accessing subsequent<br>\n  elements. This allows them to be used like an array, in types like <code>iovec</code><br>\n  and <code>ciovec</code>.</p>\n</li>\n<li>\n<p><code>ReprError</code> describes an invalid representation of a type in guest memory.</p>\n</li>\n<li>\n<p><code>impl GuestPtr&lt;'a, T&gt; { pub fn read(&amp;self) -&gt; Result&lt;T, ReprError&gt; }</code><br>\n  dereferences a pointer. As part of dereferencing, it validates the pointee</p>\n<ul>\n<li>that will check if enum and flag values are in bounds, and recursively<br>\nfor each member of a struct. It won't do any validation on a union - you<br>\n  have to pick a variant in order to validate it.</li>\n</ul>\n</li>\n<li>\n<p><code>impl GuestPtrMut&lt;'a, T&gt; { pub fn write(&amp;self, T) }</code> writes a <code>T: GuestValue</code><br>\n   into the memory it references.</p>\n</li>\n<li>\n<p>The <code>T: GuestValue</code> for a witx enum should be the host <code>enum $Typename</code>. The<br>\n<code>GuestValue</code> impl will be used to validate and decode memory into this<br>\n  owned type. This decoding can be done inside <code>GuestPtr::read</code>, or on a bare<br>\n  integer of the enum's repr size.</p>\n</li>\n<li>\n<p>The <code>T: GuestValue</code> for a witx flags should be the host <code>struct $Typename</code>.<br>\n  As above, <code>GuestValue</code> does the validation into an owned type.</p>\n</li>\n<li>\n<p>The <code>T: GuestValue</code> for a witx struct has layout defined by witx. The generated<br>\n  struct depends on whether the struct recursively contains any unions, pointers,<br>\n  or arrays:</p>\n<ul>\n<li>\n<p>If it does contain a guest memory reference - lets call these <code>complex\n   GuestValues</code> until I think of a better name, it is a <code>mod guest { struct\n   $Typename }</code>. Rather than have public members, the struct has methods<br>\n   corresponding to each field, with a constructor function to create complex GuestValues.</p>\n<p>* All fields have a<br>\n<code>fn $fieldname_{ref,mut}(&amp;self) -&gt; Result&lt;GuestPtr{Mut}&lt;T&gt;, MemoryError&gt;</code><br>\n    accessor to take references of fields</p>\n<p>* Fields containing flat values are <code>fn $fieldname(&amp;self) -&gt; Result&lt;T, ReprError&gt;</code><br>\n  * Fields which are a (mut) pointer are <code>fn $fieldname(&amp;self) -&gt;\n    Result&lt;GuestPtr{Mut}&lt;â€™a, T&gt;, MemoryError&gt;</code>. Same for arrays.</p>\n<p>* Fields which are a union are <code>fn $fieldname(&amp;self) -&gt; T</code></p>\n</li>\n<li>\n<p>If it does not - lets call these <code>flat GuestValues</code> - then additionally derive <code>ToOwned</code><br>\n    to be used without ceremony by the host</p>\n</li>\n</ul>\n</li>\n<li>\n<p>The <code>T: GuestValue</code> for a witx union is an opaque struct with a method<br>\n  for each variant: <code>fn $variantname(&amp;self) -&gt; Result&lt;T, ReprError&gt;</code></p>\n</li>\n</ul>\n</li>\n<li>\n<p>Using a value in the Rust implementation of wasi-common. This should be an<br>\n  idiomatic, wholly owned Rust value. It should look like a Rust type: use modules<br>\n  for namespacing instead of repeated prefixes, use <code>CamelCase</code> not<br>\n<code>__SHOUTING_SNAKE_CASE</code>.</p>\n<ul>\n<li>A witx struct should be a rust struct</li>\n<li>A witx union should be a rust enum</li>\n<li>A witx enum should be a rust enum</li>\n<li>\n<p>A witx flags should be a rust <code>struct $Typename { val: repr_type }</code>, and a<br>\n  rust <code>enum $TypenameFlag { flag_variants... }</code>, and Typename should have<br>\n  setter and getter methods in terms of $TypenameFlag.</p>\n</li>\n<li>\n<p>A witx array should be a rust Vec</p>\n</li>\n<li>A witx (const,) pointer should be a <code>Box&lt;T&gt;</code> where <code>T</code> is the owned rust value.</li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 242904432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623860245
    },
    {
        "content": "<p>pchickey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/734#issuecomment-862517300\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/734\">issue #734</a>:</p>\n<blockquote>\n<p>wiggle has been done for a while now! its neat to go back and remember the bad old days</p>\n</blockquote>",
        "id": 242904452,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1623860261
    }
]