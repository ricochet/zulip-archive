[
    {
        "content": "<p>uweigand opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, I had to support vector registers that are defined as partially callee-saved by ABI.  This is the same situation that already exists on AArch64, and I used the same method: removing Call instructions from consideration when computing function-wide clobbers via the <code>is_included_in_clobbers</code> callback.</p>\n<p>This works in general, but there is one unexpected issue.  On s390x, calls work by loading the return address into a \"link register\", which the callee will use to return back to the caller.  This means of course that the call instruction clobbers that link register - so if the caller later has to return to <em>its</em> caller, it will need the original value of the link register at function entry, and therefore has to save/restore it.</p>\n<p>This used to work fine since the link register is marked as \"defined\" by the call instruction.  However, once call instructions are ignored via <code>is_included_in_clobbers</code>, that definition of the link register is <em>also</em> ignored.  I would have expected that only the <em>clobbers</em> of the call instruction would be ignored - but the current implementation ignores the instruction completely.</p>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine.  But this seems a bit awkward.  Any thoughts?</p>\n<p>FYI @cfallin </p>\n</blockquote>",
        "id": 289053518,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657388365
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425#issuecomment-1180370938\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<blockquote>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine. But this seems a bit awkward. Any thoughts?</p>\n</blockquote>\n<p>The 64-bit Arm architecture works in pretty much the same way with respect to the link register, and that is the solution that has been chosen.</p>\n</blockquote>",
        "id": 289184977,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657543835
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, I had to support vector registers that are defined as partially callee-saved by ABI.  This is the same situation that already exists on AArch64, and I used the same method: removing Call instructions from consideration when computing function-wide clobbers via the <code>is_included_in_clobbers</code> callback.</p>\n<p>This works in general, but there is one unexpected issue.  On s390x, calls work by loading the return address into a \"link register\", which the callee will use to return back to the caller.  This means of course that the call instruction clobbers that link register - so if the caller later has to return to <em>its</em> caller, it will need the original value of the link register at function entry, and therefore has to save/restore it.</p>\n<p>This used to work fine since the link register is marked as \"defined\" by the call instruction.  However, once call instructions are ignored via <code>is_included_in_clobbers</code>, that definition of the link register is <em>also</em> ignored.  I would have expected that only the <em>clobbers</em> of the call instruction would be ignored - but the current implementation ignores the instruction completely.</p>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine.  But this seems a bit awkward.  Any thoughts?</p>\n<p>FYI @cfallin </p>\n</blockquote>",
        "id": 289216096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657556714
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, I had to support vector registers that are defined as partially callee-saved by ABI.  This is the same situation that already exists on AArch64, and I used the same method: removing Call instructions from consideration when computing function-wide clobbers via the <code>is_included_in_clobbers</code> callback.</p>\n<p>This works in general, but there is one unexpected issue.  On s390x, calls work by loading the return address into a \"link register\", which the callee will use to return back to the caller.  This means of course that the call instruction clobbers that link register - so if the caller later has to return to <em>its</em> caller, it will need the original value of the link register at function entry, and therefore has to save/restore it.</p>\n<p>This used to work fine since the link register is marked as \"defined\" by the call instruction.  However, once call instructions are ignored via <code>is_included_in_clobbers</code>, that definition of the link register is <em>also</em> ignored.  I would have expected that only the <em>clobbers</em> of the call instruction would be ignored - but the current implementation ignores the instruction completely.</p>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine.  But this seems a bit awkward.  Any thoughts?</p>\n<p>FYI @cfallin </p>\n</blockquote>",
        "id": 289216097,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657556714
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, I had to support vector registers that are defined as partially callee-saved by ABI.  This is the same situation that already exists on AArch64, and I used the same method: removing Call instructions from consideration when computing function-wide clobbers via the <code>is_included_in_clobbers</code> callback.</p>\n<p>This works in general, but there is one unexpected issue.  On s390x, calls work by loading the return address into a \"link register\", which the callee will use to return back to the caller.  This means of course that the call instruction clobbers that link register - so if the caller later has to return to <em>its</em> caller, it will need the original value of the link register at function entry, and therefore has to save/restore it.</p>\n<p>This used to work fine since the link register is marked as \"defined\" by the call instruction.  However, once call instructions are ignored via <code>is_included_in_clobbers</code>, that definition of the link register is <em>also</em> ignored.  I would have expected that only the <em>clobbers</em> of the call instruction would be ignored - but the current implementation ignores the instruction completely.</p>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine.  But this seems a bit awkward.  Any thoughts?</p>\n<p>FYI @cfallin </p>\n</blockquote>",
        "id": 289216098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657556714
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425#issuecomment-1191766089\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>OK, given we need to special-case the link register anyway to support preserve_frame_pointers (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/4477\">https://github.com/bytecodealliance/wasmtime/pull/4477</a>), I think this is fine after all.  Closing this issue now.</p>\n</blockquote>",
        "id": 290409444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658425469
    },
    {
        "content": "<p>uweigand closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4425\">issue #4425</a>:</p>\n<blockquote>\n<p>In implementing SIMD support for s390x, I had to support vector registers that are defined as partially callee-saved by ABI.  This is the same situation that already exists on AArch64, and I used the same method: removing Call instructions from consideration when computing function-wide clobbers via the <code>is_included_in_clobbers</code> callback.</p>\n<p>This works in general, but there is one unexpected issue.  On s390x, calls work by loading the return address into a \"link register\", which the callee will use to return back to the caller.  This means of course that the call instruction clobbers that link register - so if the caller later has to return to <em>its</em> caller, it will need the original value of the link register at function entry, and therefore has to save/restore it.</p>\n<p>This used to work fine since the link register is marked as \"defined\" by the call instruction.  However, once call instructions are ignored via <code>is_included_in_clobbers</code>, that definition of the link register is <em>also</em> ignored.  I would have expected that only the <em>clobbers</em> of the call instruction would be ignored - but the current implementation ignores the instruction completely.</p>\n<p>Now, I can work around this by implicitly considering the link register clobbered in any non-leaf routine.  But this seems a bit awkward.  Any thoughts?</p>\n<p>FYI @cfallin </p>\n</blockquote>",
        "id": 290409445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658425469
    }
]