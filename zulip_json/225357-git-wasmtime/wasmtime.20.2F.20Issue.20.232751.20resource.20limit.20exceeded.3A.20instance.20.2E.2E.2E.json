[
    {
        "content": "<p>bxq2011hust opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>I use one module to wasm_instance_new(C-API) instance to execute the function to save the cost of wasm_module_new, at start it works well, After some time running, I can't use wasm_instance_new to create new instance and got the error message <code>resource limit exceeded: instance count too high at 10001</code>. But I freed the instance use wasm_instance_delete every time execution is done, also free the exports. Is there some way to use one module to create instances more than 10000 times?<br>\n</p>\n</blockquote>",
        "id": 231325608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616425633
    },
    {
        "content": "<p>bxq2011hust edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>I use one module to wasm_instance_new(C-API) instance to execute the function to save the cost of wasm_module_new, at start it works well, After some time running, I can't use wasm_instance_new to create new instance and got the error message <code>resource limit exceeded: instance count too high at 10001</code>. <br>\nI freed the instance use wasm_instance_delete every time execution is done, also free the exports, I think the count of instance should decrease to zero after execution, It seems the count of instance is cumulative. Is there some way to use one module to create instances more than 10000 times?<br>\n</p>\n</blockquote>",
        "id": 231326079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616425788
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804157019\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>You can use <code>wasmtime_config_max_instances_set</code> which gets a <code>wasm_config_t*</code> and <code>size_t</code> as argument.</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L292\">https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L292</a></p>\n</blockquote>",
        "id": 231330939,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616427261
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804157019\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>You can use <code>wasmtime_config_max_instances_set</code> which gets a <code>wasm_config_t*</code> and <code>size_t</code> as argument.</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L286-L292\">https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L286-L292</a></p>\n</blockquote>",
        "id": 231331001,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616427277
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804268297\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>It's important to note that <code>wasm_instance_delete</code> does not actually delete the underlying instance's resources, just the C object representing the instance. I don't think we have a ton of documentation for this but an instance's resources are only deallocated when the entire <code>Store</code> (or <code>wasm_store_t</code>) goes away. This means that for a long-lived use case you likely want a singular <code>wasm_engine_t</code> and the <code>wasm_store_t</code> should be ephemeral and not as long-lived.</p>\n<p>Otherwise though, if you'd like to do this, 10000 is just the default and as mentioned you can up the limit yourself.</p>\n</blockquote>",
        "id": 231354953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616435441
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804518368\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@bjorn3  thank you very much, I read the <code>WASMTIME_CONFIG_PROP(void, max_instances, size_t) </code>, this can allow me to create more instance use one module. <br>\nAlso, I found <code>wasmtime_store_gc</code> in wasmtime.h, I wonder if I can use <code>wasmtime_store_gc</code> to decrease the store's count of the instance before it reaches the max_instances  so that I can use one module to create instances always?<br>\n</p>\n</blockquote>",
        "id": 231410494,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616463437
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804524886\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton ok, I see. Is <code>wasmtime_store_gc</code> can release the instance's resource?<span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>️</p>\n<p>If the <code>wasmtime_store_gc</code> can't release the instance's resource then I will consider recreating the <code>wasm_engine_t</code> and the <code>wasm_store_t</code> before it reaches 10000.</p>\n</blockquote>",
        "id": 231411754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616464634
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804524886\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton ok, I see, thanks. Is <code>wasmtime_store_gc</code> can release the instance's resource?<span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>️</p>\n<p>If the <code>wasmtime_store_gc</code> can't release the instance's resource then I will consider recreating the <code>wasm_engine_t</code> and the <code>wasm_store_t</code> before it reaches 10000.</p>\n</blockquote>",
        "id": 231411894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616464802
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804530087\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@bxq2011hust <code>wasmtime_store_gc</code> is used to perform a garbage collection of <code>externref</code> values that may no longer be reachable; it has no relationship to instances and only has relevance if you're passing <code>externref</code> values into WebAssembly code.</p>\n<p>In Wasmtime, a module has no relation to a store, so you can also use <code>wasmtime_module_new</code> which better encapsulates this (the store passed to <code>wasm_module_new</code> is only used to get the related engine).  </p>\n<p>As module and engine have no relation to store, you may continue to use them after any calls to <code>wasm_store_delete</code>; thus you may create a new store each time you wish to instantiate your module.</p>\n</blockquote>",
        "id": 231412773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616465601
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804530087\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@bxq2011hust <code>wasmtime_store_gc</code> is used to perform a garbage collection of <code>externref</code> values that may no longer be reachable; it has no relationship to instances and only has relevance if you're passing <code>externref</code> values into WebAssembly code.</p>\n<p>In Wasmtime, a module has no relation to a store, so you can also use <code>wasmtime_module_new</code> which better encapsulates this (the store passed to <code>wasm_module_new</code> is only used to get the related engine).  </p>\n<p>As module and engine have no relation to store, you may continue to use them after any calls to <code>wasm_store_delete</code>; thus you may create a new store each time you wish to instantiate your module.  This should help prevent you reaching any sort of limits by reusing a store for multiple instantiations.</p>\n</blockquote>",
        "id": 231412833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616465647
    },
    {
        "content": "<p>peterhuene edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804530087\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@bxq2011hust <code>wasmtime_store_gc</code> is used to perform a garbage collection of <code>externref</code> values that may no longer be reachable; it has no relationship to instances and only has relevance if you're passing <code>externref</code> values into WebAssembly code.</p>\n<p>In Wasmtime, a module has no relation to a store, so you can also use <code>wasmtime_module_new</code> which better encapsulates this (the store passed to <code>wasm_module_new</code> is only used to get the related engine).  </p>\n<p>As module and engine have no relation to store, you may continue to use them after any calls to <code>wasm_store_delete</code>; thus you may create a new store each time you wish to instantiate your module.  This should help prevent you from reaching any sort of limits by not reusing a store for multiple instantiations.</p>\n</blockquote>",
        "id": 231412864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616465679
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804610376\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  yes, that's what I want. I tried your idea and it worked, thanks!!!<span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span><span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>\n</blockquote>",
        "id": 231421013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616474161
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804615068\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@bxq2011hust may I close this issue if your problem has been resolved?</p>\n</blockquote>",
        "id": 231422006,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616475115
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.<br>\nIt seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of function and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 231422262,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616475395
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of function and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n</blockquote>",
        "id": 231422265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616475412
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of functions and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n</blockquote>",
        "id": 231422294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616475438
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of functions and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n<p>Although according to the document, this is not allowed. <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>\n</blockquote>",
        "id": 231422378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616475535
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of functions and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n<p>Although according to the document, this is not allowed. <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span><br>\nok, I tried use one instance in multi-thread, failed. I need to try to cache some instances to improve performance.</p>\n<p>Thank you very much for your reply! wasmtime is great!</p>\n</blockquote>",
        "id": 231440123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616490603
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of functions and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n<p>Although according to the document, this is not allowed. <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span><br>\nok, I tried use one instance in multi-thread, failed. Maybe I should try to cache some instances to improve performance.</p>\n<p>Thank you very much for your reply! wasmtime is great!</p>\n</blockquote>",
        "id": 231440177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616490631
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-804616707\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@peterhuene  Last question. In the <a href=\"https://github.com/WebAssembly/wasm-c-api\">https://github.com/WebAssembly/wasm-c-api</a>, it said</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>All runtime objects are tied to a specific store (wasm::Store/wasm_store_t). Multiple stores can be created, but their objects cannot interact. Every store and its objects must only be accessed in a single thread.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>It seems in one thread I need a new instance, and I surely do that now. I want to save the time cost of creating imports of functions and the time of creating new instances by use one instance in multi-thread. I want to know if I call <code>wasm_func_call</code> with the same instance in multi-threads is it ok of the wasmtime engine? </p>\n<p>Although according to the document, this is not allowed. <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span><br>\nok, I tried using one instance in multi-thread, failed. Maybe I should try to cache some instances to improve performance.</p>\n<p>Thank you very much for your reply! wasmtime is great!</p>\n</blockquote>",
        "id": 231440201,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616490644
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805002028\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>It is not safe to <code>wasm_func_call</code> the same function on multiple threads, all objects connected to <code>wasm_store_t</code> (which includes <code>wasm_func_t</code>) must be used on only one thread at a time.</p>\n<p>The Rust <code>wasmtime</code> crate has the ability to define functions in the <code>Engine</code>-scope to share them across stores  -- <a href=\"https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func\">https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func</a> -- but this is not currently exposed in the C API.</p>\n</blockquote>",
        "id": 231490619,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616513612
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805423828\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<blockquote>\n<p>It is not safe to <code>wasm_func_call</code> the same function on multiple threads, all objects connected to <code>wasm_store_t</code> (which includes <code>wasm_func_t</code>) must be used on only one thread at a time.</p>\n<p>The Rust <code>wasmtime</code> crate has the ability to define functions in the <code>Engine</code>-scope to share them across stores -- <a href=\"https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func\">https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func</a> -- but this is not currently exposed in the C API.</p>\n</blockquote>\n<p>Ok, get it, thanks<span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span> .  A little suggestion, if the cache config has an API to config it may be  more convenient, like</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"n\">WASMTIME_CONFIG_PROP</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">,</span> <span class=\"n\">enable_cache</span><span class=\"p\">,</span> <span class=\"n\">wasm_config_t</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"p\">,</span> <span class=\"kt\">size_t</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span><span class=\"p\">);</span>\n<span class=\"n\">WASMTIME_CONFIG_PROP</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">,</span> <span class=\"n\">disable_cache</span><span class=\"p\">,</span> <span class=\"n\">wasm_config_t</span><span class=\"o\">*</span><span class=\"p\">);</span>\n</code></pre></div>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L306\">https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L306</a></p>\n<p>I use wasmtime as a library to offer wasm runtime in my library, it's not convenient for my library to create a toml file to use cache.</p>\n<p>Again, thanks you guys for your help.</p>\n</blockquote>",
        "id": 231572575,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616552151
    },
    {
        "content": "<p>bxq2011hust closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>I use one module to wasm_instance_new(C-API) instance to execute the function to save the cost of wasm_module_new, at start it works well, After some time running, I can't use wasm_instance_new to create new instance and got the error message <code>resource limit exceeded: instance count too high at 10001</code>. <br>\nI freed the instance use wasm_instance_delete every time execution is done, also free the exports, I think the count of instance should decrease to zero after execution, It seems the count of instance is cumulative. Is there some way to use one module to create instances more than 10000 times?<br>\n</p>\n</blockquote>",
        "id": 231572576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616552151
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805423828\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<blockquote>\n<p>It is not safe to <code>wasm_func_call</code> the same function on multiple threads, all objects connected to <code>wasm_store_t</code> (which includes <code>wasm_func_t</code>) must be used on only one thread at a time.</p>\n<p>The Rust <code>wasmtime</code> crate has the ability to define functions in the <code>Engine</code>-scope to share them across stores -- <a href=\"https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func\">https://docs.rs/wasmtime/0.25.0/wasmtime/struct.Config.html#method.define_host_func</a> -- but this is not currently exposed in the C API.</p>\n</blockquote>\n<p>Ok, get it, thanks<span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span> .  A little suggestion, if the cache config has an API to config it may be  more convenient, like</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"n\">WASMTIME_CONFIG_PROP</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">,</span> <span class=\"n\">enable_cache</span><span class=\"p\">,</span> <span class=\"n\">wasm_config_t</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"p\">,</span> <span class=\"kt\">size_t</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span><span class=\"p\">);</span>\n<span class=\"n\">WASMTIME_CONFIG_PROP</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">,</span> <span class=\"n\">disable_cache</span><span class=\"p\">,</span> <span class=\"n\">wasm_config_t</span><span class=\"o\">*</span><span class=\"p\">);</span>\n</code></pre></div>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L306\">https://github.com/bytecodealliance/wasmtime/blob/6e6713ae0b0be578221a2802719327526458a8cf/crates/c-api/include/wasmtime.h#L306</a></p>\n<p>I use wasmtime as a library to offer wasm runtime in my library, it's not convenient for my library to create a toml file to use cache.</p>\n<p>Again, thanks you guys for your help!</p>\n</blockquote>",
        "id": 231572599,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616552163
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  I create a pool of instances, each instance has its own store, when a request is arrived, get an instance to process, but I failed with EXC_BAD_ACCESS. Is it possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?</p>\n</blockquote>",
        "id": 231598806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575102
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Hi, I create a pool of instances, each instance has its own store, when a request is arrived, get an instance to process, but I failed with EXC_BAD_ACCESS. Is it possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?</p>\n</blockquote>",
        "id": 231598834,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575116
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Hi, I create a pool of instances, each instance has its own store, when a request is arrived, get an instance to process, but I failed with EXC_BAD_ACCESS. Is it possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?<br>\nI found some discuss in #2295 , but not answered my question</p>\n</blockquote>",
        "id": 231599076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575249
    },
    {
        "content": "<p>bxq2011hust reopened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>I use one module to wasm_instance_new(C-API) instance to execute the function to save the cost of wasm_module_new, at start it works well, After some time running, I can't use wasm_instance_new to create new instance and got the error message <code>resource limit exceeded: instance count too high at 10001</code>. <br>\nI freed the instance use wasm_instance_delete every time execution is done, also free the exports, I think the count of instance should decrease to zero after execution, It seems the count of instance is cumulative. Is there some way to use one module to create instances more than 10000 times?<br>\n</p>\n</blockquote>",
        "id": 231599106,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575272
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Hi, In my use case, I will call an export function of the instance with different parameters many times, so if I can reuse instance, then I can save the cost of creating instance and imports, with a pool of instances I can parallel to preocess the call request.<br>\nSo I create a pool of instances, each instance has its own store, when a request is arrived, get an instance to process, but I failed with EXC_BAD_ACCESS. <br>\nIs it possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?</p>\n<p>I found some discuss in #2295 , but not answered my question</p>\n</blockquote>",
        "id": 231599823,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575715
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Hi, In my use case, I will call an export function of the instance with different parameters many times, so if I can reuse instance, then I can save the cost of creating instance and imports, with a pool of instances I can parallel to preocess the call request.<br>\nSo I create a pool of instances, each instance has its own store, when a request is arrived, a thread will try to get an idle instance to process, if there isn't an idle instance then create one, but I failed with the EXC_BAD_ACCESS. <br>\nIs it possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?</p>\n<p>I found some discuss in #2295 , but not answered my question</p>\n</blockquote>",
        "id": 231599994,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575827
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805611230\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Hi, In my use case, I will call an export function of the instance with different parameters many times, so if I can reuse instance, then I can save the cost of creating instance and imports, with a pool of instances I can parallel to preocess the call request.<br>\nSo I create a pool of instances, each instance has its own store, when a request is arrived, a thread will try to get an idle instance to process, if there isn't an idle instance then create one, but I failed with the EXC_BAD_ACCESS. <br>\nI wonder if it is possible to reuse an instance(the first use and next maybe in different thread, but each instance is used by one thread at the same time)?</p>\n<p>I found some discuss in #2295 , but not answered my question</p>\n</blockquote>",
        "id": 231600029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616575850
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805856274\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>Yes a strategy such as that should be safe to use from Wasmtime. You have to be sure, though, that everything connected to a store moves as a single unit between threads. If an instance is used on multiple threads over its lifetime, though, that's fine.</p>\n<p>If you're getting faults with that strategy, though, can you gist the code you're working with so we can reproduce and investigate?</p>\n</blockquote>",
        "id": 231640604,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616595228
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-805932568\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Thank you very much, it is a bug in my code. The env of function closure is invalid after execution and I forget to update the env pointer before the next execution.<span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span>‍♂️  Now it works well! 😄</p>\n</blockquote>",
        "id": 231656227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616600445
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used under 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I guess the instance has some limit(memory, stack of something), the below what I see. Do you have any ideas?<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231743371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616643463
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used under 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I guess the instance has some limit(memory, stack or something), the below what I see. Do you have any ideas?<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231743939,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616644046
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used under 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231746001,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616646066
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231752264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616652602
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I call another function in wasm always ok. Are there some tools to help me profile?<br>\n<del>I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?</del></p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231774375,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616666988
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I call another function in wasm always ok. Are there some tools to help me profile? <a href=\"https://github.com/bxq2011hust/hera/blob/dev-liquid-asset/src/wasmc.cpp#L1280-L1691\">https://github.com/bxq2011hust/hera/blob/dev-liquid-asset/src/wasmc.cpp#L1280-L1691</a><br>\n<del>I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?</del></p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231774625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616667102
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I call another function in wasm always ok. Are there some tools to help me profile? <a href=\"https://github.com/bxq2011hust/hera/blob/dev-liquid-asset/src/wasmc.cpp#L1280-L1691\">here</a> is the code how I use wasmtime to make instances pool.<br>\n<del>I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?</del></p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231774785,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616667171
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I call another function in wasm always ok. Are there some tools to help me profile? <a href=\"https://github.com/bxq2011hust/hera/blob/dev-liquid-asset/src/wasmc.cpp#L1280-L1691\">here</a> is the code how I use wasmtime to make instances pool. I even tried wasmer, get the same issue, <br>\n<del>I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?</del></p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231775018,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616667303
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806339823\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton Hi, I come back again. I meet a new problem, the instance works well before it is used less than 109 times, but I try to use the instance again, I get <code>EXC_BAD_ACCESS</code>. I call another function in wasm always ok. Are there some tools to help me profile? <a href=\"https://github.com/bxq2011hust/hera/blob/dev-liquid-asset/src/wasmc.cpp#L1280-L1691\">here</a> is the code how I use wasmtime to make instances pool. I even tried wasmer, get the same issue, also<code>RegisterSetjmp</code> and <code>EXC_BAD_ACCESS</code>.<br>\n<del>I guess the instance has some limit(memory, stack or something), the below is what I see. Do you have any ideas?</del></p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png\">https://user-images.githubusercontent.com/15418097/112415093-2ad55b80-8d5e-11eb-915f-fd5b4b1ab15f.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png\">https://user-images.githubusercontent.com/15418097/112415124-3d4f9500-8d5e-11eb-8f15-56453153ba32.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png\">https://user-images.githubusercontent.com/15418097/112415181-5a846380-8d5e-11eb-8ab1-f0575331168e.png</a>)<br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png\">https://user-images.githubusercontent.com/15418097/112415206-6c660680-8d5e-11eb-9a2b-e1f94c31961c.png</a>)</p>\n</blockquote>",
        "id": 231775094,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616667347
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-806828082\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>I'd recommend trying to use valgrind or perhaps thread sanitizers in C++, otherwise nothing looks too obviously awry from a quick scan. Otherwise the most useful thing I think would be to try to reduce it to a smaller program to help narrow in on what the problem is.</p>\n<p>Instances shouldn't have limits which poison them after some use, unless they're incorrectly cleaned up, which doesn't look like it's the case there I think.</p>\n</blockquote>",
        "id": 231807366,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616681611
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807957929\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton I try to use algrind trace the bug, the below is results. <br>\n![image](<a href=\"https://user-images.githubusercontent.com/15418097/112500773-a289a180-8dc3-11eb-9d76-340ce4190b4a.png\">https://user-images.githubusercontent.com/15418097/112500773-a289a180-8dc3-11eb-9d76-340ce4190b4a.png</a>)</p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112500904-c1883380-8dc3-11eb-8a3a-2195176ac62f.png\">https://user-images.githubusercontent.com/15418097/112500904-c1883380-8dc3-11eb-8a3a-2195176ac62f.png</a>)</p>\n<p>I think that the bug is in the wasm I used, there has an illegal memory access happened in the wasm, I also get <code>out of bounds memory access</code> in the trap. </p>\n<p>![image](<a href=\"https://user-images.githubusercontent.com/15418097/112572766-db5a6280-8e25-11eb-9c46-24c88ba6529a.png\">https://user-images.githubusercontent.com/15418097/112572766-db5a6280-8e25-11eb-9c46-24c88ba6529a.png</a>)</p>\n</blockquote>",
        "id": 231918683,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616738090
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if i use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time call the F the memory usage of instance will grow. The wasm binary I used is optimized, maybe the optimized make the F not grow memory, so after many times call F the memory is out of bounds.<br>\nIs there some way to release all linear memory of an instance? Or maybe there is a better way to interrupt the execution?</p>\n</blockquote>",
        "id": 231919579,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616738929
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if i use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time call the F the memory usage of instance will grow. The wasm binary I used is optimized, maybe the optimization makes the F can't grow memory, so after many times call F the memory is out of bounds.<br>\nIs there some way to reset the linear memory of an instance after each execution? Or maybe there is a better way to interrupt the execution and release the memory at the same time?</p>\n</blockquote>",
        "id": 231920145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616739573
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if i use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time call the F the memory usage of instance will grow. The wasm binary I used is optimized, maybe the optimization makes the F can't grow memory, so after many times call F the memory is out of bounds.<br>\nIs there some way to reset the linear memory of an instance after each execution? Or maybe there is a better way to interrupt the execution and release the memory at the same time?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset ?</p>\n</blockquote>",
        "id": 231922098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616741517
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if i use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time call the F the memory usage of instance will grow. The wasm binary I used is optimized, maybe the optimization makes the F can't grow memory always or the way stop execution creates too many traps, so after many times call F the memory is out of bounds.<br>\nIs there some way to reset the linear memory of an instance after each execution? Or maybe there is a better way to interrupt the execution and release the memory at the same time?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset ?</p>\n</blockquote>",
        "id": 231924398,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616743641
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if I use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time calls the F the memory usage of instance will grow. I guess either the way stop execution makes troubles, or the wasm I used has bugs in manage linear memory.</p>\n<p>Is there some way to reset the state of an instance after each execution? Or maybe there is a better way to interrupt the execution elegant?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in the host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset?</p>\n</blockquote>",
        "id": 231925563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616744583
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if I use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time calls the F the memory usage of instance will grow. I guess either the way stop execution makes troubles, or the wasm I used has bugs in manage linear memory.</p>\n<p>Is there some way to reset the state of an instance after each execution? Or maybe there is a better way to interrupt the execution elegant?</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>call main, error message: wasm trap: out of bounds memory access\nwasm backtrace:\n    <span class=\"m\">0</span>: 0x8c73c - &lt;unknown&gt;!wee_alloc::FreeCell::try_alloc::hb2660e954f6e5223\n    <span class=\"m\">1</span>: 0x8d3c7 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hfd5f453a5b3dec0c\n    <span class=\"m\">2</span>: 0x8d227 - &lt;unknown&gt;!wee_alloc::walk_free_list::hd831c341105a6b2d\n    <span class=\"m\">3</span>: 0x8d596 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::h7f42292292e49180\n    <span class=\"m\">4</span>: 0x8d603 - &lt;unknown&gt;!wee_alloc::alloc_with_refill::h3525530d2d10e1ae\n    <span class=\"m\">5</span>: 0x8da3f - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hd235f0224f501596\n    <span class=\"m\">6</span>: 0x8d97f - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::h1153d640b2b12f57\n    <span class=\"m\">7</span>: 0x906ea - &lt;unknown&gt;!wee_alloc::imp_wasm32::Exclusive&lt;T&gt;::with_exclusive_access::hebe42350c45bd1b7\n    <span class=\"m\">8</span>: 0x8d8bb - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::h06f3b976cadcd3c9\n    <span class=\"m\">9</span>: 0x8df5e - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::hbd0790bc4271633f\n   <span class=\"m\">10</span>: 0x8e169 - &lt;unknown&gt;!&lt;wee_alloc::WeeAlloc as core::alloc::global::GlobalAlloc&gt;::alloc::h366b133ed0c2cb3f\n   <span class=\"m\">11</span>: 0x8b3c6 - &lt;unknown&gt;!__rg_alloc\n   <span class=\"m\">12</span>: 0x47f5b - &lt;unknown&gt;!__rust_alloc\n   <span class=\"m\">13</span>: 0x86f0f - &lt;unknown&gt;!alloc::alloc::alloc::hc87f001bc6c9f141\n   <span class=\"m\">14</span>: 0x8702d - &lt;unknown&gt;!alloc::alloc::Global::alloc_impl::haa97078f3f34b5da\n   <span class=\"m\">15</span>: 0x86e74 - &lt;unknown&gt;!&lt;alloc::alloc::Global as core::alloc::Allocator&gt;::allocate::hfa4575a09cbd1182\n   <span class=\"m\">16</span>: 0x83d35 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in::h1570326482613819\n   <span class=\"m\">17</span>: 0x85490 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in::h5abb55ecde21b81f\n   <span class=\"m\">18</span>: 0x80d1c - &lt;unknown&gt;!alloc::vec::Vec&lt;T,A&gt;::with_capacity_in::hfafb52572c534d64\n   <span class=\"m\">19</span>: 0x86c97 - &lt;unknown&gt;!&lt;T as alloc::slice::hack::ConvertVec&gt;::to_vec::hc813c591a8fa1bfd\n   <span class=\"m\">20</span>: 0x87a10 - &lt;unknown&gt;!alloc::slice::hack::to_vec::hef5ce951d3ea8fbe\n   <span class=\"m\">21</span>: 0x7bb8e - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec_in::h885d10b1cfcd4103\n   <span class=\"m\">22</span>: 0x7bb40 - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec::h5083212bb2e14c81\n   <span class=\"m\">23</span>: 0x25a43 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::typed_cell::TypedCell&lt;T&gt;::new::ha7ebd5c4811cd7f3\n   <span class=\"m\">24</span>: 0x138c2 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::cached_cell::CachedCell&lt;T&gt;::new::h4093120e1570dec6\n   <span class=\"m\">25</span>: 0xfd04 - &lt;unknown&gt;!&lt;liquid_lang::lang_core::storage::value::Value&lt;T&gt; as liquid_lang::lang_core::storage::traits::Bind&gt;::bind_with::hc390e7ecb7ed1422\n   <span class=\"m\">26</span>: 0xa054 - &lt;unknown&gt;!&lt;parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage as liquid_lang::lang_core::storage::traits::New&gt;::new::h2cc23a83c1212243\n   <span class=\"m\">27</span>: 0xbadb - &lt;unknown&gt;!parallelok::parallel_ok::__liquid_private::_::&lt;impl parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage&gt;::dispatch::h5004208c4c584335\n   <span class=\"m\">28</span>: 0x34613 - &lt;unknown&gt;!main\nnote: run with <span class=\"sb\">`</span><span class=\"nv\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"m\">1</span><span class=\"sb\">`</span> environment variable to display more information\n</code></pre></div>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in the host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset?</p>\n</blockquote>",
        "id": 231935391,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616750939
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if I use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time calls the F the memory usage of instance will grow. I guess either the way stop execution makes troubles, or the wasm I used has bugs in manage linear memory.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>call main, error message: wasm trap: out of bounds memory access\nwasm backtrace:\n    <span class=\"m\">0</span>: 0x8c73c - &lt;unknown&gt;!wee_alloc::FreeCell::try_alloc::hb2660e954f6e5223\n    <span class=\"m\">1</span>: 0x8d3c7 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hfd5f453a5b3dec0c\n    <span class=\"m\">2</span>: 0x8d227 - &lt;unknown&gt;!wee_alloc::walk_free_list::hd831c341105a6b2d\n    <span class=\"m\">3</span>: 0x8d596 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::h7f42292292e49180\n    <span class=\"m\">4</span>: 0x8d603 - &lt;unknown&gt;!wee_alloc::alloc_with_refill::h3525530d2d10e1ae\n    <span class=\"m\">5</span>: 0x8da3f - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hd235f0224f501596\n    <span class=\"m\">6</span>: 0x8d97f - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::h1153d640b2b12f57\n    <span class=\"m\">7</span>: 0x906ea - &lt;unknown&gt;!wee_alloc::imp_wasm32::Exclusive&lt;T&gt;::with_exclusive_access::hebe42350c45bd1b7\n    <span class=\"m\">8</span>: 0x8d8bb - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::h06f3b976cadcd3c9\n    <span class=\"m\">9</span>: 0x8df5e - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::hbd0790bc4271633f\n   <span class=\"m\">10</span>: 0x8e169 - &lt;unknown&gt;!&lt;wee_alloc::WeeAlloc as core::alloc::global::GlobalAlloc&gt;::alloc::h366b133ed0c2cb3f\n   <span class=\"m\">11</span>: 0x8b3c6 - &lt;unknown&gt;!__rg_alloc\n   <span class=\"m\">12</span>: 0x47f5b - &lt;unknown&gt;!__rust_alloc\n   <span class=\"m\">13</span>: 0x86f0f - &lt;unknown&gt;!alloc::alloc::alloc::hc87f001bc6c9f141\n   <span class=\"m\">14</span>: 0x8702d - &lt;unknown&gt;!alloc::alloc::Global::alloc_impl::haa97078f3f34b5da\n   <span class=\"m\">15</span>: 0x86e74 - &lt;unknown&gt;!&lt;alloc::alloc::Global as core::alloc::Allocator&gt;::allocate::hfa4575a09cbd1182\n   <span class=\"m\">16</span>: 0x83d35 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in::h1570326482613819\n   <span class=\"m\">17</span>: 0x85490 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in::h5abb55ecde21b81f\n   <span class=\"m\">18</span>: 0x80d1c - &lt;unknown&gt;!alloc::vec::Vec&lt;T,A&gt;::with_capacity_in::hfafb52572c534d64\n   <span class=\"m\">19</span>: 0x86c97 - &lt;unknown&gt;!&lt;T as alloc::slice::hack::ConvertVec&gt;::to_vec::hc813c591a8fa1bfd\n   <span class=\"m\">20</span>: 0x87a10 - &lt;unknown&gt;!alloc::slice::hack::to_vec::hef5ce951d3ea8fbe\n   <span class=\"m\">21</span>: 0x7bb8e - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec_in::h885d10b1cfcd4103\n   <span class=\"m\">22</span>: 0x7bb40 - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec::h5083212bb2e14c81\n   <span class=\"m\">23</span>: 0x25a43 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::typed_cell::TypedCell&lt;T&gt;::new::ha7ebd5c4811cd7f3\n   <span class=\"m\">24</span>: 0x138c2 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::cached_cell::CachedCell&lt;T&gt;::new::h4093120e1570dec6\n   <span class=\"m\">25</span>: 0xfd04 - &lt;unknown&gt;!&lt;liquid_lang::lang_core::storage::value::Value&lt;T&gt; as liquid_lang::lang_core::storage::traits::Bind&gt;::bind_with::hc390e7ecb7ed1422\n   <span class=\"m\">26</span>: 0xa054 - &lt;unknown&gt;!&lt;parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage as liquid_lang::lang_core::storage::traits::New&gt;::new::h2cc23a83c1212243\n   <span class=\"m\">27</span>: 0xbadb - &lt;unknown&gt;!parallelok::parallel_ok::__liquid_private::_::&lt;impl parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage&gt;::dispatch::h5004208c4c584335\n   <span class=\"m\">28</span>: 0x34613 - &lt;unknown&gt;!main\nnote: run with <span class=\"sb\">`</span><span class=\"nv\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"m\">1</span><span class=\"sb\">`</span> environment variable to display more information\n</code></pre></div>\n<p>Is there some way to reset the state of an instance after each execution? Or maybe there is a better way to interrupt the execution elegant?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in the host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset?</p>\n</blockquote>",
        "id": 231935455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616750997
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if I use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time calls the F the memory usage of instance will grow. As the memory growing, at some time the trap return <code>out of bounds memory access</code>.I guess either the way stop execution makes troubles, or the wasm I used has bugs in manage linear memory.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>call main, error message: wasm trap: out of bounds memory access\nwasm backtrace:\n    <span class=\"m\">0</span>: 0x8c73c - &lt;unknown&gt;!wee_alloc::FreeCell::try_alloc::hb2660e954f6e5223\n    <span class=\"m\">1</span>: 0x8d3c7 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hfd5f453a5b3dec0c\n    <span class=\"m\">2</span>: 0x8d227 - &lt;unknown&gt;!wee_alloc::walk_free_list::hd831c341105a6b2d\n    <span class=\"m\">3</span>: 0x8d596 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::h7f42292292e49180\n    <span class=\"m\">4</span>: 0x8d603 - &lt;unknown&gt;!wee_alloc::alloc_with_refill::h3525530d2d10e1ae\n    <span class=\"m\">5</span>: 0x8da3f - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hd235f0224f501596\n    <span class=\"m\">6</span>: 0x8d97f - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::h1153d640b2b12f57\n    <span class=\"m\">7</span>: 0x906ea - &lt;unknown&gt;!wee_alloc::imp_wasm32::Exclusive&lt;T&gt;::with_exclusive_access::hebe42350c45bd1b7\n    <span class=\"m\">8</span>: 0x8d8bb - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::h06f3b976cadcd3c9\n    <span class=\"m\">9</span>: 0x8df5e - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::hbd0790bc4271633f\n   <span class=\"m\">10</span>: 0x8e169 - &lt;unknown&gt;!&lt;wee_alloc::WeeAlloc as core::alloc::global::GlobalAlloc&gt;::alloc::h366b133ed0c2cb3f\n   <span class=\"m\">11</span>: 0x8b3c6 - &lt;unknown&gt;!__rg_alloc\n   <span class=\"m\">12</span>: 0x47f5b - &lt;unknown&gt;!__rust_alloc\n   <span class=\"m\">13</span>: 0x86f0f - &lt;unknown&gt;!alloc::alloc::alloc::hc87f001bc6c9f141\n   <span class=\"m\">14</span>: 0x8702d - &lt;unknown&gt;!alloc::alloc::Global::alloc_impl::haa97078f3f34b5da\n   <span class=\"m\">15</span>: 0x86e74 - &lt;unknown&gt;!&lt;alloc::alloc::Global as core::alloc::Allocator&gt;::allocate::hfa4575a09cbd1182\n   <span class=\"m\">16</span>: 0x83d35 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in::h1570326482613819\n   <span class=\"m\">17</span>: 0x85490 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in::h5abb55ecde21b81f\n   <span class=\"m\">18</span>: 0x80d1c - &lt;unknown&gt;!alloc::vec::Vec&lt;T,A&gt;::with_capacity_in::hfafb52572c534d64\n   <span class=\"m\">19</span>: 0x86c97 - &lt;unknown&gt;!&lt;T as alloc::slice::hack::ConvertVec&gt;::to_vec::hc813c591a8fa1bfd\n   <span class=\"m\">20</span>: 0x87a10 - &lt;unknown&gt;!alloc::slice::hack::to_vec::hef5ce951d3ea8fbe\n   <span class=\"m\">21</span>: 0x7bb8e - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec_in::h885d10b1cfcd4103\n   <span class=\"m\">22</span>: 0x7bb40 - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec::h5083212bb2e14c81\n   <span class=\"m\">23</span>: 0x25a43 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::typed_cell::TypedCell&lt;T&gt;::new::ha7ebd5c4811cd7f3\n   <span class=\"m\">24</span>: 0x138c2 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::cached_cell::CachedCell&lt;T&gt;::new::h4093120e1570dec6\n   <span class=\"m\">25</span>: 0xfd04 - &lt;unknown&gt;!&lt;liquid_lang::lang_core::storage::value::Value&lt;T&gt; as liquid_lang::lang_core::storage::traits::Bind&gt;::bind_with::hc390e7ecb7ed1422\n   <span class=\"m\">26</span>: 0xa054 - &lt;unknown&gt;!&lt;parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage as liquid_lang::lang_core::storage::traits::New&gt;::new::h2cc23a83c1212243\n   <span class=\"m\">27</span>: 0xbadb - &lt;unknown&gt;!parallelok::parallel_ok::__liquid_private::_::&lt;impl parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage&gt;::dispatch::h5004208c4c584335\n   <span class=\"m\">28</span>: 0x34613 - &lt;unknown&gt;!main\nnote: run with <span class=\"sb\">`</span><span class=\"nv\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"m\">1</span><span class=\"sb\">`</span> environment variable to display more information\n</code></pre></div>\n<p>Is there some way to reset the state of an instance after each execution? Or maybe there is a better way to interrupt the execution elegant?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in the host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset?</p>\n</blockquote>",
        "id": 231935738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616751145
    },
    {
        "content": "<p>bxq2011hust edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-807963571\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  It seems if I use linear memory in wasm and the function F in wasm exit by call host function to return a trap, the memory allocated by the F is not freed, then the next time calls the F the memory usage of instance will grow. As the memory growing, at some time the trap return <code>out of bounds memory access</code>, and the instance will be failed from then.I guess either the way stop execution makes troubles, or the wasm I used has bugs in manage linear memory.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>call main, error message: wasm trap: out of bounds memory access\nwasm backtrace:\n    <span class=\"m\">0</span>: 0x8c73c - &lt;unknown&gt;!wee_alloc::FreeCell::try_alloc::hb2660e954f6e5223\n    <span class=\"m\">1</span>: 0x8d3c7 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hfd5f453a5b3dec0c\n    <span class=\"m\">2</span>: 0x8d227 - &lt;unknown&gt;!wee_alloc::walk_free_list::hd831c341105a6b2d\n    <span class=\"m\">3</span>: 0x8d596 - &lt;unknown&gt;!wee_alloc::alloc_first_fit::h7f42292292e49180\n    <span class=\"m\">4</span>: 0x8d603 - &lt;unknown&gt;!wee_alloc::alloc_with_refill::h3525530d2d10e1ae\n    <span class=\"m\">5</span>: 0x8da3f - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::hd235f0224f501596\n    <span class=\"m\">6</span>: 0x8d97f - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::<span class=\"o\">{{</span>closure<span class=\"o\">}}</span>::h1153d640b2b12f57\n    <span class=\"m\">7</span>: 0x906ea - &lt;unknown&gt;!wee_alloc::imp_wasm32::Exclusive&lt;T&gt;::with_exclusive_access::hebe42350c45bd1b7\n    <span class=\"m\">8</span>: 0x8d8bb - &lt;unknown&gt;!wee_alloc::WeeAlloc::with_free_list_and_policy_for_size::h06f3b976cadcd3c9\n    <span class=\"m\">9</span>: 0x8df5e - &lt;unknown&gt;!wee_alloc::WeeAlloc::alloc_impl::hbd0790bc4271633f\n   <span class=\"m\">10</span>: 0x8e169 - &lt;unknown&gt;!&lt;wee_alloc::WeeAlloc as core::alloc::global::GlobalAlloc&gt;::alloc::h366b133ed0c2cb3f\n   <span class=\"m\">11</span>: 0x8b3c6 - &lt;unknown&gt;!__rg_alloc\n   <span class=\"m\">12</span>: 0x47f5b - &lt;unknown&gt;!__rust_alloc\n   <span class=\"m\">13</span>: 0x86f0f - &lt;unknown&gt;!alloc::alloc::alloc::hc87f001bc6c9f141\n   <span class=\"m\">14</span>: 0x8702d - &lt;unknown&gt;!alloc::alloc::Global::alloc_impl::haa97078f3f34b5da\n   <span class=\"m\">15</span>: 0x86e74 - &lt;unknown&gt;!&lt;alloc::alloc::Global as core::alloc::Allocator&gt;::allocate::hfa4575a09cbd1182\n   <span class=\"m\">16</span>: 0x83d35 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in::h1570326482613819\n   <span class=\"m\">17</span>: 0x85490 - &lt;unknown&gt;!alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in::h5abb55ecde21b81f\n   <span class=\"m\">18</span>: 0x80d1c - &lt;unknown&gt;!alloc::vec::Vec&lt;T,A&gt;::with_capacity_in::hfafb52572c534d64\n   <span class=\"m\">19</span>: 0x86c97 - &lt;unknown&gt;!&lt;T as alloc::slice::hack::ConvertVec&gt;::to_vec::hc813c591a8fa1bfd\n   <span class=\"m\">20</span>: 0x87a10 - &lt;unknown&gt;!alloc::slice::hack::to_vec::hef5ce951d3ea8fbe\n   <span class=\"m\">21</span>: 0x7bb8e - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec_in::h885d10b1cfcd4103\n   <span class=\"m\">22</span>: 0x7bb40 - &lt;unknown&gt;!alloc::slice::&lt;impl <span class=\"o\">[</span>T<span class=\"o\">]</span>&gt;::to_vec::h5083212bb2e14c81\n   <span class=\"m\">23</span>: 0x25a43 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::typed_cell::TypedCell&lt;T&gt;::new::ha7ebd5c4811cd7f3\n   <span class=\"m\">24</span>: 0x138c2 - &lt;unknown&gt;!liquid_lang::lang_core::storage::cell::cached_cell::CachedCell&lt;T&gt;::new::h4093120e1570dec6\n   <span class=\"m\">25</span>: 0xfd04 - &lt;unknown&gt;!&lt;liquid_lang::lang_core::storage::value::Value&lt;T&gt; as liquid_lang::lang_core::storage::traits::Bind&gt;::bind_with::hc390e7ecb7ed1422\n   <span class=\"m\">26</span>: 0xa054 - &lt;unknown&gt;!&lt;parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage as liquid_lang::lang_core::storage::traits::New&gt;::new::h2cc23a83c1212243\n   <span class=\"m\">27</span>: 0xbadb - &lt;unknown&gt;!parallelok::parallel_ok::__liquid_private::_::&lt;impl parallelok::parallel_ok::__liquid_private::__liquid_storage::Storage&gt;::dispatch::h5004208c4c584335\n   <span class=\"m\">28</span>: 0x34613 - &lt;unknown&gt;!main\nnote: run with <span class=\"sb\">`</span><span class=\"nv\">WASMTIME_BACKTRACE_DETAILS</span><span class=\"o\">=</span><span class=\"m\">1</span><span class=\"sb\">`</span> environment variable to display more information\n</code></pre></div>\n<p>Is there some way to reset the state of an instance after each execution? Or maybe there is a better way to interrupt the execution elegant?</p>\n<p>I found <code>wasmtime_interrupt_handle_interrupt</code>,  the wasmtime_interrupt_handle should call from another thread? Can I call it in the host function called by wasm? If I call wasmtime_interrupt_handle will the linear memory be reset?</p>\n</blockquote>",
        "id": 231935864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616751210
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-808339371\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>Oh <code>valgrind</code> may not actually be too useful now that I think about it, wasm intentionally segfaults and raises illegal instructions, that's how we implement traps efficiently. Alas!</p>\n<p>Currently there's no way to reset the state of an instance after each execution. For use cases like that we recommend creating new instances instead of reusing existing instances (provides better isolation for each wasm as well).</p>\n<p>For interruption the interrupt handle is indeed intended to be invoked from anotehr thread. It can be called at any time. Interruption only affects execution, it doesn't affect linear memory. There's no way to \"reset\" linear memory since that's not a wasm concept per se.</p>\n</blockquote>",
        "id": 231991294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616775087
    },
    {
        "content": "<p>bxq2011hust <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751#issuecomment-808697687\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2751\">Issue #2751</a>:</p>\n<blockquote>\n<p>@alexcrichton  Ok, get it. Thanks again! <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>\n</blockquote>",
        "id": 232076827,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616836323
    }
]