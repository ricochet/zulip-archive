[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216923870\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<p>cc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3250\">https://github.com/bytecodealliance/wasmtime/issues/3250</a></p>\n<p>One of my arguments against this is that it makes the clif ir harder to read and harder to generate.</p>\n</blockquote>",
        "id": 293763635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660670128
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216932467\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<p>Hah, I guess I accidentally implemented what @cfallin proposed just by being confused. Thanks for digging that link up! It's helpful context.</p>\n<p>I noticed a couple things that I think are existing bugs while exploring this:</p>\n<ul>\n<li>\n<p>The backends all panic if they see these opcodes during lowering... Except that x64 has rules in <code>lower.isle</code> to match <code>iadd_imm</code>. Can those rules ever fire?</p>\n</li>\n<li>\n<p>I see <code>simple_preopt</code> was intended to rewrite \"(iadd (iconst x) (iadd (iconst y) z))\" to fold the constants together, and it uses the <code>*_imm</code> opcodes as an intermediate step. But it looks like that only actually happens if the constant is the first operand, not the second, because only one case has a recursive call to <code>simplify</code>.</p>\n</li>\n</ul>\n<p>Independent of whether we keep the <code>*_imm</code> instructions, I'm also wondering: Can <code>simple_preopt</code> be replaced with ISLE and match on the full tree structure, instead of rewriting to this intermediate form to avoid having to look three layers down in the tree of operators? I wonder if it would reduce compile time by not modifying instructions that it can't actually improve. Is that something that should happen after the e-graph work lands?</p>\n</blockquote>",
        "id": 293764846,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660670541
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216937875\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<p>Wow, there is a lot more stuff attached to <code>_imm</code> than i expected!</p>\n<p>Is it possible to print a comment with the const value if one of the sides of the <code>iadd</code>/<code>isub</code>/etc.. is a const? That way we could recover some of the readability.</p>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i16</span><span class=\"w\"> </span><span class=\"mh\">0xABCD</span><span class=\"w\"></span>\n<span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i16</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\">   </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0xABCD</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It would also help in cases other than <code>*_imm</code>. But probably does not cover all cases.</p>\n</blockquote>",
        "id": 293765743,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660670855
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216938693\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>Independent of whether we keep the *_imm instructions, I'm also wondering: Can simple_preopt be replaced with ISLE and match on the full tree structure</p>\n</blockquote>\n<p>I believe that is exactly what will happen with the egraph PR if it gets merged. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4249/files#diff-a596f1a407284b0b3591c17053fe0eff7f0229b70a2fcd9282fc2aedf9cd38a4\">https://github.com/bytecodealliance/wasmtime/pull/4249/files#diff-a596f1a407284b0b3591c17053fe0eff7f0229b70a2fcd9282fc2aedf9cd38a4</a></p>\n</blockquote>",
        "id": 293765912,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660670901
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216939603\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is it possible to print a comment with the const value if one of the sides of the iadd/isub/etc.. is a const? That way we could recover some of the readability.</p>\n</blockquote>\n<p>I like that! It would resolve my readability concerns. It doesn't resolve my clif ir generation concern though.</p>\n</blockquote>",
        "id": 293766086,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660670953
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216965678\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>It doesn't resolve my clif ir generation concern though.</p>\n</blockquote>\n<p>Reading the PR it looks like we keep the <code>_imm</code> builder functions, but they now emit the <code>op</code> + <code>iconst</code>, so there should no difference to users of cranelift. It that what you were referring to or did I miss something?</p>\n</blockquote>",
        "id": 293770365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660672518
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216965678\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>It doesn't resolve my clif ir generation concern though.</p>\n</blockquote>\n<p>Reading the PR it looks like we keep the <code>_imm</code> builder functions, but they now emit the <code>op</code> + <code>iconst</code>, so there should no difference to users of cranelift. It that what you were referring to or did I miss something?</p>\n<p>Although I do think we should note in the docs that those helpers are not actual instructions by themselves.</p>\n</blockquote>",
        "id": 293770505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660672586
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1216970128\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>Reading the PR it looks like we keep the _imm builder functions, but they now emit the op + iconst, so there should no difference to users of cranelift.</p>\n</blockquote>\n<p>Right, missed that.</p>\n</blockquote>",
        "id": 293770931,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660672773
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1217093830\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<p>@jameysharp thanks for exploring here. As others have pointed out, there's a lot of prior thought on this, and overall I think we do want to remove these variants in due time.</p>\n<blockquote>\n<p>The backends all panic if they see these opcodes during lowering... Except that x64 has rules in lower.isle to match iadd_imm. Can those rules ever fire?</p>\n</blockquote>\n<p>Currently the legalizer rewrites them from <code>_imm</code> form to op-with-iconst before the lowering backends see the CLIF; this is why we don't need to handle them in each backend.</p>\n<blockquote>\n<p>I see simple_preopt was intended to rewrite \"(iadd (iconst x) (iadd (iconst y) z))\" to fold the constants together, and it uses the *_imm opcodes as an intermediate step. But it looks like that only actually happens if the constant is the first operand, not the second, because only one case has a recursive call to simplify.</p>\n<p>Independent of whether we keep the *_imm instructions, I'm also wondering: Can simple_preopt be replaced with ISLE and match on the full tree structure, instead of rewriting to this intermediate form to avoid having to look three layers down in the tree of operators? I wonder if it would reduce compile time by not modifying instructions that it can't actually improve. Is that something that should happen after the e-graph work lands?</p>\n</blockquote>\n<p>Indeed, that's one of the main effects of my mid-end optimizer work; it will replace <code>simple_preopt</code> just as you are suggesting.</p>\n<p>Now, regarding <code>iadd</code> vs <code>iadd_imm</code> and friends:</p>\n<p>I think that breaking the ops into smaller pieces, and keeping <code>iadd</code> separate from its <code>imm</code>, makes the most sense from an optimization-rules perspective: we otherwise need rules to match both. (For example, multiply-add needs to also match multiply-add-imm.) Likewise it's useful to keep <code>iconst</code> separate because we want to do special things with it sometimes, like rematerialization and/or use of constant pools.</p>\n<p>Part of the reason for the original <code>_imm</code> forms, aside from the code-size advantage that @sunfishcode mentions in #3250, was that old Cranelift rewrote CLIF until each op had a direct machine-instruction equivalent; so <code>iadd_imm</code> was useful to represent the reg-immediate form of the x86 add instruction. We no longer have that constraint, though.</p>\n<p>So I think the right way forward is in spirit similar to what you've done here, but (i) do it after the mid-end optimizer lands (pending RFC approval!) because there are some immediate followup thoughts in how to make legalization ride on top of it; and (ii) generate the <code>_imm</code> helpers on the <code>InstBuilder</code> in a programmatic way, rather than manually writing them.</p>\n</blockquote>",
        "id": 293789103,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660679540
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1217148710\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is it possible to print a comment with the const value if one of the sides of the <code>iadd</code>/<code>isub</code>/etc.. is a const? That way we could recover some of the readability.<br>\n...<br>\n<code>\nv3 = iadd.i16 v2, v0   ; v0 = 0xABCD\n</code></p>\n</blockquote>\n<p>This turned out to be really easy to do. I've opened #4725 for that.</p>\n<blockquote>\n<blockquote>\n<p>The backends all panic if they see these opcodes during lowering... Except that x64 has rules in lower.isle to match iadd_imm. Can those rules ever fire?</p>\n</blockquote>\n<p>Currently the legalizer rewrites them from <code>_imm</code> form to op-with-iconst before the lowering backends see the CLIF; this is why we don't need to handle them in each backend.</p>\n</blockquote>\n<p>Right. So <a href=\"https://github.com/bytecodealliance/wasmtime/blob/fbfceaec9821deec2d18587505f7efce2b0a42db/cranelift/codegen/src/isa/x64/lower.isle#L192-L221\">these rules in x64's lower.isle</a> can never match, yeah?</p>\n<blockquote>\n<p>So I think the right way forward is in spirit similar to what you've done here, but (i) do it after the mid-end optimizer lands (pending RFC approval!) because there are some immediate followup thoughts in how to make legalization ride on top of it; and (ii) generate the <code>_imm</code> helpers on the <code>InstBuilder</code> in a programmatic way, rather than manually writing them.</p>\n</blockquote>\n<p>(i) makes sense. (ii) isn't immediately (!) obvious to me: is it that you want to make this pattern available as a convenience on more instructions, or you're worried about the correctness of the hand-written wrappers, or...?</p>\n</blockquote>",
        "id": 293797958,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660682895
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1217153461\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>(i) makes sense. (ii) isn't immediately (!) obvious to me: is it that you want to make this pattern available as a convenience on more instructions, or you're worried about the correctness of the hand-written wrappers, or...?</p>\n</blockquote>\n<p>Basically, generating the code is less error-prone and allows us to extend the pattern to arbitrary instructions as we choose fit; it's a lower-entropy encoding of the system design. We already generate <code>.iadd()</code> so generating <code>.iadd_imm()</code> given a special flag isn't a huge stretch. In contrast, mixing generated code and handwritten code (this PR) feels asymmetric and is difficult to maintain and extend in the future.</p>\n</blockquote>",
        "id": 293798759,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660683201
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1217154246\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<p>Right. So <a href=\"https://github.com/bytecodealliance/wasmtime/blob/fbfceaec9821deec2d18587505f7efce2b0a42db/cranelift/codegen/src/isa/x64/lower.isle#L192-L221\">these rules in x64's lower.isle</a> can never match, yeah?</p>\n</blockquote>\n<p>Apparently so! We can go ahead and delete those; I suspect fuzz coverage, if we were to get it in terms of ISLE source, would show this as well.</p>\n</blockquote>",
        "id": 293798927,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660683254
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721#issuecomment-1217164764\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4721\">issue #4721</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Right. So <a href=\"https://github.com/bytecodealliance/wasmtime/blob/fbfceaec9821deec2d18587505f7efce2b0a42db/cranelift/codegen/src/isa/x64/lower.isle#L192-L221\">these rules in x64's lower.isle</a> can never match, yeah?</p>\n</blockquote>\n<p>Apparently so! We can go ahead and delete those; I suspect fuzz coverage, if we were to get it in terms of ISLE source, would show this as well.</p>\n</blockquote>\n<p>Great, I've opened #4726 for deleting those.</p>\n<blockquote>\n<p>Basically, generating the code is less error-prone and allows us to extend the pattern to arbitrary instructions as we choose fit; it's a lower-entropy encoding of the system design. We already generate <code>.iadd()</code> so generating <code>.iadd_imm()</code> given a special flag isn't a huge stretch. In contrast, mixing generated code and handwritten code (this PR) feels asymmetric and is difficult to maintain and extend in the future.</p>\n</blockquote>\n<p>Okay, I can see that. It's not obvious to me what code that should generate, though, because the current <code>InstBuilder</code> traits assume each method will build exactly one instruction, consuming the builder. These <code>_imm</code> variants, being a kind of macro for multiple instructions, are fundamentally different.</p>\n<p>But we can sort that out when it's time to re-visit this after your e-graph work lands.</p>\n</blockquote>",
        "id": 293800569,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1660683950
    }
]