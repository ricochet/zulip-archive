[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1649117009\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:c-api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:c-api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 378335229,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690260291
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1649992866\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Thanks for the PR! I'm a bit hesitant personally about this, however, because if you're able to use <code>Cargo.toml</code> dependencies is there any reason you couldn't use the <code>wasmtime</code> crate itself? The C API isn't designed to be used as a Rust crate dependency and probably exposes some functions as safe which are actually <code>unsafe</code> for example (which doesn't matter on a C API bounary but matters to Rust). </p>\n<p>There's also other niche concerns where the Rust compiler has some odd gotchas about crates that are compiled as both a <code>cdylib</code> and an <code>rlib</code> and I think it would be best to avoid that.</p>\n</blockquote>",
        "id": 378505008,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690296651
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1650007645\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>There's also other niche concerns where the Rust compiler has some odd gotchas about crates that are compiled as both a cdylib and an rlib and I think it would be best to avoid that.</p>\n</blockquote>\n<p>That is fixed as of <a href=\"https://github.com/rust-lang/rust/pull/113695\">https://github.com/rust-lang/rust/pull/113695</a></p>\n</blockquote>",
        "id": 378508094,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690297170
    },
    {
        "content": "<p>RubixDev <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1650923196\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>Thanks for the PR! I'm a bit hesitant personally about this, however, because if you're able to use <code>Cargo.toml</code> dependencies is there any reason you couldn't use the <code>wasmtime</code> crate itself?</p>\n</blockquote>\n<p>Yes, I guess it didn't really become clear. Tree-sitter is written in C and provides Rust bindings. The C part uses wasmtime internally. The build script for the Rust bindings compiles the C code. For this, the wasmtime C library must be available because the tree-sitter C code uses it. The easiest way to have it available is to add it as a cargo dependency.</p>\n<blockquote>\n<p>The C API isn't designed to be used as a Rust crate dependency and probably exposes some functions as safe which are actually <code>unsafe</code> for example (which doesn't matter on a C API bounary but matters to Rust).</p>\n</blockquote>\n<p>So the Rust crate does _not_ interface with wasmtime directly (that could be done with the normal <code>wasmtime</code> crate), but the C code it provides bindings to _does_. The safe/unsafe functions from the <code>wasmtime-c-api</code> crate still only get called from C, not from Rust.</p>\n<p>I hope this time it's clearer</p>\n</blockquote>",
        "id": 378655083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690342212
    },
    {
        "content": "<p>RubixDev edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1650923196\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>Thanks for the PR! I'm a bit hesitant personally about this, however, because if you're able to use <code>Cargo.toml</code> dependencies is there any reason you couldn't use the <code>wasmtime</code> crate itself?</p>\n</blockquote>\n<p>Yes, I guess it didn't really become clear. Tree-sitter is written in C and provides Rust bindings. The C part uses wasmtime internally. The build script for the Rust bindings compiles the C code. For this, the wasmtime C library must be available because the tree-sitter C code uses it. The easiest way to have it available is to add it as a cargo dependency.</p>\n<blockquote>\n<p>The C API isn't designed to be used as a Rust crate dependency and probably exposes some functions as safe which are actually <code>unsafe</code> for example (which doesn't matter on a C API bounary but matters to Rust).</p>\n</blockquote>\n<p>So the Rust crate _does not_ interface with wasmtime directly (that could be done with the normal <code>wasmtime</code> crate), but the C code it provides bindings to _does_. The safe/unsafe functions from the <code>wasmtime-c-api</code> crate still only get called from C, not from Rust.</p>\n<p>I hope this time it's clearer</p>\n</blockquote>",
        "id": 378655146,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690342261
    },
    {
        "content": "<p>RubixDev <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1651090336\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Ok and to address the failing CI, this is because the C library is expected to just be called <code>wasmtime</code> (or <code>libwasmtime.a</code>), whereas with this change it is called <code>wasmtime_c_api</code> instead. That's obviously not desired, but necessary for tree-sitter to additionally depend on the normal Rust <code>wasmtime</code> crate. I think the best alternative would be to revert the name change and re-export the Rust <code>wasmtime</code> API from the <code>wasmtime-c-api</code> crate. This way, tree-sitter only needs to depend on <code>wasmtime-c-api</code> for both the normal Rust API and the C API.</p>\n<p>Before I push this though, I would like feedback on this idea.</p>\n</blockquote>",
        "id": 378684589,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690354695
    },
    {
        "content": "<p>RubixDev edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1651090336\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Ok and to address the failing CI, this is because the C library is expected to just be called <code>wasmtime</code> (or <code>libwasmtime.a</code>), whereas with this change it is called <code>wasmtime_c_api</code> instead. That's obviously not desired, but necessary for tree-sitter to additionally depend on the normal Rust <code>wasmtime</code> crate. I think the best alternative would be to revert the name change and re-export the Rust <code>wasmtime</code> API from the <code>wasmtime-c-api</code> crate. This way, tree-sitter only needs to depend on <code>wasmtime-c-api</code> for both the normal Rust API and the C API.</p>\n<p>Before I push this though, I would like feedback on this idea.</p>\n<p>&lt;details&gt;<br>\n&lt;summary&gt;The final diff would then look something like this&lt;/summary&gt;</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/crates/c-api/Cargo.toml b/crates/c-api/Cargo.toml</span>\n<span class=\"gh\">index a464c0dbd..eb08a548a 100644</span>\n<span class=\"gd\">--- a/crates/c-api/Cargo.toml</span>\n<span class=\"gi\">+++ b/crates/c-api/Cargo.toml</span>\n<span class=\"gu\">@@ -11,7 +11,7 @@ publish = false</span>\n\n<span class=\"w\"> </span>[lib]\n<span class=\"w\"> </span>name = \"wasmtime\"\n<span class=\"gd\">-crate-type = [\"staticlib\", \"cdylib\"]</span>\n<span class=\"gi\">+crate-type = [\"staticlib\", \"cdylib\", \"rlib\"]</span>\n<span class=\"w\"> </span>doc = false\n<span class=\"w\"> </span>test = false\n<span class=\"w\"> </span>doctest = false\n<span class=\"gh\">diff --git a/crates/c-api/src/lib.rs b/crates/c-api/src/lib.rs</span>\n<span class=\"gh\">index 4bc111b5d..3ef450731 100644</span>\n<span class=\"gd\">--- a/crates/c-api/src/lib.rs</span>\n<span class=\"gi\">+++ b/crates/c-api/src/lib.rs</span>\n<span class=\"gu\">@@ -11,6 +11,8 @@</span>\n\n<span class=\"w\"> </span>#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]\n\n<span class=\"gi\">+pub use wasmtime::*;</span>\n<span class=\"gi\">+</span>\n<span class=\"w\"> </span>mod config;\n<span class=\"w\"> </span>mod engine;\n<span class=\"w\"> </span>mod error;\n</code></pre></div>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 378685281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690354900
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1651907768\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>That is fixed as of https://github.com/rust-lang/rust/pull/113695\n</code></pre></div>\n\n</blockquote>\n<p>Oh nice! I was also thinking of issues though with LTO where rlib+cdylib has at least caused problems there where LTO settings effectively don't apply. That may have been fixed, though, I'm not sure.</p>\n<blockquote>\n<p>Tree-sitter is written in C and provides Rust bindings</p>\n</blockquote>\n<p>Hm ok it might be good to better understand your use case first then. This is a recipe for things going wrong where a Rust crate depends on a C library which depends on a Rust library. There's two versions of the rust standard library in that final program and that may or may not be expected (and may also cause things like linking issues).</p>\n<p>I'm also still not sure how this PR is expected to be integrated successfully? Why is reexporting <code>wasmtime::*</code> necessary? Are you using both Wasmtime's C API and the native Rust API? Or are the Rust bindings for tree-sitter exclusively using tree-sitter's own C API?</p>\n<hr>\n<p>At least for me I've never found a way to strike a right balance providing a C API from a Rust crate. I've gotten requests like this historically to support the C API both when used from Rust and C and I don't know how best to organize and enable that. In the end though if this works for you (it'd be good to end-to-end test to confirm) then my concerns are pretty niche and we can go ahead and merge it.</p>\n</blockquote>",
        "id": 378821530,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690381273
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1651938785\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>Oh nice! I was also thinking of issues though with LTO where rlib+cdylib has at least caused problems there where LTO settings effectively don't apply. That may have been fixed, though, I'm not sure.</p>\n</blockquote>\n<p>Seems not. <code>echo | rustc - --crate-type rlib --crate-type cdylib -Clto=thin</code> gives <code>error: lto can only be run for executables, cdylibs and static library outputs</code></p>\n</blockquote>",
        "id": 378827042,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690382169
    },
    {
        "content": "<p>RubixDev <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1653347709\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>Hm ok it might be good to better understand your use case first then. This is a recipe for things going wrong where a Rust crate depends on a C library which depends on a Rust library. There's two versions of the rust standard library in that final program and that may or may not be expected (and may also cause things like linking issues).</p>\n</blockquote>\n<p>Well, the proposed solution only has one Rust and one C part which interoperate. The tree-sitter Rust bindings call functions from the C part, and the C part calls the wasmtime functions from the Rust part. Note that the wasmtime functions are in the same Rust binary as the tree-sitter bindings (because the wasmtime C API is used as a dependency) so there will only be one Rust stdlib and no linking issues. The use of the C API is required as tree-sitter should also be usable from C, just that there users will have to manually provide wasmtime.</p>\n<blockquote>\n<p>I'm also still not sure how this PR is expected to be integrated successfully? Why is reexporting <code>wasmtime::*</code> necessary? Are you using both Wasmtime's C API and the native Rust API? Or are the Rust bindings for tree-sitter exclusively using tree-sitter's own C API?</p>\n</blockquote>\n<p>The Rust bindings don't interface with the wasmtime C API directly, but the C code called from the Rust bindings uses the wasmtime C API. Additionally, the Rust bindings use a small part of the native Rust API, actually just <code>Engine</code>. Due to the lib name clash between <code>wasmtime</code> and <code>wasmtime-c-api</code>, a re-export is required for the usage of both crates simultaneously.</p>\n<blockquote>\n<p>In the end though if this works for you (it'd be good to end-to-end test to confirm) then my concerns are pretty niche and we can go ahead and merge it.</p>\n</blockquote>\n<p>I'm not sure what exactly you mean by \"end-to-end test\", but I've successfully used the fork locally.</p>\n</blockquote>",
        "id": 379097756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1690453953
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1667954720\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Can you explain more about why <code>pub use</code> is required? That's venturing more into the territory of this seems to situation-solve a specific use case which isn't documented and won't be guarnateed to continue working. For example that's a very easy thing to overlook and accidentally remove during a refactoring or something like that.</p>\n<p>Again though I don't know if there are any widely used idioms about defining C APIs in Rust and using them from Rust as well. This is not a use case I've ever seen before work successfully, so I don't know how best to organize this.</p>\n<blockquote>\n<p>Note that the wasmtime functions are in the same Rust binary as the tree-sitter bindings (because the wasmtime C API is used as a dependency)</p>\n</blockquote>\n<p>I'll note as well that what you're describing here is a circular dependency between libraries which is not guaranteed to work with all native linkers. To get circular dependencies to always work native linkers have <code>--start-group</code> and <code>--end-group</code> options (or similar) which are required to indicate that there are circular references within that set of arguments passed. The Rust compiler would not pass these for arbitrary libraries and there's no means of doing so in general. While some platforms may work (e.g. the ones you've tested) it's unlikely to work on all platforms or into the future (e.g. in the face of future refactorings)</p>\n<hr>\n<p>Sorry if I may be repeating myself, I've been doing a bit of travel and lost context on this...</p>\n</blockquote>",
        "id": 382648839,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1691418091
    },
    {
        "content": "<p>maxbrunsfeld <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1740115770\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> I wrote the Tree-sitter PR that gave rise to this change. It'd be great to land this functionality, so that Tree-sitter can provide the WASM plugin functionality that's implemented in <a href=\"https://github.com/tree-sitter/tree-sitter/pull/1864\">https://github.com/tree-sitter/tree-sitter/pull/1864</a>, without having to depend on a fork of wasmtime.</p>\n<blockquote>\n<p>I'll note as well that what you're describing here is a circular dependency between libraries which is not guaranteed to work with all native linkers</p>\n</blockquote>\n<p>I don't think there's a dependency cycle here. The dependencies between the different compilation units are as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"mf\">1.</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">-</span><span class=\"n\">sitter</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"o\">+--</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">2.</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">-</span><span class=\"n\">sitter</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">library</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"o\">+------+---</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">3.</span><span class=\"w\"> </span><span class=\"n\">Wasmtime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">API</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"o\">+------+---</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">4.</span><span class=\"w\"> </span><span class=\"n\">Wasmtime</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"n\">Crate</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>All of the edges in this graph are expressed directly to Cargo, except for the dependency between 2 and 3 (because 2 is a C library compiled in a build script). When compiling with Cargo, the linking works fine though, I imagine because 1 and 2 are part of the same crate, and 1 has a Cargo dependency on 3.</p>\n<p>It seems to work without issue on all of the platforms I've tried it on, and it's useful.</p>\n</blockquote>",
        "id": 393818414,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1695943169
    },
    {
        "content": "<p>maxbrunsfeld edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1740115770\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> I wrote the Tree-sitter PR that gave rise to this change. It'd be great to land this functionality, so that Tree-sitter can provide the WASM plugin functionality that's implemented in <a href=\"https://github.com/tree-sitter/tree-sitter/pull/1864\">https://github.com/tree-sitter/tree-sitter/pull/1864</a>, without having to depend on a fork of wasmtime.</p>\n<blockquote>\n<p>I'll note as well that what you're describing here is a circular dependency between libraries which is not guaranteed to work with all native linkers</p>\n</blockquote>\n<p>I don't think there's a dependency cycle here. The dependencies between the different compilation units are as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"mf\">1.</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">-</span><span class=\"n\">sitter</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"p\">)</span>\n<span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\"> </span><span class=\"o\">+--</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">2.</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"o\">-</span><span class=\"n\">sitter</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">library</span><span class=\"p\">)</span>\n<span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">      </span><span class=\"o\">|</span>\n<span class=\"w\"> </span><span class=\"o\">+------+-----</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">3.</span><span class=\"w\"> </span><span class=\"n\">Wasmtime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">API</span><span class=\"p\">)</span>\n<span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">                </span><span class=\"o\">|</span>\n<span class=\"w\"> </span><span class=\"o\">+----------------+-----</span>-&gt; <span class=\"p\">(</span><span class=\"mf\">4.</span><span class=\"w\"> </span><span class=\"n\">Wasmtime</span><span class=\"w\"> </span><span class=\"n\">Rust</span><span class=\"w\"> </span><span class=\"n\">Crate</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>All of the edges in this graph are expressed directly to Cargo, except for the dependency between 2 and 3 (because 2 is a C library compiled in a build script). When compiling with Cargo, the linking works fine though, I imagine because 1 and 2 are part of the same crate, and 1 has a Cargo dependency on 3.</p>\n<p>It seems to work without issue on all of the platforms I've tried it on, and it's useful.</p>\n</blockquote>",
        "id": 393818717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1695943414
    },
    {
        "content": "<p>maxbrunsfeld <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1740121457\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<blockquote>\n<p>Can you explain more about why <code>pub use</code> is required?</p>\n</blockquote>\n<p>The <code>pub use</code> isn't strictly required, but we do need some way to access the items in the <code>wasmtime</code> crate, while depending on the <code>wasmtime-c-api</code> crate. Right now, we're prevented from importing anything from <code>wasmtime</code> while depending on <code>wasmtime-c-api</code>, because <code>wasmtime-c-api</code> does this in its Cargo.toml:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/Cargo.toml#L12-L13\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/Cargo.toml#L12-L13</a></p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">lib</span><span class=\"p\">]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"wasmtime\"</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 393819214,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1695943760
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1740955033\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Ok thanks for coming back to this, and given how useful it is for y'all I think this is ok to land. If issues come up we can try to work with you to figure out how to fix it (if any), and otherwise can take care of things in the meantime.</p>\n<p>Testing locally I don't think the <code>pub use</code> is required with a bit of a Cargo workaround:</p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"k\">[dependencies]</span>\n<span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"*\"</span>\n<span class=\"n\">this-is-your-name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">version</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"*\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">package</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">'wasmtime-c-api'</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>The <code>package</code> key tricks cargo into passing <code>--extern this_is_your_name=...</code>. Note that <code>this-is-your-name</code> could even be <code>wasmtime-c-api</code> which would allow Rust code to use <code>wasmtime_c_api::...</code>.</p>\n<p>I'm going to go ahead and queue this up for merge and I'll send a follow-up to remove the <code>pub use</code> under the assumption that it's best to go ahead and land this somewhat-old PR rather than ask for further changes.</p>\n<p>Thank you again for following up, it's appreciated!<br>\n</p>\n</blockquote>",
        "id": 393938056,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1695996482
    },
    {
        "content": "<p>maxbrunsfeld <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765#issuecomment-1741174426\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6765\">issue #6765</a>:</p>\n<blockquote>\n<p>Thanks so much @alexcrichton, and I really appreciate that solution of using a custom dependency name. I didn't know you could do that!</p>\n</blockquote>",
        "id": 393965597,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1696004762
    }
]