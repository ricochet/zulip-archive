[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a> from <code>segfault-no-trap</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit fixes an issue in Wasmtime where Wasmtime would accidentally<br>\n\"handle\" non-wasm segfaults while executing host imports of wasm<br>\nmodules. If a host import segfaulted then Wasmtime would recognize that<br>\nwasm code is on the stack, so it'd longjmp out of the wasm code. This<br>\npapers over real bugs though in host code and erroneously classified<br>\nsegfaults as wasm traps.</p>\n<p>The fix here was to add a check to our wasm signal handler for if the<br>\nfaulting address falls in JIT code itself. Actually threading through<br>\nall the right information for that check to happen is a bit tricky,<br>\nthough, so this involved some refactoring:</p>\n<ul>\n<li>\n<p>A closure parameter to <code>catch_traps</code> was added. This closure is<br>\n  responsible for classifying addresses as whether or not they fall in<br>\n  JIT code. Anything returning <code>false</code> means that the trap won't get<br>\n  handled and we'll forward to the next signal handler.</p>\n</li>\n<li>\n<p>To avoid passing tons of context all over the place, the start<br>\n  function is now no longer automatically invoked by <code>InstanceHandle</code>.<br>\n  This avoids the need for passing all sorts of trap-handling contextual<br>\n  information like the maximum stack size and \"is this a jit address\"<br>\n  closure. Instead creators of <code>InstanceHandle</code> (like wasmtime) are now<br>\n  responsible for invoking the start function.</p>\n</li>\n<li>\n<p>To avoid excessive use of <code>transmute</code> with lifetimes since the<br>\n  traphandler state now has a lifetime the per-instance custom signal<br>\n  handler is now replaced with a per-store custom signal handler. I'm<br>\n  not entirely certain the purpose of the custom signal handler, though,<br>\n  so I'd look for feedback on this part.</p>\n</li>\n</ul>\n<p>A new test has been added which ensures that if a host function<br>\nsegfaults we don't accidentally try to handle it, and instead we<br>\ncorrectly report the segfault.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194955694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587572408
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a> from <code>segfault-no-trap</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit fixes an issue in Wasmtime where Wasmtime would accidentally<br>\n\"handle\" non-wasm segfaults while executing host imports of wasm<br>\nmodules. If a host import segfaulted then Wasmtime would recognize that<br>\nwasm code is on the stack, so it'd longjmp out of the wasm code. This<br>\npapers over real bugs though in host code and erroneously classified<br>\nsegfaults as wasm traps.</p>\n<p>The fix here was to add a check to our wasm signal handler for if the<br>\nfaulting address falls in JIT code itself. Actually threading through<br>\nall the right information for that check to happen is a bit tricky,<br>\nthough, so this involved some refactoring:</p>\n<ul>\n<li>\n<p>A closure parameter to <code>catch_traps</code> was added. This closure is<br>\n  responsible for classifying addresses as whether or not they fall in<br>\n  JIT code. Anything returning <code>false</code> means that the trap won't get<br>\n  handled and we'll forward to the next signal handler.</p>\n</li>\n<li>\n<p>To avoid passing tons of context all over the place, the start<br>\n  function is now no longer automatically invoked by <code>InstanceHandle</code>.<br>\n  This avoids the need for passing all sorts of trap-handling contextual<br>\n  information like the maximum stack size and \"is this a jit address\"<br>\n  closure. Instead creators of <code>InstanceHandle</code> (like wasmtime) are now<br>\n  responsible for invoking the start function.</p>\n</li>\n<li>\n<p>To avoid excessive use of <code>transmute</code> with lifetimes since the<br>\n  traphandler state now has a lifetime the per-instance custom signal<br>\n  handler is now replaced with a per-store custom signal handler. I'm<br>\n  not entirely certain the purpose of the custom signal handler, though,<br>\n  so I'd look for feedback on this part.</p>\n</li>\n</ul>\n<p>A new test has been added which ensures that if a host function<br>\nsegfaults we don't accidentally try to handle it, and instead we<br>\ncorrectly report the segfault.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194956581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587572805
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a> from <code>segfault-no-trap</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit fixes an issue in Wasmtime where Wasmtime would accidentally<br>\n\"handle\" non-wasm segfaults while executing host imports of wasm<br>\nmodules. If a host import segfaulted then Wasmtime would recognize that<br>\nwasm code is on the stack, so it'd longjmp out of the wasm code. This<br>\npapers over real bugs though in host code and erroneously classified<br>\nsegfaults as wasm traps.</p>\n<p>The fix here was to add a check to our wasm signal handler for if the<br>\nfaulting address falls in JIT code itself. Actually threading through<br>\nall the right information for that check to happen is a bit tricky,<br>\nthough, so this involved some refactoring:</p>\n<ul>\n<li>\n<p>A closure parameter to <code>catch_traps</code> was added. This closure is<br>\n  responsible for classifying addresses as whether or not they fall in<br>\n  JIT code. Anything returning <code>false</code> means that the trap won't get<br>\n  handled and we'll forward to the next signal handler.</p>\n</li>\n<li>\n<p>To avoid passing tons of context all over the place, the start<br>\n  function is now no longer automatically invoked by <code>InstanceHandle</code>.<br>\n  This avoids the need for passing all sorts of trap-handling contextual<br>\n  information like the maximum stack size and \"is this a jit address\"<br>\n  closure. Instead creators of <code>InstanceHandle</code> (like wasmtime) are now<br>\n  responsible for invoking the start function.</p>\n</li>\n<li>\n<p>To avoid excessive use of <code>transmute</code> with lifetimes since the<br>\n  traphandler state now has a lifetime the per-instance custom signal<br>\n  handler is now replaced with a per-store custom signal handler. I'm<br>\n  not entirely certain the purpose of the custom signal handler, though,<br>\n  so I'd look for feedback on this part.</p>\n</li>\n</ul>\n<p>A new test has been added which ensures that if a host function<br>\nsegfaults we don't accidentally try to handle it, and instead we<br>\ncorrectly report the segfault.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 195238215,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587758721
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/fitzgen\" title=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a>.</p>",
        "id": 195609361,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588099701
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#pullrequestreview-402299147\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#pullrequestreview-402299147\">PR Review</a>.</p>",
        "id": 195645669,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588119648
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577#pullrequestreview-402905066\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577#pullrequestreview-402905066\">PR Review</a>.</p>",
        "id": 195746945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588182906
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a> from <code>segfault-no-trap</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit fixes an issue in Wasmtime where Wasmtime would accidentally<br>\n\"handle\" non-wasm segfaults while executing host imports of wasm<br>\nmodules. If a host import segfaulted then Wasmtime would recognize that<br>\nwasm code is on the stack, so it'd longjmp out of the wasm code. This<br>\npapers over real bugs though in host code and erroneously classified<br>\nsegfaults as wasm traps.</p>\n<p>The fix here was to add a check to our wasm signal handler for if the<br>\nfaulting address falls in JIT code itself. Actually threading through<br>\nall the right information for that check to happen is a bit tricky,<br>\nthough, so this involved some refactoring:</p>\n<ul>\n<li>\n<p>A closure parameter to <code>catch_traps</code> was added. This closure is<br>\n  responsible for classifying addresses as whether or not they fall in<br>\n  JIT code. Anything returning <code>false</code> means that the trap won't get<br>\n  handled and we'll forward to the next signal handler.</p>\n</li>\n<li>\n<p>To avoid passing tons of context all over the place, the start<br>\n  function is now no longer automatically invoked by <code>InstanceHandle</code>.<br>\n  This avoids the need for passing all sorts of trap-handling contextual<br>\n  information like the maximum stack size and \"is this a jit address\"<br>\n  closure. Instead creators of <code>InstanceHandle</code> (like wasmtime) are now<br>\n  responsible for invoking the start function.</p>\n</li>\n<li>\n<p>To avoid excessive use of <code>transmute</code> with lifetimes since the<br>\n  traphandler state now has a lifetime the per-instance custom signal<br>\n  handler is now replaced with a per-store custom signal handler. I'm<br>\n  not entirely certain the purpose of the custom signal handler, though,<br>\n  so I'd look for feedback on this part.</p>\n</li>\n</ul>\n<p>A new test has been added which ensures that if a host function<br>\nsegfaults we don't accidentally try to handle it, and instead we<br>\ncorrectly report the segfault.</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 195748119,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588183493
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1577\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1577\">PR #1577</a>.</p>",
        "id": 195758251,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588188296
    }
]