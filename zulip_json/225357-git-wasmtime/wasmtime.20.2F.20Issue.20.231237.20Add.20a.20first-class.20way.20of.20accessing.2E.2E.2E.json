[
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-596742298\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-596742298\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>The part about this that makes me nervous is being able to access a module's memory without it being exported.</p>\n<p>Obviously, requiring modules to export their memory is unfortunate, and the simple name \"memory\" isn't ideal, and we should do something better, but for now, it does help to model what's going on. You're calling out with <code>i32</code> values which are pointers to a memory accessed via the \"memory\" export. We don't want Wasmtime or any tools assuming that a non-exported memory isn't mutated by anything outside the module. The export also helps in the case of multiple memories, because you can pick which one to export as \"memory\".</p>\n<p>Would it still achieve your goal here if you reinstated the <code>lookup(\"memory\")</code> logic in <code>from_abi</code>, keeping the rest of the feature?</p>\n</blockquote>",
        "id": 190109217,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583782831
    },
    {
        "content": "<p>lostman <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-596930790\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-596930790\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<blockquote>\n<p>Typically you'll have to set up an <code>Rc&lt;RefCell&lt;Option&lt;Memory&gt;&gt;&gt;</code>, close over that in your function imports, and then fill it in once the instance is created.</p>\n</blockquote>\n<p>When an instance is created it automatically runs the <code>(start)</code> function. If the <code>Rc&lt;...&gt;</code> was the only way to access memory then it wouldn't be possible to use a memory-accessing host call inside <code>(start)</code>.</p>\n<p>Is that the intended behavior?</p>\n<p>Alternatively, if one could make an instance, tie the knot, and only then explicitly run <code>(start)</code>, the <code>Rc&lt;...&gt;</code> approach would work.</p>\n<p>How would interface types solve this problem?</p>\n</blockquote>",
        "id": 190146022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583822965
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597164272\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597164272\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>@sunfishcode yeah we could definitely go that route, only giving access to exported memories. I would prefer to not hardcode the string <code>\"memory\"</code> , though, so we could switch to something like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Func</span>::<span class=\"n\">wrap1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">mem</span>: <span class=\"nc\">wasmtime</span>::<span class=\"n\">Caller</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">mem</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">&quot;memory&quot;</span><span class=\"p\">).</span><span class=\"n\">and_then</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">e</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">memory</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>That way the string <code>\"memory\"</code> would still be passed in by the caller, and we could enhance <code>CallerMemory</code> over time with other stuff if we really wanted. For now it'd just be a thin wrapper around <code>*mut VMContext</code>.</p>\n<p>@lostman yes the current way to implement this today with <code>Rc</code> doesn't support calling imports in the <code>start</code> function, but this is basically the same limitation of the JS API and is one of the known caveats of the <code>start</code> function. </p>\n<p>Interface types would solve this issue because callers would simply say \"I need a string\", and it's the job of <code>wasmtime</code> to figure out how to give you that string, not the caller to figure out how to read the string out of linear memory.</p>\n</blockquote>",
        "id": 190189540,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583855725
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597176385\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597176385\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>Passing in the \"memory\" string sounds good. Maybe we could also add a <code>pub const WASM_MEMORY_EXPORT_NAME = \"memory\"</code> or some such thing that we could recommend people use with this API, so that when we do change it, we have more options for helping them avoid silent breakage.</p>\n</blockquote>",
        "id": 190192392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583857064
    },
    {
        "content": "<p>lostman <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597450456\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597450456\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>What about multiple memories? Is that anywhere on the road map? If it is, any API that relies on specific names will lead to trouble.</p>\n<p>The current situation is already a bit messy. What if a module exports memory but calls it <code>\"mem\"</code>? I recall compiling C++ to Wasm while back and there was no option to chose the name. Not sure what the current state of Rust toolchain is either.</p>\n</blockquote>",
        "id": 190251565,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583904362
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597667114\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597667114\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>@lostman with @sunfishcode's suggestion nothing will be hardcoded here any more, so we'll have an easy way to specify which memory is being accessed (via an exported name). I'm working on an update to the various traits here to support all this.</p>\n</blockquote>",
        "id": 190286942,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583936950
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597675533\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597675533\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>As additional background, the \"memory\" export name is currently <a href=\"https://github.com/llvm/llvm-project/blob/master/lld/wasm/Writer.cpp#L505\" target=\"_blank\" title=\"https://github.com/llvm/llvm-project/blob/master/lld/wasm/Writer.cpp#L505\">hard-wired into lld</a>, and it's become a de-facto convention that engines assume now. This is obviously not ideal, but I am optimistic that we'll have chances to move away from programs exporting their entire memory to the world, which will be opportunities to fix this.</p>\n</blockquote>",
        "id": 190288743,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583937848
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597679062\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597679062\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>I'm gonna end up taking a pretty different approach to doing this, so I'm going to close this.</p>\n</blockquote>",
        "id": 190289520,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583938228
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597818280\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237#issuecomment-597818280\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">Issue #1237</a>:</p>\n<blockquote>\n<p>Ok I've followed up with <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1290\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1290\">https://github.com/bytecodealliance/wasmtime/pull/1290</a> which I think is a better way to tackle this, thanks for the suggestion @sunfishcode!</p>\n</blockquote>",
        "id": 190320188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583954047
    }
]