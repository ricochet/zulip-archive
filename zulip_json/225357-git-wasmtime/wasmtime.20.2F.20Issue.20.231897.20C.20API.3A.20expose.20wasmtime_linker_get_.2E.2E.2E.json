[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-645815789\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:c-api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:c-api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 201232907,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592462901
    },
    {
        "content": "<p>thibaultcha <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646225492\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>Hi there!</p>\n<p>Yes, I have been using this in my embedding and its been working fine, and returning the Extern as expected.</p>\n<p>However, there has been something bugging me, and I am not sure if it is related or not. I am observing <code>wasmtime_func_call()</code> leaking some memory every time it is invoked. Details:</p>\n<p>I've been using this new API like so:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">wasm_name_t</span>        <span class=\"n\">mod_name</span><span class=\"p\">,</span>  <span class=\"n\">func_name</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_extern_t</span>     <span class=\"o\">*</span><span class=\"n\">func_extern</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_func_t</span>       <span class=\"o\">*</span><span class=\"n\">func</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* ... */</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_linker_get_one_by_name</span><span class=\"p\">(</span><span class=\"n\">linker</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">wasm_extern_as_func</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_func_call</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">trap</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasm_extern_delete</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span> <span class=\"o\">||</span> <span class=\"n\">trap</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n<p>In a gdb session, I observe 1152Kb being allocated <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/src/func.rs#L225\">here</a> and never freed. This amount of memory sounded a lot like the default wasm stack to me, but even when I update the stack size in my Engine's config, I still see the same 1152Kb allocations.</p>\n<p>Am I missing something here? I'm not sure if this is caused by a mistake in my use of <code>wasmtime_func_call()</code> or in this new C API...</p>\n</blockquote>",
        "id": 201305676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592503912
    },
    {
        "content": "<p>thibaultcha edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646225492\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>Hi there!</p>\n<p>Yes, I have been using this in my embedding and its been working fine, and returning the Extern as expected.</p>\n<p>However, there has been something bugging me, and I am not sure if it is related or not. I am observing <code>wasmtime_func_call()</code> leaking some memory every time it is invoked. Details:</p>\n<p>I've been using this new API like so:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// static_memory_maximum_size = 0 for testing</span>\n\n<span class=\"n\">wasm_name_t</span>        <span class=\"n\">mod_name</span><span class=\"p\">,</span>  <span class=\"n\">func_name</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_extern_t</span>     <span class=\"o\">*</span><span class=\"n\">func_extern</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_func_t</span>       <span class=\"o\">*</span><span class=\"n\">func</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* ... */</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_linker_get_one_by_name</span><span class=\"p\">(</span><span class=\"n\">linker</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">wasm_extern_as_func</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_func_call</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">trap</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasm_extern_delete</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span> <span class=\"o\">||</span> <span class=\"n\">trap</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n<p>In a gdb session, I observe 1152Kb being allocated <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/src/func.rs#L225\">here</a> and never freed. This amount of memory sounded a lot like the default wasm stack to me, but even when I update the stack size in my Engine's config, I still see the same 1152Kb allocations.</p>\n<p>Am I missing something here? I'm not sure if this is caused by a mistake in my use of <code>wasmtime_func_call()</code> or in this new C API...</p>\n</blockquote>",
        "id": 201309933,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592506093
    },
    {
        "content": "<p>thibaultcha edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646225492\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>Hi there!</p>\n<p>Yes, I have been using this in my embedding and its been working fine, and returning the Extern as expected.</p>\n<p>However, there has been something bugging me, and I am not sure if it is related or not. I am observing <code>wasmtime_func_call()</code> leaking some memory every time it is invoked. Details:</p>\n<p>I've been using this new API like so:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// static_memory_maximum_size = 0 for testing</span>\n\n<span class=\"n\">wasm_name_t</span>        <span class=\"n\">mod_name</span><span class=\"p\">,</span>  <span class=\"n\">func_name</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_extern_t</span>     <span class=\"o\">*</span><span class=\"n\">func_extern</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_func_t</span>       <span class=\"o\">*</span><span class=\"n\">func</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* ... */</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_linker_get_one_by_name</span><span class=\"p\">(</span><span class=\"n\">linker</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">wasm_extern_as_func</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span> <span class=\"c1\">// this function is a nop</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_func_call</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">trap</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasm_extern_delete</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span> <span class=\"o\">||</span> <span class=\"n\">trap</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n<p>In a gdb session, I observe 1152Kb being allocated <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/src/func.rs#L225\">here</a> and never freed. This amount of memory sounded a lot like the default wasm stack to me, but even when I update the stack size in my Engine's config, I still see the same 1152Kb allocations.</p>\n<p>Am I missing something here? I'm not sure if this is caused by a mistake in my use of <code>wasmtime_func_call()</code> or in this new C API...</p>\n</blockquote>",
        "id": 201310026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592506144
    },
    {
        "content": "<p>thibaultcha edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646225492\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>Hi there!</p>\n<p>Yes, I have been using this in my embedding and its been working fine, and returning the Extern as expected.</p>\n<p>However, there has been something bugging me, and I am not sure if it is related or not. I am observing <code>wasmtime_func_call()</code> leaking some memory every time it is invoked. Details:</p>\n<p>I've been using this new API like so:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// static_memory_maximum_size = 0 for testing</span>\n\n<span class=\"n\">wasm_name_t</span>        <span class=\"n\">mod_name</span><span class=\"p\">,</span>  <span class=\"n\">func_name</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_extern_t</span>     <span class=\"o\">*</span><span class=\"n\">func_extern</span><span class=\"p\">;</span>\n<span class=\"n\">wasm_func_t</span>       <span class=\"o\">*</span><span class=\"n\">func</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* ... */</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_linker_get_one_by_name</span><span class=\"p\">(</span><span class=\"n\">linker</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_name</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">wasm_extern_as_func</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span> <span class=\"c1\">// this function is a nop</span>\n\n<span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">wasmtime_func_call</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">trap</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasm_extern_delete</span><span class=\"p\">(</span><span class=\"n\">func_extern</span><span class=\"p\">);</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error</span> <span class=\"o\">||</span> <span class=\"n\">trap</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n<p>In a gdb session, I observe 1152Kb being allocated <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/src/func.rs#L225\">here</a> and never freed. This amount of memory sounded a lot like the default wasm stack to me, but even when I update the stack size in my Engine's config, I still see the same 1152Kb allocations. When I remove the <code>static_memory_maximum_size = 0</code> setting, I see the 6Gb of static memory being allocated and never freed for every call. Aren't these Externs in the Linker already backed by an underlying Instance?</p>\n<p>Am I missing something here? I'm not sure if this is caused by a mistake in my use of <code>wasmtime_func_call()</code> or in this new C API...</p>\n</blockquote>",
        "id": 201312623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592507323
    },
    {
        "content": "<p>thibaultcha <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646264820\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>It does make it hard to use indeed! I found out what the issue is, although I cannot explain quite why without digging into the Linker. Said Linker does not have WASI defined, and the function was declared in a module as such:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">_start</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// nop</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Turns out that changing the name from <code>_start</code> to, e.g. <code>my_func</code> does not trigger the allocation/leak issue anymore. I recall that <code>_start</code> isn't really supposed to be part of a Reactor module (am I wrong?), so I don't mind much renaming it; nonetheless, the behaviour seems to highlight and underlying, problematic issue, isn't it?</p>\n</blockquote>",
        "id": 201315254,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592508841
    },
    {
        "content": "<p>thibaultcha edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646264820\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>It does make it hard to use indeed! I found out what the issue is, although I cannot explain quite why without digging into the Linker. Said Linker does not have WASI defined, and the function was declared in a module as such:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">_start</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// nop</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Turns out that changing the name from <code>_start</code> to, e.g. <code>my_func</code> does not trigger the allocation/leak issue anymore. I recall that <code>_start</code> isn't really supposed to be part of a Reactor module (am I wrong?), so I don't mind much renaming it; nonetheless, the behaviour seems to highlight an underlying, problematic issue, doesnâ€™t it?</p>\n</blockquote>",
        "id": 201318298,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592510265
    },
    {
        "content": "<p>thibaultcha <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646306779\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>One more somewhat related question on memory management via the C API: should I expect <code>wasmtime_linker_delete()</code>/<code>wasm_store_delete()</code>/<code>wasm_engine_delete()</code> to properly free all of the underlying instances of my Modules?</p>\n<p>Valgrind seems to have a lot of complaints about me calling these, below is an excerpt of the Valgrind output when calling the above 3 functions on my single Linker/Store/Engine during my application's exit.:</p>\n<div class=\"codehilite\"><pre><span></span><code>==3218139== 488 bytes in 1 blocks are still reachable in loss record 66 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x5048BBB: alloc::alloc::alloc (alloc.rs:80)\n==3218139==    by 0x5048FF3: &lt;alloc::alloc::Global as core::alloc::AllocRef&gt;::alloc (alloc.rs:174)\n==3218139==    by 0x5048B14: alloc::alloc::exchange_malloc (alloc.rs:268)\n==3218139==    by 0x507420D: alloc::sync::Arc&lt;T&gt;::new (sync.rs:323)\n==3218139==    by 0x5055E7A: wasmtime_jit::instantiate::CompiledModule::new (instantiate.rs:145)\n==3218139==    by 0x4FB2663: wasmtime::module::Module::compile (module.rs:304)\n==3218139==    by 0x4FB249F: wasmtime::module::Module::from_binary_unchecked (module.rs:275)\n==3218139==    by 0x4FB2469: wasmtime::module::Module::from_binary (module.rs:244)\n==3218139==    by 0x4B1BEFD: wasmtime_module_new (module.rs:56)\n==3218139==    by 0x4DA9B1: [my_embedding] ([my_embedding].c:298)\n==3218139==\n==3218139== 640 bytes in 8 blocks are still reachable in loss record 72 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x5EDC62F: alloc (alloc.rs:80)\n==3218139==    by 0x5EDC62F: alloc (alloc.rs:174)\n==3218139==    by 0x5EDC62F: exchange_malloc (alloc.rs:268)\n==3218139==    by 0x5EDC62F: new&lt;std::thread::Inner&gt; (sync.rs:323)\n==3218139==    by 0x5EDC62F: std::thread::Thread::new (mod.rs:1141)\n==3218139==    by 0x598D95D: std::thread::Builder::spawn_unchecked (mod.rs:462)\n==3218139==    by 0x598E2CB: std::thread::Builder::spawn (mod.rs:386)\n==3218139==    by 0x596FB58: &lt;rayon_core::registry::DefaultSpawn as rayon_core::registry::ThreadSpawn&gt;::spawn (registry.rs:101)\n==3218139==    by 0x5970862: rayon_core::registry::Registry::new (registry.rs:257)\n==3218139==    by 0x596FDCD: rayon_core::registry::global_registry::{{closure}} (registry.rs:168)\n==3218139==    by 0x596FF59: rayon_core::registry::set_global_registry::{{closure}} (registry.rs:194)\n==3218139==    by 0x5973C23: std::sync::once::Once::call_once::{{closure}} (once.rs:264)\n==3218139==    by 0x5EE6F47: std::sync::once::Once::call_inner (once.rs:416)\n==3218139==    by 0x5973B50: std::sync::once::Once::call_once (once.rs:264)\n==3218139==    by 0x596FE9A: rayon_core::registry::set_global_registry (registry.rs:193)\n==3218139==\n==3218139== 704 bytes in 1 blocks are indirectly lost in loss record 73 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x4B3BA4B: alloc::alloc::alloc (alloc.rs:80)\n==3218139==    by 0x4B3BE83: &lt;alloc::alloc::Global as core::alloc::AllocRef&gt;::alloc (alloc.rs:174)\n==3218139==    by 0x4AE9B76: alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in (raw_vec.rs:152)\n==3218139==    by 0x4AEDBDB: alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in (raw_vec.rs:135)\n==3218139==    by 0x4AE62FD: alloc::raw_vec::RawVec&lt;T&gt;::with_capacity (raw_vec.rs:92)\n==3218139==    by 0x4B4075D: alloc::vec::Vec&lt;T&gt;::with_capacity (vec.rs:358)\n==3218139==    by 0x4B4DC63: &lt;alloc::vec::Vec&lt;T&gt; as alloc::vec::SpecExtend&lt;T,I&gt;&gt;::from_iter (vec.rs:2073)\n==3218139==    by 0x4B5146B: &lt;alloc::vec::Vec&lt;T&gt; as core::iter::traits::collect::FromIterator&lt;T&gt;&gt;::from_iter (vec.rs:1981)\n==3218139==    by 0x4AFF6EF: core::iter::traits::iterator::Iterator::collect (iterator.rs:1660)\n==3218139==    by 0x4B3AEB8: wasmtime::module::wasmtime_module_new::{{closure}} (module.rs:61)\n==3218139==    by 0x4B2858D: wasmtime::error::handle_result (error.rs:30)\n\n...\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201326453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592514538
    },
    {
        "content": "<p>thibaultcha edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-646306779\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>One more somewhat related question on memory management via the C API: should I expect <code>wasmtime_linker_delete()</code>/<code>wasm_store_delete()</code>/<code>wasm_engine_delete()</code> to properly free all of the underlying instances of my Modules?</p>\n<p>Valgrind seems to have a lot of complaints about me calling these, below is an excerpt of the Valgrind output when calling the above 3 functions on my single Linker/Store/Engine during my application's exit:</p>\n<div class=\"codehilite\"><pre><span></span><code>==3218139== 488 bytes in 1 blocks are still reachable in loss record 66 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x5048BBB: alloc::alloc::alloc (alloc.rs:80)\n==3218139==    by 0x5048FF3: &lt;alloc::alloc::Global as core::alloc::AllocRef&gt;::alloc (alloc.rs:174)\n==3218139==    by 0x5048B14: alloc::alloc::exchange_malloc (alloc.rs:268)\n==3218139==    by 0x507420D: alloc::sync::Arc&lt;T&gt;::new (sync.rs:323)\n==3218139==    by 0x5055E7A: wasmtime_jit::instantiate::CompiledModule::new (instantiate.rs:145)\n==3218139==    by 0x4FB2663: wasmtime::module::Module::compile (module.rs:304)\n==3218139==    by 0x4FB249F: wasmtime::module::Module::from_binary_unchecked (module.rs:275)\n==3218139==    by 0x4FB2469: wasmtime::module::Module::from_binary (module.rs:244)\n==3218139==    by 0x4B1BEFD: wasmtime_module_new (module.rs:56)\n==3218139==    by 0x4DA9B1: [my_embedding] ([my_embedding].c:298)\n==3218139==\n==3218139== 640 bytes in 8 blocks are still reachable in loss record 72 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x5EDC62F: alloc (alloc.rs:80)\n==3218139==    by 0x5EDC62F: alloc (alloc.rs:174)\n==3218139==    by 0x5EDC62F: exchange_malloc (alloc.rs:268)\n==3218139==    by 0x5EDC62F: new&lt;std::thread::Inner&gt; (sync.rs:323)\n==3218139==    by 0x5EDC62F: std::thread::Thread::new (mod.rs:1141)\n==3218139==    by 0x598D95D: std::thread::Builder::spawn_unchecked (mod.rs:462)\n==3218139==    by 0x598E2CB: std::thread::Builder::spawn (mod.rs:386)\n==3218139==    by 0x596FB58: &lt;rayon_core::registry::DefaultSpawn as rayon_core::registry::ThreadSpawn&gt;::spawn (registry.rs:101)\n==3218139==    by 0x5970862: rayon_core::registry::Registry::new (registry.rs:257)\n==3218139==    by 0x596FDCD: rayon_core::registry::global_registry::{{closure}} (registry.rs:168)\n==3218139==    by 0x596FF59: rayon_core::registry::set_global_registry::{{closure}} (registry.rs:194)\n==3218139==    by 0x5973C23: std::sync::once::Once::call_once::{{closure}} (once.rs:264)\n==3218139==    by 0x5EE6F47: std::sync::once::Once::call_inner (once.rs:416)\n==3218139==    by 0x5973B50: std::sync::once::Once::call_once (once.rs:264)\n==3218139==    by 0x596FE9A: rayon_core::registry::set_global_registry (registry.rs:193)\n==3218139==\n==3218139== 704 bytes in 1 blocks are indirectly lost in loss record 73 of 97\n==3218139==    at 0x483A809: malloc (vg_replace_malloc.c:307)\n==3218139==    by 0x4B3BA4B: alloc::alloc::alloc (alloc.rs:80)\n==3218139==    by 0x4B3BE83: &lt;alloc::alloc::Global as core::alloc::AllocRef&gt;::alloc (alloc.rs:174)\n==3218139==    by 0x4AE9B76: alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in (raw_vec.rs:152)\n==3218139==    by 0x4AEDBDB: alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in (raw_vec.rs:135)\n==3218139==    by 0x4AE62FD: alloc::raw_vec::RawVec&lt;T&gt;::with_capacity (raw_vec.rs:92)\n==3218139==    by 0x4B4075D: alloc::vec::Vec&lt;T&gt;::with_capacity (vec.rs:358)\n==3218139==    by 0x4B4DC63: &lt;alloc::vec::Vec&lt;T&gt; as alloc::vec::SpecExtend&lt;T,I&gt;&gt;::from_iter (vec.rs:2073)\n==3218139==    by 0x4B5146B: &lt;alloc::vec::Vec&lt;T&gt; as core::iter::traits::collect::FromIterator&lt;T&gt;&gt;::from_iter (vec.rs:1981)\n==3218139==    by 0x4AFF6EF: core::iter::traits::iterator::Iterator::collect (iterator.rs:1660)\n==3218139==    by 0x4B3AEB8: wasmtime::module::wasmtime_module_new::{{closure}} (module.rs:61)\n==3218139==    by 0x4B2858D: wasmtime::error::handle_result (error.rs:30)\n\n...\n</code></pre></div>\n\n\n</blockquote>",
        "id": 201326463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592514547
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-648369363\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>I've opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1913\">https://github.com/bytecodealliance/wasmtime/issues/1913</a> to track the leak issues you were encountering.</p>\n<p>Otherwise for API usage you'll want to <code>*_delete(..)</code> every handle you're given ownership of, but if you do that then no memory should be leaked.</p>\n<p>And finally, this looks good otherwise, so I'm going to go ahead and merge!</p>\n<p>Feel free to ping me on Zulip if you've still got memory issues though</p>\n</blockquote>",
        "id": 201770673,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592940227
    },
    {
        "content": "<p>thibaultcha <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897#issuecomment-648370144\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1897\">Issue #1897</a>:</p>\n<blockquote>\n<p>@alexcrichton I was writing something here to clarify that I read your comment at <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1902#issuecomment-648330651\">https://github.com/bytecodealliance/wasmtime/issues/1902#issuecomment-648330651</a> which answered my above question. Anyway, thank you for detailing it once again!</p>\n<p>Thanks for the merge too.</p>\n</blockquote>",
        "id": 201770853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592940319
    }
]