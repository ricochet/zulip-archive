[
    {
        "content": "<p>yurydelendik opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1518\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1518\">Issue #1518</a>:</p>\n<blockquote>\n<p>C global variables (such as <code>double s = 0;</code>) are compiled to WebAssembly as locations in the memory. The produced DWARF describes them as DIEs with <code>DW_AT_location</code> attribute that points to that memory address, e.g.:</p>\n<div class=\"codehilite\"><pre><span></span>0x00000072:   DW_TAG_variable\n                DW_AT_name  (&quot;s&quot;)\n                DW_AT_type  (0x00000083 &quot;double&quot;)\n                DW_AT_external  (true)\n                DW_AT_decl_file (&quot;/Users/yury/Work/wasmtime/t.c&quot;)\n                DW_AT_decl_line (11)\n                DW_AT_location  (DW_OP_addr 0x410)\n</pre></div>\n\n\n<p>The wasmtime does not attempt to transform such locations since it needs \"vmctx\". In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1482\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1482\">https://github.com/bytecodealliance/wasmtime/pull/1482</a> , we used some global state, accessible to debugger, to resolve pointers. It is possible to do the same for <code>DW_OP_addr</code> in static variables expression: user sets current vmctx in some global memory and a debugger gets it in DWARF expressions (in crates/debug/transform/expression.rs). Though we need to able to <a href=\"https://github.com/gimli-rs/gimli/issues/474\" title=\"https://github.com/gimli-rs/gimli/issues/474\">relocate the data in the DWARF expression written by gimli</a> to make this work.</p>\n<p>The similar approach can be used for transformation of <code>DW_OP_Wasm_location wasm-global</code> operation.</p>\n</blockquote>",
        "id": 194231493,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586986885
    }
]