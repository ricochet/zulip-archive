[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265264656\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTW the purpose of the membarrier() call is not cache maintenance, but rather flushing the processor pipeline (refer to the discussion in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3426\">https://github.com/bytecodealliance/wasmtime/pull/3426</a> for more details), so this means that there is still a gap in the implementation on Windows. Looking at Microsoft's documentation, <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers\">FlushProcessWriteBuffers()</a> seems to have the necessary semantics.</p>\n</blockquote>\n<p>The documentation for FlushInstructionCache says:</p>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache\">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache</a></p>\n<blockquote>\n<p>Applications should call FlushInstructionCache if they generate or modify code in memory. The CPU cannot detect the change, and may execute the old code it cached.</p>\n</blockquote>\n<p>So it seems that FlushInstructionCache must always be called no matter if FlushProcessWriteBuffers is called or not.</p>\n</blockquote>",
        "id": 302039317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664794244
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265272288\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Yes, I am not claiming that <code>FlushProcessWriteBuffers()</code> replaces <code>FlushInstructionCache()</code> - my point is that it (or something else with the necessary semantics) should be used after the latter, unless <code>FlushInstructionCache()</code> also performs an implicit broadcast <code>ISB</code> operation in all running threads of the process (which the documentation doesn't suggest, to me at least). Similarly, as I mentioned on Linux <code>membarrier()</code> does not flush instruction caches.</p>\n</blockquote>",
        "id": 302040420,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664794731
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265272288\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Yes, I am not claiming that <code>FlushProcessWriteBuffers()</code> replaces <code>FlushInstructionCache()</code> - my point is that it (or something else with the necessary semantics) should be used after the latter, unless <code>FlushInstructionCache()</code> also performs an implicit broadcast <code>ISB</code> operation in all running threads of the process (which the documentation doesn't suggest, to me at least). Similarly, as I mentioned on Linux <code>membarrier()</code> does not flush instruction caches.</p>\n<p><strong>P.S.</strong> The same considerations about single-threaded applications apply to <code>FlushProcessWriteBuffers()</code> as well, of course.</p>\n</blockquote>",
        "id": 302040778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664794882
    },
    {
        "content": "<p>akirilov-arm edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265272288\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Yes, I am not claiming that <code>FlushProcessWriteBuffers()</code> replaces <code>FlushInstructionCache()</code> - my point is that it (or something else with the necessary semantics) should be used after the latter, unless <code>FlushInstructionCache()</code> also performs an implicit broadcast <code>ISB</code> operation to all running threads of the process (which the documentation doesn't suggest, to me at least). Similarly, as I mentioned on Linux <code>membarrier()</code> does not flush instruction caches.</p>\n<p><strong>P.S.</strong> The same considerations about single-threaded applications apply to <code>FlushProcessWriteBuffers()</code> as well, of course.</p>\n</blockquote>",
        "id": 302040841,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664794912
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265284778\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Thanks for reviewing this!</p>\n<blockquote>\n<p>BTW the purpose of the membarrier() call is not cache maintenance, but rather flushing the processor pipeline (refer to the discussion in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3426\">https://github.com/bytecodealliance/wasmtime/pull/3426</a> for more details), so this means that there is still a gap in the implementation on Windows. Looking at Microsoft's documentation, <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers\">FlushProcessWriteBuffers()</a> seems to have the necessary semantics.</p>\n</blockquote>\n<p>So, if I understand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3310\">https://github.com/bytecodealliance/wasmtime/issues/3310</a> correctly we need to both flush the icache (<code>clear_cache</code> / <code>FlushInstructionCache</code>) and then subsequently also flush the pipeline (<code>membarrier</code> / <code>FlushProcessWriteBuffers</code>).  The flush only needs to happen in multi threaded environments but we cant easily detect that.</p>\n<p>Is that right? If that is the case I might as well just clean up the terminology and add a <code>clear_cache</code> call for linux and that also fixes #3310 right?</p>\n</blockquote>",
        "id": 302042160,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664795447
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265284778\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Thanks for reviewing this! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️ </p>\n<blockquote>\n<p>BTW the purpose of the membarrier() call is not cache maintenance, but rather flushing the processor pipeline (refer to the discussion in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3426\">https://github.com/bytecodealliance/wasmtime/pull/3426</a> for more details), so this means that there is still a gap in the implementation on Windows. Looking at Microsoft's documentation, <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers\">FlushProcessWriteBuffers()</a> seems to have the necessary semantics.</p>\n</blockquote>\n<p>So, if I understand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3310\">https://github.com/bytecodealliance/wasmtime/issues/3310</a> correctly we need to both flush the icache (<code>clear_cache</code> / <code>FlushInstructionCache</code>) and then subsequently also flush the pipeline (<code>membarrier</code> / <code>FlushProcessWriteBuffers</code>).  The flush only needs to happen in multi threaded environments but we cant easily detect that.</p>\n<p>Is that right? If that is the case I might as well just clean up the terminology and add a <code>clear_cache</code> call for linux and that also fixes #3310 right?</p>\n</blockquote>",
        "id": 302042188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664795459
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265284778\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Thanks for reviewing this! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️ </p>\n<blockquote>\n<p>BTW the purpose of the membarrier() call is not cache maintenance, but rather flushing the processor pipeline (refer to the discussion in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3426\">https://github.com/bytecodealliance/wasmtime/pull/3426</a> for more details), so this means that there is still a gap in the implementation on Windows. Looking at Microsoft's documentation, <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers\">FlushProcessWriteBuffers()</a> seems to have the necessary semantics.</p>\n</blockquote>\n<p>So, if I understand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3310\">https://github.com/bytecodealliance/wasmtime/issues/3310</a> correctly we need to both flush the icache (<code>clear_cache</code> / <code>FlushInstructionCache</code>) and then subsequently also flush the pipeline (<code>membarrier</code> / <code>FlushProcessWriteBuffers</code>).  The pipeline flush only needs to happen in multi threaded environments but we cant easily detect that.</p>\n<p>Is that right? If that is the case I might as well just clean up the terminology and add a <code>clear_cache</code> call for linux and that also fixes #3310 right?</p>\n</blockquote>",
        "id": 302042214,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664795474
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265359359\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is that right?</p>\n</blockquote>\n<p>Yes, your understanding is correct. Technically the pipeline flush is always mandatory, but all implementations of <code>__builtin___clear_cache()</code> that I am aware of end with an <code>ISB</code> instruction (and I'd guess that <code>FlushInstructionCache()</code> does too) and furthermore a system call (e.g. the subsequent change of the memory page permissions to executable, since we don't use RWX mappings) is a context synchronization operation as well.</p>\n<p>The ideal solution, which I had in mind when I opened #3310, would be to have a generic <code>clear_cache()</code> function (probably in the <a href=\"https://crates.io/crates/compiler_builtins\">compiler-builtins</a> crate to mirror what GCC and LLVM are doing; I am not aware of anything like that existing, but I would be happy to be proven wrong). Then we would call that function, followed by <code>membarrier()</code>/<code>FlushProcessWriteBuffers()</code>, finishing with making the memory executable. The order of the last 2 operations does not matter (as long as no one tries to run the newly executable code without a pipeline flush before that), but I think that this sequence looks nicer.</p>\n<p>Note that it might appear that on Linux we don't flush instruction caches, so there might be a correctness issue. Actually we are relying on an implementation detail (as discussed in #3426), but I'd rather see an explicit operation, hence I have kept #3310 open. However, I would advise against implementing the cache flushing instruction sequence inside Cranelift and/or Wasmtime because it is a bit involved and a solution that is easily accessible to all Rust users on AArch64 is a much better option. In the meantime we can continue relying on an implementation detail; any other cleanup would be appreciated, of course.</p>\n</blockquote>",
        "id": 302051848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664799596
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265373020\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<blockquote>\n<p>probably in the <a href=\"https://crates.io/crates/compiler_builtins\">compiler-builtins</a> crate to mirror what GCC and LLVM are doing</p>\n</blockquote>\n<p>It should rather be in libcore as compiler-builtins is an implementation detail of rustc to be used by the compiler backend and never directly called by the user.</p>\n</blockquote>",
        "id": 302053712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664800326
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265615723\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Alright I think I understand this a little bit more! Thank you for your patience dealing with this.</p>\n<blockquote>\n<p>However, I would advise against implementing the cache flushing instruction sequence inside Cranelift and/or Wasmtime because it is a bit involved and a solution that is easily accessible to all Rust users on AArch64 is a much better option. In the meantime we can continue relying on an implementation detail; any other cleanup would be appreciated, of course.</p>\n</blockquote>\n<p>Yeah I also doubt I could write anything like that correctly <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> So I'm not very inclined to go that route.</p>\n<p>What I think we could do is something along the lines of what @cfallin suggested on <a href=\"#narrow/stream/217126-wasmtime/topic/Code.20generation.20and.20CPU.20cache.20maintenance/near/252357510\">zulip</a> create a <code>jit-icache-coherence</code> crate with the interface that we want, use that on both <code>wasmtime-jit</code> and <code>cranelift-jit</code>. This at least shares the windows implementation between both crates, we still need to duplicate the membarriers between <code>rsix</code> and <code>libc</code> since we want to keep those separate. But at least it is a little bit more organized.</p>\n<p>For <code>__builtin___clear_cache()</code> can we for now link it in from a C file as you suggested? And later on use a version from <code>libcore</code> if one gets upstreamed. Or if we don't want to do that on wasmtime (due to not using <code>rsix</code>, not sure if that is a requirement), we can ignore it for now and have essentially the same implementation but shared with cranelift.</p>\n<p>What do you guys think about this?</p>\n<blockquote>\n<p>Note that it might appear that on Linux we don't flush instruction caches, so there might be a correctness issue. Actually we are relying on an implementation detail (as discussed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3426\">https://github.com/bytecodealliance/wasmtime/pull/3426</a>), but I'd rather see an explicit operation, hence I have kept <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3310\">https://github.com/bytecodealliance/wasmtime/issues/3310</a> open.</p>\n</blockquote>\n<p>Yeah that confused me for a while! This whole thing is not easy to understand. I'd really like to get this in a central place and write all of these details in comments around this code.</p>\n</blockquote>",
        "id": 302083797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664809889
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1265722200\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<blockquote>\n<p>For <code>__builtin___clear_cache()</code> can we for now link it in from a C file as you suggested?</p>\n</blockquote>\n<p>That is certainly an option, but my impression is that we are trying to move away from relying on C files as much as possible (refer to the refactoring that has been done in the <code>wasmtime-fiber</code> crate, for instance), and given that on Linux we are kind of OK at the moment, IMHO it might not be the best course of action.</p>\n<p>As for creating a crate to be used by both <code>cranelift-jit</code> and <code>wasmtime-jit</code>, since the issue was that <code>cranelift-jit</code> should not depend on <code>rustix</code>, I am not sure how much sharing would be possible, though we do have the option of just implementing the <code>libc</code> variant (and avoiding <code>rustix</code> completely). That would also help with consolidating the locations that @cfallin needs to change in #4987.</p>\n</blockquote>",
        "id": 302099893,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664814675
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1267408973\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I've implemented a new crate <code>jit-icache-coherency</code>, that merges all of this code together so that we don't have to update stuff in multiple places, it also provides a common interface that both <code>wasmtime-jit</code> and <code>cranelift-jit</code> can use.</p>\n<p>It does change our call's to <code>SYNC_CORE</code> membarriers, using the new method suggested by @akirilov-arm. We now execute <code>SYNC_CORE</code>  and if it fails we retry after registering it. This should only happen once per process, so I don't think its too much overhead.</p>\n<p>It also includes the changes made by @cfallin in  #4987 since I thought it was just easier to do it here instead of having to deal with the ensuing merge conflicts.</p>\n<p>I've tried to explain the whole cache coherency thing as best as I could in the documentation, hopefully I didn't miss anything!</p>\n</blockquote>",
        "id": 302322349,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664908192
    },
    {
        "content": "<p>akirilov-arm <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1268565068\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Forgot to post a general comment with my review - the overall code structure looks great and is definitely cleaner than what we had before; my remarks are mostly about improving the code comments. Also, as I have said before I am fine with just implementing the <code>libc</code> code path (and omitting the <code>rustix</code> one).</p>\n</blockquote>",
        "id": 302481879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664983393
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1268694802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I think I got all of them, let me know if I missed any of the changes that you requested. And thanks for you patience in dealing with this! I'm still very much learning about all of this stuff.</p>\n<blockquote>\n<p>Also, as I have said before I am fine with just implementing the libc code path (and omitting the rustix one).</p>\n</blockquote>\n<p>I'm okay with libc too, but would like an ack from someone on the wasmtime side if we want to do that.</p>\n</blockquote>",
        "id": 302502590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664989260
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1274577025\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I had to add a flags arg to membarrier on libc since on my aarch64 machine it wasn't being properly added, somehow cranelift never triggered this. I've confirmed with <code>strace</code> and the membarrier is now being properly executed, and the register on fail trick is working.</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">EPERM</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Operation</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">permitted</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 303422688,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665489931
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1274577025\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I had to add a flags arg to membarrier on libc since on my aarch64 machine it wasn't being properly added, somehow cranelift never triggered this. I've confirmed with <code>strace</code> and the membarrier is now being properly executed, and the register on fail trick is working.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">EPERM</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Operation</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">permitted</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there a way to test the GLOBAL path on modern kernels?</p>\n</blockquote>",
        "id": 303423162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665489983
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1274577025\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I had to add a flags arg to membarrier on libc since on my aarch64 machine it wasn't being properly added, somehow cranelift never triggered this. I've confirmed with <code>strace</code> and the membarrier is now being properly executed, and the register on fail trick is working.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">EPERM</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Operation</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">permitted</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there a way to test the GLOBAL path on modern kernels? i.e. fail MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE with EINVAL?</p>\n</blockquote>",
        "id": 303423226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665490016
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1274577025\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>I had to add a flags arg to membarrier on libc since on my aarch64 machine it wasn't being properly added, somehow cranelift never triggered this. I've confirmed with <code>strace</code> and the membarrier is now being properly executed, and the register on fail trick is working.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">EPERM</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Operation</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">permitted</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">pid</span><span class=\"w\"> </span><span class=\"mi\">615515</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">membarrier</span><span class=\"p\">(</span><span class=\"n\">MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there a way to test the GLOBAL path on modern kernels? i.e. fail <code>MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE</code> with <code>EINVAL</code>?</p>\n</blockquote>",
        "id": 303423247,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665490024
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1274632988\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Right, I just wanted to check if there was an easy way to add a test that forces us to use GLOBAL so that we at least have some CI coverage on that branch. But I tested that manually and it worked, so I guess that's ok.</p>\n</blockquote>",
        "id": 303429817,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665492340
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276418359\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Hey, @alexcrichton @sunfishcode we discussed this in the cranelift meeting today, and @cfallin mentioned that you might be interested in this PR as (in its current form) changes wasmtime to use libc on this particular <code>membarrier</code> call. </p>\n<p>As a summary: We got to this situation when I merged this particular piece of code from <code>wasmtime-jit</code> and <code>cranelift-jit</code>, both those crates have to do the exact same thing when it comes to icache mainetenance, after merging we had two backends which do exactly the same thing, and to avoid having duplicated code we need to decide on one.</p>\n<p>wasmtime already has libc on its dependency tree, but cranelift does not have rustix yet, so to avoid adding more stuff to the compilation path, I decided to keep libc.</p>\n<p>I'd like to know if this is okay with you guys.</p>\n</blockquote>",
        "id": 303671979,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665590863
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276418359\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Hey, @alexcrichton @sunfishcode we discussed this in the cranelift meeting today, and @cfallin mentioned that you might be interested in this PR as (in its current form) it changes wasmtime to use libc on this particular <code>membarrier</code> call. </p>\n<p>As a summary: We got to this situation when I merged this particular piece of code from <code>wasmtime-jit</code> and <code>cranelift-jit</code>, both those crates have to do the exact same thing when it comes to icache mainetenance, after merging we had two backends which do exactly the same thing, and to avoid having duplicated code we need to decide on one.</p>\n<p>wasmtime already has libc on its dependency tree, but cranelift does not have rustix yet, so to avoid adding more stuff to the compilation path, I decided to keep libc.</p>\n<p>I'd like to know if this is okay with you guys.</p>\n</blockquote>",
        "id": 303672057,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665590883
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276418359\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Hey, @alexcrichton @sunfishcode we discussed this in the cranelift meeting today, and @cfallin mentioned that you might be interested in this PR as (in its current form) it changes wasmtime to use libc on this particular <code>membarrier</code> call. </p>\n<p>As a summary: We got to this situation when I merged this particular piece of code from <code>wasmtime-jit</code> and <code>cranelift-jit</code>, both of those crates have to do the exact same thing when it comes to icache mainetenance, after merging we had two backends which do exactly the same thing, and to avoid having duplicated code we need to decide on one.</p>\n<p>wasmtime already has libc on its dependency tree, but cranelift does not have rustix yet, so to avoid adding more stuff to the compilation path, I decided to keep libc.</p>\n<p>I'd like to know if this is okay with you guys.</p>\n</blockquote>",
        "id": 303672140,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665590903
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276419477\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Yes, that makes sense!</p>\n</blockquote>",
        "id": 303672159,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665590912
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276418359\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Hey, @alexcrichton @sunfishcode we discussed this in the cranelift meeting today, and @cfallin mentioned that you might be interested in this PR as (in its current form) it changes wasmtime to use libc on this particular <code>membarrier</code> call. </p>\n<p>As a summary: We got to this situation when I merged this particular piece of code from <code>wasmtime-jit</code> and <code>cranelift-jit</code>, both of those crates have to do the exact same thing when it comes to icache maintenance. After merging we had two backends which do exactly the same thing, and to avoid having duplicated code we need to decide on one.</p>\n<p>wasmtime already has libc on its dependency tree, but cranelift does not have rustix yet, so to avoid adding more stuff to the compilation path, I decided to keep libc.</p>\n<p>I'd like to know if this is okay with you guys.</p>\n</blockquote>",
        "id": 303672177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665590916
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997#issuecomment-1276436851\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4997\">issue #4997</a>:</p>\n<blockquote>\n<p>Indeed seems reasonable to me!</p>\n</blockquote>",
        "id": 303674630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1665591746
    }
]