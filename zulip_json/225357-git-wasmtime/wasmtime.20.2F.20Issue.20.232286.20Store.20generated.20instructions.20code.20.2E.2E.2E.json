[
    {
        "content": "<p>sirgl opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Usually I explore new API by completion and quick documentation in IDE. For the instructions emission methods (the core API of cranelift) this functionality is absent.</p>\n<p>Now instructions code is generated in <code>cranelift-codegen</code> in during build and then it get inserted into library using include.<br>\nThis allows to have always fresh version of instruction code, but at the same time breaks experience with IDE.<br>\nBoth IntelliJ and rust-analyser can't index code that created during build and can't provide completion/navigation/reliable refactorings.</p>\n<h4>Feature / Implementation</h4>\n<p>Insert generated code for instructions right into library. It will allow IDE index it and provide all information for completion/hover and so on.</p>\n<h4>Benefit</h4>\n<p>Cranelifts' newcomers will be able to explore and understand API quickly.</p>\n<h4>Alternatives</h4>\n<p>Leave everything as is. For newcomers API will still be a bigger problem.</p>\n</blockquote>",
        "id": 212981278,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602449756
    },
    {
        "content": "<p>sirgl edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Usually I explore new API by completion and quick documentation in IDE (and AFAIK most of the people do so). For the instructions emission methods (the core API of cranelift) this functionality is absent. You have to go to online documentation first and then write code.</p>\n<p>Here I would expect to see <code>return_</code>, but there is nothing in completion list.<br>\n![2020-10-11_22-54](<a href=\"https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png\">https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png</a>)</p>\n<p>Now instructions code is generated in <code>cranelift-codegen</code> in during build and then it get inserted into library using include.<br>\nThis allows to have always fresh version of instruction code, but at the same time breaks experience with IDE.<br>\nBoth IntelliJ and rust-analyser can't index code that created during build and can't provide completion/navigation/reliable refactorings. Also it is bad for validation of parameter types.</p>\n<h4>Feature / Implementation</h4>\n<p>Insert generated code for instructions right into library. It will allow IDE index it and provide all information for completion/hover and so on.</p>\n<h4>Benefit</h4>\n<p>Cranelifts' newcomers will be able to explore and understand API quickly.</p>\n<h4>Alternatives</h4>\n<p>Leave everything as is. For newcomers API will still be a bigger problem.</p>\n</blockquote>",
        "id": 212981470,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602450026
    },
    {
        "content": "<p>sirgl edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Usually I explore new API by completion and quick documentation in IDE (and AFAIK most of the people do so). For the instructions emission methods (the core API of cranelift) this functionality is absent. You have to go to online documentation first and then write code.</p>\n<p>Here I would expect to see <code>return_</code>, but there is nothing in completion list.<br>\n![2020-10-11_22-54](<a href=\"https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png\">https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png</a>)</p>\n<p>Now instructions code is generated in <code>cranelift-codegen</code> during build and then it get inserted into library using include.<br>\nThis allows to have always fresh version of instruction code, but at the same time breaks experience with IDE.<br>\nBoth IntelliJ and rust-analyser can't index code that created during build and can't provide completion/navigation/reliable refactorings. Also it is bad for validation of parameter types.</p>\n<h4>Feature / Implementation</h4>\n<p>Insert generated code for instructions right into library. It will allow IDE index it and provide all information for completion/hover and so on.</p>\n<h4>Benefit</h4>\n<p>Cranelifts' newcomers will be able to explore and understand API quickly, IDE will be able to provide inline documentation, refactorings, parameter hints, errors.</p>\n<h4>Alternatives</h4>\n<p>Leave everything as is. For newcomers API will still be a bigger problem.</p>\n</blockquote>",
        "id": 212981534,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602450124
    },
    {
        "content": "<p>sirgl edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Usually I explore new API by completion and quick documentation in IDE (and AFAIK most of the people do so). For the instructions emission methods (the core API of cranelift) this functionality is not working in IntelliJ and rust-analyser. You have to go to online documentation first and then write code.</p>\n<p>Here I would expect to see <code>return_</code>, but there is nothing in completion list.<br>\n![2020-10-11_22-54](<a href=\"https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png\">https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png</a>)</p>\n<p>Now instructions code is generated in <code>cranelift-codegen</code> during build and then it get inserted into library using include.<br>\nThis allows to have always fresh version of instruction code, but at the same time breaks experience with IDE.<br>\nBoth IntelliJ and rust-analyser can't index code that created during build and can't provide completion/navigation/reliable refactorings. Also it is bad for validation of parameter types.</p>\n<h4>Feature / Implementation</h4>\n<p>Insert generated code for instructions right into library. It will allow IDE index it and provide all information for completion/hover and so on.</p>\n<h4>Benefit</h4>\n<p>Cranelifts' newcomers will be able to explore and understand API quickly, IDE will be able to provide inline documentation, refactorings, parameter hints, errors.</p>\n<h4>Alternatives</h4>\n<p>Leave everything as is. For newcomers API will still be a bigger problem.</p>\n</blockquote>",
        "id": 212981559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602450189
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-706775627\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>You can enable support for build script generated code in rust-analyzer using:</p>\n<div class=\"codehilite\" data-code-language=\"jsonc\"><pre><span></span><code>{\n    \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n}\n</code></pre></div>\n\n</blockquote>",
        "id": 212984048,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602454399
    },
    {
        "content": "<p>sirgl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-706883551\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Thank you, then, probably, you should add it to readme to dev instructions.</p>\n</blockquote>",
        "id": 213000269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602482186
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-707240429\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>@sirgl, do you mind creating a PR with that setup information? (And I wonder if there is a way to add OUT dirs to IntelliJ scanning...).</p>\n</blockquote>",
        "id": 213063658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602522415
    },
    {
        "content": "<p>sirgl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-709269933\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Seems that in IntelliJ you can enable <code>org.rust.cargo.evaluate.build.scripts</code> in Experimental Features. Sure, I'll make PR.</p>\n</blockquote>",
        "id": 213415175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1602764295
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-803436022\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Should this be closed?</p>\n</blockquote>",
        "id": 231161404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616263435
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286#issuecomment-804232614\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>I'm think so; there's a way to do this with IDEs using rust-analyzer (e.g. VS Code).</p>\n</blockquote>",
        "id": 231347219,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616432563
    },
    {
        "content": "<p>abrown closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2286\">Issue #2286</a>:</p>\n<blockquote>\n<p>Usually I explore new API by completion and quick documentation in IDE (and AFAIK most of the people do so). For the instructions emission methods (the core API of cranelift) this functionality is not working in IntelliJ and rust-analyser. You have to go to online documentation first and then write code.</p>\n<p>Here I would expect to see <code>return_</code>, but there is nothing in completion list.<br>\n![2020-10-11_22-54](<a href=\"https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png\">https://user-images.githubusercontent.com/11944514/95690071-6ac3de80-0c15-11eb-9a34-acd1352e2214.png</a>)</p>\n<p>Now instructions code is generated in <code>cranelift-codegen</code> during build and then it get inserted into library using include.<br>\nThis allows to have always fresh version of instruction code, but at the same time breaks experience with IDE.<br>\nBoth IntelliJ and rust-analyser can't index code that created during build and can't provide completion/navigation/reliable refactorings. Also it is bad for validation of parameter types.</p>\n<h4>Feature / Implementation</h4>\n<p>Insert generated code for instructions right into library. It will allow IDE index it and provide all information for completion/hover and so on.</p>\n<h4>Benefit</h4>\n<p>Cranelifts' newcomers will be able to explore and understand API quickly, IDE will be able to provide inline documentation, refactorings, parameter hints, errors.</p>\n<h4>Alternatives</h4>\n<p>Leave everything as is. For newcomers API will still be a bigger problem.<br>\n</p>\n</blockquote>",
        "id": 231347234,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1616432568
    }
]