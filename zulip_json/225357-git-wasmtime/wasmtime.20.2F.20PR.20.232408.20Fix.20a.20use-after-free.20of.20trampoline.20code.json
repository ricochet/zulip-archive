[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2408\">PR #2408</a> from <code>fix-use-after-free-trampoline</code> to <code>main</code>:</p>\n<blockquote>\n<p>This commit fixes an issue with wasmtime where it was possible for a<br>\ntrampoline from one module to get used for another module after it was<br>\nfreed. This issue arises because we register a module's native<br>\ntrampolines <em>before</em> it's fully instantiated, which is a fallible<br>\nprocess. Some fallibility is predictable, such as import type<br>\nmismatches, but other fallibility is less predictable, such as failure<br>\nto allocate a linear memory.</p>\n<p>The problem happened when a module was registered with a <code>Store</code>,<br>\nretaining information about its trampolines, but then instantiation<br>\nfailed and the module's code was never persisted within the <code>Store</code>.<br>\nUnlike as documented in #2374 the <code>Module</code> inside an <code>Instance</code> is not<br>\nthe primary way to hold on to a module's code, but rather the<br>\n<code>Arc&lt;ModuleCode&gt;</code> is persisted within the global frame information off<br>\non the side. This persistence only made its way into the store through<br>\nthe <code>Box&lt;Any&gt;</code> field of <code>InstanceHandle</code>, but that's never made if<br>\ninstantiation fails during import matching.</p>\n<p>The fix here is to build on the refactoring of #2407 to not store module<br>\ncode in frame information but rather explicitly in the <code>Store</code>.<br>\nRegistration is now deferred until just-before an instance handle is<br>\ncreated, and during module registration we insert the <code>Arc&lt;ModuleCode&gt;</code><br>\ninto a set stored within the <code>Store</code>.</p>\n</blockquote>",
        "id": 216536852,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605219182
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2408\">PR #2408</a> from <code>fix-use-after-free-trampoline</code> to <code>main</code>:</p>\n<blockquote>\n<p>This commit fixes an issue with wasmtime where it was possible for a<br>\ntrampoline from one module to get used for another module after it was<br>\nfreed. This issue arises because we register a module's native<br>\ntrampolines <em>before</em> it's fully instantiated, which is a fallible<br>\nprocess. Some fallibility is predictable, such as import type<br>\nmismatches, but other fallibility is less predictable, such as failure<br>\nto allocate a linear memory.</p>\n<p>The problem happened when a module was registered with a <code>Store</code>,<br>\nretaining information about its trampolines, but then instantiation<br>\nfailed and the module's code was never persisted within the <code>Store</code>.<br>\nUnlike as documented in #2374 the <code>Module</code> inside an <code>Instance</code> is not<br>\nthe primary way to hold on to a module's code, but rather the<br>\n<code>Arc&lt;ModuleCode&gt;</code> is persisted within the global frame information off<br>\non the side. This persistence only made its way into the store through<br>\nthe <code>Box&lt;Any&gt;</code> field of <code>InstanceHandle</code>, but that's never made if<br>\ninstantiation fails during import matching.</p>\n<p>The fix here is to build on the refactoring of #2407 to not store module<br>\ncode in frame information but rather explicitly in the <code>Store</code>.<br>\nRegistration is now deferred until just-before an instance handle is<br>\ncreated, and during module registration we insert the <code>Arc&lt;ModuleCode&gt;</code><br>\ninto a set stored within the <code>Store</code>.</p>\n</blockquote>",
        "id": 216537862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605219762
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2408\">PR #2408</a> from <code>fix-use-after-free-trampoline</code> to <code>main</code>:</p>\n<blockquote>\n<p>This commit fixes an issue with wasmtime where it was possible for a<br>\ntrampoline from one module to get used for another module after it was<br>\nfreed. This issue arises because we register a module's native<br>\ntrampolines <em>before</em> it's fully instantiated, which is a fallible<br>\nprocess. Some fallibility is predictable, such as import type<br>\nmismatches, but other fallibility is less predictable, such as failure<br>\nto allocate a linear memory.</p>\n<p>The problem happened when a module was registered with a <code>Store</code>,<br>\nretaining information about its trampolines, but then instantiation<br>\nfailed and the module's code was never persisted within the <code>Store</code>.<br>\nUnlike as documented in #2374 the <code>Module</code> inside an <code>Instance</code> is not<br>\nthe primary way to hold on to a module's code, but rather the<br>\n<code>Arc&lt;ModuleCode&gt;</code> is persisted within the global frame information off<br>\non the side. This persistence only made its way into the store through<br>\nthe <code>Box&lt;Any&gt;</code> field of <code>InstanceHandle</code>, but that's never made if<br>\ninstantiation fails during import matching.</p>\n<p>The fix here is to build on the refactoring of #2407 to not store module<br>\ncode in frame information but rather explicitly in the <code>Store</code>.<br>\nRegistration is now deferred until just-before an instance handle is<br>\ncreated, and during module registration we insert the <code>Arc&lt;ModuleCode&gt;</code><br>\ninto a set stored within the <code>Store</code>.</p>\n</blockquote>",
        "id": 216539043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605220403
    },
    {
        "content": "<p>fitzgen merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2408\">PR #2408</a>.</p>",
        "id": 216952769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1605573303
    }
]