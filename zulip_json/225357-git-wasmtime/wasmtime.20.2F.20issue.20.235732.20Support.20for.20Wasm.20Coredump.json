[
    {
        "content": "<p>xtuc opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>When the Wasm instance traps, it's sometimes difficult to understand what happened. Post-mortem debugging using coredumps (which is extensively used in native environment) would be helpful for investigating and fixing crashes.</p>\n<p>Wasm coredump is especially useful for serverless environment where production binaries are stripped and/or have access to limited logging.</p>\n<h4>Implementation</h4>\n<p>Implement Wasm coredumps as specified by <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md\">https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md</a>. <br>\nNote that the spec is early and subject to changes. Feedback very welcome!</p>\n<p>cc @fitzgen </p>\n</blockquote>",
        "id": 326344627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675771101
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1420689908\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Reading the linear memory after a crash is already possible. As for getting the locals and stack values, this is much more complicated. Wasmtime uses the Cranelift optimizing compiler, which can eliminate locals and stack values entirely and leaves those that remain at whichever location it likes. It did be necessary to somehow prevent optimizing locals away, at least for points where a trap could happen. There is debugger support for getting the location of locals and stack values which aren't optimized away to generate debuginfo, but I'm not sure if it is 100% accurate. By the way <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5537\">https://github.com/bytecodealliance/wasmtime/issues/5537</a> is somewhat relevant to this.</p>\n</blockquote>",
        "id": 326349471,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675772713
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1420951056\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>I don't think Wasm coredump should prevent optimizations, given that ideally it's enabled by default.</p>\n<p>It's not uncommon to see coredump in native environment with missing values because they were optimized away. They are usually not very helpful for debugging.</p>\n</blockquote>",
        "id": 326386723,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675783191
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1420972056\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>The wasm coredump format doesn't seem to allow omitting values that are optimized away, but if it is allowed, then it should be possible to implement without too much changes to Cranelift. I think it would need some changes to the unwind table generation code to store the location of callee saved registers, but that will need to be done anyway for handling exceptions. After that I guess it would be a matter of telling Cranelift to generate debuginfo and then during a crash unwind the stack and record all preserved locals and stack values for every frame from Wasmtime.</p>\n</blockquote>",
        "id": 326389862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675783965
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1420978856\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<blockquote>\n<p>The wasm coredump format doesn't seem to allow omitting values that are optimized away</p>\n</blockquote>\n<p>Correct, at the moment it doesn't. I'm going to add it, thanks for your input!<br>\n</p>\n</blockquote>",
        "id": 326390849,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675784234
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1421006163\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>This is an area I haven't dug into much, but doesn't Cranelift's support for GC already support tracking the information we need for this? I think we would need to mark potentially-trapping instructions as \"safe points\" and then request stack maps from Cranelift. And my impression was that calls are already considered safe points. But this is all conjecture based on a CVE that I was peripherally paying attention to last year, so I could have it all wrong.</p>\n</blockquote>",
        "id": 326394962,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675785320
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1421247479\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is an area I haven't dug into much, but doesn't Cranelift's support for GC already support tracking the information we need for this? I think we would need to mark potentially-trapping instructions as \"safe points\" and then request stack maps from Cranelift. And my impression was that calls are already considered safe points. But this is all conjecture based on a CVE that I was peripherally paying attention to last year, so I could have it all wrong.</p>\n</blockquote>\n<p>Stack maps only track reference values (<code>r32</code>/<code>r64</code>), and only say which stack slots have live references in them. They do not supply any kind of info to help tie that back to wasm locals or even clif SSA variables.</p>\n<p>I don't think we would want to use stack maps for this stuff.</p>\n</blockquote>",
        "id": 326427639,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675793959
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1421259497\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>On the flip-side, if you're proposing altering the generated code to assist debugging observability @jameysharp, there is a large design space that we haven't really explored. A relatively simple change would be to define a pseudoinstruction that takes <em>all</em> locals as inputs, with \"any\" constraints to regalloc (stack slot or register), and insert these wherever a crash could happen. This \"state snapshot\" instruction would then guarantee observability of all values, at the cost of hindering optimization.</p>\n<p>This goes somewhat against the \"don't alter what you're observing\" principle that is common in debug infrastructure but I'll note that we do already have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/08403c9915bbacf9f17e298d7f0700062ea0fc24/cranelift/codegen/src/machinst/lower.rs#L560-L563\">some</a> <a href=\"https://github.com/bytecodealliance/wasmtime/blob/08403c9915bbacf9f17e298d7f0700062ea0fc24/cranelift/codegen/src/machinst/lower.rs#L650-L658\">hacks</a> to keep important values alive (in this case, the vmctx, which makes all other wasm state reachable) for the whole function body.</p>\n<p>There's also the \"recovery instruction\" approach, used in IonMonkey at least: whenever a value is optimized out, generate a side-sequence of instructions that can recompute it. That's a much larger compiler-infrastructure undertaking but in principle we could do it, if perfect debug observability were a goal.</p>\n</blockquote>",
        "id": 326429914,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1675794590
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1434550038\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/WebAssembly/tool-conventions/issues/198\">https://github.com/WebAssembly/tool-conventions/issues/198</a> has been closed. The coredump format now allows to make local/stack values as missing.</p>\n</blockquote>",
        "id": 328452679,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676635659
    },
    {
        "content": "<p>xtuc edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1434550038\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/WebAssembly/tool-conventions/issues/198\">https://github.com/WebAssembly/tool-conventions/issues/198</a> has been closed. The coredump format now allows to mark local/stack values as missing.</p>\n</blockquote>",
        "id": 328452711,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676635670
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1442290202\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>I made a change to add initial/basic coredump generation: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5868\">https://github.com/bytecodealliance/wasmtime/pull/5868</a>. Could you please have a look and let me know if this is the right direction?<br>\nIt uses <code>WasmBacktrace</code> for information about frames.</p>\n</blockquote>",
        "id": 329797640,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677179082
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1449075474\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Basic coredump generation has been merged (thanks!).</p>\n<p>Now, to have the complete debugger experience, we need to collect the following information:</p>\n<ul>\n<li>Wasm locals of each stack frames</li>\n<li>Snapshot the Wasm linear memory (sounds relatively easy, it's not clear to me where the coredump code should live though).</li>\n</ul>\n<p>From @cfallin :</p>\n<blockquote>\n<p>A relatively simple change would be to define a pseudoinstruction that takes all locals as inputs, with \"any\" constraints to regalloc (stack slot or register), and insert these wherever a crash could happen. This \"state snapshot\" instruction would then guarantee observability of all values, at the cost of hindering optimization.</p>\n</blockquote>\n<p>This \"state snapshot\" instruction could be translated from Wasm's <code>(unreachable)</code> instruction. I'm curious about the performance impact. Since the coredump feature is behind a flag, would it make sense to experiment with that approach?<br>\nIs my understanding correct that it won't help identifiying the values?</p>\n</blockquote>",
        "id": 338712076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677626339
    },
    {
        "content": "<p>xtuc edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1449075474\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Basic coredump generation has been merged (thanks!).</p>\n<p>Now, to have the complete debugger experience, we need to collect the following information:</p>\n<ul>\n<li>Wasm locals of each stack frames</li>\n<li>Snapshot the Wasm linear memory (sounds relatively easy, it's not clear to me where the coredump code should live though).</li>\n</ul>\n</blockquote>",
        "id": 338764941,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677657813
    },
    {
        "content": "<p>RyanTorok <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1487637153\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Is there a chance we could revive this thread? I'm working on cloud<br>\ninfrastructure research, and being able to take a stack snapshot in wasmtime<br>\nwould allow us to get some sophisticated cold-start optimizations for<br>\nFunction-as-a-Service (FaaS) functions.</p>\n<p>There has been a plethora of academic papers published about using execution<br>\nsnapshots to speed up the cold-start (startup) time in FaaS, especially when<br>\nheavyweight VMs are involved. Starting up a Module in wasmtime tends to be<br>\nfaster than VMs by 2-3 orders of magnitude, but recent papers have also explored<br>\nhow to snapshot the state of the function after some initialization runs, which<br>\nhas a lot in common with what Wizer does.</p>\n<p>I am trying to extend this idea with a construction called _Nondeterministic<br>\nGenerators_, which will allow FaaS functions to be snaphotted at any point in the<br>\nexecution. Generators rely on the observation that functions whose execution<br>\nthat has not performed any invocation-specific computation (i.e. anything using<br>\nthe function arguments or any nondeterministic functions imported from the host)<br>\ncan be unconditionally snapshotted and used to fast-forward future invocations<br>\nof the same function.</p>\n<p>In addition, we can create conditional snapshots that let application developers<br>\noptimize for common patterns, such as functions that want to check that their<br>\narguments are valid before they perform their expensive initialization, which<br>\ntraditional \"init function\"-based cold-start speedup techniques cannot optimize<br>\nwithout breaking the function semantics if the invocation-specific invariant is<br>\nviolated (e.g. our argument validation fails).</p>\n<p>I was looking into Wizer quite a bit and the design decisions it makes, and I<br>\nwas hoping to get some insight about the requirements Wizer lists on its <a href=\"http://docs.rs\">docs.rs</a><br>\npage, under \"Caveats\":</p>\n<ul>\n<li>The initialization function may not call any imported functions. Doing so will<br>\n  trigger a trap and wizer will exit.</li>\n</ul>\n<p>Is this just a lint against the produced module being potentially non-portable<br>\n(the snapshot would rely on the outcome of a particular host's implementation of<br>\nthe imported function), or is there a more fundamental reason this is not<br>\npossible? I imagine my generator design having the potential to snapshot any<br>\ntime just before a generator is polled (polling calls an import function, so the<br>\nhost can record the outcome of the generator function), which would necessitate<br>\nsnapshotting after code that has already called into the host at least once if we<br>\nhave multiple generators.</p>\n<ul>\n<li>The Wasm module may not import globals, tables, or memories.</li>\n</ul>\n<p>I don't anticipate the application code running on my system to need any of<br>\nthese, but I'd like some clarification about why this applies to the entire<br>\nmodule and not just the init function, like for host functions.</p>\n<ul>\n<li>Reference types are not supported yet. This is tricky because it would allow<br>\n  the Wasm module to mutate tables, and we would need to be able to snapshot the<br>\n  new table state, but funcrefs and externrefs don’t have identity and aren’t<br>\n  comparable in the Wasm spec, which makes snapshotting difficult.</li>\n</ul>\n<p>This makes sense. Application code in my system should not need to use these.</p>\n<p>More fundamentally, the major roadblock to my design working with WebAssembly<br>\nmodules is wasmtime's current inability to snapshot the WebAssembly _stack_. Since<br>\nmy design allows the execution to snapshot at any point, not just after some<br>\ninitialization function runs (as Wizer supports), my design would require all<br>\nthe application's local state to be moved to a Memory before we snapshot, which<br>\nwould slow down function execution and be a very awkward paradigm to program in.</p>\n<p>My main question is (and I apologize for taking a page to get there), is what<br>\nroadblocks would need to be overcome in order to make stack snapshots possible<br>\nin wasmtime? Since it will be relevant below, I should point out that the<br>\nrequirements for my use case are actually a bit looser than Wizer's in two ways:</p>\n<ul>\n<li>\n<p>I don't necessarily care that a snapshot is actually in the form of a new<br>\n  WebAssembly Module that can be instantiated and run on its own. I just want my<br>\n  host to be able to store _something_ that lets it fast-forward a module to the<br>\n  point where a snapshot occurred, possibly by instantiating the original module<br>\n  and overwriting the globals, memory, and stack. Likewise, I'm not concerned<br>\n  about portability of the snapshot. We can assume that the snapshot will be<br>\n  loaded on the same Engine (and therefore the same version of wasmtime) it was<br>\n  produced on.</p>\n</li>\n<li>\n<p>I don't require the host to necessarily do all the snapshotting work on its<br>\n  own. If we can invoke a callback that allows the application, through a<br>\n  library they link to, to, say, copy the stack to a Memory object so it can be<br>\n  snapshotted, that should suffice.</p>\n</li>\n</ul>\n<p>I had the intuition that the application library could just run some WebAssembly<br>\ncode that copies the locals on the stack into a Memory object, but I was<br>\nconcerned about how wasmtime would behave when we restored such a stack. Unlike<br>\nthe core-dumping use case, I'm less concerned about the actual contents of the<br>\nstack in relation to cranelift's dead-code elimination (DCE); however, I am<br>\nconcerned that if during the run that produced the snapshot, cranelift decides<br>\nby DCE to eliminate an unnecessary value from the stack, is it possible that<br>\nwhen we restore that stack in a new instantiation of the module that skips to<br>\nthe snapshot, cranelift won't perform the same optimization and it will try to<br>\npop a value off the stack that isn't there? If I had one reason for writing this<br>\ncomment, it's that I would really appreciate some clarification on how this<br>\ncompilation process works and what guarantees are in place, and how that might<br>\naffect our endeavor to produce restorable stack snapshots.</p>\n<p>Thanks everyone for reading. You all do great work, and I'd love to contribute<br>\ngoing forward.</p>\n</blockquote>",
        "id": 345247605,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680040114
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1487678247\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Something that may work is if you reuse the exact same compiled machine code then you could take a snapshot of the part of the native stack that contains the wasm frames and restore it later. You did have to fixup pointers (which probably requires emitting extra metadata and maybe some changes to avoid keeping pointers alive across function calls) and making sure that no native frames are on the stack as those can't safely be snapshotted. By keeping the same compiled machine code you know that the stack layout is identical. Wasmtime already allows emitting compiled wasm modules (.cwasm extension) and loading them again. You did only need to implement the stack snapshotting and pointer fixups. This still not exactly trivial, but likely much easier than perfectly reconstructing the wasm vm state.</p>\n<blockquote>\n<p>The initialization function may not call any imported functions. Doing so will<br>\ntrigger a trap and wizer will exit.</p>\n</blockquote>\n<p>I would guess this is a combination of there being no way to hook up any imported functions from the host to wizer and this limitation ensuring that there is no native state that wizer can't snapshot. But I'm not a contributor to it, so it is nothing but a guess.</p>\n</blockquote>",
        "id": 345252041,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680042059
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1487680309\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@RyanTorok there are a lot of interesting ideas in your comment (I have to admit that I skimmed it in parts; I'd encourage a \"tl;dr\" of points for comments this long!). A few thoughts:</p>\n<ul>\n<li>\n<p>The fundamental issue that would have to be solved to snapshot and restore an active stack is relocation of mappings in the address space. In principle one could copy an image of the whole stack and all data segments, current PC and all registers, map them into a new execution at a later time and restart as if nothing changed... <em>except</em> that the heap and the stack will be at different locations than before.</p>\n<p>In order to make that work, one has to prevent \"host\" addresses from escaping, or else precisely track where the escape to, or some combination. An example of the latter is the frame-pointer chain: one has addresses that point to the stack on the stack itself, but that's OK because one can precisely traverse the linked list and rewrite saved FPs if the stack moves. Likewise for return addresses. An example of the former is handling Wasm heap accesses. If we somehow ensure that only Wasm-level addresses (offsets to the heap) are \"live\" at snapshot points, and the only live address is the <code>vmctx</code>, except ephemerally when addresses for all other accessed memory are derived from it, then that could work. But that requires some compiler support, I think.</p>\n</li>\n<li>\n<p>Restoring a <em>native-level</em> snapshot after optimizing the code a different way is a complete non-starter, I think. (I believe this is what you're referring to when speaking of Cranelift DCE working differently in a different run.) Many incidental details of the compiled code can change if the input changes: the layout of blocks, the registers and stackslots that the register allocator assigns for particular values, existence of some values in the function causing optimization of different values to go differently, etc.</p>\n</li>\n<li>\n<p>Another option that I think you refer to is a <em>Wasm-level</em> snapshot. This is interesting, but requires mapping Wasm-level state to machine state precisely at possible snapshot points. We have a little bit of plumbing for that kind of thing with our debug support, but it's incomplete. The other side of the coin -- restoring the snapshot -- then requires \"multi-entry functions\" (something like \"on-stack replacement\" when a JIT tiers up) to entier into the middle of the IR with known values.</p>\n</li>\n</ul>\n<p>So I think some form of this is possible but it's a deep research project and requires a bunch of intimate knowledge of the compiler and runtime. We likely don't have the resources to help you design this in detail, but I'm personally curious to see what you come up with...</p>\n</blockquote>",
        "id": 345252392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680042213
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1487680309\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@RyanTorok there are a lot of interesting ideas in your comment (I have to admit that I skimmed it in parts; I'd encourage a \"tl;dr\" of points for comments this long!). A few thoughts:</p>\n<ul>\n<li>\n<p>The fundamental issue that would have to be solved to snapshot and restore an active stack is relocation of mappings in the address space. In principle one could copy an image of the whole stack and all data segments, current PC and all registers, map them into a new execution at a later time and restart as if nothing changed... <em>except</em> that the heap and the stack will be at different locations than before.</p>\n<p>In order to make that work, one has to prevent \"host\" addresses from escaping, or else precisely track where they escape to, or some combination. An example of the latter is the frame-pointer chain: one has addresses that point to the stack on the stack itself, but that's OK because one can precisely traverse the linked list and rewrite saved FPs if the stack moves. Likewise for return addresses. An example of the former is handling Wasm heap accesses. If we somehow ensure that only Wasm-level addresses (offsets to the heap) are \"live\" at snapshot points, and the only live address is the <code>vmctx</code>, except ephemerally when addresses for all other accessed memory are derived from it, then that could work. But that requires some compiler support, I think.</p>\n</li>\n<li>\n<p>Restoring a <em>native-level</em> snapshot after optimizing the code a different way is a complete non-starter, I think. (I believe this is what you're referring to when speaking of Cranelift DCE working differently in a different run.) Many incidental details of the compiled code can change if the input changes: the layout of blocks, the registers and stackslots that the register allocator assigns for particular values, existence of some values in the function causing optimization of different values to go differently, etc.</p>\n</li>\n<li>\n<p>Another option that I think you refer to is a <em>Wasm-level</em> snapshot. This is interesting, but requires mapping Wasm-level state to machine state precisely at possible snapshot points. We have a little bit of plumbing for that kind of thing with our debug support, but it's incomplete. The other side of the coin -- restoring the snapshot -- then requires \"multi-entry functions\" (something like \"on-stack replacement\" when a JIT tiers up) to entier into the middle of the IR with known values.</p>\n</li>\n</ul>\n<p>So I think some form of this is possible but it's a deep research project and requires a bunch of intimate knowledge of the compiler and runtime. We likely don't have the resources to help you design this in detail, but I'm personally curious to see what you come up with...</p>\n</blockquote>",
        "id": 345252748,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680042369
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1487680309\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@RyanTorok there are a lot of interesting ideas in your comment (I have to admit that I skimmed it in parts; I'd encourage a \"tl;dr\" of points for comments this long!). A few thoughts:</p>\n<ul>\n<li>\n<p>The fundamental issue that would have to be solved to snapshot and restore an active stack is relocation of mappings in the address space. In principle one could copy an image of the whole stack and all data segments, current PC and all registers, map them into a new execution at a later time and restart as if nothing changed... <em>except</em> that the heap and the stack will be at different locations than before.</p>\n<p>In order to make that work, one has to prevent \"host\" addresses from escaping, or else precisely track where they escape to, or some combination. An example of the latter is the frame-pointer chain: one has addresses that point to the stack on the stack itself, but that's OK because one can precisely traverse the linked list and rewrite saved FPs if the stack moves. Likewise for return addresses. An example of the former is handling Wasm heap accesses. If we somehow ensure that only Wasm-level addresses (offsets to the heap) are \"live\" at snapshot points, and the only live address is the <code>vmctx</code>, except ephemerally when addresses for all other accessed memory are derived from it, then that could work. But that requires some compiler support, I think.</p>\n</li>\n<li>\n<p>Restoring a <em>native-level</em> snapshot after optimizing the code a different way is a complete non-starter, I think. (I believe this is what you're referring to when speaking of Cranelift DCE working differently in a different run.) Many incidental details of the compiled code can change if the input changes: the layout of blocks, the registers and stackslots that the register allocator assigns for particular values, existence of some values in the function causing optimization of different values to go differently, etc.</p>\n</li>\n<li>\n<p>Another option that I think you refer to is a <em>Wasm-level</em> snapshot. This is interesting, but requires mapping Wasm-level state to machine state precisely at possible snapshot points. We have a little bit of plumbing for that kind of thing with our debug support, but it's incomplete. The other side of the coin -- restoring the snapshot -- then requires \"multi-entry functions\" (something like \"on-stack replacement\" when a JIT tiers up) to enter into the middle of the IR with known values.</p>\n</li>\n</ul>\n<p>So I think some form of this is possible but it's a deep research project and requires a bunch of intimate knowledge of the compiler and runtime. We likely don't have the resources to help you design this in detail, but I'm personally curious to see what you come up with...</p>\n</blockquote>",
        "id": 345252902,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680042440
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1488994505\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@RyanTorok,</p>\n<p>The Wasm stack doesn't really exist anymore by the time Cranelift is done emitting machine code (it is erased very early in the pipeline, basically the first thing to go). Instead you would need to capture the actual native stack. This has issues that @bjorn3 mentioned around native frames in between Wasm frames, but even if it is just Wasm there will be pointers on the stack to things <code>malloc</code>ed by the host, namely the vm context and associated data structures. Each new process will have new ASLR and new <code>malloc</code> allocations and new FaaS requests/invocations will have new stores (and their associated vm contexts). These structures will ultimately end up in different addresses in memory. So either (a) restoring a snapshot will require having a list of places to go and update pointers not dissimilar to relocs or a moving GC, or (b) take extreme care codegen only emit indirect references to these structures (somehow? need an actual handle to be the \"root\" at some point or else a host call or something). Option (a) is a <em>ton</em> of work for Wasmtime/Cranelift to keep track of these things and option (b) is also a ton of work but also makes Wasm execution speed much slower. In both cases, if we get anything wrong (miss a stack slot or register that has a native pointer when saving a snapshot or accidentally emit a direct pointer reference rather than an indirection) then we have security vulnerabilities. Supporting all this would be a large refactoring of much of Wasmtime and Cranelift, and I'm pessimistic that it would ever happen. This is the kind of thing that you ideally need to build in from the very start, and Wasmtime and Cranelift have not been built with this in mind.</p>\n<p>Backing up a bit: this topic would be better discussed in a dedicated issue or on zulip, since this issue is specifically about implementing the proposed standard Wasm coredump format, which won't help with this feature since it is strictly about the Wasm-level. I suggest filing a new issue or starting a thread on zulip if you have further questions.</p>\n</blockquote>",
        "id": 345467316,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680109991
    },
    {
        "content": "<p>RyanTorok <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1492602978\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Thank you to everyone for the quick responses and insightful comments! </p>\n<p>TL;DR: Issues with ASLR and the level of introspection into the runtime that would be required make stack snapshots pretty much a non-starter, and in fact they alerted me to limitations in the existing work on cold-starts I wasn't aware of.</p>\n<p>Based on @fitzgen 's comments about ASLR, I took another look back at the existing literature on cold-starts, and it turns out that the traditional method of snapshotting the entire state of the VM or language runtime is not compatible with ASLR _at all_, and for the exact reason @fitzgen pointed out. </p>\n<p>A summary of the problem is that language runtimes (e.g. JVM, Python, Node.js, wasmtime, ...) inherently need to compile code using native addresses, thereby making the VM state not portable to different addresses. Traditionally, the way to deal with this portability issue would be to introduce another level of indirection (i.e. position-independent addresses), but @fitzgen, @cfallin, and @bjorn3 all pointed out that any such scheme would require very deep introspection into the language runtime to convert the indirect addresses to direct addresses, which would be an enormous endeavor to the point you'd be better of redesigning the entire runtime to support this indirection. Otherwise, you're really walking a tightrope on both performance and security (mess up the indirection once, and the tenant can read memory their program doesn't own).</p>\n<p>The existing literature on cold-starts essentially punts on this issue; it requires all memory owned by the VM or runtime to be loaded at the same address every time. While I don't see any major reasons wasmtime couldn't support this from an implementation standpoint, I don't recommend this as a direction for multiple reasons:</p>\n<ul>\n<li>Disabling ASLR is potentially bad for security. While I'm not aware of any features of language runtimes that fundamentally depend on ASLR to ensure security, disabiling it would make any memory bugs much easier for the tenant, because the attacker could just hard-code addresses in their code, or, short of that, memorize them from a previous run using the same snapshot.</li>\n<li>Security aside, in the cloud space, requiring code to always occupy the same address ranges every time would add unwanted contention to multi-tenant systems (i.e. cloud infrastructure). If two functions each had even a single (native) memory page that required the same fixed address, host could not run both functions in parallel. One possible mitigation to this would be to spawn multiple processes, so the functions would not compete for the same virtual addresses, but not only does this introduce overhead of interprocess communication (IPC), in wasmtime's case, this would force us to choose between reverting back to OS-based lazy loading of pages (with mmap), rather than preallocating pages using userfaultfd or becoming a _serious_ memory hog by preallocating a userspace page cache for all N processes, neither of which would be worth the performance wins of more flexible snapshots.</li>\n</ul>\n<p>To summarize (in research paper speak), there are several open problems that have to be addressed with language runtimes in general, not just wasmtime, in order for generalized snapshots to be a practical solution for the cloud. I'm going to continue looking into how we might provide a subset of this feature set via library abstractions that work with the designs of existing language runtimes. </p>\n<p>Thanks for all your help everyone!</p>\n</blockquote>",
        "id": 346056264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680296514
    },
    {
        "content": "<p>RyanTorok <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1492610545\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>As an aside, I think this question from my original comment: </p>\n<blockquote>\n<p>is it possible that when we restore that stack in a new instantiation of the module that skips to the snapshot, cranelift won't perform the same optimization and it will try to pop a value off the stack that isn't there?</p>\n</blockquote>\n<p>was a simple misunderstanding by me about the mechanics of cranelift. Clearly everything has to be compiled in order to run, it's just a matter of when that happens (AOT or JIT). My last project was in browser security, and in JavaScript engines we actually have to worry about code running at multiple optimization levels, and my confusion stemmed from there. This doesn't change anything about the issues with ASLR or introspection, however.</p>\n</blockquote>",
        "id": 346057361,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680296969
    },
    {
        "content": "<p>RyanTorok edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1492602978\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Thank you to everyone for the quick responses and insightful comments! </p>\n<p>TL;DR: Issues with ASLR and the level of introspection into the runtime that would be required make stack snapshots pretty much a non-starter, and in fact they alerted me to limitations in the existing work on cold-starts I wasn't aware of.</p>\n<p>Based on @fitzgen 's comments about ASLR, I took another look back at the existing literature on cold-starts, and it turns out that the traditional method of snapshotting the entire state of the VM or language runtime is not compatible with ASLR _at all_, and for the exact reason @fitzgen pointed out. </p>\n<p>A summary of the problem is that language runtimes (e.g. JVM, Python, Node.js, wasmtime, ...) inherently need to compile code using native addresses, thereby making the VM state not portable to different addresses. Traditionally, the way to deal with this portability issue would be to introduce another level of indirection (i.e. position-independent addresses), but @fitzgen, @cfallin, and @bjorn3 all pointed out that any such scheme would require very deep introspection into the language runtime to convert the indirect addresses to direct addresses, which would be an enormous endeavor to the point you'd be better of redesigning the entire runtime to support this indirection. Otherwise, you're really walking a tightrope on both performance and security (mess up the indirection once, and the tenant can read memory their program doesn't own).</p>\n<p>The existing literature on cold-starts essentially punts on this issue; it requires all memory owned by the VM or runtime to be loaded at the same address every time. While I don't see any major reasons wasmtime couldn't support this from an implementation standpoint, I don't recommend this as a direction for multiple reasons:</p>\n<ul>\n<li>Disabling ASLR is potentially bad for security. While I'm not aware of any features of language runtimes that fundamentally depend on ASLR to ensure security, disabiling it would make any memory bugs much easier for the tenant to exploit, because the attacker could just hard-code addresses in their code, or, short of that, memorize them from a previous run using the same snapshot.</li>\n<li>Security aside, in the cloud space, requiring code to always occupy the same address ranges every time would add unwanted contention to multi-tenant systems (i.e. cloud infrastructure). If two functions each had even a single (native) memory page that required the same fixed address, host could not run both functions in parallel. One possible mitigation to this would be to spawn multiple processes, so the functions would not compete for the same virtual addresses, but not only does this introduce overhead of interprocess communication (IPC), in wasmtime's case, this would force us to choose between reverting back to OS-based lazy loading of pages (with mmap), rather than preallocating pages using userfaultfd, or becoming a _serious_ memory hog by preallocating a userspace page cache for all N processes, neither of which would be worth the performance wins of more flexible snapshots.</li>\n</ul>\n<p>To summarize (in research paper speak), there are several open problems that have to be addressed with language runtimes in general, not just wasmtime, in order for generalized snapshots to be a practical solution for the cloud. I'm going to continue looking into how we might provide a subset of this feature set via library abstractions that work with the designs of existing language runtimes. </p>\n<p>Thanks for all your help everyone!</p>\n</blockquote>",
        "id": 346058096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680297263
    },
    {
        "content": "<p>RyanTorok edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-1492602978\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Thank you to everyone for the quick responses and insightful comments! </p>\n<p>TL;DR: Issues with ASLR and the level of introspection into the runtime that would be required make stack snapshots pretty much a non-starter, and in fact they alerted me to limitations in the existing work on cold-starts I wasn't aware of.</p>\n<p>Based on @fitzgen 's comments about ASLR, I took another look back at the existing literature on cold-starts, and it turns out that the traditional method of snapshotting the entire state of the VM or language runtime is not compatible with ASLR _at all_, and for the exact reason @fitzgen pointed out. </p>\n<p>A summary of the problem is that language runtimes (e.g. JVM, Python, Node.js, wasmtime, ...) inherently need to compile code using native addresses, thereby making the VM state not portable to different addresses. Traditionally, the way to deal with this portability issue would be to introduce another level of indirection (i.e. position-independent addresses), but @fitzgen, @cfallin, and @bjorn3 all pointed out that any such scheme would require very deep introspection into the language runtime to convert the indirect addresses to direct addresses, which would be an enormous endeavor to the point you'd be better of redesigning the entire runtime to support this indirection. Otherwise, you're really walking a tightrope on both performance and security (mess up the indirection once, and the tenant can read memory their program doesn't own).</p>\n<p>The existing literature on cold-starts essentially punts on this issue; it requires all memory owned by the VM or runtime to be loaded at the same address every time. While I don't see any major reasons wasmtime couldn't support this from an implementation standpoint, I don't recommend this as a direction for multiple reasons:</p>\n<ul>\n<li>Disabling ASLR is potentially bad for security. While I'm not aware of any features of language runtimes that fundamentally depend on ASLR to ensure security, disabiling it would make any memory bugs much easier for the tenant to exploit, because the attacker could just hard-code addresses in their code, or, short of that, memorize them from a previous run using the same snapshot.</li>\n<li>Security aside, in the cloud space, requiring code to always occupy the same address ranges every time would add unwanted contention to multi-tenant systems (i.e. cloud infrastructure). If two functions each had even a single (native) memory page that required the same fixed address, the host could not run both functions in parallel. One possible mitigation to this would be to spawn multiple processes, so the functions would not compete for the same virtual addresses, but not only does this introduce overhead of interprocess communication (IPC), in wasmtime's case, this would force us to choose between reverting back to OS-based lazy loading of pages (with mmap), rather than preallocating pages using userfaultfd, or becoming a _serious_ memory hog by preallocating a userspace page cache for all N processes, neither of which would be worth the performance wins of more flexible snapshots.</li>\n</ul>\n<p>To summarize (in research paper speak), there are several open problems that have to be addressed with language runtimes in general, not just wasmtime, in order for generalized snapshots to be a practical solution for the cloud. I'm going to continue looking into how we might provide a subset of this feature set via library abstractions that work with the designs of existing language runtimes. </p>\n<p>Thanks for all your help everyone!</p>\n</blockquote>",
        "id": 346058298,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1680297349
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2119375017\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>What tools can I use to inspect the coredumps?</p>\n</blockquote>",
        "id": 439470340,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1716156553
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2121230192\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@whitequark unfortunately there isn't much off-the-shelf at the moment.</p>\n<p>There was <a href=\"https://github.com/xtuc/wasm-coredump/tree/main/bin/wasmgdb\">https://github.com/xtuc/wasm-coredump/tree/main/bin/wasmgdb</a> but as far as I know it only works with an old version of the format.</p>\n<p>There are plans to build support for inspecting them via the debug adapter protocol in Wasmtime itself, as a stepping stone towards fuller debugging capabilities. See <a href=\"https://github.com/bytecodealliance/rfcs/pull/34\">https://github.com/bytecodealliance/rfcs/pull/34</a> for more details. Unfortunately, that doesn't exist yet.</p>\n<p>In the meantime, Wasm's core dumps are just wasm modules themselves, so you can use any tool that you might inspect a wasm module with to get at the information inside a core dump, e.g. <code>wasm-tools print</code> or <code>wasm-objdump</code>.</p>\n<p>I know this isn't a great answer. I wish I had a better one. But we are planning on getting there!</p>\n</blockquote>",
        "id": 439682121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1716239996
    },
    {
        "content": "<p>whitequark <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2121268443\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Thanks! I'll keep it in mind--I have to use <code>wasm-objdump</code> a lot already so, cursed as it is, this does fit into my workflow...</p>\n</blockquote>",
        "id": 439686217,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1716241804
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2122139173\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<blockquote>\n<p>There was <a href=\"https://github.com/xtuc/wasm-coredump/tree/main/bin/wasmgdb\">https://github.com/xtuc/wasm-coredump/tree/main/bin/wasmgdb</a> but as far as I know it only works with an old version of the format.</p>\n</blockquote>\n<p>Sorry about that. I'm planning to update wasmgdb to the latest spec but haven't had the time yet.</p>\n</blockquote>",
        "id": 439766091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1716282368
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2565610076\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>@fitzgen  do you know if there are plans now in Wasmtime to recover the locals and operand stack, especially for cranelift? I saw that winch might preserve them.</p>\n<p>Unfortunately, right now coredumps aren't very useful in Wasmtime (or most optimizing compilers).</p>\n</blockquote>",
        "id": 491293736,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735571768
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2565971097\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>There are Plans&lt;sup&gt;tm&lt;/sup&gt; to add support for this kind of thing, but no one actively working on it AFAIK.</p>\n</blockquote>",
        "id": 491336455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735597626
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2565977143\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Specifically the debug RFC from Nick, Trevor and Rainy <a href=\"https://github.com/elliottt/rfcs/blob/trevor/wasmtime-debugging/accepted/wasmtime-debugging.md\">here</a> covers our overall plans, with coredump fidelity (providing all Wasm virtual machine state) as a necessary prerequisite for our further-along goals.</p>\n<p>The plan of record is to use Winch as the main backend when debugging, because its native machine state has a much closer correspondence to Wasm VM state, as you've noted; we've kicked around some ideas on how to do this for Cranelift too, eventually, if the performance need arises (basically: pseudo-insts that propagate mapping of Wasm VM state to machine code).</p>\n<p>Any contributors looking to help us in this long-term goal could probably most effectively help by filling out remaining Winch functionality (aarch64, SIMD on x86-64 and aarch64, Windows support, tail calls, reftypes, other stuff -- see <a href=\"https://github.com/bytecodealliance/wasmtime/issues?q=is%3Aissue+is%3Aopen+winch\">here</a>).</p>\n</blockquote>",
        "id": 491337408,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735598233
    },
    {
        "content": "<p>xtuc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2566306262\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Sounds good.</p>\n<p>I'm assuming adding some kind of pseudo instructions in Cranelift for extra bookkeeping (when the trap-on-coredump is set) has an acceptable perf impact.</p>\n<p>Comparing to the current solution of rewriting the Wasm binary ahead of time to inject coredump support, for essentially the doing the same bookkeeping, adds significantly more overhead and is more limited.</p>\n</blockquote>",
        "id": 491387712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735639386
    },
    {
        "content": "<p>xtuc edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2566306262\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Sounds good.</p>\n<p>I'm assuming adding some kind of pseudo instructions in Cranelift for extra bookkeeping (when trap-on-coredump is set) has an acceptable perf impact.</p>\n<p>Comparing to the current solution of rewriting the Wasm binary ahead of time to inject coredump support, for essentially the doing the same bookkeeping, adds significantly more overhead and is more limited.</p>\n</blockquote>",
        "id": 491407923,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735654725
    },
    {
        "content": "<p>xtuc edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2566306262\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Sounds good.</p>\n<p>I'm assuming adding some kind of pseudo instructions in Cranelift for extra bookkeeping (when coredump-on-trap is set) has an acceptable perf impact.</p>\n<p>Comparing to the current solution of rewriting the Wasm binary ahead of time to inject coredump support, for essentially the doing the same bookkeeping, adds significantly more overhead and is more limited.</p>\n</blockquote>",
        "id": 491407940,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735654740
    },
    {
        "content": "<p>xtuc edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2566306262\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<p>Sounds good.</p>\n<p>I'm assuming adding some kind of pseudo instructions in Cranelift for extra bookkeeping (when coredump-on-trap is set) has an acceptable perf impact.</p>\n<p>Comparing to the current solution of rewriting the Wasm binary ahead of time to inject coredump support, for essentially doing the same bookkeeping, adds significantly more overhead and is more limited.</p>\n</blockquote>",
        "id": 491407962,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735654764
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732#issuecomment-2566579375\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5732\">issue #5732</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm assuming adding some kind of pseudo instructions in Cranelift for extra bookkeeping (when coredump-on-trap is set) has an acceptable perf impact.</p>\n</blockquote>\n<p>That would be the first question to answer if we pursue that approach! I did have some ideas around conditionalizing it -- to sketch it a little more, generate IR that has branches for each trap condition (as we do today for many but not all traps) and puts the \"Wasm VM state\" pseudoinst that consumes all op stack + locals in the cold trapping path, so our demand-based code placement during optimization would put any optimized-out-except-in-debug value computations in a \"recover state after we detect a trap\" sequence on that path. But that's just an idea to pursue; and this was post-RFC discussion, so the RFC's plan (Winch-based coredumps+debug) should come first.</p>\n</blockquote>",
        "id": 491419544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735662941
    }
]