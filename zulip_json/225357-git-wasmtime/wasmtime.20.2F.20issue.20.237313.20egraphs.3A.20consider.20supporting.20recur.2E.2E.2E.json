[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7313\">issue #7313</a>:</p>\n<blockquote>\n<p>After #7306, we have a rematerialization mechanism that can remat a single operator into the block where it's used. To solve another decision-ordering issue w.r.t. LICM, remat was moved very late: just before using args. As a result, it no longer participates in the main elaboration pass and so we don't automatically get \"recursive\" remat. This might occur in cases where we have, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span>:\n  <span class=\"nc\">v10</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"w\">  </span><span class=\"n\">v11</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v10</span>\n\n<span class=\"n\">blockN</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span>:\n  <span class=\"nc\">store</span><span class=\"w\"> </span><span class=\"n\">v11</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>if we had marked both <code>v10</code> and <code>v11</code> as rematerializable. The old mechanism would move both into <code>blockN</code>, but the new mechanism moves only <code>iadd</code>.</p>\n<p>This is solvable if we add a new recursion site, but in the egraphs code we've been careful to avoid any native recursion, using an explicit stack and open-coded state machine instead. The only reason we haven't done that for this issue is complexity.</p>\n<p>The current situation (post-#7306) is possibly OK for a while: we remat constants, and adds-with-one-constant-arg; the latter will fold small (common) constants into the instruction on most architectures. If it ever becomes an issue, though, we could add the recursion and solve this issue in the general way.</p>\n</blockquote>",
        "id": 397765776,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697830468
    }
]