[
    {
        "content": "<p>giteewif opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out.</p>\n</blockquote>",
        "id": 491227647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735526058
    },
    {
        "content": "<p>giteewif edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out. And i also test on engine. Test is like the figure below.<br>\n![image](<a href=\"https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d\">https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d</a>)</p>\n</blockquote>",
        "id": 491227805,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1735526196
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2573362785\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>Once the <code>Engine</code>, <code>Module</code>, and <code>Store</code> have all been deallocated then the memory is released back to the OS. Could you detail a bit more what statistic syolu're measuring in <code>get_memory_use</code> and <code>get_detailed_memory_info</code> and what they are printing out in your snippet above?</p>\n</blockquote>",
        "id": 492127661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736177800
    },
    {
        "content": "<p>giteewif <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">call_engine</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wasm_bytes</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">work_path</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_wasm_bytes</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_engine_linker</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// {</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load_module</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">wasm_bytes</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n\n<span class=\"w\">    </span><span class=\"c1\">// get_detailed_memory_info(std::process::id().to_string().as_str()).unwrap();</span>\n<span class=\"w\">    </span><span class=\"c1\">// let module3 = load_module(&amp;engine, &amp;wasm_bytes).unwrap();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// call_fork()?;</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_func_call_env</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">linker</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">work_path</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"n\">call_func</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"_start\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// get_memory_use(std::process::id().to_string().as_str()).unwrap();</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">call_engine</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"after\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">get_memory_use</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>output<br>\n![image](<a href=\"https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533\">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>\n</blockquote>",
        "id": 492229992,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736217718
    },
    {
        "content": "<p>giteewif edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">call_engine</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wasm_bytes</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">work_path</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_wasm_bytes</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_engine_linker</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// {</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load_module</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">wasm_bytes</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_func_call_env</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">linker</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">work_path</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"n\">call_func</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"_start\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">call_engine</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"after\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">get_memory_use</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>output<br>\n![image](<a href=\"https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533\">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>\n</blockquote>",
        "id": 492230191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736217807
    },
    {
        "content": "<p>giteewif edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2574284552\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I also think so.get_memory_use and get_detailed_memory_info is based on the /proc/self/smaps, read the rss or vmrss. Detailed test bellow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">call_engine</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wasm_bytes</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">work_path</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_wasm_bytes</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_engine_linker</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load_module</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">wasm_bytes</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">init_func_call_env</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">linker</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">work_path</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"n\">call_func</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"_start\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">call_engine</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"after\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">get_memory_use</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">get_detailed_memory_info</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">process</span><span class=\"p\">::</span><span class=\"n\">id</span><span class=\"p\">().</span><span class=\"n\">to_string</span><span class=\"p\">().</span><span class=\"n\">as_str</span><span class=\"p\">()).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>output<br>\n![image](<a href=\"https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533\">https://github.com/user-attachments/assets/9beae311-4497-41ef-abef-ca9721b89533</a>)</p>\n</blockquote>",
        "id": 492230218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736217827
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2575842176\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I'm not personally super familar with these statistics from Linux, so I don't know exactly what the problem is myself. That being said you might be seeing some side effects of using Tokio as a runtime through <code>wasmtime-wasi</code> which persists data structures and such.</p>\n<p>Regardless though I'm not aware of how <code>Engine</code>, <code>Store</code>, <code>Module</code>, etc, could leak something at this time. There's always the possibility of a bug, however.</p>\n<p>Can you clarify which of these statistics you're looking at in particular? For example did you expect \"Total RSS\" to go down to what it was before?</p>\n</blockquote>",
        "id": 492353003,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736270408
    },
    {
        "content": "<p>giteewif <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2576596574\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I think it is not the problems of the tokio, wasmtime-wasi is created when WasiCtxBuilder call build. </p>\n<p>At the begining, the wasmtime only take 4 MB rss,  it increases at 20 MB after loading the Module.In the load_modules func , i just call the func Module::new().</p>\n<p>In my aspect, RSS represent the real physical memory the process takes. It seems that Module::new() takes more memory. I think it results from the compilation of a Module. In my expectation it should release the memory, when the module out of time, or engine out of lifetime which means \"Total RSS\" should go down to 4-10 MB. However, the total rss also in 20MB.</p>\n<p>It may results from cranelift compiler? I'm not sure. </p>\n<p>Here i give the more concise info<br>\n![image](<a href=\"https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221\">https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221</a>)</p>\n</blockquote>",
        "id": 492424942,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736304405
    },
    {
        "content": "<p>giteewif edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2576596574\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I think it is not the problems of the tokio, wasmtime-wasi is created when WasiCtxBuilder call build. </p>\n<p>At the begining, the wasmtime only take 2 MB rss,  it increases at 22 MB after loading the Module.In the load_modules func , i just call the func Module::new().</p>\n<p>In my aspect, RSS represent the real physical memory the process takes. It seems that Module::new() takes more memory. I think it results from the compilation of a Module. In my expectation it should release the memory, when the module out of time, or engine out of lifetime which means \"Total RSS\" should go down to 3-10 MB. However, the total rss also in 20MB.</p>\n<p>It may results from cranelift compiler? I'm not sure. </p>\n<p>Here i give the more concise info<br>\n![image](<a href=\"https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221\">https://github.com/user-attachments/assets/abc7d615-5f6f-445a-8ccb-7dd0275c5221</a>)</p>\n</blockquote>",
        "id": 492424972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736304434
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2577997854\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>\n</blockquote>",
        "id": 492531357,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736351062
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2578019890\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>\n<p>(For what it's worth, this is the standard in C/C++ programs too: one tests for leaks with Valgrind, not by looking at RSS.)</p>\n</blockquote>",
        "id": 492533046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736351593
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2578019890\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>\n<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>\n</blockquote>",
        "id": 492533076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736351602
    },
    {
        "content": "<p>giteewif <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579028538\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<blockquote>\n<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>\n</blockquote>\n<p>I have gave it a try. It showed that rss measured is improved. It is associated with the rayon thread pool in some parts.<br>\n![image](<a href=\"https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37\">https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37</a>)</p>\n<blockquote>\n<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>\n<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>\n</blockquote>\n<p>I got it, i would like to test based on the valgrind.</p>\n</blockquote>",
        "id": 492616162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736388500
    },
    {
        "content": "<p>giteewif edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579028538\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<blockquote>\n<p>Oh you know this is probably related to the Rayon thread pool for parallel compilation of the module. Could you try configuring <code>Config::parallel_compilation(false)</code> and see if that improves the RSS you're measuring?</p>\n</blockquote>\n<p>I have gave it a try. It showed that rss measured is improved. It is associated with the rayon thread pool in some parts.<br>\n![image](<a href=\"https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37\">https://github.com/user-attachments/assets/bc1afc41-88e2-4946-8f31-bc67ee585d37</a>)</p>\n<blockquote>\n<p>It's also possible that allocations with the system allocator (regular <code>Box</code>/<code>Vec</code> stuff in the compiler for example) are returned to the allocator, but the allocator does not return the memory to the OS. Pretty likely even (otherwise new allocations would always be expensive because there would be no freelisted already-mapped memory!). For that reason, I think one would have to have Valgrind-level instrumentation to truly determine that we have no leaks.</p>\n<p>(For what it's worth, this is the standard in C/C++ programs too: one usually tests for leaks with Valgrind, not by looking at RSS.)</p>\n</blockquote>\n<p>I got it, i would like to test based on the valgrind. And i think the system allocator is the probable reason, cause i see the similar situation in other wasm runtime.</p>\n</blockquote>",
        "id": 492616381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736388672
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>I use the wasmtime api of  loading wasm to get a module, when a module out of lifetime in rust code, i get the memory , and figure out that the memory also cost a lot. Is the compile memory still stay even the module out of lifetime? In rust , when the module out of time i think it would be freed out. And i also test on engine. Test is like the figure below.<br>\n![image](<a href=\"https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d\">https://github.com/user-attachments/assets/ef9c83c2-8bc4-4fb0-95a7-3decd978a16d</a>)</p>\n</blockquote>",
        "id": 492630275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736397492
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914#issuecomment-2579166180\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9914\">issue #9914</a>:</p>\n<blockquote>\n<p>Ah ok, nice! Chris also brings up excellent points as well which I would definitely echo too (and completely forgot about at the start of this thread...)</p>\n<p>In any case I don't think we have any leaks here in Wasmtime, so I'm going to close this. If you see suspicious behavior though in Valgrind let us know!</p>\n</blockquote>",
        "id": 492630277,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736397492
    }
]