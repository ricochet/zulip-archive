[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3574\">issue #3574</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3560#discussion_r757955589\">this comment</a> on ISLE documentation, @avanhatt mentioned fuzzing as related to the <code>Context</code> trait that separates generated code from the Cranelift glue. This got me thinking that there is actually a nice way we could fuzz the ISLE-generated code independently.</p>\n<p>Specifically, we could write an alternate implementation of the <code>Context</code> that stubs out external constructors, and that implements all external extractors in terms of an <code>arbitrary::Unstructured</code> state that it carries. As the pattern-matching makes queries about its input by calling external extractors, the context object could invent answers on the fly with <code>Arbitrary</code> implementations.</p>\n<p>This would allow us both to test the generated code to look for unexpected panics -- for example, if we have <code>unreachable!()</code> anywhere -- and to look for inefficiencies/timeouts, e.g. if there is an infinite recursion.</p>\n<p>There is some maintenance effort involved (separate implementation of each external etor/ctor that we add) but it might be worthwhile; thoughts?</p>\n</blockquote>",
        "id": 263201511,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1638302984
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3574\">issue #3574</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3560#discussion_r757955589\">this comment</a> on ISLE documentation, @avanhatt mentioned fuzzing as related to the <code>Context</code> trait that separates generated code from the Cranelift glue. This got me thinking that there is actually a nice way we could fuzz the ISLE-generated code independently.</p>\n<p>Specifically, we could write an alternate implementation of the <code>Context</code> that stubs out external constructors, and that implements all external extractors in terms of an <code>arbitrary::Unstructured</code> state that it carries. As the pattern-matching makes queries about its input by calling external extractors, the context object could invent answers on the fly with <code>Arbitrary</code> implementations.</p>\n<p>This would allow us both to test the generated code to look for unexpected panics -- for example, if we have <code>unreachable!()</code> anywhere -- and to look for inefficiencies/timeouts, e.g. if there is an infinite recursion.</p>\n<p>There is some maintenance effort involved (separate implementation of each external etor/ctor that we add) but it might be worthwhile; thoughts?</p>\n</blockquote>",
        "id": 263208118,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1638306114
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3574#issuecomment-983017158\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3574\">issue #3574</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 263208187,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1638306126
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3574\">issue #3574</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3560#discussion_r757955589\">this comment</a> on ISLE documentation, @avanhatt mentioned fuzzing as related to the <code>Context</code> trait that separates generated code from the Cranelift glue. This got me thinking that there is actually a nice way we could fuzz the ISLE-generated code independently.</p>\n<p>Specifically, we could write an alternate implementation of the <code>Context</code> that stubs out external constructors, and that implements all external extractors in terms of an <code>arbitrary::Unstructured</code> state that it carries. As the pattern-matching makes queries about its input by calling external extractors, the context object could invent answers on the fly with <code>Arbitrary</code> implementations.</p>\n<p>This would allow us both to test the generated code to look for unexpected panics -- for example, if we have <code>unreachable!()</code> anywhere -- and to look for inefficiencies/timeouts, e.g. if there is an infinite recursion.</p>\n<p>There is some maintenance effort involved (separate implementation of each external etor/ctor that we add) but it might be worthwhile; thoughts?</p>\n</blockquote>",
        "id": 281212123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694564
    }
]