[
    {
        "content": "<p>yamt opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>my co-worker told me that wasmtime project wanted to hear use-cases/demands/requirements for embedded scenarios.<br>\nhere is FYI about our requirements.</p>\n<h4>Feature</h4>\n<p>support embedded environment</p>\n<p>by \"embedded\", i meant something like</p>\n<ul>\n<li>32-bit</li>\n<li>no mmu</li>\n<li>no linux. probably nuttx or freertos.</li>\n<li>memory: from a few hundred KB to several MB (for the entire system, not just wasmtime)</li>\n<li>aot is a must as jit is unrealistic</li>\n<li>storage: probably a several MB</li>\n<li>cpu arch: probably xtensa or 32-bit riscv</li>\n</ul>\n<h4>Benefit</h4>\n<p>more adaptation?</p>\n<h4>Implementation</h4>\n<p>i myself have no idea.<br>\ndo you think it's realistic to support this sort of small environments?</p>\n<h4>Alternatives</h4>\n<ul>\n<li>stick with \"huge\" linux environments like raspberry pi.</li>\n<li>use other runtime. eg. wamr.<br>\n</li>\n</ul>\n</blockquote>",
        "id": 397668082,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697794016
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1772881516\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>Thanks for writing this up! Wasmtime has aways to go to support systems like this, but at least in my opinion it's tractable. Some questions for you:</p>\n<ul>\n<li>Do you know if Rust code runs at all on this system? For example what Rust targets should we look at as a compilation target? I notice, for example, that Rust has a <code>riscv32i-unknown-none-elf</code> target but there's no corresponding Linux target, so it may be that Rust doesn't have a target for this yet (that's ok though). I'm not familiar with xtensa, though, is that an ARM platform?</li>\n<li>Do these environments have a kernel? Or without an MMU is the program basically running directly on the hardware?</li>\n<li>In terms of memory allocation, is there something that's mmap-like or is the thinking that it's \"just call <code>malloc</code>\"? For example how are linear memories allocated today for wasm?</li>\n</ul>\n<p>I think the two major lifts for supporting a platform like this will be (a) a riscv32 backend in Cranelift and (b) porting work to get Wasmtime to compile on the target. I know (a) is a big chunk of work but (b) depends on whether there's a Rust target already for this platform. If there's not it'll be a bit more work.</p>\n</blockquote>",
        "id": 397726131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697813316
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1773257821\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>Xtensa is a <a href=\"https://dl.espressif.com/github_assets/espressif/xtensa-isa-doc/releases/download/latest/Xtensa.pdf\">separate ISA</a>. It's a little unique (register windows automatically shifted by calls, deja vu from SPARC!) but it's conceivable it could be supported by Cranelift. If we had to pick one \"embedded-friendly\" ISA to support I think I'd definitely prefer it be RV32I: it's more \"standard\" w.r.t. our other ISAs, especially as we support RV64GC already.</p>\n<p>My main concern with both, in terms of porting effort, would actually be floating-point: from the above it doesn't look like Xtensa has hardware FP, and RV32I doesn't either; so we'd need to do softfloat (an integer-only Wasm subset would probably not be something we'd ship as it wouldn't be a conforming implementation). We could turn every FP op into a libcall and use an existing softfloat library, I guess.</p>\n</blockquote>",
        "id": 397762162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697828535
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1773279241\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>I don't think you would want to avoid floats entirely on an embedded system without fpu as softfloat is expensive, especially on microcontrollers that are already slow. A softfloat impl in wasmtime would also take up a lot of precious space. Entirely omitting float support from wasmtime if the cpu doesn't support it makes sense from that perspective even if not conforming with the wasm spec. Something that would be possible though I think is to have a tool rewriting wasm to replace floats with a softfloat impl inside wasm itself. This can then allow wasm-opt to strip out unused softfloat intrinsics as well as inline those that are used whenever it saves code size.</p>\n</blockquote>",
        "id": 397764218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697829639
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1773358611\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>One possible middle ground related to floats, we could expose wasmparser's <code>floats</code> feature which, if disabled in Wasmtime, would statically verify the input module has no floats anywhere in it. We could then relax the base required feature set for RISC-V to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/3a5e112c18af084c796928224f7279f809fe3ecf/cranelift/codegen/src/isa/riscv64/mod.rs#L245-L246\">not require the <code>d</code> and <code>f</code> extensions</a>. Optionally we could go further and add <code>has_f</code> and <code>has_d</code> to all of the various instructions from those extensions to surface panic if there's bugs anywhere by accident and anything slips through.</p>\n</blockquote>",
        "id": 397772559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697833961
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1773361385\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>Er to elaborate further on that, we would avoid the need for softfloat anywhere because wasm floats would always compile to hardware floats and we would statically know via verification that the input module doesn't have floats so there's no need for the runtime or the compiler to have a soft-float path. </p>\n<p>The only trickiness would be what if the input module had floats, and for that I think @bjorn3's suggestion is a good one, a theoretical pass to insert soft-float routines in the wasm module itself.</p>\n</blockquote>",
        "id": 397772789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697834107
    },
    {
        "content": "<p>ayakoakasaka <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1775021158\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>Thank you for considering the embedded scenario.<br>\nIs it possible to gradually move the target closer to the Embedded world? </p>\n<blockquote>\n<p>Do you know if Rust code runs at all on this system? For example what Rust targets should we look at as a compilation target? I notice, for example, that Rust has a riscv32i-unknown-none-elf target but there's no corresponding Linux target, so it may be that Rust doesn't have a target for this yet (that's ok though). I'm not familiar with xtensa, though, is that an ARM platform?</p>\n</blockquote>\n<p>-&gt; Q1</p>\n<blockquote>\n<p>Do these environments have a kernel? Or without an MMU is the program basically running directly on the hardware?</p>\n</blockquote>\n<p>-&gt; Q2</p>\n<blockquote>\n<p>In terms of memory allocation, is there something that's mmap-like or is the thinking that it's \"just call malloc\"? For example how are linear memories allocated today for wasm?</p>\n</blockquote>\n<p>-&gt; Q3</p>\n<p>Phase 1:<br>\nUse <a href=\"https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html\">https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html</a><br>\nQ1: RV64GCV with <a href=\"https://github.com/bouffalolab/bl-pac/tree/main/bl808\">https://github.com/bouffalolab/bl-pac/tree/main/bl808</a> might be used<br>\nQ2: the main CPU has MMU and has linux<br>\nQ3: just call malloc</p>\n<p>Phase 2:<br>\nUse <a href=\"https://docs.espressif.com/projects/espressif-esp-dev-kits/en/latest/esp32c6/esp32-c6-devkitc-1/index.html\">https://docs.espressif.com/projects/espressif-esp-dev-kits/en/latest/esp32c6/esp32-c6-devkitc-1/index.html</a><br>\nQ1: 32-bit RISC-V with <a href=\"https://github.com/esp-rs/esp-rust-board\">https://github.com/esp-rs/esp-rust-board</a> might be used <br>\nQ2: no MMU/ no linux<br>\nQ3: just call malloc(I guess)</p>\n</blockquote>",
        "id": 398067671,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1698061769
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1775056887\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<blockquote>\n<p>Phase 1</p>\n</blockquote>\n<p>This should work today! It is pretty much the same as a regular environment, just with a slower CPU and less RAM, so as long as you don't run into those issues you should be good.</p>\n<blockquote>\n<p>Phase 2</p>\n</blockquote>\n<p>Looking at the datasheet for that SOC it looks like the CPU is  RV32IMAC, so we do have the issues above with not supporting floats / doubles. (And not having a cranelift backend for RISC-V 32)</p>\n<p>Having malloc support is good, in that it brings us closer to normal non embedded rust, but I think we'd still need some minimal support for whatever OS is running. (i.e. using Espressif's SDK's I think it's a fork of FreeRTOS)</p>\n<p>If you are running without any OS or other platform, then I'm not entirely sure how rust works on those platforms W.R.T threading / interrupts / etc..</p>\n</blockquote>",
        "id": 398071677,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1698063155
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1775056887\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<blockquote>\n<p>Phase 1</p>\n</blockquote>\n<p>This should work today! It is pretty much the same as a regular environment, just with a slower CPU and less RAM, so as long as you don't run into those issues you should be good.</p>\n<p>It looks like the BL808 has a fairly large 64MiB of RAM. I have never measured how much RAM we use in Wasmtime so I don't know if that is enough.</p>\n<blockquote>\n<p>Phase 2</p>\n</blockquote>\n<p>Looking at the datasheet for that SOC it looks like the CPU is  RV32IMAC, so we do have the issues above with not supporting floats / doubles. (And not having a cranelift backend for RISC-V 32)</p>\n<p>Having malloc support is good, in that it brings us closer to normal non embedded rust, but I think we'd still need some minimal support for whatever OS is running. (i.e. using Espressif's SDK's I think it's a fork of FreeRTOS)</p>\n<p>If you are running without any OS or other platform, then I'm not entirely sure how rust works on those platforms W.R.T threading / interrupts / etc..</p>\n</blockquote>",
        "id": 398072746,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1698063585
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1776120745\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>I'd echo what @afonso360 said already, and I'd additionally add though that I think it makes sense to move Wasmtime in the direction of embedded. This will require a nontrivial amount of work that will take some time but at least in my opinion it's possible so long as there are resources to apply. </p>\n<p>The big-ticket items of RV32 and size optimizations are fairly separable and I suspect there's probably other smaller porting work and such to happen as well. No need for that to all happen as one big bang and I think PRs can trickle in over time to improve the situation here.</p>\n</blockquote>",
        "id": 398164290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1698100044
    },
    {
        "content": "<p>ayakoakasaka <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-1778122007\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>Thank you for considering embedded systems. As @alexcrichton and @bjorn3 mentioned, soft-floats are too expensive for a weak environment. Therefore, we use hardware floats for our case.</p>\n<p>However, I'm grateful to know there's a way even without hardware support.</p>\n</blockquote>",
        "id": 398367570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1698185329
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:platform-support label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">Issue #7311</a>.</p>",
        "id": 405599648,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1701575844
    },
    {
        "content": "<p>TheQuantumPhysicist <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-2107078740\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>The fact that armv7/armhf are not supported is very disappointing. This is a problem for me because many embedded devices are 32-bit, including Raspberry Pi zero. </p>\n<p>Raspberry Pi zero 2 isn't properly supported in many systems, like Buildroot, which makes dealing with 32-bit much easier. </p>\n<p>Supporting 32-bit just makes everything much simpler for embedded devices.</p>\n</blockquote>",
        "id": 438314732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715592291
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-2108097493\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<p>@TheQuantumPhysicist we're well aware! No one in the project has really made a decision <em>not</em> to support 32-bit targets. The reality is rather that it takes a good amount of effort to add a new compiler target (i.e., write a backend), on the order of a few months of full-time work, and none of us can afford that time away from other tasks that we also have to do at the moment.</p>\n<p>Please do keep in mind that this is an open-source project, that is, a collaboration, and the best way to obtain a large feature is to show up with a PR; registering your displeasure alone (\"very disappointing\") is fairly unlikely to be effective.</p>\n</blockquote>",
        "id": 438396871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715616021
    },
    {
        "content": "<p>TheQuantumPhysicist <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311#issuecomment-2108170432\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7311\">issue #7311</a>:</p>\n<blockquote>\n<blockquote>\n<p>@TheQuantumPhysicist we're well aware! No one in the project has really made a decision _not_ to support 32-bit targets. The reality is rather that it takes a good amount of effort to add a new compiler target (i.e., write a backend), on the order of a few months of full-time work, and none of us can afford that time away from other tasks that we also have to do at the moment.</p>\n<p>Please do keep in mind that this is an open-source project, that is, a collaboration, and the best way to obtain a large feature is to show up with a PR; registering your displeasure alone (\"very disappointing\") is fairly unlikely to be effective.</p>\n</blockquote>\n<p>Apologies for sounding self-centered and entitled in that comment. I didn't mean that I'm entitled to anything. It's just a frustrating experience I went through that complicated everything for some work I'm doing. Everyone's efforts here are highly appreciated and thank you for the great work you've been doing.</p>\n<p>Perhaps it's just my ignorance, but I imagined that adding a 32-bit target wouldn't be that difficult, especially that wasm is 32-bit itself and that aarch64 is already supported. But I have to say that I have zero knowledge about how the backend operates, so I'm probably wrong.</p>\n</blockquote>",
        "id": 438404237,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715618317
    }
]