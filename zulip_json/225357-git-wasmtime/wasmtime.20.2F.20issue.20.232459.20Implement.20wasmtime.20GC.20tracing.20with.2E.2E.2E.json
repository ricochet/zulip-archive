[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459#issuecomment-1198705958\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459\">issue #2459</a>:</p>\n<blockquote>\n<p>@fitzgen now that #4431 is merged (<span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> ) is this issue subsumed as well? I.e. I wonder if GC tracing works with unwinding info omitted?</p>\n</blockquote>",
        "id": 291263432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659049066
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459#issuecomment-1198706349\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459\">issue #2459</a>:</p>\n<blockquote>\n<p>(the other part of this issue is I guess discussing ways to avoid the need for stackmaps entirely, but the toplevel problem description is basically just \"make do without libunwind\")</p>\n</blockquote>",
        "id": 291263554,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659049117
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459#issuecomment-1201504910\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459\">issue #2459</a>:</p>\n<blockquote>\n<p>Yes, this issue should be resolved, but I'll leave it open until I can verify whether we can disable dynamically registering unwind info without breaking <code>perf</code> or what have you.</p>\n</blockquote>",
        "id": 291608005,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659375157
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459#issuecomment-1205501169\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459\">issue #2459</a>:</p>\n<blockquote>\n<p>I'm actually going to close this as complete, and handle the unwind info and all that in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4554\">https://github.com/bytecodealliance/wasmtime/issues/4554</a></p>\n</blockquote>",
        "id": 292032966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659630893
    },
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2459\">issue #2459</a>:</p>\n<blockquote>\n<p>In wasmtime, GC tracing of reftype pointers currently works by using <code>libunwind</code> to iterate over stack frames, fetching a stackmap for each relevant PC and finding the stack slots with live pointers.</p>\n<p>This works perfectly fine, but is potentially slower than we would like, because <code>libunwind</code> relies on DWARF info to understand stack frames. It is also more complex -- it relies on DWARF generation and interpretation to be correct -- which increases risk a little because GC-tracing bugs can lead to various security issues.</p>\n<p>In contrast, many other high-performance JITs use explicit data structures of some sort on the stack so that tracing stack roots boils down to walking a linked list of some sort. For example, SpiderMonkey has a strict <a href=\"https://searchfox.org/mozilla-central/rev/168c45a7acc44e9904cfd4eebcb9eb080e05699c/js/src/wasm/WasmFrameIter.h#50-57\">JIT-frame discipline allowing fast iteration</a> (different from the system ABI), and V8 indirects object references through <code>InstanceHandle</code>s that link themselves into a list on the thread context.</p>\n<p>We should look into designing a mechanism that maintains a stack of frames reachable from the <code>vmctx</code> and walkable without any metadata (aside from the stackmaps). Two options that come to mind are:</p>\n<h3>Option 1: Shadow Stack of (SP, Stackmap) Tuples</h3>\n<p>Maintain a shadow stack (with top and limit pointers in <code>vmctx</code>) of <code>(stackmap, SP)</code> tuples. On function entry, allocate a tuple. At every safepoint, ensure that the stack pointer and stackmap for that safepoint are up-to-date in the tuple. Walking the stack for GC roots then simply requires (i) looping over these tuples, and (ii) tracing references at offsets indicated by the stackmap.</p>\n<p>Some advantages of this scheme are:</p>\n<ul>\n<li>It is a relatively small delta from today's implementation. It requires inserting code at prologue and epilogue/returns to alloc/dealloc the tuple, and at every safepoint to store the stackmap pointer and SP value.</li>\n</ul>\n<p>Some disadvantages of this scheme are: </p>\n<ul>\n<li>The stackmap pointer would have to be indirected somehow; we cannot bake the raw pointer value into the code if the code is cached on disk.</li>\n<li>It will slightly increase memory traffic at every safepoint, as in addition to the spills of all references inserted by the register allocator, we have to store stackmap and SP pointers.</li>\n</ul>\n<h3>Option 2: Shadow Stack of References</h3>\n<p>Maintain a shadow stack that actually stores spilled references. On function entry, bounds-check that there is enough shadow-stack space for the maximal live-set of reftyped values at any safepoint in the function (this is statically known). At any safepoint, push all live reftyped values to the shadow stack; after the safepoint, restore them (if we implement a moving GC that may edit pointers) or bulk-pop them by bumping the top pointer.</p>\n<p>Some advantages of this scheme are:</p>\n<ul>\n<li>It is independent of reftypes support in Cranelift and <code>regalloc.rs</code>; in other words, it is very simple and easy to verify. While we are pretty confident in the reftypes implementation at least in the backtracking allocator at this point, less complexity is always good; and it lowers the bar for adopting other register allocators in the future, if we choose to do that.</li>\n<li>Tracing will be as fast as possible; we literally provide the GC with a <code>&amp;[PointerT]</code> (slice of contiguous live pointers). This is even better than walking a potentially sparse stackmap looking for set bits.</li>\n<li>It has no additional memory traffic relative to the status quo (what we do today) unless a reftyped value was already spilled; we are simply replacing regalloc spills with stores to our shadow stack.</li>\n</ul>\n<p>A disadvantage of this scheme is:</p>\n<ul>\n<li>It adds a little memory traffic when a reftyped value was already spilled at a safepoint: it will be loaded from the spillslot and then pushed onto the shadow stack. Note that this does not need to be explicitly handled (shadow-stack code is inserted before regalloc, so regalloc will just Do The Right Thing and reload the spilled value), but it is suboptimal.</li>\n</ul>\n<p>I tentatively prefer Option 2, but I can see both options as viable. Thoughts?</p>\n<p>cc @fitzgen</p>\n</blockquote>",
        "id": 292032967,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659630893
    }
]