[
    {
        "content": "<p>uweigand opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Support for instructions with multiple outputs in ISLE seems to be missing and/or broken at the moment.   In general, CLIF instructions may have any number of outputs, each of which may in turn be implemented as one or more registers (i.e. a <code>ValueRegs</code> structure).</p>\n<p>However, with ISLE instruction selection, the <code>lower_common</code> helper routine calls the <code>lower</code> ISLE constructor, which only has a _single_ <code>ValueRegs</code> return value.   Now, there is some code in <code>lower_common</code> that seems intended to use the registers provides in that single <code>ValueRegs</code> to implement multiple outputs.  But that doesn't appear to be working.</p>\n<p>In particular, in the common case where we have two outputs with a single register each, and the ISLE <code>lower</code> constructor attempts to handle this by returning two registers in a single <code>ValueRegs</code>, we run into this loop:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dsts</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_output_reg</span><span class=\"p\">(</span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">.</span><span class=\"n\">output_ty</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">insn</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">C</span>::<span class=\"n\">I</span><span class=\"o\">&gt;</span>::<span class=\"n\">rc_for_type</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">temp_regs</span><span class=\"p\">.</span><span class=\"n\">by_ref</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">dsts</span><span class=\"p\">.</span><span class=\"n\">regs</span><span class=\"p\">()).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">renamer</span><span class=\"p\">.</span><span class=\"n\">add_rename</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">.</span><span class=\"n\">to_reg</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The problem here is that due to the way the Rust <code>zip</code> routine works, the first pass through that loop will already consume <em>both</em> registers in <code>temp_regs</code> (the <code>ValueRegs</code> returned from <code>lower</code>).   The second pass through the loop will find <code>temp_regs</code> empty and simply not initialize the second output at all.</p>\n<p>This isn't an issue at the moment since the only multi-output instruction currently implemented in ISLE is <code>iadd_ifcout</code>, and here the second output is the carry flag, which is ignored as an output anyway (it's handled differently by explicitly matching the combination of the <code>iadd_ifcout</code> and the carry consumer).   But if we want to handle instructions that really use multiple outputs (most notably call instructions), this is a problem.</p>\n<p>Now, this specific issue can be fixed by doing the <code>zip</code> the other way around.   B.t.w. this then actually breaks <code>iadd_ifcout</code> - the current implementations <em>rely</em> on the second output being dropped!  That problem can also be fixed e.g. by special-casing <code>IFLAG</code> type outputs.  But even then, we can only handle at most two outputs, because any single <code>ValueRegs</code> contains at most two registers.</p>\n<p>How is this supposed to be handled?   Should <code>lower</code> be changed to return something like a vector of <code>ValueRegs</code> instead of just a single one?   Or should there be a different ISLE constructor for multi-output instructions?</p>\n<p>CC @cfallin </p>\n</blockquote>",
        "id": 270183018,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643710817
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Support for instructions with multiple outputs in ISLE seems to be missing and/or broken at the moment.   In general, CLIF instructions may have any number of outputs, each of which may in turn be implemented as one or more registers (i.e. a <code>ValueRegs</code> structure).</p>\n<p>However, with ISLE instruction selection, the <code>lower_common</code> helper routine calls the <code>lower</code> ISLE constructor, which only has a _single_ <code>ValueRegs</code> return value.   Now, there is some code in <code>lower_common</code> that seems intended to use the registers provides in that single <code>ValueRegs</code> to implement multiple outputs.  But that doesn't appear to be working.</p>\n<p>In particular, in the common case where we have two outputs with a single register each, and the ISLE <code>lower</code> constructor attempts to handle this by returning two registers in a single <code>ValueRegs</code>, we run into this loop:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dsts</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_output_reg</span><span class=\"p\">(</span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">.</span><span class=\"n\">output_ty</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">insn</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">C</span>::<span class=\"n\">I</span><span class=\"o\">&gt;</span>::<span class=\"n\">rc_for_type</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">temp_regs</span><span class=\"p\">.</span><span class=\"n\">by_ref</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">dsts</span><span class=\"p\">.</span><span class=\"n\">regs</span><span class=\"p\">()).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">renamer</span><span class=\"p\">.</span><span class=\"n\">add_rename</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">.</span><span class=\"n\">to_reg</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The problem here is that due to the way the Rust <code>zip</code> routine works, the first pass through that loop will already consume <em>both</em> registers in <code>temp_regs</code> (the <code>ValueRegs</code> returned from <code>lower</code>).   The second pass through the loop will find <code>temp_regs</code> empty and simply not initialize the second output at all.</p>\n<p>This isn't an issue at the moment since the only multi-output instruction currently implemented in ISLE is <code>iadd_ifcout</code>, and here the second output is the carry flag, which is ignored as an output anyway (it's handled differently by explicitly matching the combination of the <code>iadd_ifcout</code> and the carry consumer).   But if we want to handle instructions that really use multiple outputs (most notably call instructions), this is a problem.</p>\n<p>Now, this specific issue can be fixed by doing the <code>zip</code> the other way around.   B.t.w. this then actually breaks <code>iadd_ifcout</code> - the current implementations <em>rely</em> on the second output being dropped!  That problem can also be fixed e.g. by special-casing <code>IFLAG</code> type outputs.  But even then, we can only handle at most two outputs, because any single <code>ValueRegs</code> contains at most two registers.</p>\n<p>How is this supposed to be handled?   Should <code>lower</code> be changed to return something like a vector of <code>ValueRegs</code> instead of just a single one?   Or should there be a different ISLE constructor for multi-output instructions?</p>\n<p>CC @cfallin </p>\n</blockquote>",
        "id": 270261886,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643740416
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1027161169\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 270262023,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643740459
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1027161462\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Thanks for writing this up -- it's still an unresolved question in the ISLE integration but we've talked about a few approaches -- the main ones that I think are viable exactly those you named in your last paragraph. To expand a bit more:</p>\n<ul>\n<li>We could add a <code>lower_2</code>, <code>lower_3</code>, ... entrypoint for those instructions that have a fixed number of results -- the add+carry-like operators, etc. Here we should have a return type that is a container with exactly this many <code>ValueRegs</code>.</li>\n<li>We could additionally add a <code>lower_multiple</code> entrypoint for those instructions that return a dynamic (at compiler-backend-author-time) number of values. <code>call</code> and, if we eventually SSA-ify by creating a pseudoinst that grabs argument values, <code>func_args</code> are probably the two most prominent examples. Any others that might fit this?</li>\n<li>Specifically I think it's important that we <em>don't</em> change the existing <code>lower</code> entrypoint -- the clarity of just returning one value, without additional wrappers, should remain for most operators I think.</li>\n</ul>\n</blockquote>",
        "id": 270262078,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643740483
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1027162621\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Thanks for digging into this.</p>\n<blockquote>\n<p>How is this supposed to be handled? Should <code>lower</code> be changed to return something like a vector of <code>ValueRegs</code> instead of just a single one? Or should there be a different ISLE constructor for multi-output instructions?</p>\n</blockquote>\n<p>I think having a different ISLE constructor for multi-output instructions would strike a good balance here. We want the single-output common case to read nicely, and the more we have to repackage and wrap the result (<code>Reg</code> into <code>ValueRegs</code> into <code>ValuesRegs</code> or something) the more difficult it is to read 99% of the lowerings.</p>\n</blockquote>",
        "id": 270262335,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643740574
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1027796559\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Hmm.  I agree that we shouldn't have to do mass changes of existing back ends.  But I don't see how these would be needed just because we change the return type of <code>lower</code> - basically all existing rules for <code>lower</code> return either <code>value_reg</code>, <code>value_regs</code>, or <code>value_regs_none</code>, so as long as we change the return type of those accordingly, the actual written rules wouldn't have to change.</p>\n<p>So as an example, we could change the output type of <code>lower</code> to something like <code>ValueRegsList</code>, and then have <code>value_regs_none</code> return an empty <code>ValueRegsList</code> and <code>value_reg</code> and <code>value_regs</code> return a single-element <code>ValueRegsList</code>.  We'd probably want a new <code>value_regs_pair</code> or something for the <code>iadd_ifcout</code> case.</p>\n<p>For variadic instructions like <code>call</code> we'd need a new mechanism to generate variable-length lists anyway, probably using some sort of builder pattern, starting from an empty list and appending outputs in a matching rule using tail recursion.<br>\n</p>\n</blockquote>",
        "id": 270363317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643798067
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1027991982\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Would it be possible to migrate call and ret to ISLE at all? They use quite a lot of non-trivial logic to handle the calling convention.</p>\n</blockquote>",
        "id": 270391269,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643811916
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747#issuecomment-1028010740\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<blockquote>\n<p>Would it be possible to migrate call and ret to ISLE at all? They use quite a lot of non-trivial logic to handle the calling convention.</p>\n</blockquote>\n<p>I believe it is possible.  In fact, I have an experimental patch that does so for s390x, and it is working except for functions with multiple return values, which is why I opened this issue.</p>\n<p>Once I'm a bit further along with cleaning up the remaining issues, I'd be happy to post a proof-of-concept patch to start further discussion.</p>\n</blockquote>",
        "id": 270394460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643813096
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Support for instructions with multiple outputs in ISLE seems to be missing and/or broken at the moment.   In general, CLIF instructions may have any number of outputs, each of which may in turn be implemented as one or more registers (i.e. a <code>ValueRegs</code> structure).</p>\n<p>However, with ISLE instruction selection, the <code>lower_common</code> helper routine calls the <code>lower</code> ISLE constructor, which only has a _single_ <code>ValueRegs</code> return value.   Now, there is some code in <code>lower_common</code> that seems intended to use the registers provides in that single <code>ValueRegs</code> to implement multiple outputs.  But that doesn't appear to be working.</p>\n<p>In particular, in the common case where we have two outputs with a single register each, and the ISLE <code>lower</code> constructor attempts to handle this by returning two registers in a single <code>ValueRegs</code>, we run into this loop:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dsts</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_output_reg</span><span class=\"p\">(</span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">.</span><span class=\"n\">output_ty</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">insn</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">C</span>::<span class=\"n\">I</span><span class=\"o\">&gt;</span>::<span class=\"n\">rc_for_type</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">temp_regs</span><span class=\"p\">.</span><span class=\"n\">by_ref</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">dsts</span><span class=\"p\">.</span><span class=\"n\">regs</span><span class=\"p\">()).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">renamer</span><span class=\"p\">.</span><span class=\"n\">add_rename</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">.</span><span class=\"n\">to_reg</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The problem here is that due to the way the Rust <code>zip</code> routine works, the first pass through that loop will already consume <em>both</em> registers in <code>temp_regs</code> (the <code>ValueRegs</code> returned from <code>lower</code>).   The second pass through the loop will find <code>temp_regs</code> empty and simply not initialize the second output at all.</p>\n<p>This isn't an issue at the moment since the only multi-output instruction currently implemented in ISLE is <code>iadd_ifcout</code>, and here the second output is the carry flag, which is ignored as an output anyway (it's handled differently by explicitly matching the combination of the <code>iadd_ifcout</code> and the carry consumer).   But if we want to handle instructions that really use multiple outputs (most notably call instructions), this is a problem.</p>\n<p>Now, this specific issue can be fixed by doing the <code>zip</code> the other way around.   B.t.w. this then actually breaks <code>iadd_ifcout</code> - the current implementations <em>rely</em> on the second output being dropped!  That problem can also be fixed e.g. by special-casing <code>IFLAG</code> type outputs.  But even then, we can only handle at most two outputs, because any single <code>ValueRegs</code> contains at most two registers.</p>\n<p>How is this supposed to be handled?   Should <code>lower</code> be changed to return something like a vector of <code>ValueRegs</code> instead of just a single one?   Or should there be a different ISLE constructor for multi-output instructions?</p>\n<p>CC @cfallin </p>\n</blockquote>",
        "id": 281212127,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651694565
    },
    {
        "content": "<p>uweigand closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3747\">issue #3747</a>:</p>\n<blockquote>\n<p>Support for instructions with multiple outputs in ISLE seems to be missing and/or broken at the moment.   In general, CLIF instructions may have any number of outputs, each of which may in turn be implemented as one or more registers (i.e. a <code>ValueRegs</code> structure).</p>\n<p>However, with ISLE instruction selection, the <code>lower_common</code> helper routine calls the <code>lower</code> ISLE constructor, which only has a _single_ <code>ValueRegs</code> return value.   Now, there is some code in <code>lower_common</code> that seems intended to use the registers provides in that single <code>ValueRegs</code> to implement multiple outputs.  But that doesn't appear to be working.</p>\n<p>In particular, in the common case where we have two outputs with a single register each, and the ISLE <code>lower</code> constructor attempts to handle this by returning two registers in a single <code>ValueRegs</code>, we run into this loop:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">outputs</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dsts</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_output_reg</span><span class=\"p\">(</span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isle_ctx</span><span class=\"p\">.</span><span class=\"n\">lower_ctx</span><span class=\"p\">.</span><span class=\"n\">output_ty</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">insn</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">output</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">C</span>::<span class=\"n\">I</span><span class=\"o\">&gt;</span>::<span class=\"n\">rc_for_type</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">temp_regs</span><span class=\"p\">.</span><span class=\"n\">by_ref</span><span class=\"p\">().</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">dsts</span><span class=\"p\">.</span><span class=\"n\">regs</span><span class=\"p\">()).</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">tys</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">renamer</span><span class=\"p\">.</span><span class=\"n\">add_rename</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">temp</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">.</span><span class=\"n\">to_reg</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ty</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The problem here is that due to the way the Rust <code>zip</code> routine works, the first pass through that loop will already consume <em>both</em> registers in <code>temp_regs</code> (the <code>ValueRegs</code> returned from <code>lower</code>).   The second pass through the loop will find <code>temp_regs</code> empty and simply not initialize the second output at all.</p>\n<p>This isn't an issue at the moment since the only multi-output instruction currently implemented in ISLE is <code>iadd_ifcout</code>, and here the second output is the carry flag, which is ignored as an output anyway (it's handled differently by explicitly matching the combination of the <code>iadd_ifcout</code> and the carry consumer).   But if we want to handle instructions that really use multiple outputs (most notably call instructions), this is a problem.</p>\n<p>Now, this specific issue can be fixed by doing the <code>zip</code> the other way around.   B.t.w. this then actually breaks <code>iadd_ifcout</code> - the current implementations <em>rely</em> on the second output being dropped!  That problem can also be fixed e.g. by special-casing <code>IFLAG</code> type outputs.  But even then, we can only handle at most two outputs, because any single <code>ValueRegs</code> contains at most two registers.</p>\n<p>How is this supposed to be handled?   Should <code>lower</code> be changed to return something like a vector of <code>ValueRegs</code> instead of just a single one?   Or should there be a different ISLE constructor for multi-output instructions?</p>\n<p>CC @cfallin </p>\n</blockquote>",
        "id": 292067984,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659646030
    }
]