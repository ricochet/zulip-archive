[
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189693906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583331186
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189694960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583331745
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189705419,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583337821
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189712741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583341964
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369075419\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369075419\">PR Review</a>.</p>",
        "id": 189728199,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583351524
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387897968\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387897968\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Should this be <code>test_path_link_nonstrict</code> for convention's sake?</p>\n</blockquote>",
        "id": 189728200,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583351524
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189732086,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583353974
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189732226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583354070
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369127518\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369127518\">PR Review</a>.</p>",
        "id": 189735806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583356624
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387939204\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387939204\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This looks like a good choice of errno value here, but I'd like @sunfishcode to double check that though.</p>\n</blockquote>",
        "id": 189735808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583356624
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369127518\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-369127518\">PR Review</a>.</p>",
        "id": 189735809,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583356625
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387938245\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r387938245\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hmm, I think I'd prefer if we had two versions of the testcase, not necessarily overlapping in any way, but such that the \"strict\" tests are executed only on supported *nix platform, while the rest always executes the \"nonstrict\" set.</p>\n</blockquote>",
        "id": 189735811,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583356625
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189877051,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583488320
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189878513,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583489680
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189878609,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583489769
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189878963,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583490232
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 189879307,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583490514
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n</blockquote>",
        "id": 190083544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583768940
    },
    {
        "content": "<p>marmistrz edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190273224,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583927711
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190421168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584035163
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190484727,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584091692
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190486081,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584092781
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190488613,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584095268
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190489033,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584095653
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190489299,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584095883
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190490593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584097133
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 190553453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584132815
    },
    {
        "content": "<p>marmistrz created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r392472688\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r392472688\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done, the non-strict version is no more!</p>\n</blockquote>",
        "id": 190553866,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584133079
    },
    {
        "content": "<p>marmistrz submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-374615854\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-374615854\">PR Review</a>.</p>",
        "id": 190553867,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584133079
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191025141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584557221
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191034847,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584561942
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191037593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584563334
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191079913,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584604800
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191080089,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584604889
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191081355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584605999
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191082467,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584606910
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191086453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584609556
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191086637,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584609644
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191088069,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584610449
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191090203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584611759
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191094168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584613965
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191096101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584614953
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191473035,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584970476
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191473614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584970732
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191474074,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584970943
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191477816,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584972643
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191478835,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584973153
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191479150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584973291
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191479372,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584973381
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191479919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584973547
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191511951,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584986157
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191522916,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584991130
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191532987,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584995937
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191546516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585003062
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191548383,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585004235
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191572207,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585033598
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191580518,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585040353
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191582764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585041579
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191584522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585042574
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191585583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585043137
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191585614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585043155
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191587816,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585044294
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191588772,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585044795
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191589679,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585045303
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191598100,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585050342
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" target=\"_blank\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" target=\"_blank\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" target=\"_blank\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191603344,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585053897
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191759277,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585148912
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191759949,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585149117
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191760466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585149271
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191762245,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585149795
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 191763304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585150121
    },
    {
        "content": "<p><strong>marmistrz</strong> requested <a href=\"https://github.com/peterhuene\" title=\"https://github.com/peterhuene\">peterhuene</a> and <a href=\"https://github.com/sunfishcode\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a>.</p>",
        "id": 191763542,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585150199
    },
    {
        "content": "<p><strong>marmistrz</strong> requested <a href=\"https://github.com/peterhuene\" title=\"https://github.com/peterhuene\">peterhuene</a>, <a href=\"https://github.com/kubkon\" title=\"https://github.com/kubkon\">kubkon</a> and <a href=\"https://github.com/sunfishcode\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a>.</p>",
        "id": 191763571,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585150202
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192607180,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585785491
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386037148\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386037148\">PR Review</a>.</p>",
        "id": 192609027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787498
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386037148\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386037148\">PR Review</a>.</p>",
        "id": 192609028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787498
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986764\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986764\">PR Review Comment</a>:</p>\n<blockquote>\n<p>If we remove the RAII type, we should remove or update this comment.  Calling out that the <code>fd_close</code> must be called prior to unlinking on Windows probably isn't worth a comment, but I'm also good with updating this comment to reflect that.</p>\n</blockquote>",
        "id": 192609029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787499
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986971\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986971\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Is this TODO comment actionable or can it be removed?</p>\n</blockquote>",
        "id": 192609030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787499
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986399\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986399\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Rather than using an RAII type for this single test, perhaps we should just insert the <code>fd_close</code> calls in the three places that are needed?</p>\n</blockquote>",
        "id": 192609031,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787499
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986471\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r401986471\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We can remove this comment now I think.</p>\n</blockquote>",
        "id": 192609032,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585787499
    },
    {
        "content": "<p>marmistrz submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386446223\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386446223\">PR Review</a>.</p>",
        "id": 192667692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585835498
    },
    {
        "content": "<p>marmistrz created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402329287\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402329287\">PR Review Comment</a>:</p>\n<blockquote>\n<p>What's wrong with RAII here?</p>\n</blockquote>",
        "id": 192667693,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585835498
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386453783\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386453783\">PR Review</a>.</p>",
        "id": 192668699,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585835948
    },
    {
        "content": "<p>kubkon created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402335092\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402335092\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm also eager to remove RAII here. It makes the test logic somewhat clunky since we have to force nested scoping for the <code>drop</code> to fire. I cannot see why manually calling <code>fd_close</code> on all needed resources should be inferior to using the RAII type.</p>\n</blockquote>",
        "id": 192668701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585835948
    },
    {
        "content": "<p>marmistrz submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386616841\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386616841\">PR Review</a>.</p>",
        "id": 192695771,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846551
    },
    {
        "content": "<p>marmistrz created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402464800\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402464800\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm removing this mapping, because there is no clear reason why it's needed, just as in #1359.</p>\n</blockquote>",
        "id": 192695772,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846551
    },
    {
        "content": "<p>marmistrz submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386617240\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386617240\">PR Review</a>.</p>",
        "id": 192695848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846580
    },
    {
        "content": "<p>marmistrz created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402465095\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402465095\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Okay, I'll remove RAII.</p>\n</blockquote>",
        "id": 192695849,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846580
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192696433,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846870
    },
    {
        "content": "<p>marmistrz submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386621293\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386621293\">PR Review</a>.</p>",
        "id": 192696448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846878
    },
    {
        "content": "<p>marmistrz created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402468405\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402468405\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Done</p>\n</blockquote>",
        "id": 192696450,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846879
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386621713\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386621713\">PR Review</a>.</p>",
        "id": 192696503,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846910
    },
    {
        "content": "<p>peterhuene created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402468735\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#discussion_r402468735\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Yeah, I wouldn't say there's anything wrong with it by itself, just that it's a little bit of implementation that only saves three <code>fd_close</code> calls in a single test case.</p>\n</blockquote>",
        "id": 192696504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846911
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192696629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585846965
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192697367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585847298
    },
    {
        "content": "<p>peterhuene submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386632754\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386632754\">PR Review</a>.</p>",
        "id": 192698268,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585847799
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192703752,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585850461
    },
    {
        "content": "<p>marmistrz updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a> from <code>path_link</code> to <code>master</code>:</p>\n<blockquote>\n<p>This is probably the last missing syscall for Windows!</p>\n<p>This PR implements <code>path_link</code> for Windows and adds a non-strict version of the <code>path_link</code> integration test.</p>\n<p>I'm unsure about the error handling in <code>path_link</code>. MSDN doesn't say much about possible error codes for either <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka\"><code>CreateHardLinkA</code></a> or <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\" title=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\"><code>CreateSymbolicLinkA</code></a>. I mostly copied over the error conversion from <code>path_symlink</code>, but I'm not sure if it's correct. In particular, it's unclear to me what the purpose of <code>strip_trailing_slashes_and_concatenate</code> is.</p>\n<p><code>path_symlink</code> will now also detect an attempt to create a dangling symlink and return <code>ENOTSUP</code>. (is this the correct return code)?</p>\n<p>Currently the non-strictness of the test consists of:</p>\n<ol>\n<li>we use a separate subdirectories <code>subdir</code>, <code>subdir2</code>, <code>subdir3</code> for each test stage. This is due to the fact Windows will not remove the directory and won't allow to create a directory with the same name until the previous one has been deleted. I don't see any way of circumventing it, because the application may still try to access the directory through the unclosed file descriptor.</li>\n<li><code>path_link</code> will return <code>EACCES</code> instead of <code>EPERM</code> when trying to create a link to a subdirectory. This violates the POSIX spec. We could manually check if the source path is a directory in case of <code>ERROR_ACCESS_DENIED</code> but this would cost us an extra syscall.</li>\n<li>Tests for dangling symlinks or symlink loops have been disabled. Alternatively, we could check if the attempt to create a dangling symlink returns <code>ENOTSUP</code>, but this doesn't make much sense while 1&amp;2 are an issue.</li>\n</ol>\n<p>Let me know what you think.</p>\n<p>Btw. @kubkon, according to <a href=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\" title=\"https://stackoverflow.com/questions/1432540/creating-directory-hard-links-in-mac-os-x\">this stackoverflow post</a> Mac OS X 10.5+ permits hard links to directories, which our tests expect to fail.</p>\n<hr>\n<p>Notes about links and symlinks under Windows:</p>\n<ul>\n<li>creating a symlink requires administrative privileges (<code>SeCreateSymbolicLinkPrivilege</code>). On Windows 10 <a href=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\" title=\"https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\">this requirement may be removed, but this requires enabling developer mode</a></li>\n<li>Windows distinguishes between file and directory symlinks</li>\n<li>It's possible to create a dangling symlink, but the type (file/directory) has to be specified upon creation. The behavior in case of type mismatch is inconsistent. Precisely, suppose that a dangling file symlink is created <code>foo -&gt; bar</code> and later, a directory <code>bar</code> is created. Then:<ul>\n<li>under msys64 bash, <code>cd foo</code> succeeds and the directory view is the same when access either directly or through the symlink</li>\n<li>under cmd (both windowed and as a child process from msys64 bash). <code>cd foo</code> fails with <code>The directory name is invalid</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 192703973,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585850546
    },
    {
        "content": "<p>kubkon submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386777952\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199#pullrequestreview-386777952\">PR Review</a>.</p>",
        "id": 192726774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585861783
    },
    {
        "content": "<p>marmistrz merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1199\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1199\">PR #1199</a>.</p>",
        "id": 192852658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585941880
    }
]