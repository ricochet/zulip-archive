[
    {
        "content": "<p>MendyBerger opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Currently, if you wanna implement the traits generated by <code>component::bindgen</code> in a library that other's are gonna use with custom types, you can't do it on <code>T: YourTrait</code>, you have to implement it on <code>dyn YourTrait</code>. At least that's what I gather from what <a href=\"https://github.com/bytecodealliance/wasmtime/blob/af59c4d568d487b7efbb49d7d31a861e7c3933a6/crates/wasi-http/src/types_impl.rs#L22\">wasi-http</a> is doing.</p>\n<p>I'm working on <a href=\"https://github.com/wasi-gfx/wasi-gfx-runtime\">wasi-webgpu</a>, where we'd really like one of our methods to be generic, but generics are not object-safe. Is there any way we can do that?</p>\n</blockquote>",
        "id": 443864382,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718053614
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2159306664\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Heh I was actually just talking with others about possibly changing some parts about wasi-http about this. </p>\n<p>For your use case would something like this work?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">MyWebgpuWrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyWebgpuView</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MyWebgpuView</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">bindings</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">webgpu</span><span class=\"p\">::</span><span class=\"n\">interface</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyWebgpuWrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">add_to_linker</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MyWebgpuView</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">linker</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Linker</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Basically having a newtype wrapper locally which is used internally in <code>add_to_linker</code> as a temporary value?</p>\n</blockquote>",
        "id": 443866582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718054542
    },
    {
        "content": "<p>MendyBerger <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2159328041\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Not sure I understand how this would work. <br>\nWouldn't this require the consumer of the wasi-webgpu library to implement <code>Host</code> manually? Or do you mean that all of this would be in library code?</p>\n</blockquote>",
        "id": 443868588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718055489
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2159351722\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Oh the wasi-webgpu library would have impls that look like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MyWebgpuView</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">bindings</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">webgpu</span><span class=\"p\">::</span><span class=\"n\">interface</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyWebgpuWrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>\n</code></pre></div>\n<p>so users wouldn't need to implement <code>Host</code> themselves. They only need to construct <code>MyWebgpuWrapper&lt;T&gt;</code> which is probably <code>MyWebgpuWrapper(&amp;mut my_stuff)</code></p>\n<p>Also, to confirm, you're looking to provide a small trait of methods and then from that small trait of methods all other methods are implemented? That's what wasmtime-wasi/wasmtime-wasi-http are doing but if you're not leap frogging traits like this then most of this infrastructure isn't necessary<br>\n</p>\n</blockquote>",
        "id": 443870415,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718056341
    },
    {
        "content": "<p>MendyBerger <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2159595343\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Oh! I think I see it now!<br>\n<code>Host</code> is implemented for a concrete type. And the concrete implementation won't conflict with the auto generated <code>&amp;mut T</code> implementations because of the wrapper. Brilliant idea!<br>\nLet me check if I can get this to work.</p>\n</blockquote>",
        "id": 443895965,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718069211
    },
    {
        "content": "<p>MendyBerger <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2161226934\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>@alexcrichton I was able to get it to work, thanks for the help!</p>\n<p>I modeled it like <a href=\"https://github.com/bytecodealliance/wasmtime/blob/b7aacfc8728b6891bd934a4c5a85d19c47ec7b6b/crates/wasi-http/src/types.rs#L159\">wasi-http</a> which seems to be doing the same thing.</p>\n<p>It took me a couple of hours to figure this out though. Would it be possible for <code>bindgen!</code> to generate all the plumbing, and just expose a ready to use <code>WasiFooImpl</code> and <code>add_to_linker</code>?<br>\nFiguring out exactly what needs to go in the <code>add_to_linker</code> like the <code>type_annotate</code>, as well as the requirement to implement <code>WasiFooView</code> on <code>WasiFooImpl</code>, <code>&amp;mut T: WasiFooView</code>, and <code>Box&lt;T: WasiFooView&gt;</code> is a lot of work.<br>\n</p>\n</blockquote>",
        "id": 444054324,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718125179
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2161442929\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Hm unfortuantely I don't think so. The <code>WasiView</code> trait is a handwritten trait and has no means of being automatically derived. Furthermore all implementations of the <code>Host</code> traits are implemented in terms of <code>WasiView</code> and additionally can't be auto-derived. For the same reasons nothing can auto-derive the impls and such too.</p>\n<p>I'll also reiterate though that none of this is ideally necessary. I'd much rather have, for example <code>Host for WasiCtx</code> for all of WASI or something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">WasiTemp</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">ResourceTable</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">WasiCtx</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">WasiTemp</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>Or put another way I'd much rather to have <code>Host</code> for concrete types. The only reason <code>WasiView</code> exists is to mirror the design of <code>WasiHttpView</code> and the only reason that exists is the various trait methods it has for customizing how a request is dispatched for example. If you can get away with it I'd recommend not using a <code>*View</code> triat entirely and instead using a configuration context of some kind and everything is implemented in terms of that context.</p>\n</blockquote>",
        "id": 444079564,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718133266
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2161577010\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>I think historically <code>WasiView</code> came before <code>WasiHttpView</code>, opposite of what your example is, but no matter. The real unfortunate necessity for all of this machinery is that all* bindings implementations on a store need to share the same <code>ResourceTable</code>, but have their own Ctx type for \"everything else\": WasiCtx, WasiHttpCtx, WebGpuCtx etc. The best way we came up with in wasmtime-wasi and wasmtime-wasi-http is to have a trait where you can borrow either the ctx or the table mutably, but it would work just as well with a struct like Alex describes where each of those mut borrows is a member of the struct.</p>\n<ul>\n<li>well, technically only bindings implementations that have resource types in common, but in practice everything of nontrivial complexity needs a pollable or stream at some point, so effectively its all bindings</li>\n</ul>\n</blockquote>",
        "id": 444097933,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718138791
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2162056630\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Ah yes true! One thing I'll also point out is that we haven't historically done something like <code>WasiTemp&lt;'a&gt;</code> because that wasn't possible until <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8448\">https://github.com/bytecodealliance/wasmtime/pull/8448</a> landed. Now with that we could in theory move all WASI bits, but the customization bits that use a trait still necessitate otherwise. </p>\n<p>That being said a better yet design from what we have now, perhaps for wasi-http, would be to have <code>WasiHttpCtx&lt;T&gt;</code> where <code>T: WasiHttpImplTrait</code> where it's not the same as <code>WasiView</code> but just the customization methods. That way we could in fact use <code>WasiTemp&lt;'a&gt;</code> or something similar.</p>\n</blockquote>",
        "id": 444141532,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718164613
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>Currently, if you wanna implement the traits generated by <code>component::bindgen</code> in a library that other's are gonna use with custom types, you can't do it on <code>T: YourTrait</code>, you have to implement it on <code>dyn YourTrait</code>. At least that's what I gather from what <a href=\"https://github.com/bytecodealliance/wasmtime/blob/af59c4d568d487b7efbb49d7d31a861e7c3933a6/crates/wasi-http/src/types_impl.rs#L22\">wasi-http</a> is doing.</p>\n<p>I'm working on <a href=\"https://github.com/wasi-gfx/wasi-gfx-runtime\">wasi-webgpu</a>, where we'd really like one of our methods to be generic, but generics are not object-safe. Is there any way we can do that?</p>\n</blockquote>",
        "id": 445216319,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718655189
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764#issuecomment-2174340991\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8764\">issue #8764</a>:</p>\n<blockquote>\n<p>I think this has been answered now so I'm going to close this, but if there are any lingering questions/clarifications feel free to comment and/or open a new issue.</p>\n</blockquote>",
        "id": 445216320,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1718655190
    }
]