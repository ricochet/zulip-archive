[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463\">issue #4463</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>We are missing a <code>frem x, y</code> instruction providing the floating-point remainder of x/y.</p>\n<h4>Benefit</h4>\n<p>This is a strange omission to our instruction set. We have <code>srem</code> and <code>urem</code> for integers and the rest of the commonly available floating point operations but no remainder.</p>\n<p>Some of our users are already lowering it to libcall's themselves:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/ezrosent/frawk/blob/f2345dfa22aa99535ab63706f7c4bb30724a4015/src/codegen/clif.rs#L994-L995\"><code>frawk</code></a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/11007c02f70130cdc70b98f0909e5c150a2751a6/src/num.rs#L329-L336\"><code>rustc_codegen_cranelift</code></a></p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>Currently the idea would be to implement this as a libcall on all 3 backends, this seems to be what llvm does (on x86 and aarch64 at least) and should be fairly easy to implement.</p>\n<p>I'd be available to work on this.</p>\n<h4>Alternatives</h4>\n<p>We can ignore this and let implementers lower it to a libcall themselves, which is what is already happening in practice.<br>\n</p>\n</blockquote>",
        "id": 289886766,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658066762
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463#issuecomment-1186549182\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463\">issue #4463</a>:</p>\n<blockquote>\n<p>I can give some background on why <code>frem</code> was not originally included.</p>\n<p>\"Remainder\" isn't a natural operation for floating-point values. With integers, division rounds to the nearest integer toward zero, so there is an inherent quantity which is left over from division, which we call the remainder. In floating point, division rounds to the nearest representable value in the floating point type, so there is no representable quantity which is left over from division.</p>\n<p>Consequently, it's somewhat ambiguous what \"remainder\" for floating point even means. There isn't a single common definition in common use. The thing LLVM calls \"frem\" is ends up being different from the IEEE 754 <code>remainder</code> operation and the C <code>remainder</code> function. It does have uses, but they're uncommon in practice, and far less common than operations like <code>sin</code> or <code>cos</code>, for example. It isn't present in any modern hardware. It will probably always be implemented as a library call, and it will always have subtle behavior.</p>\n<p>I witnessed the existence of <code>frem</code> in LLVM contribute to a high-level source language deciding to support <code>%</code> on floating-point values in the language, and considered that to have been a mistake.</p>\n</blockquote>",
        "id": 289890600,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658072253
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463#issuecomment-1186560591\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463\">issue #4463</a>:</p>\n<blockquote>\n<p>Thanks for clarifying! I didn't know there was such a disagreement about the implementation of the remainder.</p>\n</blockquote>",
        "id": 289892216,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658074535
    },
    {
        "content": "<p>afonso360 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4463\">issue #4463</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>We are missing a <code>frem x, y</code> instruction providing the floating-point remainder of x/y.</p>\n<h4>Benefit</h4>\n<p>This is a strange omission to our instruction set. We have <code>srem</code> and <code>urem</code> for integers and the rest of the commonly available floating point operations but no remainder.</p>\n<p>Some of our users are already lowering it to libcall's themselves:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/ezrosent/frawk/blob/f2345dfa22aa99535ab63706f7c4bb30724a4015/src/codegen/clif.rs#L994-L995\"><code>frawk</code></a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/11007c02f70130cdc70b98f0909e5c150a2751a6/src/num.rs#L329-L336\"><code>rustc_codegen_cranelift</code></a></p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>Currently the idea would be to implement this as a libcall on all 3 backends, this seems to be what llvm does (on x86 and aarch64 at least) and should be fairly easy to implement.</p>\n<p>I'd be available to work on this.</p>\n<h4>Alternatives</h4>\n<p>We can ignore this and let implementers lower it to a libcall themselves, which is what is already happening in practice.<br>\n</p>\n</blockquote>",
        "id": 289892217,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658074535
    }
]