[
    {
        "content": "<p>lostman opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>The documentation for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size: Option&lt;u64&gt;,\n    guard_size: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>states:</p>\n<blockquote>\n<p>The reserved_size value indicates the expected size of the reservation that is to be made for this memory. If this value is None than the implementation is free to allocate memory as it sees fit. If the value is Some, however, then the implementation is expected to reserve that many bytes for the memory's allocation, plus the guard size at the end</p>\n</blockquote>\n<p>Aside: please also note the typo <code>than</code>.</p>\n<p>This sounds like the intended unit for <code>reserved_size</code> is bytes which is also supported by its <code>u64</code> type . However, the implementation passes in the size in pages:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl RuntimeMemoryCreator for MemoryCreatorProxy {\n    fn new_memory(&amp;self, plan: &amp;MemoryPlan) -&gt; Result&lt;Box&lt;dyn RuntimeLinearMemory&gt;, String&gt; {\n        let ty = MemoryType::new(Limits::new(plan.memory.minimum, plan.memory.maximum));\n        let reserved_size = match plan.style {\n            MemoryStyle::Static { bound } =&gt; Some(bound.into()),\n            MemoryStyle::Dynamic =&gt; None,\n        };\n        self.mem_creator\n            .new_memory(ty, reserved_size, plan.offset_guard_size)\n            .map(|mem| Box::new(LinearMemoryProxy { mem }) as Box&lt;dyn RuntimeLinearMemory&gt;)\n    }\n}\n</code></pre></div>\n\n\n<p>where:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub enum MemoryStyle {\n    /// The actual memory can be resized and moved.\n    Dynamic,\n    /// Addresss space is allocated up front.\n    Static {\n        /// The number of mapped and unmapped pages.\n        bound: u32,\n    },\n}\n</code></pre></div>\n\n\n<p>I'll be honest, when working with WebAssembly I am often confused as to whether the memory size is expressed in Wasm pages, OS pages, or bytes. Often it is all three at different points in time! Thus, I tend to make my variable names very explicit. May I suggest changing the function signature to:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size_in_bytes: Option&lt;u64&gt;,\n    guard_size_in_bytes: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>?</p>\n<p>Or perhaps <code>reserved_size_in_wasm_pages</code> if that is the desired unit?</p>\n</blockquote>",
        "id": 199137907,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590749061
    },
    {
        "content": "<p>lostman labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>The documentation for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size: Option&lt;u64&gt;,\n    guard_size: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>states:</p>\n<blockquote>\n<p>The reserved_size value indicates the expected size of the reservation that is to be made for this memory. If this value is None than the implementation is free to allocate memory as it sees fit. If the value is Some, however, then the implementation is expected to reserve that many bytes for the memory's allocation, plus the guard size at the end</p>\n</blockquote>\n<p>Aside: please also note the typo <code>than</code>.</p>\n<p>This sounds like the intended unit for <code>reserved_size</code> is bytes which is also supported by its <code>u64</code> type . However, the implementation passes in the size in pages:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl RuntimeMemoryCreator for MemoryCreatorProxy {\n    fn new_memory(&amp;self, plan: &amp;MemoryPlan) -&gt; Result&lt;Box&lt;dyn RuntimeLinearMemory&gt;, String&gt; {\n        let ty = MemoryType::new(Limits::new(plan.memory.minimum, plan.memory.maximum));\n        let reserved_size = match plan.style {\n            MemoryStyle::Static { bound } =&gt; Some(bound.into()),\n            MemoryStyle::Dynamic =&gt; None,\n        };\n        self.mem_creator\n            .new_memory(ty, reserved_size, plan.offset_guard_size)\n            .map(|mem| Box::new(LinearMemoryProxy { mem }) as Box&lt;dyn RuntimeLinearMemory&gt;)\n    }\n}\n</code></pre></div>\n\n\n<p>where:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub enum MemoryStyle {\n    /// The actual memory can be resized and moved.\n    Dynamic,\n    /// Addresss space is allocated up front.\n    Static {\n        /// The number of mapped and unmapped pages.\n        bound: u32,\n    },\n}\n</code></pre></div>\n\n\n<p>I'll be honest, when working with WebAssembly I am often confused as to whether the memory size is expressed in Wasm pages, OS pages, or bytes. Often it is all three at different points in time! Thus, I tend to make my variable names very explicit. May I suggest changing the function signature to:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size_in_bytes: Option&lt;u64&gt;,\n    guard_size_in_bytes: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>?</p>\n<p>Or perhaps <code>reserved_size_in_wasm_pages</code> if that is the desired unit?</p>\n</blockquote>",
        "id": 199137908,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590749061
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785#issuecomment-636170432\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>The intention here is that the values are all in bytes, so if it's in wasm pages that's definitely a bug! Renaming the parameter names sounds great too!</p>\n<p>Would you be up for a PR to update this?</p>\n</blockquote>",
        "id": 199205877,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590783024
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>The documentation for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size: Option&lt;u64&gt;,\n    guard_size: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>states:</p>\n<blockquote>\n<p>The reserved_size value indicates the expected size of the reservation that is to be made for this memory. If this value is None than the implementation is free to allocate memory as it sees fit. If the value is Some, however, then the implementation is expected to reserve that many bytes for the memory's allocation, plus the guard size at the end</p>\n</blockquote>\n<p>Aside: please also note the typo <code>than</code>.</p>\n<p>This sounds like the intended unit for <code>reserved_size</code> is bytes which is also supported by its <code>u64</code> type . However, the implementation passes in the size in pages:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl RuntimeMemoryCreator for MemoryCreatorProxy {\n    fn new_memory(&amp;self, plan: &amp;MemoryPlan) -&gt; Result&lt;Box&lt;dyn RuntimeLinearMemory&gt;, String&gt; {\n        let ty = MemoryType::new(Limits::new(plan.memory.minimum, plan.memory.maximum));\n        let reserved_size = match plan.style {\n            MemoryStyle::Static { bound } =&gt; Some(bound.into()),\n            MemoryStyle::Dynamic =&gt; None,\n        };\n        self.mem_creator\n            .new_memory(ty, reserved_size, plan.offset_guard_size)\n            .map(|mem| Box::new(LinearMemoryProxy { mem }) as Box&lt;dyn RuntimeLinearMemory&gt;)\n    }\n}\n</code></pre></div>\n\n\n<p>where:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub enum MemoryStyle {\n    /// The actual memory can be resized and moved.\n    Dynamic,\n    /// Addresss space is allocated up front.\n    Static {\n        /// The number of mapped and unmapped pages.\n        bound: u32,\n    },\n}\n</code></pre></div>\n\n\n<p>I'll be honest, when working with WebAssembly I am often confused as to whether the memory size is expressed in Wasm pages, OS pages, or bytes. Often it is all three at different points in time! Thus, I tend to make my variable names very explicit. May I suggest changing the function signature to:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size_in_bytes: Option&lt;u64&gt;,\n    guard_size_in_bytes: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>?</p>\n<p>Or perhaps <code>reserved_size_in_wasm_pages</code> if that is the desired unit?</p>\n</blockquote>",
        "id": 199205895,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590783035
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785#issuecomment-636175909\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 199207537,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1590783864
    },
    {
        "content": "<p>lostman <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785#issuecomment-638560877\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>Sure, will make a PR.</p>\n</blockquote>",
        "id": 199698804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1591237072
    },
    {
        "content": "<p>lostman closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1785\">Issue #1785</a>:</p>\n<blockquote>\n<p>The documentation for</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size: Option&lt;u64&gt;,\n    guard_size: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>states:</p>\n<blockquote>\n<p>The reserved_size value indicates the expected size of the reservation that is to be made for this memory. If this value is None than the implementation is free to allocate memory as it sees fit. If the value is Some, however, then the implementation is expected to reserve that many bytes for the memory's allocation, plus the guard size at the end</p>\n</blockquote>\n<p>Aside: please also note the typo <code>than</code>.</p>\n<p>This sounds like the intended unit for <code>reserved_size</code> is bytes which is also supported by its <code>u64</code> type . However, the implementation passes in the size in pages:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl RuntimeMemoryCreator for MemoryCreatorProxy {\n    fn new_memory(&amp;self, plan: &amp;MemoryPlan) -&gt; Result&lt;Box&lt;dyn RuntimeLinearMemory&gt;, String&gt; {\n        let ty = MemoryType::new(Limits::new(plan.memory.minimum, plan.memory.maximum));\n        let reserved_size = match plan.style {\n            MemoryStyle::Static { bound } =&gt; Some(bound.into()),\n            MemoryStyle::Dynamic =&gt; None,\n        };\n        self.mem_creator\n            .new_memory(ty, reserved_size, plan.offset_guard_size)\n            .map(|mem| Box::new(LinearMemoryProxy { mem }) as Box&lt;dyn RuntimeLinearMemory&gt;)\n    }\n}\n</code></pre></div>\n\n\n<p>where:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub enum MemoryStyle {\n    /// The actual memory can be resized and moved.\n    Dynamic,\n    /// Addresss space is allocated up front.\n    Static {\n        /// The number of mapped and unmapped pages.\n        bound: u32,\n    },\n}\n</code></pre></div>\n\n\n<p>I'll be honest, when working with WebAssembly I am often confused as to whether the memory size is expressed in Wasm pages, OS pages, or bytes. Often it is all three at different points in time! Thus, I tend to make my variable names very explicit. May I suggest changing the function signature to:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn new_memory(\n    &amp;self,\n    ty: MemoryType,\n    reserved_size_in_bytes: Option&lt;u64&gt;,\n    guard_size_in_bytes: u64\n) -&gt; Result&lt;Box&lt;dyn LinearMemory&gt;, String&gt;\n</code></pre></div>\n\n\n<p>?</p>\n<p>Or perhaps <code>reserved_size_in_wasm_pages</code> if that is the desired unit?</p>\n</blockquote>",
        "id": 201101755,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1592369995
    }
]