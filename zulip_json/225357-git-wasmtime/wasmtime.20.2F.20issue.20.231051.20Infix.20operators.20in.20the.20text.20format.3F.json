[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1051#issuecomment-1117902011\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1051\">issue #1051</a>:</p>\n<blockquote>\n<p>I'm doing some issue gardening and came across this. I think that I agree with the above arguments that this is not very \"IR-like\": in a sense it privileges certain operations (add, multiply, ...) and allows them to be written in a special syntax that looks like something other than a linear sequence of instructions. Since the underlying abstraction is that linear sequence of instructions, IMHO it would be better for the notation to remain closer to that.</p>\n<p>There are also issues about round-tripping: do we represent <em>how</em> the expression was written in the parsed input and try to reproduce that when printing the CLIF back out? Or do we try to maximally use an expression syntax? It's simpler if we always, unconditionally, print one instruction per line, in instruction order.</p>\n<p>So I'll go ahead and close this, given the discussion has quiesced, but if someone wants to make a renewed push for it, please feel free to do so.</p>\n</blockquote>",
        "id": 281216802,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651696921
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1051\">issue #1051</a>:</p>\n<blockquote>\n<p>Currently, cranelift IR is always printed with one instruction per line, eg.:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">ebb0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>:<span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">imul</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>What if we introduced some simple syntax sugar for instructions with only one use? It'd be in addition to the existing syntax. We could then (optionally) print that same code like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">ebb0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>:<span class=\"kt\">i32</span><span class=\"p\">)</span>:\n    <span class=\"nc\">return</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That would be much easier to read in many cases, which is of potential interest to cranelift developers, but also to cranelift users looking to understand how cranelift is compiling their code.</p>\n<p>This also might make it even more interesting to switch to <code>//</code> comments (#471).</p>\n<p>There's some ambiguity with syntax like <code>v0 + 1</code>, but I think we can resolve it by saying that we always use the <code>_imm</code> instruction when possible rather than emitting an iconst</p>\n<p>And there's the question if value numbers for the intermediate values. My rough idea is that they'd just always use the next available value number.</p>\n<p>There are other issues to consider too, such as printing srclocs and instruction encodings. But I think we could find reasonable ways to make these work. The main question is, is this idea worth pursuing?</p>\n</blockquote>",
        "id": 281216803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651696921
    }
]