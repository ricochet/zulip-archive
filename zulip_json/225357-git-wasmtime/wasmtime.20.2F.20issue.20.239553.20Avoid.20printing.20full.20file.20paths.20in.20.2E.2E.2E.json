[
    {
        "content": "<p>nmattia opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553\">issue #9553</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>It would be great to avoid printing full paths of source files in the generated code.</p>\n<h4>Benefit</h4>\n<p>This would allow for better or more correct caching in third party build systems like Bazel or Nix.</p>\n<h4>Implementation</h4>\n<ol>\n<li>The naive solution is to remove references to the source files:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/cranelift/codegen/meta/src/srcgen.rs b/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gh\">index d3c321e5b..5b94ddd19 100644</span>\n<span class=\"gd\">--- a/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gi\">+++ b/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gu\">@@ -94,7 +94,6 @@ impl Formatter {</span>\n<span class=\"w\"> </span>        directory: &amp;std::path::Path,\n<span class=\"w\"> </span>    ) -&gt; Result&lt;(), error::Error&gt; {\n<span class=\"w\"> </span>        let path = directory.join(&amp;filename);\n<span class=\"gd\">-        eprintln!(\"Writing generated file: {}\", path.display());</span>\n<span class=\"w\"> </span>        let mut f = fs::File::create(path)?;\n\n<span class=\"w\"> </span>        for l in self.lines.iter().map(|l| l.as_bytes()) {\n<span class=\"gh\">diff --git a/cranelift/isle/isle/src/codegen.rs b/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gh\">index 158285832..d292e43c0 100644</span>\n<span class=\"gd\">--- a/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gi\">+++ b/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gu\">@@ -127,9 +127,6 @@ impl&lt;'a&gt; Codegen&lt;'a&gt; {</span>\n<span class=\"w\"> </span>            \"// Generated automatically from the instruction-selection DSL code in:\",\n<span class=\"w\"> </span>        )\n<span class=\"w\"> </span>        .unwrap();\n<span class=\"gd\">-        for file in &amp;self.files.file_names {</span>\n<span class=\"gd\">-            writeln!(code, \"// - {file}\").unwrap();</span>\n<span class=\"gd\">-        }</span>\n\n<span class=\"w\"> </span>        if !options.exclude_global_allow_pragmas {\n<span class=\"w\"> </span>            writeln!(\n<span class=\"gu\">@@ -641,12 +638,11 @@ impl&lt;L: Length, C&gt; Length for ContextIterWrapper&lt;L, C&gt; {{</span>\n<span class=\"w\"> </span>                            stack.push((Self::validate_block(ret_kind, body), \"\", scope));\n<span class=\"w\"> </span>                        }\n\n<span class=\"gd\">-                        &amp;ControlFlow::Return { pos, result } =&gt; {</span>\n<span class=\"gi\">+                        &amp;ControlFlow::Return { pos: _pos, result } =&gt; {</span>\n<span class=\"w\"> </span>                            writeln!(\n<span class=\"w\"> </span>                                ctx.out,\n<span class=\"gd\">-                                \"{}// Rule at {}.\",</span>\n<span class=\"gi\">+                                \"{}\",</span>\n<span class=\"w\"> </span>                                &amp;ctx.indent,\n<span class=\"gd\">-                                pos.pretty_print_line(&amp;self.files)</span>\n<span class=\"w\"> </span>                            )?;\n<span class=\"w\"> </span>                            write!(ctx.out, \"{}\", &amp;ctx.indent)?;\n<span class=\"w\"> </span>                            match ret_kind {\n</code></pre></div>\n<ol start=\"2\">\n<li>The behavior could be enabled/disabled based on a crate feature or environment variable.</li>\n<li>The path could be made relative to <code>CARGO_MANIFEST_DIR</code>; alternatively only the <code>basename</code> of the source file could be retained and written to the generated files.</li>\n</ol>\n<p>Not very familiar with the crate so can't make an educated decision! But this would be a nice improvement in the way of system-independent reproducible builds.</p>\n</blockquote>",
        "id": 480667714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730796228
    },
    {
        "content": "<p>nmattia edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553\">issue #9553</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>It would be great to avoid printing full paths of source files in the generated code.</p>\n<h4>Benefit</h4>\n<p>This would allow for better or more correct caching in third party build systems like Bazel or Nix.</p>\n<h4>Implementation</h4>\n<ol>\n<li>The naive solution is to remove references to the source files:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/cranelift/codegen/meta/src/srcgen.rs b/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gh\">index d3c321e5b..5b94ddd19 100644</span>\n<span class=\"gd\">--- a/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gi\">+++ b/cranelift/codegen/meta/src/srcgen.rs</span>\n<span class=\"gu\">@@ -94,7 +94,6 @@ impl Formatter {</span>\n<span class=\"w\"> </span>        directory: &amp;std::path::Path,\n<span class=\"w\"> </span>    ) -&gt; Result&lt;(), error::Error&gt; {\n<span class=\"w\"> </span>        let path = directory.join(&amp;filename);\n<span class=\"gd\">-        eprintln!(\"Writing generated file: {}\", path.display());</span>\n<span class=\"w\"> </span>        let mut f = fs::File::create(path)?;\n\n<span class=\"w\"> </span>        for l in self.lines.iter().map(|l| l.as_bytes()) {\n<span class=\"gh\">diff --git a/cranelift/isle/isle/src/codegen.rs b/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gh\">index 158285832..d292e43c0 100644</span>\n<span class=\"gd\">--- a/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gi\">+++ b/cranelift/isle/isle/src/codegen.rs</span>\n<span class=\"gu\">@@ -127,9 +127,6 @@ impl&lt;'a&gt; Codegen&lt;'a&gt; {</span>\n<span class=\"w\"> </span>            \"// Generated automatically from the instruction-selection DSL code in:\",\n<span class=\"w\"> </span>        )\n<span class=\"w\"> </span>        .unwrap();\n<span class=\"gd\">-        for file in &amp;self.files.file_names {</span>\n<span class=\"gd\">-            writeln!(code, \"// - {file}\").unwrap();</span>\n<span class=\"gd\">-        }</span>\n\n<span class=\"w\"> </span>        if !options.exclude_global_allow_pragmas {\n<span class=\"w\"> </span>            writeln!(\n<span class=\"gu\">@@ -641,12 +638,11 @@ impl&lt;L: Length, C&gt; Length for ContextIterWrapper&lt;L, C&gt; {{</span>\n<span class=\"w\"> </span>                            stack.push((Self::validate_block(ret_kind, body), \"\", scope));\n<span class=\"w\"> </span>                        }\n\n<span class=\"gd\">-                        &amp;ControlFlow::Return { pos, result } =&gt; {</span>\n<span class=\"gi\">+                        &amp;ControlFlow::Return { pos: _pos, result } =&gt; {</span>\n<span class=\"w\"> </span>                            writeln!(\n<span class=\"w\"> </span>                                ctx.out,\n<span class=\"gd\">-                                \"{}// Rule at {}.\",</span>\n<span class=\"gi\">+                                \"{}\",</span>\n<span class=\"w\"> </span>                                &amp;ctx.indent,\n<span class=\"gd\">-                                pos.pretty_print_line(&amp;self.files)</span>\n<span class=\"w\"> </span>                            )?;\n<span class=\"w\"> </span>                            write!(ctx.out, \"{}\", &amp;ctx.indent)?;\n<span class=\"w\"> </span>                            match ret_kind {\n</code></pre></div>\n<ol start=\"2\">\n<li>The behavior could be enabled/disabled based on a crate feature or environment variable.</li>\n<li>The path could be made relative to <code>CARGO_MANIFEST_DIR</code>; alternatively only the <code>basename</code> of the source file could be retained and written to the generated files.</li>\n</ol>\n<p>Not very familiar with the crate so can't make an educated decision! But this would be a nice improvement in the way of system-independent reproducible builds.</p>\n</blockquote>",
        "id": 480667803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730796246
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553#issuecomment-2457909080\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553\">issue #9553</a>:</p>\n<blockquote>\n<p>Hi @nmattia -- thanks for filing this issue!</p>\n<p>I don't think we will remove the paths altogether -- let me explain a bit more why. We emit these paths in the generated Rust code to help us debug and to see where rule-matching cases are defined in the original source. It was an explicit design goal for the output of the ISLE metacompiler to be relatively comprehensible to humans. The ability to refer back to source locations is useful for this.</p>\n<p>That said, I'd be happy to review a PR that makes the paths relative to the source root (your option 3).</p>\n<p>I'm also a bit curious about your use-case. You say \"more correct caching\" -- do you mean, higher cache hit-rate for a cache shared across many builds at different paths? We have not made it an explicit design goal to avoid, e.g., absolute paths in comments, though we do take care to ensure the final built code is semantically deterministic (i.e. our only variances should be in comments). I think it'd be reasonable to aim for this tighter intermediate-textual-form definition of determinism, just want to clarify the exact requirement.</p>\n</blockquote>",
        "id": 480780251,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730832089
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553#issuecomment-2460565124\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553\">issue #9553</a>:</p>\n<blockquote>\n<p>FWIW, I think we do (or did at one point do) this kind of prefix removal in cranelift's build script or the meta crate.</p>\n</blockquote>",
        "id": 480983710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730920079
    },
    {
        "content": "<p>nmattia <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553#issuecomment-2461724558\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9553\">issue #9553</a>:</p>\n<blockquote>\n<blockquote>\n<p>We emit these paths in the generated Rust code to help us debug</p>\n</blockquote>\n<p>That makes complete sense!</p>\n<blockquote>\n<p>I'd be happy to review a PR that makes the paths relative to the source root </p>\n</blockquote>\n<p>I'll prepare something and send it your way then :) </p>\n<blockquote>\n<p>higher cache hit-rate for a cache shared across many builds at different paths?</p>\n</blockquote>\n<p>Yes, that's right! Some build systems read and hash inputs to see if any of the outputs that depend on said inputs need to be rebuilt -- unlike Make for instance, which uses mtime. So when some of those inputs (generated code with changing comments) change, the previously built outputs are discarded and need to be rebuilt, even though the changed comments should not have an impact on the actual built code.<br>\n</p>\n</blockquote>",
        "id": 481076595,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730971521
    }
]