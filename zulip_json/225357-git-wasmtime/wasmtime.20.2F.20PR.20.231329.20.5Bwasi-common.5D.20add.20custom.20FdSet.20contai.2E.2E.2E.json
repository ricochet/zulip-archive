[
    {
        "content": "<p>kubkon opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190758859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584381379
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a>, and <a href=\"https://github.com/sunfishcode\" target=\"_blank\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190758860,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584381379
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a>, and <a href=\"https://github.com/sunfishcode\" target=\"_blank\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190758861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584381379
    },
    {
        "content": "<p><strong>kubkon</strong> requested <a href=\"https://github.com/alexcrichton\" target=\"_blank\" title=\"https://github.com/alexcrichton\">alexcrichton</a>, <a href=\"https://github.com/pchickey\" target=\"_blank\" title=\"https://github.com/pchickey\">pchickey</a>, and <a href=\"https://github.com/sunfishcode\" target=\"_blank\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a>.</p>",
        "id": 190758862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584381379
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190758967,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584381441
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190766209,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584385513
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190766807,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584385821
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190770498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584387856
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190784716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584395639
    },
    {
        "content": "<p>kubkon updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1329\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1329\">PR #1329</a> from <code>fd_handles</code> to <code>master</code>:</p>\n<blockquote>\n<p>This PR adds a custom <code>FdSet</code> container which is intended<br>\nfor use in <code>wasi-common</code> to track WASI fd allocs/deallocs. The<br>\nmain aim for this container is to abstract away the current<br>\napproach of spawning new handles</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fd</span><span class=\"p\">.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">ok_or</span><span class=\"p\">(...)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and to make it possible to reuse unused/reclaimed handles<br>\nwhich currently is not done.</p>\n<p>The struct offers 3 methods to manage its functionality:</p>\n<ul>\n<li>\n<p><code>FdSet::new</code> initialises the internal data structures,<br>\n  and most notably, it preallocates an <code>FdSet::BATCH_SIZE</code><br>\n  worth of handles in such a way that we always start popping<br>\n  from the \"smallest\" handle (think of it as of reversed stack,<br>\n  I guess; it's not a binary heap since we don't really care<br>\n  whether internally the handles are sorted in some way, just that<br>\n  the \"largets\" handle is at the bottom. Why will become clear<br>\n  when describing <code>allocate</code> method.)</p>\n</li>\n<li>\n<p><code>FdSet::allocate</code> pops the next available handle if one is available.<br>\n  The tricky bit here is that, if we run out of handles, we preallocate<br>\n  the next <code>FdSet::BATCH_SIZE</code> worth of handles starting from the<br>\n  latest popped handle (i.e., the \"largest\" handle). This<br>\n  works only because we make sure to only ever pop and push already<br>\n  existing handles from the back, and push _new_ handles (from the<br>\n  preallocation step) from the front. When we ultimately run out<br>\n  of _all_ available handles, we then return <code>None</code> for the client<br>\n  to handle in some way (e.g., throwing an error such as <code>WasiError::EMFILE</code><br>\n  or whatnot).</p>\n</li>\n<li>\n<p><code>FdSet::deallocate</code> returns the already allocated handle back to<br>\n  the pool for further reuse.</p>\n</li>\n</ul>\n<p>When figuring out the internals, I've tried to optimise for both<br>\nalloc and dealloc performance, and I believe we've got an amortised<br>\n<code>O(1)~*</code> performance for both (if my maths is right, and it may very<br>\nwell not be, so please verify!).</p>\n<p>In order to keep <code>FdSet</code> fairly generic, I've made sure not to hard-code<br>\nit for the current type system generated by <code>wig</code> (i.e., <code>wasi::__wasi_fd_t</code><br>\nrepresenting WASI handle), but rather, any type which wants to be managed<br>\nby <code>FdSet</code> needs to conform to <code>Fd</code> trait. This trait is quite simple as<br>\nit only requires a couple of rudimentary traits (although <code>std:#️⃣:Hash</code><br>\nis quite a powerful assumption here!), and a custom method</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Fd</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is there to encapsulate creating another handle from the given one.<br>\nIn the current state of the code, that'd be simply <code>u32::checked_add(1)</code>.<br>\nWhen <code>wiggle</code> makes it way into the <code>wasi-common</code>, I'd imagine it being<br>\nsimilar to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">checked_add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Self</span>::<span class=\"n\">from</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Anyhow, I'd be happy to learn your thoughts about this design!</p>\n</blockquote>",
        "id": 190821881,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1584436137
    }
]