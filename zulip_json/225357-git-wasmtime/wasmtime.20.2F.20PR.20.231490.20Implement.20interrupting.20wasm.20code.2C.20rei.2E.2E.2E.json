[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193495704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586459298
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193498461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586460576
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319\">PR Review</a>.</p>",
        "id": 193508013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586465684
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391122319\">PR Review</a>.</p>",
        "id": 193508014,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586465684
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406469091\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406469091\">PR Review Comment</a>:</p>\n<blockquote>\n<p>How is this serialized to a .clif file?</p>\n</blockquote>",
        "id": 193508015,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586465684
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391155996\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391155996\">PR Review</a>.</p>",
        "id": 193513735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586468985
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406497575\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406497575\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It is not.</p>\n</blockquote>",
        "id": 193513736,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586468985
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391325978\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391325978\">PR Review</a>.</p>",
        "id": 193547661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586506683
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Maybe use a <code>GlobalValue</code> here instead. That way it is serializable.</p>\n</blockquote>",
        "id": 193547662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586506683
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406656377\">PR Review Comment</a>.</p>",
        "id": 193547678,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586506699
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193587823,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586535834
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391531715\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391531715\">PR Review</a>.</p>",
        "id": 193587916,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586535870
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406832982\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406832982\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm not sure if that would work out because of how manual this is due to how late in the pipeline this executes. I'm also pretty unfamiliar with cranelift itself. If you've got an example of how to do this that would be great!</p>\n</blockquote>",
        "id": 193587917,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586535870
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170\">PR Review</a>.</p>",
        "id": 193594690,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539509
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391533170\">PR Review</a>.</p>",
        "id": 193594691,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539509
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406834338\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406834338\">PR Review Comment</a>:</p>\n<blockquote>\n<p>FWIW, this needs to be <code>[]</code> not <code>()</code>.</p>\n</blockquote>",
        "id": 193594692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539509
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406836297\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406836297\">PR Review Comment</a>:</p>\n<blockquote>\n<p>assert that the size is greater than zero? (or some reasonable min)</p>\n</blockquote>",
        "id": 193594693,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539509
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406848003\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406848003\">PR Review Comment</a>:</p>\n<blockquote>\n<p>What @bjorn3 was hinting at is that all input cranelift accepts (not cranelift-wasm, but cranelift itself) is currently representable in the the clif text format. This is really nice for testing, reproducibility, and test case reduction. For example, see \"Don't Lose Our Copy-and-Paste-This-IR-and-it-is-a-Test Property\" in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342\">https://github.com/bytecodealliance/wasmtime/issues/1146#issuecomment-566790342</a></p>\n<p>By providing a closure that is called in the middle of cranelift compilation, and without a text representation, we're losing those nice testing properties.</p>\n<p>In this specific case, I'm not sure what alternative is better here. This isn't really generic behavior that makes sense inside cranelift. And we don't have anything like \"always inline functions/macros\" right now (maybe <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1267\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1267\">https://github.com/bytecodealliance/wasmtime/pull/1267</a> could eventually be that, its motivation was similar, but for GC barriers).</p>\n<p>@sunfishcode felt pretty strongly about the everything-is-in-clif-text property, so tagging him for ideas here.</p>\n</blockquote>",
        "id": 193594694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539510
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855994\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855994\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This should be four bools because it uses two per config (one for it the swarm is enabled, another for if it actually sets the config flag).</p>\n<p>Also the comment above should be updated.</p>\n</blockquote>",
        "id": 193594695,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539510
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855000\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406855000\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Also add a test for this file over here: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs\">https://github.com/bytecodealliance/wasmtime/blob/master/crates/c-api/tests/wasm-c-examples.rs</a></p>\n</blockquote>",
        "id": 193594697,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539510
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406849627\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406849627\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Would it be possible to add <code>translate_func_prologue</code> to <code>cranelift_wasm::FuncEnviron</code>, where we already have embedder hooks and can side step these issues? I think this would also make it so we wouldn't need to regalloc by hand here.</p>\n</blockquote>",
        "id": 193594698,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586539510
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391575774\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391575774\">PR Review</a>.</p>",
        "id": 193597852,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541200
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870296\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870296\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hm I think that <code>()</code> is what's wanted here since that's the destination of the link. I was fixing rustdoc warnings here and this is what was necessary to fix the warning.</p>\n</blockquote>",
        "id": 193597853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541201
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576189\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576189\">PR Review</a>.</p>",
        "id": 193597990,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541249
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870658\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406870658\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I don't think it'd help much to single-out zero here, 1 byte of stack allocation is just as nonsensical in a sense. I personally think it's ok to take everything here, and if someone is toying around with 0-byte wasm stacks for testing that seems like it's fine to allow.</p>\n</blockquote>",
        "id": 193597991,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541249
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576656\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391576656\">PR Review</a>.</p>",
        "id": 193598092,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541306
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406871045\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406871045\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Hm I don't think this is actually that necessary, we already run all the examples on CI with <code>cargo run -p run-examples</code>?</p>\n</blockquote>",
        "id": 193598093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541306
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193598167,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541358
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391577962\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391577962\">PR Review</a>.</p>",
        "id": 193598413,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541471
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406872123\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406872123\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I'm not really wed to this particular solution at all, and I agree it's a great property to have everything reflected in the text format. That being said though we need <em>some</em> solution here which actually works and accounts for the wasmtime-specific behavior of where the stack limit is located. I don't know of a great way to do this, but would be totally onboard with alternative ways.</p>\n<p>I don't know how to make <code>translate_func_prologue</code> work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>\n</blockquote>",
        "id": 193598414,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541471
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582084\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582084\">PR Review</a>.</p>",
        "id": 193599397,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541971
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875502\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875502\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah ok, I guess <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1463\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1463\">https://github.com/bytecodealliance/wasmtime/pull/1463</a> was unnecessary</p>\n</blockquote>",
        "id": 193599398,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586541971
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582592\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391582592\">PR Review</a>.</p>",
        "id": 193599526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586542037
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875923\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406875923\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't know how to make <code>translate_func_prologue</code> work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>\n</blockquote>\n<p>I think we would need an instruction to get the current stack frame's size or something. Not sure how well this would work out.</p>\n</blockquote>",
        "id": 193599527,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586542037
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391584950\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-391584950\">PR Review</a>.</p>",
        "id": 193600087,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586542340
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406877960\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r406877960\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The impression I get though is that representing this in IR is the wrong idea because if we generate IR to do the stack check, then the actual stack adjustment happens in the function's prologue, which is too late then to perform the stack check. This is very machine-specific because it's part of the prologue/epilogue generation at a very particular part of codegen, so afaik it can't be very easily represented in IR without a lot of \"magic\", but others may know better routes!</p>\n</blockquote>",
        "id": 193600088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586542340
    },
    {
        "content": "<p>bnjbvr submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-392774970\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-392774970\">PR Review</a>.</p>",
        "id": 193873581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586857990
    },
    {
        "content": "<p>bnjbvr created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408011344\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408011344\">PR Review Comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't know how to make translate_func_prologue work since the stack limit check happens at such an odd time (machine code generation) not at cranelift IR generation time (when wasm is translated). Would this need some sort of magical sequence of instructions at the prologue which gets pattern-matched for the stack check?</p>\n</blockquote>\n<p>For what it's worth, the way it's dealt with in Spidermonkey is that:</p>\n<ol>\n<li>Spidermonkey has its own calling convention \"baldrdash\", used in Cranelift.</li>\n<li>Cranelift won't generate the prologue and epilogue if the calling convention is baldrdash; Spidermonkey will.</li>\n<li>Then the interrupt check can be done in Cranelift IR from the Spidermonkey side.</li>\n<li>In addition to this, Spidermonkey has to use the <code>fallthrough_return</code> instead of a plain return, since it generates its own epilogue.</li>\n</ol>\n<p>I imagine replicating this behavior for Wasmtime would be quite a hassle, so this might not be the best path here...</p>\n</blockquote>",
        "id": 193873582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586857990
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193904779,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586874181
    },
    {
        "content": "<p>pepyakin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666\">PR Review</a>.</p>",
        "id": 193921228,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586880841
    },
    {
        "content": "<p>pepyakin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408243887\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408243887\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I think you meant <code>max_wasm_stack</code> here, right?</p>\n</blockquote>",
        "id": 193921229,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586880841
    },
    {
        "content": "<p>pepyakin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393060666\">PR Review</a>.</p>",
        "id": 193921230,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586880841
    },
    {
        "content": "<p>pepyakin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408242909\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408242909\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Doesn't this warrant an unsafe marker on <code>update_stack_limit</code> since this only works if <code>self</code> is on the stack. A comment at the call site might do as well.</p>\n</blockquote>",
        "id": 193921231,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586880841
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 193949173,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586894209
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408397568\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r408397568\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh oops good point. I've updated the comment on the function a bit</p>\n</blockquote>",
        "id": 193949207,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586894222
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393249348\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-393249348\">PR Review</a>.</p>",
        "id": 193949208,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586894222
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194031617,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586958080
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194496378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587155708
    },
    {
        "content": "<p>abrown submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395771124\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395771124\">PR Review</a>.</p>",
        "id": 194499557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587157399
    },
    {
        "content": "<p>abrown created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410468638\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410468638\">PR Review Comment</a>:</p>\n<blockquote>\n<p>-1?</p>\n</blockquote>",
        "id": 194499558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587157399
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395777731\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395777731\">PR Review</a>.</p>",
        "id": 194501009,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587158185
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\">PR Review Comment</a>:</p>\n<blockquote>\n<p>If you can use a <code>GlobalValueData::Load</code> to load from a <code>GlobalValueData::VMContext</code>. Then you set this field to the <code>GlobalValue</code> of the <code>GlobalValueData</code>. You can then during the stack check codegen use <code>global_value</code> to get the stack limit</p>\n</blockquote>",
        "id": 194501011,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587158186
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\">PR Review Comment</a>.</p>",
        "id": 194501023,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587158200
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395785536\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395785536\">PR Review</a>.</p>",
        "id": 194502637,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159187
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410480349\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410480349\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Keeping <code>ir::Function</code> serializable makes it easier for us to extract standalone Cranelift testcases that don't require linking with surrounding applications. And in the future, we also hope to use this property to enable more compilation caching and remote/ipc compilation.</p>\n<p>Global values are an expression language which you can use to define code templates that Cranelift can expand into actual code later (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/1267\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1267\">https://github.com/bytecodealliance/wasmtime/pull/1267</a> is a further step toward generalizing the concept and actually renames it to \"template\"). Currently, you can only do a few simple things with them: <a href=\"https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/enum.GlobalValueData.html\" title=\"https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/enum.GlobalValueData.html\">load, iadd_imm, vmctx addresses, and symbolic addresses</a>. That looks like it may actually be enough for what you need to do here, though we can add more operations if needed.</p>\n<p>So the idea is, you create them, one \"instruction\" at a time, with <a href=\"https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/function/struct.Function.html#method.create_global_value\" title=\"https://docs.rs/cranelift-codegen/0.62.0/cranelift_codegen/ir/function/struct.Function.html#method.create_global_value\">declare_global_value</a> which returns the index of the global value which you can then use however you want within the <code>ir::Function</code>.</p>\n</blockquote>",
        "id": 194502638,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159187
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395786342\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395786342\">PR Review</a>.</p>",
        "id": 194502838,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159289
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410481007\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410481007\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I <a href=\"https://gist.github.com/alexcrichton/c43e66cc13154a97be2af665dc1aa117\" title=\"https://gist.github.com/alexcrichton/c43e66cc13154a97be2af665dc1aa117\">tried that</a> but <a href=\"https://gist.github.com/alexcrichton/02697129b5a92ad2b8983a74115b244a\" title=\"https://gist.github.com/alexcrichton/02697129b5a92ad2b8983a74115b244a\">got a panic</a> that I think means the legalizer needs to run, but this is happening after the legalizer has already run.</p>\n</blockquote>",
        "id": 194502839,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159290
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395789113\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395789113\">PR Review</a>.</p>",
        "id": 194503569,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159678
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410483356\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410483356\">PR Review Comment</a>:</p>\n<blockquote>\n<p>@sunfishcode oh I think that's what @bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410474016\">recommended above</a> a few minutes ago as well, but do you know how to work around the legalizer issue? Expanding a global value seems to require the legalizer to run, but since this is in prologue/epilogue generation that's too late for the legalizer to run it seems.</p>\n</blockquote>",
        "id": 194503570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587159678
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395792403\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395792403\">PR Review</a>.</p>",
        "id": 194504475,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587160121
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410486174\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410486174\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It seems that <code>EncCursor</code> doesn't allow inserting instructions that need to be legalized.</p>\n</blockquote>",
        "id": 194504476,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587160121
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194505923,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587161021
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395799141\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395799141\">PR Review</a>.</p>",
        "id": 194505935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587161032
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410491892\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410491892\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oops, updated the comment!</p>\n</blockquote>",
        "id": 194505936,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587161032
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194507643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587162256
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946\">PR Review</a>.</p>",
        "id": 194517569,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-395834946\">PR Review</a>.</p>",
        "id": 194517570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523700\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523700\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This technique is independent of x86, so we should just say \"the stack pointer\" rather than \"%rsp\".</p>\n</blockquote>",
        "id": 194517571,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523495\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523495\">PR Review Comment</a>:</p>\n<blockquote>\n<p>s/wasm/Wasmtime/</p>\n</blockquote>",
        "id": 194517572,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523838\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410523838\">PR Review Comment</a>:</p>\n<blockquote>\n<p>\"How does Wasmtime interrupt wasm code\"?</p>\n</blockquote>",
        "id": 194517573,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410524479\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410524479\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This focuses on how we implement it, but for users, we should say something like \"Whether or not to enable the ability to interrupt wasm code dynamically\", and also mention the limitation that calls into host code can't be interrupted. And maybe also link to how to perform an interrupt.</p>\n</blockquote>",
        "id": 194517574,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527112\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527112\">PR Review Comment</a>:</p>\n<blockquote>\n<p>With this change, we're now overriding Rust's <code>SA_ONSTACK</code> handler with our own non-<code>SA_ONSTACK</code> handler. This means that all Rust code in a program which uses Wasmtime will no longer get the Rust stack overflow handler on stack overflow, but a generic segfault; is that right? That seems like something we should document somewhere; Rust users may be accustomed to not seeing their programs killed by segfault, and may otherwise interpret a segfault as a sign of a more serious problem.</p>\n</blockquote>",
        "id": 194517575,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410525292\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410525292\">PR Review Comment</a>:</p>\n<blockquote>\n<p>It's surprising that this is being represented as a signed <code>i32</code>, since the value becomes negative, and elsewhere it's casted to a <code>usize</code> and treated as unsigned.</p>\n</blockquote>",
        "id": 194517576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527590\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r410527590\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Would it be difficult to add similar code to the wasmtime-cli as a command-line argument to let users specify <code>--timeout=30s</code> or so?</p>\n</blockquote>",
        "id": 194517577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587171081
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194683911,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587393493
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396516772\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396516772\">PR Review</a>.</p>",
        "id": 194683954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587393514
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411431960\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411431960\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Sure!</p>\n<p>I added this as <code>--wasm-timeout=30</code> so in the future we could add <code>--timeout</code> which accounts for both compile time and for wasm execution time.</p>\n</blockquote>",
        "id": 194683955,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587393514
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396518164\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396518164\">PR Review</a>.</p>",
        "id": 194684174,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587393604
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411433170\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411433170\">PR Review Comment</a>:</p>\n<blockquote>\n<p>That's true yeah, and unfortunately I'm not sure there's really anything we can do about it. The only real way to fix this would be to always run on the sigaltstack which brings up the same issues that <em>not</em> running on the sigaltstack is trying to fix. </p>\n<p>I'll throw a comment here in signal registration in case anyone is poking around, I'm not really sure where else would be an effective place to comment this.</p>\n</blockquote>",
        "id": 194684178,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587393605
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194685160,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587394061
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194685449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587394170
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396527305\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396527305\">PR Review</a>.</p>",
        "id": 194685483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587394187
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411440942\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411440942\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Er I'm basically trying to be too clever by half here, I've updated this to be <code>usize</code>.</p>\n</blockquote>",
        "id": 194685484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587394187
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322\">PR Review</a>.</p>",
        "id": 194689762,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587395903
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411448540\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411448540\">PR Review Comment</a>:</p>\n<blockquote>\n<p>We already have a dependency on <code>humantime</code> (via <code>env_logger</code>), so could we make this take a string and parse it with <a href=\"https://docs.rs/humantime/2.0.0/humantime/fn.parse_duration.html\" title=\"https://docs.rs/humantime/2.0.0/humantime/fn.parse_duration.html\"><code>parse_duration</code></a>? That way people can specify timeouts less than a second, and large timeouts are more convenient.</p>\n</blockquote>",
        "id": 194689764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587395903
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396536322\">PR Review</a>.</p>",
        "id": 194689765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587395903
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411456237\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411456237\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Typo: tha-&gt;that</p>\n</blockquote>",
        "id": 194689766,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587395903
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194693077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587397120
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396573227\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396573227\">PR Review</a>.</p>",
        "id": 194693086,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587397127
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411480275\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411480275\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Oh nice idea!</p>\n<p>Updated now</p>\n</blockquote>",
        "id": 194693087,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587397127
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194694503,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587397737
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396783692\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396783692\">PR Review</a>.</p>",
        "id": 194727673,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587414153
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194731649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587415940
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194732504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587416319
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194737502,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587419038
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396968166\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#pullrequestreview-396968166\">PR Review</a>.</p>",
        "id": 194758592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587441103
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411848258\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490#discussion_r411848258\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>func()</code> has been renamed to <code>into_func()</code>, but this can be simplified to just <code>instance.get_func(\"foo\")</code>.</p>\n</blockquote>",
        "id": 194758593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587441103
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194808447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587478823
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a> from <code>catch-stack-overflow</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit is a relatively large change for wasmtime with two main<br>\ngoals:</p>\n<ul>\n<li>\n<p>Primarily this enables interrupting executing wasm code with a trap,<br>\n  preventing infinite loops in wasm code. Note that resumption of the<br>\n  wasm code is not a goal of this commit.</p>\n</li>\n<li>\n<p>Additionally this commit reimplements how we handle stack overflow to<br>\n  ensure that host functions always have a reasonable amount of stack to<br>\n  run on. This fixes an issue where we might longjmp out of a host<br>\n  function, skipping destructors.</p>\n</li>\n</ul>\n<p>Lots of various odds and ends end up falling out in this commit once the<br>\ntwo goals above were implemented. The strategy for implementing this was<br>\nalso lifted from Spidermonkey and existing functionality inside of<br>\nCranelift. I've tried to write up thorough documentation of how this all<br>\nworks in <code>crates/environ/src/cranelift.rs</code> where gnarly-ish bits are.</p>\n<p>A brief summary of how this works is that each function and each loop<br>\nheader now checks to see if they're interrupted. Interrupts and the<br>\nstack overflow check are actually folded into one now, where function<br>\nheaders check to see if they've run out of stack and the sentinel value<br>\nused to indicate an interrupt, checked in loop headers, tricks functions<br>\ninto thinking they're out of stack. An interrupt is basically just<br>\nwriting a value to a location which is read by JIT code.</p>\n<p>When interrupts are delivered and what triggers them has been left up to<br>\nembedders of the <code>wasmtime</code> crate. The <code>wasmtime::Store</code> type has a<br>\nmethod to acquire an <code>InterruptHandle</code>, where <code>InterruptHandle</code> is a<br>\n<code>Send</code> and <code>Sync</code> type which can travel to other threads (or perhaps<br>\neven a signal handler) to get notified from. It's intended that this<br>\nprovides a good degree of flexibility when interrupting wasm code. Note<br>\nthough that this does have a large caveat where interrupts don't work<br>\nwhen you're interrupting host code, so if you've got a host import<br>\nblocking for a long time an interrupt won't actually be received until<br>\nthe wasm starts running again.</p>\n<p>Some fallout included from this change is:</p>\n<ul>\n<li>\n<p>Unix signal handlers are no longer registered with <code>SA_ONSTACK</code>.<br>\n  Instead they run on the native stack the thread was already using.<br>\n  This is possible since stack overflow isn't handled by hitting the<br>\n  guard page, but rather it's explicitly checked for in wasm now. Native<br>\n  stack overflow will continue to abort the process as usual.</p>\n</li>\n<li>\n<p>Unix sigaltstack management is now no longer necessary since we don't<br>\n  use it any more.</p>\n</li>\n<li>\n<p>Windows no longer has any need to reset guard pages since we no longer<br>\n  try to recover from faults on guard pages.</p>\n</li>\n<li>\n<p>On all targets probestack intrinsics are disabled since we use a<br>\n  different mechanism for catching stack overflow.</p>\n</li>\n<li>\n<p>The C API has been updated with interrupts handles. An example has<br>\n  also been added which shows off how to interrupt a module.</p>\n</li>\n</ul>\n<p>Closes #139<br>\nCloses #860<br>\nCloses #900</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194831658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587488298
    },
    {
        "content": "<p>sunfishcode merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1490\">PR #1490</a>.</p>",
        "id": 194840087,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587492210
    }
]