[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a> from <code>afonso360:riscv-simd-widening-iadd</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This PR adds the widening add instructions from the V spec. These are <code>vwadd{u,}.{w,v}{v,x}</code>.</p>\n<p>This also adds a bunch of rules to try to match these instructions. And some of these end up being quite complex.</p>\n<p>Rules that match <code>{u,s}widen_high</code> are the same as their <code>{u,s}widen_low</code> counterparts but they first do a <code>vslidedown</code> of half the vector, to bring the top lanes down.</p>\n<p><code>uwiden_low</code> rules are the same as the <code>swiden_low</code> rules, but they use <code>vwaddu.*</code> instead of <code>vwadd.*</code> which is the unsigned version of the instruction.</p>\n<p>Now, in each of these groups of rules we have a few different instructions.</p>\n<p><code>vwadd.wv</code> does a 2<em>SEW = 2</em>SEW + SEW, this just means that the elements in the RHS vector are first sign extended before doing the addition. The only trick here is that since the result is 2*SEW we must use a vstate type that has half the element size as the type that we want to end up with. So to end up with a i32x4 <code>iadd</code> we need to pass in a i16x4 type as a vstate type.</p>\n<p><code>vwadd.vv</code> does 2*SEW = SEW + SEW, so as long as both sides are extended we can use this instruction. Again we must pass in a type with half the element size.</p>\n<p><code>vwadd.wx</code> and <code>vwadd.vx</code> do the same thing, but the RHS is expected to be a extended and splatted X register, so we try to match exactly that. To make these rules more applicable I've previously added some egraph rules (#6533) that convert <code>{u,s}widen_{low,high}</code> into <code>splat+{u,s}extend</code>, this way we only have to try to match the splat version, which reduces the number of rules.</p>\n<p>All of these rules use <code>vstate_mf2</code>. This is sets the LMUL setting to 1/2, meaning that at most we will read half of the source vector registers, and the result is guaranteed to fit in a single destination register. Otherwise the CPU could have to write the result into multiple registers, which is something that the ISA supports, but adds a bunch of constraints that we don't need here.</p>\n<hr>\n<p>I would really appreciate if we could find a way to reduce the number of rules here. I couldn't really come up with anything, but maybe someone does. We have equivalents to all of these for <code>isub</code> and <code>imul</code> so finding  a good reduction here, will hopefully make implementing those easier.</p>\n</blockquote>",
        "id": 364587445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235465
    },
    {
        "content": "<p><strong>afonso360</strong> requested <a href=\"https://github.com/cfallin\">cfallin</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>.</p>",
        "id": 364587448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235466
    },
    {
        "content": "<p><strong>afonso360</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>.</p>",
        "id": 364587449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235466
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This PR adds the widening add instructions from the V spec. These are <code>vwadd{u,}.{w,v}{v,x}</code>.</p>\n<p>This also adds a bunch of rules to try to match these instructions. And some of these end up being quite complex.</p>\n<p>Rules that match <code>{u,s}widen_high</code> are the same as their <code>{u,s}widen_low</code> counterparts but they first do a <code>vslidedown</code> of half the vector, to bring the top lanes down.</p>\n<p><code>uwiden_low</code> rules are the same as the <code>swiden_low</code> rules, but they use <code>vwaddu.*</code> instead of <code>vwadd.*</code> which is the unsigned version of the instruction.</p>\n<p>Now, in each of these groups of rules we have a few different instructions.</p>\n<p><code>vwadd.wv</code> does a 2 * SEW = 2 * SEW + SEW, this just means that the elements in the RHS vector are first sign extended before doing the addition. The only trick here is that since the result is 2*SEW we must use a vstate type that has half the element size as the type that we want to end up with. So to end up with a i32x4 <code>iadd</code> we need to pass in a i16x4 type as a vstate type.</p>\n<p><code>vwadd.vv</code> does 2 * SEW = SEW + SEW, so as long as both sides are extended we can use this instruction. Again we must pass in a type with half the element size.</p>\n<p><code>vwadd.wx</code> and <code>vwadd.vx</code> do the same thing, but the RHS is expected to be a extended and splatted X register, so we try to match exactly that. To make these rules more applicable I've previously added some egraph rules (#6533) that convert <code>{u,s}widen_{low,high}</code> into <code>splat+{u,s}extend</code>, this way we only have to try to match the splat version, which reduces the number of rules.</p>\n<p>All of these rules use <code>vstate_mf2</code>. This is sets the LMUL setting to 1/2, meaning that at most we will read half of the source vector registers, and the result is guaranteed to fit in a single destination register. Otherwise the CPU could have to write the result into multiple registers, which is something that the ISA supports, but adds a bunch of constraints that we don't need here.</p>\n<hr>\n<p>I would really appreciate if we could find a way to reduce the number of rules here. I couldn't really come up with anything, but maybe someone does. We have equivalents to all of these for <code>isub</code> and <code>imul</code> so finding  a good reduction here, will hopefully make implementing those easier.</p>\n</blockquote>",
        "id": 364587576,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235496
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This PR adds the widening add instructions from the V spec. These are <code>vwadd{u,}.{w,v}{v,x}</code>.</p>\n<p>This also adds a bunch of rules to try to match these instructions. And some of these end up being quite complex.</p>\n<p>Rules that match <code>{u,s}widen_high</code> are the same as their <code>{u,s}widen_low</code> counterparts but they first do a <code>vslidedown</code> of half the vector, to bring the top lanes down.</p>\n<p><code>uwiden_low</code> rules are the same as the <code>swiden_low</code> rules, but they use <code>vwaddu.*</code> instead of <code>vwadd.*</code> which is the unsigned version of the instruction.</p>\n<p>Now, in each of these groups of rules we have a few different instructions.</p>\n<p><code>vwadd.wv</code> does a 2 * SEW = 2 * SEW + SEW, this just means that the elements in the RHS vector are first sign extended before doing the addition. The only trick here is that since the result is 2*SEW we must use a vstate type that has half the element size as the type that we want to end up with. So to end up with a i32x4 <code>iadd</code> we need to pass in a i16x4 type as a vstate type.</p>\n<p><code>vwadd.vv</code> does 2 * SEW = SEW + SEW, so as long as both sides are extended we can use this instruction. Again we must pass in a type with half the element size.</p>\n<p><code>vwadd.wx</code> and <code>vwadd.vx</code> do the same thing, but the RHS is expected to be a extended and splatted X register, so we try to match exactly that. To make these rules more applicable I've previously added some egraph rules (#6533) that convert <code>{u,s}widen_{low,high}</code> into <code>splat+{u,s}extend</code>, this way we only have to try to match the splat version, which reduces the number of rules.</p>\n<p>All of these rules use <code>vstate_mf2</code>. This is sets the LMUL setting to 1/2, meaning that at most we will read half of the source vector registers, and the result is guaranteed to fit in a single destination register. Otherwise we could have to write the result into multiple registers, which is something that the ISA supports, but adds a bunch of constraints that we don't need here.</p>\n<hr>\n<p>I would really appreciate if we could find a way to reduce the number of rules here. I couldn't really come up with anything, but maybe someone does. We have equivalents to all of these for <code>isub</code> and <code>imul</code> so finding  a good reduction here, will hopefully make implementing those easier.</p>\n</blockquote>",
        "id": 364588268,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235629
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This PR adds the widening add instructions from the V spec. These are <code>vwadd{u,}.{w,v}{v,x}</code>.</p>\n<p>This also adds a bunch of rules to try to match these instructions. And some of these end up being quite complex.</p>\n<p>Rules that match <code>{u,s}widen_high</code> are the same as their <code>{u,s}widen_low</code> counterparts but they first do a <code>vslidedown</code> of half the vector, to bring the top lanes down.</p>\n<p><code>uwiden_low</code> rules are the same as the <code>swiden_low</code> rules, but they use <code>vwaddu.*</code> instead of <code>vwadd.*</code> which is the unsigned version of the instruction.</p>\n<p>Now, in each of these groups of rules we have a few different instructions.</p>\n<p><code>vwadd.wv</code> does a 2 * SEW = 2 * SEW + SEW, this just means that the elements in the RHS vector are first sign extended before doing the addition. The only trick here is that since the result is 2*SEW we must use a vstate type that has half the element size as the type that we want to end up with. So to end up with a i32x4 <code>iadd</code> we need to pass in a i16x4 type as a vstate type.</p>\n<p><code>vwadd.vv</code> does 2 * SEW = SEW + SEW, so as long as both sides are extended we can use this instruction. We must set the vstate with a type that has half the element size and half the lanes.</p>\n<p><code>vwadd.wx</code> and <code>vwadd.vx</code> do the same thing, but the RHS is expected to be a extended and splatted X register, so we try to match exactly that. To make these rules more applicable I've previously added some egraph rules (#6533) that convert <code>{u,s}widen_{low,high}</code> into <code>splat+{u,s}extend</code>, this way we only have to try to match the splat version, which reduces the number of rules.</p>\n<p>All of these rules use <code>vstate_mf2</code>. This is sets the LMUL setting to 1/2, meaning that at most we will read half of the source vector registers, and the result is guaranteed to fit in a single destination register. Otherwise we could have to write the result into multiple registers, which is something that the ISA supports, but adds a bunch of constraints that we don't need here.</p>\n<hr>\n<p>I would really appreciate if we could find a way to reduce the number of rules here. I couldn't really come up with anything, but maybe someone does. We have equivalents to all of these for <code>isub</code> and <code>imul</code> so finding  a good reduction here, will hopefully make implementing those easier.</p>\n</blockquote>",
        "id": 364589564,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235875
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This PR adds the widening add instructions from the V spec. These are <code>vwadd{u,}.{w,v}{v,x}</code>.</p>\n<p>This also adds a bunch of rules to try to match these instructions. And some of these end up being quite complex.</p>\n<p>Rules that match <code>{u,s}widen_high</code> are the same as their <code>{u,s}widen_low</code> counterparts but they first do a <code>vslidedown</code> of half the vector, to bring the top lanes down.</p>\n<p><code>uwiden_low</code> rules are the same as the <code>swiden_low</code> rules, but they use <code>vwaddu.*</code> instead of <code>vwadd.*</code> which is the unsigned version of the instruction.</p>\n<p>Now, in each of these groups of rules we have a few different instructions.</p>\n<p><code>vwadd.wv</code> does a 2 * SEW = 2 * SEW + SEW, this just means that the elements in the RHS vector are first sign extended before doing the addition. The only trick here is that since the result is 2*SEW we must use a vstate type that has half the element size as the type that we want to end up with. So to end up with a i32x4 <code>iadd</code> we need to pass in a i16x4 type as a vstate type.</p>\n<p><code>vwadd.vv</code> does 2 * SEW = SEW + SEW, so as long as both sides are extended we can use this instruction. We must set the vstate with a type that has half the element size and half the lanes of the final type.</p>\n<p><code>vwadd.wx</code> and <code>vwadd.vx</code> do the same thing, but the RHS is expected to be a extended and splatted X register, so we try to match exactly that. To make these rules more applicable I've previously added some egraph rules (#6533) that convert <code>{u,s}widen_{low,high}</code> into <code>splat+{u,s}extend</code>, this way we only have to try to match the splat version, which reduces the number of rules.</p>\n<p>All of these rules use <code>vstate_mf2</code>. This is sets the LMUL setting to 1/2, meaning that at most we will read half of the source vector registers, and the result is guaranteed to fit in a single destination register. Otherwise we could have to write the result into multiple registers, which is something that the ISA supports, but adds a bunch of constraints that we don't need here.</p>\n<hr>\n<p>I would really appreciate if we could find a way to reduce the number of rules here. I couldn't really come up with anything, but maybe someone does. We have equivalents to all of these for <code>isub</code> and <code>imul</code> so finding  a good reduction here, will hopefully make implementing those easier.</p>\n</blockquote>",
        "id": 364589597,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686235886
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542#pullrequestreview-1470274941\">PR review</a>:</p>\n<blockquote>\n<p>I must admit I didn't dig super deep into every single rule/test, but it looks like it has the bits it should have, so LGTM!</p>\n</blockquote>",
        "id": 364609998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686239705
    },
    {
        "content": "<p>afonso360 merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6542\">PR #6542</a>.</p>",
        "id": 364655386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1686251346
    }
]