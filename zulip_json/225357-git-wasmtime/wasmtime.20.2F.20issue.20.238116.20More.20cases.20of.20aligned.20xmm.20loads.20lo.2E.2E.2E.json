[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116\">issue #8116</a>:</p>\n<blockquote>\n<p>On the heels of #8112 and #8113, this should succeed but it does not:</p>\n<div class=\"codehilite\" data-code-language=\"wasm\"><pre><span></span><code>(module\n  (memory 1)\n  (func (export \"main\") (param i32 f64 i32) (result f64)\n    local.get 2\n    f64.load\n    f64.ceil\n    return))\n\n(assert_return\n  (invoke \"main\"\n    (i32.const 1)\n    (f64.const 1)\n    (i32.const 0xfff8)\n  )\n  (f64.const 0))\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">wast</span><span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">cranelift</span><span class=\"o\">-</span><span class=\"n\">has</span><span class=\"o\">-</span><span class=\"n\">avx</span><span class=\"o\">=</span><span class=\"kc\">false</span>\n<span class=\"n\">Error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">script</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span><span class=\"o\">'</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">directive</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span>:<span class=\"mi\">9</span>:<span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n           <span class=\"mi\">0</span>:   <span class=\"mh\">0x2f</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!&lt;</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"nc\">memory</span><span class=\"w\"> </span><span class=\"n\">fault</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"w\"> </span><span class=\"mh\">0x10000</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">linear</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"mh\">0x10000</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span>: <span class=\"nc\">wasm</span><span class=\"w\"> </span><span class=\"n\">trap</span>: <span class=\"nc\">out</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">access</span>\n</code></pre></div>\n<p>I discovered this by commenting out <a href=\"https://github.com/bytecodealliance/wasmtime/blob/daa7fdf2cef425f73fcd50f91bad2698d0d1813f/cranelift/codegen/src/isa/x64/inst.isle#L5124-L5125\">these conversions</a> and auditing everything that relied on them. The instructions I found were <code>rounds{s,d}</code> which are related to instructions like <code>f64.ceil</code>. Note that this requires AVX to be disabled (since AVX works on unaligned loads/stores) and additionally requires SSE4.1 (or some sse variant) to be enabled.</p>\n<p>I think that this is the only one relying on non-128-bit size registers, but at the same time I'm not certain.</p>\n</blockquote>",
        "id": 426359889,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710342020
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116#issuecomment-1994619303\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116\">issue #8116</a>:</p>\n<blockquote>\n<p>I believe that this may just be limited to the round instructions because I believe that floating-point operations on f32 and f64 do not require alignment but working on 128-bit values does require alignment. That means instructions [like <code>addss](https://github.com/bytecodealliance/wasmtime/blob/daa7fdf2cef425f73fcd50f91bad2698d0d1813f/cranelift/codegen/src/isa/x64/inst.isle#L3348-L3351) specifically use </code>*_unaligned<code> variants of instructions to avoid this issue. However </code>rounds{s,d}<code> were special in that I was \"too lazy\" to make a whole new instruction variant for a unaligned-unary-operation-with-immediate. That I think at least explains why it's just </code>rounds{s,d}` affected and it looks like no others.</p>\n<p>Even with that though with a fix like <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8113\">https://github.com/bytecodealliance/wasmtime/pull/8113</a> to \"just\" do the load eagerly and never take advantage of load sinking I'd fear that I would never be able to remember this when reviewing changes to the x64 backend.</p>\n</blockquote>",
        "id": 426361730,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710342468
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116#issuecomment-1994619303\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116\">issue #8116</a>:</p>\n<blockquote>\n<p>I believe that this may just be limited to the round instructions because I believe that floating-point operations on f32 and f64 do not require alignment but working on 128-bit values does require alignment. That means instructions <a href=\"https://github.com/bytecodealliance/wasmtime/blob/daa7fdf2cef425f73fcd50f91bad2698d0d1813f/cranelift/codegen/src/isa/x64/inst.isle#L3348-L3351\">like <code>addss</code></a> specifically use <code>*_unaligned</code> variants of instructions to avoid this issue. However <code>rounds{s,d}</code> were special in that I was \"too lazy\" to make a whole new instruction variant for a unaligned-unary-operation-with-immediate. That I think at least explains why it's just <code>rounds{s,d}</code> affected and it looks like no others.</p>\n<p>Even with that though with a fix like <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8113\">https://github.com/bytecodealliance/wasmtime/pull/8113</a> to \"just\" do the load eagerly and never take advantage of load sinking I'd fear that I would never be able to remember this when reviewing changes to the x64 backend.</p>\n</blockquote>",
        "id": 426361762,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710342475
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116#issuecomment-1994661085\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116\">issue #8116</a>:</p>\n<blockquote>\n<p>Potentially very unpopular suggestion: we could build another newtype around xmm registers (and memory variants) that means \"narrow <code>f{32,64}</code> value\". It's a departure from how we handle GPRs (we have no problem using <code>Gpr</code> for 8/16/32/64-bit-wide values, and we don't seem to have load-width bugs at the moment), but it at least is a speedbump for the ISLE rule author to remember that some special handling may be required.</p>\n<p>Another possibility would be to encode operand size into the <code>XmmMem</code> and at least assert it matches what the instruction it's been given to will do.</p>\n<p>Happy to talk more during the CL meeting in a few minutes!</p>\n</blockquote>",
        "id": 426366146,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710343564
    },
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8116\">issue #8116</a>:</p>\n<blockquote>\n<p>On the heels of #8112 and #8113, this should succeed but it does not:</p>\n<div class=\"codehilite\" data-code-language=\"wasm\"><pre><span></span><code>(module\n  (memory 1)\n  (func (export \"main\") (param i32 f64 i32) (result f64)\n    local.get 2\n    f64.load\n    f64.ceil\n    return))\n\n(assert_return\n  (invoke \"main\"\n    (i32.const 1)\n    (f64.const 1)\n    (i32.const 0xfff8)\n  )\n  (f64.const 0))\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">wast</span><span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">cranelift</span><span class=\"o\">-</span><span class=\"n\">has</span><span class=\"o\">-</span><span class=\"n\">avx</span><span class=\"o\">=</span><span class=\"kc\">false</span>\n<span class=\"n\">Error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">script</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span><span class=\"o\">'</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">directive</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">wast</span>:<span class=\"mi\">9</span>:<span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n           <span class=\"mi\">0</span>:   <span class=\"mh\">0x2f</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!&lt;</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span>: <span class=\"nc\">memory</span><span class=\"w\"> </span><span class=\"n\">fault</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"w\"> </span><span class=\"mh\">0x10000</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">linear</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"mh\">0x10000</span>\n<span class=\"w\">    </span><span class=\"mi\">3</span>: <span class=\"nc\">wasm</span><span class=\"w\"> </span><span class=\"n\">trap</span>: <span class=\"nc\">out</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">access</span>\n</code></pre></div>\n<p>I discovered this by commenting out <a href=\"https://github.com/bytecodealliance/wasmtime/blob/daa7fdf2cef425f73fcd50f91bad2698d0d1813f/cranelift/codegen/src/isa/x64/inst.isle#L5124-L5125\">these conversions</a> and auditing everything that relied on them. The instructions I found were <code>rounds{s,d}</code> which are related to instructions like <code>f64.ceil</code>. Note that this requires AVX to be disabled (since AVX works on unaligned loads/stores) and additionally requires SSE4.1 (or some sse variant) to be enabled.</p>\n<p>I think that this is the only one relying on non-128-bit size registers, but at the same time I'm not certain.</p>\n</blockquote>",
        "id": 426425909,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710363638
    }
]