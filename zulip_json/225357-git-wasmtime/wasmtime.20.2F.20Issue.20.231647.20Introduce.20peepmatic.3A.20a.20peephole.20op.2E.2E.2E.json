[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622632876\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622632876\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\" title=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 196024558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588380136
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622785581\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622785581\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Cool! By the way does this fix the bug where preopt forgets to sign extend <code>imm</code> when optimizing <code>v1 = iconst.i8 imm; v2 = icmp sgt v0, v1</code> to <code>v2 = icmp_imm sgt v0, imm</code>?</p>\n</blockquote>",
        "id": 196038354,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588404200
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622937235\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622937235\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Can you add the commit messages introducing a new crate to a top level doc comment in the respective crate?</p>\n</blockquote>",
        "id": 196046893,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588418032
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622785581\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622785581\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Cool! By the way does this fix the bug where preopt forgets to sign extend <code>imm</code> when optimizing <code>v1 = iconst.i8 imm; v2 = icmp sgt v0, v1</code> to <code>v2 = icmp_imm sgt v0, imm</code>?</p>\n<p>Edit: It doesn't. Left a comment at the place it should sign extend.</p>\n</blockquote>",
        "id": 196049775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588422937
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622950243\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-622950243\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>This is very well documented and structured code!</p>\n</blockquote>",
        "id": 196050642,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588424482
    },
    {
        "content": "<p>Techcable <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-626111962\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-626111962\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Super cool! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> How does this compare to <a href=\"https://github.com/LuaJIT/LuaJIT/blob/87b111f/src/lj_opt_fold.c\" title=\"https://github.com/LuaJIT/LuaJIT/blob/87b111f/src/lj_opt_fold.c\">LuaJIT's FOLD optimization</a> and their perfect-hash system? I know their trace compiler has a simpler IR than crenelift, but what is the motivation of using a fst over perfect hash map? Does it enable more complex matching?</p>\n</blockquote>",
        "id": 196975633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589003951
    },
    {
        "content": "<p>bnjbvr <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-626541280\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>This is exciting! A few high-level questions that I think would be important to answer before merging:</p>\n<ul>\n<li>does this replace the existing <code>simple_preopt</code>, or is this something that ought to be disabled until it has feature parity with the current <code>simple_preopt</code>? I would advocate not enabling this by default if this isn't at feature parity with the existing system, since the current system was actually useful.</li>\n<li>if this is at feature parity and we plan to enable it by default, can you provide performance data, please? (comparisons of before/after for: wallclocks compile run time + total number of executed instructions through Valgrind/perf) If this is a slowdown considering one of these two measures, I would strongly advocate not enabling it by default and keeping the existing system in the meanwhile.</li>\n<li>(Less important, mostly for my personal curiosity but this doesn't have to block anything) do we have any ideas of what the (Rust) compile time difference would be, with this new system? (Auto-generated code tends to create large functions which are quite slow to compile.)</li>\n</ul>\n</blockquote>",
        "id": 197112386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589184204
    },
    {
        "content": "<p>froydnj <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-626633456\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>* (Less important, mostly for my personal curiosity but this doesn&#39;t have to block anything) do we have any ideas of what the (Rust) compile time difference would be, with this new system? (Auto-generated code tends to create large functions which are quite slow to compile.)\n</code></pre></div>\n\n\n</blockquote>\n<p>Something that would be nice to have sorted (pun intended) prior to merge is whether the auto-generated code is the same over multiple compilations of the crate, so <code>sccache</code> works correctly.</p>\n</blockquote>",
        "id": 197128908,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589194912
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-627017306\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>@Techcable </p>\n<blockquote>\n<p>How does this compare to <a href=\"https://github.com/LuaJIT/LuaJIT/blob/87b111f/src/lj_opt_fold.c\">LuaJIT's FOLD optimization</a> and their perfect-hash system?</p>\n</blockquote>\n<p>I'm not really familiar with LuaJIT's FOLD optimizations, but reading through that comment, it seems a little less general (can only match three operations at most?). The idea of combining three opcode checks into a single check via perfect hashing is something we could investigate and add as a new <code>MatchOp</code>, perhaps.</p>\n<hr>\n<p>@bnjbvr, as you know, we talked a bit about this at the Cranelift meeting today, but for posterity I'll put them in a comment again.</p>\n<blockquote>\n<p>does this replace the existing <code>simple_preopt</code>, or is this something that ought to be disabled until it has feature parity with the current <code>simple_preopt</code>? I would advocate not enabling this by default if this isn't at feature parity with the existing system, since the current system was actually useful.</p>\n</blockquote>\n<p>Yes, this is feature-gated behind the <code>\"enable-peepmatic\"</code> cargo feature right now, and the feature is not enabled by default.</p>\n<blockquote>\n<p>can you provide performance data, please?</p>\n</blockquote>\n<p>Performance doesn't quite match the hand-coded peephole optimizer yet. This is one reason why it makes sense to land this off-by-default. This is unsurprising, since I haven't spent time on perf and optimization yet, other than the big picture design.</p>\n<p>&lt;details&gt;&lt;summary&gt;&lt;b&gt;Graphs of wall time, instructions retired, cache misses, and branch misses&lt;/b&gt;&lt;/summary&gt;</p>\n<p>The following examples are for running <code>wasmtime markdown.wasm '# Hello, World!'</code> where <code>markdown.wasm</code> is internally using <code>pulldown-cmark</code>. This is a 272KiB wasm file.</p>\n<h3>Wall Time</h3>\n<p>![time](<a href=\"https://user-images.githubusercontent.com/74571/81618958-59905080-939d-11ea-921a-9193334a841f.png\">https://user-images.githubusercontent.com/74571/81618958-59905080-939d-11ea-921a-9193334a841f.png</a>)</p>\n<h3>Instructions Retired</h3>\n<p>![instructions](<a href=\"https://user-images.githubusercontent.com/74571/81618946-4f6e5200-939d-11ea-8961-097e7d1a078e.png\">https://user-images.githubusercontent.com/74571/81618946-4f6e5200-939d-11ea-8961-097e7d1a078e.png</a>)</p>\n<h3>Branch Misses</h3>\n<p>![branch-misses](<a href=\"https://user-images.githubusercontent.com/74571/81618997-762c8880-939d-11ea-93de-c93451f84cf2.png\">https://user-images.githubusercontent.com/74571/81618997-762c8880-939d-11ea-93de-c93451f84cf2.png</a>)</p>\n<h3>Cache Misses</h3>\n<p>![cache-misses](<a href=\"https://user-images.githubusercontent.com/74571/81619012-7b89d300-939d-11ea-8fe2-98fb6bc55716.png\">https://user-images.githubusercontent.com/74571/81619012-7b89d300-939d-11ea-8fe2-98fb6bc55716.png</a>)</p>\n<p>&lt;/details&gt;</p>\n<p>I have many ideas for perf improvements, but I'd like to land this PR first, and then start investigating perf in follow ups. Since peepmatic is not enabled by default, this shouldn't be risky.</p>\n<blockquote>\n<p>do we have any ideas of what the (Rust) compile time difference would be, with this new system?</p>\n</blockquote>\n<p>The vast majority of peepmatic code is not necessary to compile unless you're changing the set of peephole optimizations. This is the motivation for the split between the <code>peepmatic</code> crate (the compiler, only run at build time if the <code>\"rebuild-peephole-optimizers\"</code> feature is enabled) and the <code>peepmatic-runtime</code> crate (just the things needed to <em>use</em> a peepmatic-generated peephole optimizer.</p>\n<p>&lt;details&gt;&lt;summary&gt;&lt;b&gt;Timings of Cranelift's compile time&lt;/b&gt;&lt;/summary&gt;</p>\n<h3>Without Peepmatic</h3>\n<div class=\"codehilite\"><pre><span></span><code>fitzgen@erdos :: (master) :: ~/wasmtime/cranelift/codegen\n    $ cargo clean; time cargo build --quiet\n\nreal    0m24.207s\nuser    1m13.714s\nsys     0m4.391s\n\nfitzgen@erdos :: (master) :: ~/wasmtime/cranelift/codegen\n    $ echo &quot;// comment&quot; &gt;&gt; src/lib.rs\n\nfitzgen@erdos :: (master *) :: ~/wasmtime/cranelift/codegen\n    $ time cargo build --quiet\n\nreal    0m2.424s\nuser    0m1.962s\nsys     0m0.559s\n</code></pre></div>\n\n\n<h3>With Peepmatic (Not Rebuilding Peephole Optimizers)</h3>\n<div class=\"codehilite\"><pre><span></span><code>fitzgen@erdos :: (integrate-peepmatic) :: ~/wasmtime/cranelift/codegen\n    $ cargo clean; time cargo build --quiet --features enable-peepmatic\n\nreal    0m31.580s\nuser    1m44.893s\nsys     0m6.192s\n\nfitzgen@erdos :: (integrate-peepmatic) :: ~/wasmtime/cranelift/codegen\n    $ echo &quot;// comment&quot; &gt;&gt; src/lib.rs\n\nfitzgen@erdos :: (integrate-peepmatic *) :: ~/wasmtime/cranelift/codegen\n    $ time cargo build --quiet --features enable-peepmatic\n\nreal    0m2.491s\nuser    0m1.988s\nsys     0m0.604s\n</code></pre></div>\n\n\n<h3>With Peepmatic (With Rebuilding Peephole Optimizers)</h3>\n<div class=\"codehilite\"><pre><span></span><code>fitzgen@erdos :: (integrate-peepmatic) :: ~/wasmtime/cranelift/codegen\n    $ cargo clean; time cargo build --quiet --features &#39;enable-peepmatic rebuild-peephole-optimizers&#39;\n\nreal    3m35.014s\nuser    20m46.827s\nsys     1m40.616s\n\nfitzgen@erdos :: (integrate-peepmatic) :: ~/wasmtime/cranelift/codegen\n    $ echo &quot;// comment&quot; &gt;&gt; src/lib.rs\n\nfitzgen@erdos :: (integrate-peepmatic *) :: ~/wasmtime/cranelift/codegen\n    $ time cargo build --quiet --features &#39;enable-peepmatic rebuild-peephole-optimizers&#39;\n\nreal    0m2.649s\nuser    0m2.187s\nsys     0m0.563s\n</code></pre></div>\n\n\n<p>&lt;/details&gt;</p>\n<p>Incremental builds are unaffected.</p>\n<p>Clean builds without rebuilding the peephole optimizers take a little bit longer (24 -&gt; 31 seconds).</p>\n<p>Clean builds with rebuilding the peephole optimizers take ~3.5 minutes. This is mainly due to building and statically linking Z3. We could also shared link the system Z3 to avoid much of this overhead, but this has other problems, namely old Z3s that are missing some exported symbols (e.g. Ubuntu's packaged Z3).</p>\n<hr>\n<p>@froydnj </p>\n<blockquote>\n<p>whether the auto-generated code is the same over multiple compilations of the crate, so <code>sccache</code> works correctly.</p>\n</blockquote>\n<p>(There is currently no generated Rust code, only a generated automaton that is then interpreted. This may change in the future. Sorry to nitpick.)</p>\n<p>Yes, builds are deterministic, producing the same automaton bit-for-bit given the same DSL input. CI is checking this, and one of the fuzz targets is also checking this.</p>\n</blockquote>",
        "id": 197217876,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589239365
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-627023813\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Oh, also, there was a question at the Cranelift meeting about how many optimizations we can expect to get out of Souper.</p>\n<p>@jubitaneja harvested candidate left-hand sides from <code>rustfmt</code> compiled to Wasm with LLVM optimizations and then ran them through Souper. Souper successfully synthesized 836 optimizations, of which 221 are reducing the whole LHS to a constant.</p>\n<p>I think we can expect to see roughly similar results, with a couple caveats:</p>\n<ul>\n<li>\n<p>First, she was harvesting LHS candidates from the Wasm, not the clif that the Wasm gets translated into. On the one hand, it isn't clear how many of these synthesized optimizations are subsumed by our existing preopt pass. On the other, these candidates are harvested <em>after</em> LLVM optimizations, and I'm pretty sure LLVM's optimizations largely subsume our preopt pass's, so maybe these <em>are</em> new/unique/missing optimizations?</p>\n</li>\n<li>\n<p>Second, choosing a corpus of benchmark Wasms to harvest LHSes from is tricky, but I am pretty sure we will have more than a single file in the corpus from more than just a single toolchain. So I'd suspect that we would synthesize even more optimizations than this.</p>\n</li>\n</ul>\n</blockquote>",
        "id": 197219429,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589240639
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-627233544\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>It would be nice to also harvested candidate left-hand sides from cg_clif generated clif ir. Maybe add a way for a user to provide it's own set of peephole optimizations to Cranelift?</p>\n</blockquote>",
        "id": 197253054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589276748
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-627422337\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<blockquote>\n<p>It would be nice to also harvested candidate left-hand sides from cg_clif generated clif ir. Maybe add a way for a user to provide it's own set of peephole optimizations to Cranelift?</p>\n</blockquote>\n<p>Yep, this is definitely something we could do in the future.</p>\n</blockquote>",
        "id": 197294717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589297815
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647#issuecomment-627575862\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1647\">Issue #1647</a>:</p>\n<blockquote>\n<p>Finally got windows CI green, so now all CI is green!</p>\n</blockquote>",
        "id": 197334317,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589315328
    }
]