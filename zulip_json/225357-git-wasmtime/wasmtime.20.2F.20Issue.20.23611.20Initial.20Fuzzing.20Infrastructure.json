[
    {
        "content": "<p>Hyperion101010 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608982293\" title=\"https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608982293\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611\" title=\"https://github.com/bytecodealliance/wasmtime/issues/611\">Issue #611</a>:</p>\n<blockquote>\n<p>@fitzgen sir this was a gsoc2020 project idea, I worked in the application period and submitted a proposal. Given the time I had at I hand i wasn't able to get complete idea about the different vulnerabilities like ABI abstractions, Heap and Stack safety. I want to voluntarily contribute for the idea, but couldn't do the same before I clear out some doubts. <br>\nI would like to start understanding the fuzzing process more closely and contributing by writing fuzzers perhaps. During the application process I wrote mails for the project details, but I never got any reply which is completely fine given the situation we have now. <br>\nIs there any way we can do a conversation for the doubts I have, I see that there used to be a IRC channel for wasmtime one year ago, but now they migrated to Matrix which unfortunately doesn't has any such channel. If you are available on any channel of Mozilla/(other open source org) please let me know.<br>\nGood day!   </p>\n</blockquote>",
        "id": 192892774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585981263
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608987915\" title=\"https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-608987915\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611\" title=\"https://github.com/bytecodealliance/wasmtime/issues/611\">Issue #611</a>:</p>\n<blockquote>\n<p><a href=\"\" title=\"\">https://bytecodealliance.zulipchat.com/</a> is the primary discussion channel.</p>\n</blockquote>",
        "id": 192894363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1585984456
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611#issuecomment-772810080\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611\">Issue #611</a>:</p>\n<blockquote>\n<p>I think this can be closed.</p>\n</blockquote>",
        "id": 225078462,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612385037
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/611\">Issue #611</a>:</p>\n<blockquote>\n<p>I plan on laying out some foundational fuzzing infrastructure for Wasmtime in the next few weeks. I'd like to use this issue as a kind of meta issue to keep track of this work. I'd also appreciate feedback on the plan from anyone with experience fuzzing or domain knowledge of a particular thing we plan on fuzzing.</p>\n<h2>Goals</h2>\n<ul>\n<li>\n<p><strong>Find bugs!</strong></p>\n<ul>\n<li>Bugs that we wouldn't otherwise find until our users hit them.</li>\n<li>Bugs that are hard to manually write test cases for, or that you wouldn't even think of testing for.</li>\n</ul>\n</li>\n<li>\n<p>Make bugs (fuzzer-found or otherwise) easier to debug via automatic test case reduction.</p>\n</li>\n</ul>\n<h2>Strategy</h2>\n<h3>Breadth not Depth</h3>\n<p>At least initially, let's build out a few different fuzzing approaches enough that they start identifying bugs, but not spend a ton of time building bespoke tools tailored for exactly the problems we have at hand.</p>\n<p>My assumptions are that</p>\n<ol>\n<li>we have low-hanging fruit available, since we haven't done a <em>ton</em> of fuzzing for a bunch of corners yet, and</li>\n<li>different fuzzing approaches tend to uncover different sets of bugs.</li>\n</ol>\n<p>Therefore, by making a bunch of different just-good-enough fuzzers, we will repeatedly discover new, unique low-hanging fruit bugs.</p>\n<p>Additionally, this gives us a nice foundation that we can spring board off of in the future when we decide to go deeper in any particular direction.</p>\n<h3>Decouple Generators and Oracles</h3>\n<p>A <em>generator</em> creates test cases (usually given an RNG or a random byte stream input). An <em>oracle</em> determines if executing a test case uncovered a bug. In general, it is good software engineering to separate concerns, but separating these two parts specifically allows us to:</p>\n<ul>\n<li>reuse oracles during automatic test case reduction (a la <code>creduce</code>), and</li>\n<li>swap out existing, off-the-shelf generators with more intelligent, custom generators the future.</li>\n</ul>\n<h2>Implementation</h2>\n<p>In general, I recommend that we use <code>libFuzzer</code> to drive our fuzzing. It is coverage-guided, which means it can find interesting code paths more quickly than testing purely random inputs will. It also has a nice Rust interface in the form of <a href=\"https://github.com/rust-fuzz/cargo-fuzz\"><code>cargo-fuzz</code></a>.</p>\n<p>Any custom generators we create should <a href=\"https://fitzgeraldnick.com/2019/09/04/combining-coverage-guided-and-generation-based-fuzzing.html\">take <code>libFuzzer</code>-provided input bytes and then re-interpret that as a sequence of random values to drive choices inside the generator</a>. This lets us combine the benefits of smart, structure-aware generators with those of coverage-guided fuzzing. We can implement this by implementing our custom generators in terms of the <code>arbitrary</code> crate's <code>Arbitrary</code> trait.</p>\n<p>As far as test case reduction goes, when a generator is creating Wasm files, it should be relatively easy to use binaryen's <code>wasm-reduce</code> on the Wasm file, or use <code>creduce</code> on the WAT disassembly. We can, however, do some small things to make the process turnkey:</p>\n<ul>\n<li>[ ] Write glue scripts for running <code>wasm-reduce</code> and/or <code>creduce</code> on a Wasm test case with any of our various oracles</li>\n</ul>\n<p>For generators that are creating custom in-memory data structures by implementing the <code>Arbitrary</code> trait, test case reduction requires we implement some custom logic. The <code>Arbitrary</code> trait supports defining a custom <code>shrink</code> method that takes <code>&amp;self</code> and returns an iterator of smaller instances of <code>Self</code>. We can use this to create custom test case reduction for each of our custom test case generators.</p>\n<p>Finally, any custom generator we create (and any generator we wrap that supports turning the generation of individual test case features on/off) should support <a href=\"https://www.cs.utah.edu/~regehr/papers/swarm12.pdf\">swarm testing</a>. Swarm testing is where we randomly turn on/off the generation of various test case features (such as, should a generator create Wasm test cases that use <code>call_indirect</code> or not?) so that we are more likely to generate pathological test cases where bugs are more likely to be found. This is relatively easy implement and should yield</p>\n<h3>Fuzzing Wasmtime's Embedding API</h3>\n<p>This is a case where, unfortunately, we can't really use existing off-the-shelf solutions.</p>\n<h4>Generators</h4>\n<ul>\n<li>[x] Build a custom generator that creates a sequence of API calls. It shouldn't perform the calls, just describe them. This generator should have some smarts about knowing how to generate <em>valid</em> API calls.</li>\n</ul>\n<h4>Oracles</h4>\n<ul>\n<li>[x] Interpret API call descriptions and perform the actual API call. Find unexpected panics, assertion failures, and segfaults.</li>\n</ul>\n<h3>Wasm Execution Fuzzing</h3>\n<p>We should fuzz our execution of Wasm. Yes, Cranelift has some fuzzing in SpiderMonkey, but we should also make sure that all of our Wasmtime-specific JIT'ing machinery is well fuzzed, as well as our WASI implementation and sandboxing.</p>\n<h4>Generators</h4>\n<ul>\n<li>\n<p>[x] Use <code>wasm-opt -ttf</code> to generate random, valid Wasm files.</p>\n</li>\n<li>\n<p>[ ] Write a custom generator that creates Wasm files that make sequences of WASI syscalls.</p>\n</li>\n</ul>\n<h4>Oracles</h4>\n<ul>\n<li>\n<p>[ ] Execute the file and ensure Wasmtime doesn't panic, fail any <code>assert!(..)</code>s, or segfault regardless if executing the Wasm traps.</p>\n</li>\n<li>\n<p>[ ] <code>strace</code> the process or something and ensure it doesn't do any syscalls outside the preopened directory given to the WASI sandbox or something?</p>\n</li>\n<li>\n<p>[x] Differential fuzzing where we compare the observable results of execution between:</p>\n<ul>\n<li>[x] Cranelift without optimizations</li>\n<li>[x] Cranelift with opt=speed</li>\n<li>[x] Cranelift with opt=size</li>\n<li>[x] Cranelift with opt=speed_and_size</li>\n<li>[ ] Cranelift with a warm code cache</li>\n<li>[ ] Cranelift with a cold code cache</li>\n<li>[x] Lightbeam</li>\n</ul>\n</li>\n</ul>\n<h2>More Stuff to Explore in the Future</h2>\n<ul>\n<li>\n<p><a href=\"https://github.com/bytecodealliance/cranelift/issues/1235\">Add support for code-coverage in Cranelift and leverage it to build equivalence-module-inputs testing and coverage-guided fuzzing for Wasmtime</a></p>\n<ul>\n<li>Alternatively, we could MacGyver some custom code coverage scheme via instrumenting Wasm files with Walrus instead of doing this inside Cranelift at the clif level.</li>\n</ul>\n</li>\n<li>\n<p>Create test case generators and oracles for our Wasm interface types support?  What would be involved here is not super clear to me yet.</p>\n</li>\n</ul>\n<h2>Questions</h2>\n<ul>\n<li>\n<p>Should the fuzzing corpus be committed into the git repo? Or perhaps should it be a separate repo that we include as a git submodule?</p>\n</li>\n<li>\n<p>What work here should we prioritize?</p>\n<ul>\n<li>In particular, what variants would be most valuable to compare / most likely to uncover high-priority bugs in differential fuzzing of Wasm execution?</li>\n</ul>\n</li>\n<li>\n<p>Is there anything here you think we should <em>not</em> implement?</p>\n</li>\n<li>\n<p>Are there any other WASI-targeted oracles we can create? The <code>strace</code> idea is pretty half-baked right now. I'd appreciate some more ideas from folks more involved in the WASI side of things than I am...<br>\n</p>\n</li>\n</ul>\n</blockquote>",
        "id": 225079520,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612385498
    }
]