[
    {
        "content": "<p>abrown opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4949\">PR #4949</a> from <code>wasi-parallel-cpu</code> to <code>main</code>:</p>\n<blockquote>\n<p>This change implements [<code>wasi-parallel</code>] in Wasmtime. It addresses only the CPU parallelism (not GPU), since this would introduce additional complexity to an already difficult review (if you're interested about the GPU progress, talk to @egalli). Each commit implements a separate piece to the puzzle. Though most of the changed lines are not the core implementation (see <code>tests</code>, <code>LICENSE</code>, etc.), due to the size of the PR, it may be convenient to look at this commit by commit.</p>\n<p>[<code>wasi-parallel</code>]: <a href=\"https://github.com/WebAssembly/wasi-parallel\">https://github.com/WebAssembly/wasi-parallel</a></p>\n<p>I see several issues highlighted by this change:</p>\n<ul>\n<li>__lacking toolchain support__: in the absence of any other feasible path, the WebAssembly bytes of the kernel code to be executed in parallel are embedded in the host WebAssembly module itself. This is problematic for many reasons, not least of which is the ability for the host WebAssembly module to tamper with the kernel (on the flip side: an intra-module JIT compiler feature!). But that is not the end of it: toolchain support is also lacking simply to produce modules that use atomics and shared memory. For C programs: <a href=\"https://github.com/WebAssembly/wasi-libc/issues/326\">https://github.com/WebAssembly/wasi-libc/issues/326</a>. For Rust programs: <a href=\"https://github.com/rust-lang/rust/issues/102157\">https://github.com/rust-lang/rust/issues/102157</a>. Due to all this, most tests and examples in this crate are meticulously hand-crafted WAT files &mdash; once toolchain support improves these difficult-to-maintain files should be replaced.</li>\n<li>__uncomfortable Wasmtime/Wiggle APIs__: this implementation of <code>wasi-parallel</code> works by creating new instances of the kernel in each thread of a thread pool &mdash; the host module exports a shared memory and the kernel imports it. Getting access to the shared memory from within a <code>wasi-parallel</code> invocation is difficult with Wasmtime/Wiggle: the best way I could think to resolve this is to teach Wiggle to <code>skip</code> a WITX function and then manually implement <code>add_to_linker</code> for that function. This is tedious and error-prone, so I would be excited to discuss better solutions. Note that an almost identical version of this problem will arise when I try to implement [<code>wasi-threads</code>].</li>\n</ul>\n<p>[<code>wasi-threads</code>]: <a href=\"https://github.com/WebAssembly/wasi-threads\">https://github.com/WebAssembly/wasi-threads</a></p>\n<p>Why now? The rationale behind merging this code behind the <code>wasi-parallel</code> feature flag is to enable users to try this out locally and to iterate on this in-tree (e.g., toolchain, GPU parts).<br>\n</p>\n</blockquote>",
        "id": 300417254,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663954393
    }
]