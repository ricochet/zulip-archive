[
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:platform-support label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">Issue #8341</a>.</p>",
        "id": 432785778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712868874
    },
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>In this issue I'd like to propose officially adding support for Rust's <code>#![no_std]</code> mode and crate attribute to the <code>wasmtime</code> crate and runtime. Notably, I'm proposing that we refute <a href=\"https://docs.wasmtime.dev/stability-platform-support.html#what-about-no_std\">current documentation about \"why not <code>no_std</code>\"</a>. This would additionally revert earlier work in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/554\">https://github.com/bytecodealliance/wasmtime/pull/554</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2024\">https://github.com/bytecodealliance/wasmtime/pull/2024</a>.</p>\n<p>Before I go into more depth, this is not a new issue to Wasmtime. This has been discussed in a number of places such as <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">https://github.com/bytecodealliance/wasmtime/issues/1158</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3451\">https://github.com/bytecodealliance/wasmtime/issues/3451</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3495\">https://github.com/bytecodealliance/wasmtime/issues/3495</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6424\">https://github.com/bytecodealliance/wasmtime/issues/6424</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7700\">https://github.com/bytecodealliance/wasmtime/issues/7700</a>, and I'm sure I'm missing others as well. I'll also point out that I was personally one of the ones previously advocating for specifically not supporting <code>no_std</code>, and my opinion has changed in the intervening years.</p>\n<h3>Why support <code>no_std</code>?</h3>\n<p>As far as I know the benefits of <code>no_std</code> haven't really ever been in question. After all, who doesn't want a project to be able to run in as many places as possible? To me I would personally rephrase this question as why to use <code>no_std</code> to support platform as opposed to alternative strategies. I'd answer this with the fact that <code>no_std</code> is the most idiomatic and well-supported solution in the Rust ecosystem. Rust developers in the embedded space are already used to <code>no_std</code> and what it entails. Additionally there are community idioms/expectations around the <code>no_std</code> feature to follow which set precedent.</p>\n<h3>Why now?</h3>\n<p>For a number of years now Wasmtime has had a page in its documentation for \"What about <code>#[no_std]</code>?\", so I think a fair question is why would we revert this and reconsider this previous decision at this point in time. The embedded space has become more interested in WebAssembly over time and there are a fair number of users today. The general feedback is that Wasmtime is not suitable in these environments, and one primary reason is that it's difficult to get Wasmtime working in these environments. Work such as <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7995\">https://github.com/bytecodealliance/wasmtime/pull/7995</a> is to obscure for others to productively use as-is without being able to slot more idiomatically into the <code>no_std</code> ecosystem. More-or-less there's interest to use WebAssembly on platforms Wasmtime cannot easily target, and <code>no_std</code> support is intended to be a step towards making Wasmtime support on these platforms easier. </p>\n<h3>Was the previous rationale wrong?</h3>\n<p>In my opinion, the current documentation Wasmtime has for not supporting <code>no_std</code> is both right and wrong. Supporting <code>no_std</code> is not \"free\", it's something we'll have to maintain over time as a project and explicitly test in CI and consider for all new features. This cost wasn't necessarily justifiable earlier on in Wasmtime's development. Nowadays, though, Wasmtime has many more compile-time features and it's more clear what a <code>no_std</code> build of Wasmtime might look like. Supporting <code>no_std</code> is, however, idiomatic and the best way to support non-standard platforms in Rust. While it's theoretically possible to change how the standard library looks in upstream rust-lang/rust that's basically not happening any time soon.</p>\n<h2>What does <code>no_std</code> for Wasmtime mean?</h2>\n<p>With some of the more rationale-facing questions out of the way, I want to dive into some more details as to what <code>no_std</code> means for Wasmtime. If you read the title of this issue and say \"wow finally it's about time Wasmtime had support\" you're probably not going to be too interested in this section. This section is intended to outline what I learned from my experience of porting Wasmtime to <code>no_std</code>. I have two branches which ports the <code>wasmparser</code> crate to <code>no_std</code> as well as the <code>runtime</code> feature of the <code>wasmtime</code> crate:</p>\n<ul>\n<li><a href=\"https://github.com/alexcrichton/wasm-tools/tree/nostd\">https://github.com/alexcrichton/wasm-tools/tree/nostd</a></li>\n<li><a href=\"https://github.com/alexcrichton/wasmtime/tree/no-std\">https://github.com/alexcrichton/wasmtime/tree/no-std</a></li>\n</ul>\n<h3>Features of Wasmtime and <code>no_std</code></h3>\n<p>Primarily the first part to mention is that I don't think we'll want to support every single feature of Wasmtime in the <code>no_std</code> configuration. Instead we'll want a few features explicitly listed as \"this supports <code>no_std</code>\" but everything else will implicitly enable a dependency on the <code>std</code> feature and the standard library. An example of this is that the <code>runtime</code> feature, the ability to execute WebAssembly modules, won't depend on std but the <code>cache</code> feature, which writes to a filesystem, would depend on the standard library. Notably, for the initial implementation, I'd also expect that <code>cranelift</code> itself would require the standard library. There's no inherent reason to do so, but that's how I wrote things originally.</p>\n<h3>Usage of the <code>alloc</code> crate</h3>\n<p>I also personally think it's worth clarifying that <code>no_std</code> for Wasmtime means <code>core</code> and <code>alloc</code> will be used. Notably this means that Wasmtime will still assume that all allocations succeed at all times and a failing allocation will cause a process abort and/or unrecoverable error. Wasmtime can't really feasibly be ported to an <code>alloc</code>-less build at this time, although if that's of interest to folks then it's something that might be worth investigating later on. I'm not sure how we'd support this in Wasmtime, though, so I'd prefer to defer such a question to a future issue. In the meantime the rest here will assume that <code>no_std</code> means that <code>alloc</code> can be used.</p>\n<h3>Technical details of what support looks like to users</h3>\n<p>To end users and consumers of Wasmtime what I'd propose is that the <code>wasmtime</code> crate will grow <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L203\">a compile-time Cargo feature called <code>std</code></a>. This feature is <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L100\">enabled by default</a> and is additionally enabled by any other feature which depends on standard library support, <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L130\">such as <code>cache</code></a>. If all of Wasmtime's features are disabled, however, then a small set of features, such as <code>runtime</code> and <code>component-model</code>, can be enabled without enabling the <code>std</code> feature of Wasmtime. This will prevent use of the <code>std</code> crate on some platforms.</p>\n<p>The <code>wasmtime-runtime</code> crate will, by default, use the standard library on platforms that are known to have the standard library. For example on Linux the <code>wasmtime-runtime</code> crate <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/runtime/src/lib.rs#L7-L9\">will continue to use <code>std</code> as necessary</a>. If <code>wasmtime-runtime</code> is compiled for an unknown platform, however, then the custom platform support added in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7995\">https://github.com/bytecodealliance/wasmtime/pull/7995</a> will be enabled by default. This means that Wasmtime will not work out-of-the-box since <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/examples/min-platform/embedding/wasmtime-platform.h\">this header file</a> will need to be implemented. This will be mentioned as part of Wasmtime's documentation and will be the escape hatch to enable embedders to implement custom logic to implement Wasmtime's runtime needs.</p>\n<p>Put together, the general workflow for embedders using Wasmtime in <code>no_std</code> mode would look like:</p>\n<ul>\n<li>Usage of <code>wasmtime</code> is audited to confirm that only <code>no_std</code>-compatible features of Wasmtime are used (e.g. not <code>cache</code>)</li>\n<li>Wasmtime is compiled for a custom target that's not Linux, for example. This is then integrated as normal into other build systems as required.</li>\n<li>Platform support for Wasmtime's runtime needs, such as mmap, the Rust <code>GlobalAlloc</code> trait, etc, must be provided by the embedder. For now this'll be a header file for Wasmtime's runtime needs and otherwise it's up to the embedder to fix compile errors about <code>GlobalAlloc</code> for example.</li>\n</ul>\n<p>My intent would be that we'd have at least one or two examples in the repository doing all this, like the current <code>min-platform</code> example.</p>\n<h3>Technical details of what support looks like to Wasmtime developers</h3>\n<p>To those who develop Wasmtime this issue is effectively asking more development cost to be taken on by the project. Despite having community norms and expectations the <code>no_std</code> development mode in Rust is not the standard development mode and may serve as a road bump to contributions and/or developers. Here I'd like to outline the specific issues I've found when porting Wasmtime to <code>no_std</code>:</p>\n<ol>\n<li>Imports <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/runtime/src/lib.rs#L17-L22\">now come from <code>core</code> and <code>alloc</code></a>, not <code>std</code>. This is mostly a muscle memory thing to get over, but it's a downside in that only some parts of the project will do this. For example in <code>wasmtime-cache</code> we'll probably still have <code>use std::mem;</code> whereas in <code>wasmtime-runtime</code> that would be spelled <code>use core::mem;</code>.</li>\n<li>The <a href=\"https://doc.rust-lang.org/stable/std/prelude/index.html\">prelude</a> is different for <code>#![no_std]</code> mode. Notably collections like <code>Vec</code> and <code>String</code> are not present. To work around this <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/environ/src/lib.rs#L15-L30\">I've created a <code>mod prelude { ... }</code> in the <code>wasmtime-environ</code> crate</a> which is reexported at all other crate roots. Most modules in crate then have <code>use crate::prelude::*;</code> instead of individually importing common types like <code>String</code> and <code>Vec</code>.</li>\n<li>Hash maps are different. The Rust standard library does not provide <code>HashMap</code> in the <code>alloc</code><br>\n[message truncated]</li>\n</ol>\n</blockquote>",
        "id": 432785783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712868875
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2050671471\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I support this general direction, although I do have some bikes to shed on a few particular details. I'll leave those nitpicks for a little bit later on in the discussion.</p>\n</blockquote>",
        "id": 432799027,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712875251
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2050704452\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I support this direction as well.</p>\n<p>As the smallest of bikesheds, I'm curious if there's a reason for using</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![no_std]</span>\n<span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"std\"</span><span class=\"cp\">)]</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![cfg_attr(not(feature = </span><span class=\"s\">\"std\"</span><span class=\"cp\">), no_std)]</span>\n</code></pre></div>\n</blockquote>",
        "id": 432802610,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712877526
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2051022548\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>The former consistently imports libcore and uses the libcore prelude, thus reducing the need for <code>#[cfg(feature = \"std\")]</code> elsewhere. Ot also makes rust-analyzer prefer importing from libcore over libstd.</p>\n</blockquote>",
        "id": 432833559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712900778
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2052240265\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>Carring over some thoughts from <a href=\"https://github.com/bytecodealliance/wasm-tools/pull/1493#issuecomment-2051665206\">this comment</a> I've looked more closely now at the hash map and seeding situation. As background the Rust standard library uses a DoS-resistant hashing algorithm which randomizes the seed for hashes for each thread. GIven <code>wasmparser</code>'s ubiquitous use of hash maps with user-supplied inputs (wasms) it seems prudent to retain this protection where possible.</p>\n<p>What I would propose as a solution for now is:</p>\n<ul>\n<li>Add a <code>RandomState</code> structure to <code>wasmparser</code> which is used as the hasher for <code>IndexMap</code> and <code>hashbrown::HashMap</code>. This is an opaque structure and is used regardless of whether <code>feature = \"std\"</code> is enabled or not.</li>\n<li>With <code>feature = \"std\"</code>, use <code>std::hash::RandomState</code> to implement <code>wasmparser::RandomState</code></li>\n<li>Without <code>feature = \"std\"</code>, use <code>ahash::RandomState</code> to implement <code>wasmparser::RandomState</code>.</li>\n</ul>\n<p>The consequence of this is that when <code>std</code> is enabled we should have the exact same implementation/guarantees as today. This should cover \"big\" use cases such as FaaS which take lots of wasms. Without <code>std</code> the <code>ahash::RandomState</code> type uses the address of a constant as a seed input as well as a stack-based address. This relies on ASLR for security and isn't as strong as libstd's seeding. That being said there is <a href=\"https://docs.rs/ahash/latest/ahash/random_state/fn.set_random_source.html\"><code>set_random_state</code></a> which can be used to provide a higher quality seed. I think this is probably less efficient than the creation of hash maps in the standard library but that shouldn't affect Wasmtime too much.</p>\n<p>There's two drawbacks to this. First is that the <code>HashMap</code> types in the public API of <code>wasmtime</code> and <code>wasmparser</code> will not be the same as <code>hashbrown::HashMap</code> (or <code>IndexMap</code>) because of the use of a custom hasher. That's more common for <code>wasmparser</code> than <code>wasmtime</code> but it's hopefully not too onerous (type aliases will be provided in <code>wasmparser</code>). Second is that in no-std mode the hashing DoS guarantees will not be as strong and the performance of creating hash maps will not get as much scrutiny. With <code>ahash</code>-based seeding though that should help improve the DoS posture if necessary and performance can always be improved over time as necessary too.</p>\n</blockquote>",
        "id": 432957200,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712945548
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good (*) and fast without all this hassle?<br>\nI can say with confidence that for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no way to make use of <code>set_random_state</code>.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433028808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998066
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good and fast (*) without all this hassle?<br>\nI can say with confidence that for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no way to make use of <code>set_random_state</code>.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433028862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998091
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good and fast (*) without all this hassle - at least where easily possible.<br>\nI can say with confidence that for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no way to make use of <code>set_random_state</code>.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433028869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998110
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good and fast (*) without all this hassle - at least where easily possible.<br>\nUnfortunately for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no way to make use of <code>set_random_state</code>.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433028878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998134
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good and fast (*) without all this hassle - at least where easily possible.<br>\nUnfortunately for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no reliable way to make use of <code>set_random_state</code>.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433028894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998161
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053578495\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I appreciate the overall direction.</p>\n<p>I am the maintainer of the Wasmi crate and am using <code>BTreeMap</code> instead of <code>HashMap</code> pervasively there. This is also true for its dependencies such as <code>wasmparser-nostd</code> as well as <code>indexmap-nostd</code>. So far I have seen no significant impacts on performance.<br>\nTherefore I wonder, why bother with all this initialization proceudure for <code>HashMap</code> in Wasmtime and its dependencies if there is another data structure just as good and fast (*) without all this hassle - at least where easily possible.<br>\nUnfortunately for some Wasmi users using <code>HashMap</code> is simply not a possibility even with the <code>ahash</code> solution due to deterministic builds, no ASLR and no reliable way to make use of <code>set_random_state</code> and the criticality of being resilient to malicious actors.</p>\n<p>(*) I am aware that generally a well-tuned <code>HashMap</code> might outperform <code>BTreeMap</code> but this heavily depends on the usage.</p>\n</blockquote>",
        "id": 433029059,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712998341
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053644350\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>",
        "id": 433046386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713014271
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053657261\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>Unfortunately for some Wasmi users using HashMap is simply not a possibility even with the ahash solution due to deterministic builds</p>\n</blockquote>\n<p>Do you mean that the output of compilation and the execution of the resulting compiled wasm module needs to be deterministic? That should already be the case even with our current HashMap usage. Or do you mean that the execution environment in which wasmtime would run must be deterministic itself too?</p>\n</blockquote>",
        "id": 433050227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713017406
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053668965\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>\n<p>Are you referring to this forum post from 2 days ago?<br>\n<a href=\"https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4\">https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4</a><br>\nI'd hope that the <code>BTreeMap</code> insertions still reside in <code>O(log(n))</code> complexity even in the worst-case where it is significantly slower whereas <code>HashMap</code> could be exploited to have <code>O(n)</code> instead of <code>O(1)</code> insertion complexity. But maybe I am underinformed about <code>BTreeMap</code> implementations.</p>\n</blockquote>",
        "id": 433053310,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713020048
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053668965\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>\n<p>Are you referring to this forum post from 2 days ago?<br>\n<a href=\"https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4\">https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4</a><br>\nI'd hope that the <code>BTreeMap</code> insertions still reside in <code>O(log(n))</code> complexity even in the worst-case where it is significantly slower whereas <code>HashMap</code> could be exploited to have <code>O(n)</code> instead of <code>O(1)</code> insertion complexity. But maybe I am underinformed about <code>BTreeMap</code> implementations.</p>\n<blockquote>\n<p>Or do you mean that the execution environment in which wasmtime would run must be deterministic itself too?</p>\n</blockquote>\n<p>That's what I meant but just for Wasmi and not Wasmtime. Wasmi is a <code>wasmparser</code> (fork) user. Some users run Wasmi within Wasm (<code>wasm32-unknown-unknown</code>) executed via Wasmtime.</p>\n</blockquote>",
        "id": 433053466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713020161
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053668965\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>\n<p>Are you referring to this forum post from 2 days ago?<br>\n<a href=\"https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4\">https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4</a><br>\nI'd hope that the <code>BTreeMap</code> insertions still reside in <code>O(log(n))</code> complexity even in the worst-case where it is significantly slower whereas <code>HashMap</code> could be exploited to have <code>O(n)</code> instead of <code>O(1)</code> insertion complexity. But maybe I am underinformed about <code>BTreeMap</code> implementations.</p>\n<blockquote>\n<p>Or do you mean that the execution environment in which wasmtime would run must be deterministic itself too?</p>\n</blockquote>\n<p>That's what I meant but just for Wasmi and not Wasmtime. Wasmi is a <code>wasmparser</code> (fork) user. Some users run Wasmi within Wasm (<code>wasm32-unknown-unknown</code>) executed via Wasmtime. There is no random source for <code>set_random_state</code> and I am not aware of any way to get the address of a global/constant in Wasm, too. Maybe via shadow stack global it is possible to get the address of an item on the stack? But it doesn't sound very solid to me.</p>\n</blockquote>",
        "id": 433053747,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713020401
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053668965\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>\n<p>Are you referring to this forum post from 2 days ago?<br>\n<a href=\"https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4\">https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4</a><br>\nI'd hope that the <code>BTreeMap</code> insertions still reside in <code>O(log(n))</code> complexity even in the worst-case where it is significantly slower whereas <code>HashMap</code> could be exploited to have <code>O(n)</code> instead of <code>O(1)</code> insertion complexity. But maybe I am underinformed about <code>BTreeMap</code> implementations.</p>\n<blockquote>\n<p>Or do you mean that the execution environment in which wasmtime would run must be deterministic itself too?</p>\n</blockquote>\n<p>That's what I meant but just for Wasmi and not Wasmtime. Wasmi is a <code>wasmparser</code> (fork) user. Some users run Wasmi within Wasm (<code>wasm32-unknown-unknown</code>) executed via Wasmtime. There is no random source for <code>set_random_state</code> and I am not aware of any way to get the address of a global/constant in Wasm, too. Maybe via shadow stack global it is possible to get the address of an item on the stack? But it doesn't sound very solid to me.</p>\n<p>To clarify: my remakrs are mostly about the <code>wasmparser</code> crate.</p>\n</blockquote>",
        "id": 433053850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713020459
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053668965\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>BTreeMap has a non-trivial impact on compile time performance and it too can have worse than average performance under adversarial circumstances (inssrting elements in ascending order is supposedly slower than inserting in descending order according to a recent topic on <a href=\"http://users.rust-lang.org\">users.rust-lang.org</a>.)</p>\n</blockquote>\n<p>Are you referring to this forum post from 2 days ago?<br>\n<a href=\"https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4\">https://users.rust-lang.org/t/mystery-why-would-std-btreemap-be-slower-inserting-in-ascending-order-than-reverse/109720/4</a><br>\nI'd hope that the <code>BTreeMap</code> insertions still reside in <code>O(log(n))</code> complexity even in the worst-case where it is significantly slower whereas <code>HashMap</code> could be exploited to have <code>O(n)</code> instead of <code>O(1)</code> insertion complexity. But maybe I am underinformed about <code>BTreeMap</code> implementations.</p>\n<blockquote>\n<p>Or do you mean that the execution environment in which wasmtime would run must be deterministic itself too?</p>\n</blockquote>\n<p>That's what I meant but just for Wasmi and not Wasmtime. Wasmi is a <code>wasmparser</code> (fork) user. Some users run Wasmi within Wasm (<code>wasm32-unknown-unknown</code>) executed via Wasmtime. There is no random source for <code>set_random_state</code> and I am not aware of any way to get the address of a global/constant in Wasm, too. Maybe via shadow stack global it is possible to get the address of an item on the stack? But it doesn't sound very solid to me.</p>\n</blockquote>",
        "id": 433053887,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713020492
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053697067\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>Are you referring to this forum post from 2 days ago?</p>\n</blockquote>\n<p>Yes</p>\n<blockquote>\n<p>Some users run Wasmi within Wasm (wasm32-unknown-unknown) executed via Wasmtime.</p>\n</blockquote>\n<p>I see. That only seems to be relevant to the wasmparser changes, and not the wasmtime changes as Wasmtime can't run in wasm anyway. It can compile wasm modules to machine code (<code>wasmtime compile</code>), but not run the resulting code.</p>\n</blockquote>",
        "id": 433060516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713026402
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2053706106\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Are you referring to this forum post from 2 days ago?</p>\n</blockquote>\n<p>Yes</p>\n<blockquote>\n<p>Some users run Wasmi within Wasm (wasm32-unknown-unknown) executed via Wasmtime.</p>\n</blockquote>\n<p>I see. That only seems to be relevant to the wasmparser changes, and not the wasmtime changes as Wasmtime can't run in wasm anyway. It can compile wasm modules to machine code (<code>wasmtime compile</code>), but not run the resulting code.</p>\n</blockquote>\n<p>Yes that is correct. I should have said that.</p>\n</blockquote>",
        "id": 433062567,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713028548
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2057137935\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I don't really have benchmarks one way or another, but at the same time I would be hesitant to replace all usage of all hash maps in Wasmtime with BTree maps because randomness/seeding may be hard to come by in some niche situations. Hash maps feel tailor made for most of what Wasmtime needs in various purposes, so if they're problematic I would imagine that a refactoring to remove the need for a map completely would be necessary. In that sense I would prefer to not use no_std support as a reason to change how data structures are done in Wasmtime, but instead consider it as motivation to refactor and rewrite preexisting algorithms to avoid types that are less suitable in a no_std context.</p>\n</blockquote>",
        "id": 433321621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713194935
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061519772\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I was talking with @tschneidereit yesterday about this issue and one point he brought up is that it would be reasonable to have a compile-time Cargo feature on the <code>wasmparser</code> crate for whether to use b-tree maps or hash maps for your use case @Robbepop perhaps. That would probably be off-by-default but opting-in to it I think would be reasonable to do. Doing so would mostly look like \"enhance the wrapper map types to be their own structure to abstract internally on hash-map-or-not\" which seems reasonable to maintain in wasmparser.</p>\n</blockquote>",
        "id": 433809783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713367025
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061575136\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>I was talking with @tschneidereit yesterday about this issue and one point he brought up is that it would be reasonable to have a compile-time Cargo feature on the <code>wasmparser</code> crate for whether to use b-tree maps or hash maps for your use case @Robbepop perhaps. That would probably be off-by-default but opting-in to it I think would be reasonable to do. Doing so would mostly look like \"enhance the wrapper map types to be their own structure to abstract internally on hash-map-or-not\" which seems reasonable to maintain in wasmparser.</p>\n</blockquote>\n<p>That would be amazing for me! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> </p>\n</blockquote>",
        "id": 433818279,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713368094
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061575136\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>I was talking with @tschneidereit yesterday about this issue and one point he brought up is that it would be reasonable to have a compile-time Cargo feature on the <code>wasmparser</code> crate for whether to use b-tree maps or hash maps for your use case @Robbepop perhaps. That would probably be off-by-default but opting-in to it I think would be reasonable to do. Doing so would mostly look like \"enhance the wrapper map types to be their own structure to abstract internally on hash-map-or-not\" which seems reasonable to maintain in wasmparser.</p>\n</blockquote>\n<p>That would be amazing for me! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> <br>\nThough what is the intended solution for <code>indexmap</code> which uses hashmaps internally? So far I have used my own <code>no_std</code> reimplementation of it: <a href=\"https://crates.io/crates/indexmap-nostd\">https://crates.io/crates/indexmap-nostd</a></p>\n</blockquote>",
        "id": 433818547,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713368168
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061575136\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>I was talking with @tschneidereit yesterday about this issue and one point he brought up is that it would be reasonable to have a compile-time Cargo feature on the <code>wasmparser</code> crate for whether to use b-tree maps or hash maps for your use case @Robbepop perhaps. That would probably be off-by-default but opting-in to it I think would be reasonable to do. Doing so would mostly look like \"enhance the wrapper map types to be their own structure to abstract internally on hash-map-or-not\" which seems reasonable to maintain in wasmparser.</p>\n</blockquote>\n<p>That would be amazing for me! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> <br>\nThough what is the intended solution for <code>indexmap</code> which uses hashmaps internally? So far I have used my own <code>no_std</code> reimplementation of it in my <code>wasmparser-nostd</code> fork: <a href=\"https://crates.io/crates/indexmap-nostd\">https://crates.io/crates/indexmap-nostd</a></p>\n</blockquote>",
        "id": 433818588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713368185
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061575136\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>I was talking with @tschneidereit yesterday about this issue and one point he brought up is that it would be reasonable to have a compile-time Cargo feature on the <code>wasmparser</code> crate for whether to use b-tree maps or hash maps for your use case @Robbepop perhaps. That would probably be off-by-default but opting-in to it I think would be reasonable to do. Doing so would mostly look like \"enhance the wrapper map types to be their own structure to abstract internally on hash-map-or-not\" which seems reasonable to maintain in wasmparser.</p>\n</blockquote>\n<p>That would be amazing for me! <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> </p>\n<p>Though what is the intended solution for <code>indexmap</code> which uses hashmaps internally? So far I have used my own <code>no_std</code> reimplementation of it in my <code>wasmparser-nostd</code> fork: <a href=\"https://crates.io/crates/indexmap-nostd\">https://crates.io/crates/indexmap-nostd</a></p>\n<p>If we plan to actually use this <code>indexmap-nostd</code> fork then we'd have to give it a proper cleanup first.</p>\n</blockquote>",
        "id": 433818775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713368240
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061975331\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>My thinking was that the type aliases in wasmparser would become type definitions which internally #[cfg] for hash maps or tree-based maps. For the tree-based-indexmap-version I was thinking we'd implement it directly in the wasmparser crate itself as opposed to using a fork of indexmap.</p>\n</blockquote>",
        "id": 433851906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713379309
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2061975331\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>My thinking was that the type aliases in wasmparser would become type definitions which internally #[cfg] for hash maps or tree-based maps. For the tree-based-indexmap-version I was thinking we'd implement it directly in the wasmparser crate itself as opposed to using a fork of indexmap (under the assumption it's not too too big)</p>\n</blockquote>",
        "id": 433851947,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713379320
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2062085226\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>My thinking was that the type aliases in wasmparser would become type definitions which internally #[cfg] for hash maps or tree-based maps. For the tree-based-indexmap-version I was thinking we'd implement it directly in the wasmparser crate itself as opposed to using a fork of indexmap (under the assumption it's not too too big)</p>\n</blockquote>\n<p>Okay that could work. We could use the <code>indexmap-nostd</code> implementation as basis. Its implementation focuses on simplicity and from my own experiences with Wasmi I never saw perf problems because of it.</p>\n</blockquote>",
        "id": 433862104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713382839
    },
    {
        "content": "<p>JonasKruckenberg <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2063091645\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>As someone who has maintained their own <code>no_std</code> fork of <code>cranelift</code> for a number of months now I'm overjoyed to see you considering the usecase! <br>\nI have a couple features related to riscv on my fork that Id love to contribute back upstream</p>\n<blockquote>\n<p>I'd also expect that cranelift itself would require the standard library. There's no inherent reason to do so, but that's how I wrote things originally.</p>\n</blockquote>\n<p>If I can help out with this in any way I would love to do so. I see <code>no_std</code> cranelift as being more useful in embedded/low-level anyway </p>\n</blockquote>",
        "id": 433947249,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713421572
    },
    {
        "content": "<p>JonasKruckenberg edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2063091645\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>As someone who has maintained their own <code>no_std</code> fork of <code>cranelift</code> for a number of months now I'm overjoyed to see you considering the usecase! <br>\nI have a couple features related to riscv on my fork that Id love to contribute back upstream</p>\n<blockquote>\n<p>I'd also expect that cranelift itself would require the standard library. There's no inherent reason to do so, but that's how I wrote things originally.</p>\n</blockquote>\n<p>If I can help out with this in any way I would love to do so. I see <code>no_std</code> cranelift as being more useful in embedded/low-level as in those environments one needs greater control over execution &amp; memory (I do anyways)</p>\n</blockquote>",
        "id": 433947787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713421622
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2064023624\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>@Robbepop sounds good! And also to make sure I clarify I don't plan on personally pursuing the BTreeMap approach of wasmparser, but I wanted to outline how I think it'd be reasonable to add so if you're up for making a PR once the no_std work starts landing I'd be happy to review.</p>\n<p>@JonasKruckenberg oh nice! I think that PRs to add no_std to Cranelift after this work starts landing would indeed be welcome. I asked some folks at the Cranelift meeting yesterday and there were no objections and I suspect most won't object to this. One point brought up was that if Wasmtime is \"doing the no_std thing\" then it's pretty easy for Cranelift to do it as well as it'll just be an extension of what Wasmtime is already doing.</p>\n<hr>\n<p>Also, to clarify, I'm not sure precisely how best to have a \"go no go\" decision on this issue. My rough plan is to bring it up at the next Wasmtime meeting (a week from today) and assuming there are no objections start landing work at that point. My plan in landing the work is to do it piecemeal crate-by-crate so reviewers have an easier time seeing the impact as things progress.</p>\n</blockquote>",
        "id": 434061850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713450811
    },
    {
        "content": "<p>Robbepop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2064378429\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>@Robbepop sounds good! And also to make sure I clarify I don't plan on personally pursuing the BTreeMap approach of wasmparser, but I wanted to outline how I think it'd be reasonable to add so if you're up for making a PR once the no_std work starts landing I'd be happy to review.</p>\n</blockquote>\n<p>@alexcrichton Yes, I'd be willing to file that PR once <code>no_std</code> support landed in the <code>wasmparser</code> crate. :)</p>\n</blockquote>",
        "id": 434159333,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713456388
    },
    {
        "content": "<p>Robbepop edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2064378429\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>@Robbepop sounds good! And also to make sure I clarify I don't plan on personally pursuing the BTreeMap approach of wasmparser, but I wanted to outline how I think it'd be reasonable to add so if you're up for making a PR once the no_std work starts landing I'd be happy to review.</p>\n</blockquote>\n<p>@alexcrichton Yes, I'd be willing to file that PR once <code>no_std</code> support landed in the <code>wasmparser</code> crate. :)</p>\n<p>I am already looking forward to the day I can finally put the <code>wasmparser-nostd</code> fork to rest.</p>\n</blockquote>",
        "id": 434161336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1713456476
    },
    {
        "content": "<p>JonasKruckenberg <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2078913468\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>For reference I pulled my <code>no_std</code> changes out of vendored folders and into a proper fork here: <a href=\"https://github.com/JonasKruckenberg/wasmtime/tree/no_std\">https://github.com/JonasKruckenberg/wasmtime/tree/no_std</a>.<br>\nI've changed <code>thiserror</code> to <code>onlyerror</code> (which implements <code>core::error::Error</code>) which in turn requires <code>error_in_core</code> for <code>no_std</code> builds. I'm personally fine with that (most <code>no_std</code> applications probably use nightly anyway) but I can also see the opposite and would be open to just disable the error implementation on <code>no_std</code> platforms like I've done across <code>cranelift-codegen</code> already</p>\n</blockquote>",
        "id": 435541590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714120670
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2078945086\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>I'm a bit worried about the use of <code>spin::Once</code>. Spinlocks are terrible for throughput in case of contention as the spinning task/thread/... will starve the task/thread/... which would unlock the spinlock until the next preemption, which in case of a real time OS may never come if the thread waiting for the lock has a higher priority than the thread which locked it. I believe the critical-section crate is frequently used for locks in a way that allows the user to specify how locks should actually be implemented internally. Looks like it doesn't have a ready made <code>Once</code> implementation though. How hard would it be to make it possible to create the MachineEnv's in a const fn such that no runtime initialization is needed?</p>\n</blockquote>",
        "id": 435544379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714121768
    },
    {
        "content": "<p>JonasKruckenberg <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2078995183\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>Agreed, the addition of <code>spin</code> for such a small use feels pretty suboptimal. I'm not sure if contention is a concern here though (from my understanding of the code this is essentially homegrown <code>lazy_static</code> to cache the created <code>MachineEnv</code>) so you'd need multiple threads to hit the same \"once state is uninitialised\" codepath (which may happen a lot in typical cranelift operation idk)</p>\n<p>If we come up with a better solution I'd be more than happy ripping out <code>spin</code> (on a dependency minimalist basis alone)</p>\n<p>maybe on <code>no_std</code> targets we just don't cache the MachineEnv? <br>\nor change <code>Callee::machine_env</code> to take <code>&amp;mut self</code> and cache the created <code>MachineEnv</code> not in s static but in its own state?</p>\n<p>from looking at the regalloc2 docs it seems <code>MachineEnv</code> has a field that is <code>Vec&lt;[PReg]&gt;</code> so a <code>const fn</code> is out of the question I think :/<br>\n</p>\n</blockquote>",
        "id": 435548991,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714123510
    },
    {
        "content": "<p>JonasKruckenberg edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2078995183\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>Agreed, the addition of <code>spin</code> for such a small use feels pretty suboptimal. I'm not sure if contention is a concern here though (from my understanding of the code this is essentially homegrown <code>lazy_static</code> to cache the created <code>MachineEnv</code>) so you'd need multiple threads to hit the same \"once state is uninitialised\" codepath (which may happen a lot in typical cranelift operation idk)<br>\nbut on a dependency minimalist basis alone I'd be more than happy ripping out <code>spin</code> if we come up with a better solution</p>\n<p>maybe on <code>no_std</code> targets we just don't cache the MachineEnv? <br>\nor change <code>Callee::machine_env</code> to take <code>&amp;mut self</code> and cache the created <code>MachineEnv</code> not in s static but in its own state?</p>\n<p>from looking at the regalloc2 docs it seems <code>MachineEnv</code> has a field that is <code>Vec&lt;[PReg]&gt;</code> so a <code>const fn</code> is out of the question I think :/<br>\n</p>\n</blockquote>",
        "id": 435549160,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714123567
    },
    {
        "content": "<p>JonasKruckenberg edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2078995183\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>Agreed, the addition of <code>spin</code> for such a small use feels pretty suboptimal. I'm not sure if contention is a concern here though (from my understanding of the code this is essentially homegrown <code>lazy_static</code> to cache the created <code>MachineEnv</code>) so you'd need multiple threads to hit the same \"once state is uninitialised\" codepath (which may happen a lot in typical cranelift operation idk)<br>\nbut on a dependency minimalist basis alone I'd be more than happy ripping out <code>spin</code> if we come up with a better solution</p>\n<p>maybe on <code>no_std</code> targets we just don't cache the MachineEnv? <br>\nor change <code>Callee::machine_env</code> to take <code>&amp;mut self</code> and cache the created <code>MachineEnv</code> not in a static but in its own state?</p>\n<p>from looking at the regalloc2 docs it seems <code>MachineEnv</code> has a field that is <code>Vec&lt;[PReg]&gt;</code> so a <code>const fn</code> is out of the question I think :/<br>\n</p>\n</blockquote>",
        "id": 435549218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714123596
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2079014173\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>from looking at the regalloc2 docs it seems MachineEnv has a field that is Vec&lt;[PReg]&gt; so a const fn is out of the question I think :/</p>\n</blockquote>\n<p>That could theoretically be replaced by a <code>Cow&lt;'static, [PReg]&gt;</code> or even <code>&amp;'static [PReg]</code> I think, which would allow const initialization by providing a const <code>&amp;'static [PReg]</code> as value.</p>\n</blockquote>",
        "id": 435551005,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714124223
    },
    {
        "content": "<p>JonasKruckenberg <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2079055802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<blockquote>\n<p>That could theoretically be replaced by a Cow&lt;'static, [PReg]&gt; or even &amp;'static [PReg] I think, which would allow const initialization by providing a const &amp;'static [PReg] as value.</p>\n</blockquote>\n<p>Ah yeah, that might be worthwhile on its own actually. In the meantime I updated my branch with this <a href=\"https://github.com/JonasKruckenberg/wasmtime/commit/eab337c71a3955339105dc9c01aeae9b118c516f\">https://github.com/JonasKruckenberg/wasmtime/commit/eab337c71a3955339105dc9c01aeae9b118c516f</a>  (and cherry picked into it's PR #8489)</p>\n</blockquote>",
        "id": 435555128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1714125790
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>In this issue I'd like to propose officially adding support for Rust's <code>#![no_std]</code> mode and crate attribute to the <code>wasmtime</code> crate and runtime. Notably, I'm proposing that we refute <a href=\"https://docs.wasmtime.dev/stability-platform-support.html#what-about-no_std\">current documentation about \"why not <code>no_std</code>\"</a>. This would additionally revert earlier work in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/554\">https://github.com/bytecodealliance/wasmtime/pull/554</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2024\">https://github.com/bytecodealliance/wasmtime/pull/2024</a>.</p>\n<p>Before I go into more depth, this is not a new issue to Wasmtime. This has been discussed in a number of places such as <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1158\">https://github.com/bytecodealliance/wasmtime/issues/1158</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3451\">https://github.com/bytecodealliance/wasmtime/issues/3451</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3495\">https://github.com/bytecodealliance/wasmtime/issues/3495</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/6424\">https://github.com/bytecodealliance/wasmtime/issues/6424</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7700\">https://github.com/bytecodealliance/wasmtime/issues/7700</a>, and I'm sure I'm missing others as well. I'll also point out that I was personally one of the ones previously advocating for specifically not supporting <code>no_std</code>, and my opinion has changed in the intervening years.</p>\n<h3>Why support <code>no_std</code>?</h3>\n<p>As far as I know the benefits of <code>no_std</code> haven't really ever been in question. After all, who doesn't want a project to be able to run in as many places as possible? To me I would personally rephrase this question as why to use <code>no_std</code> to support platform as opposed to alternative strategies. I'd answer this with the fact that <code>no_std</code> is the most idiomatic and well-supported solution in the Rust ecosystem. Rust developers in the embedded space are already used to <code>no_std</code> and what it entails. Additionally there are community idioms/expectations around the <code>no_std</code> feature to follow which set precedent.</p>\n<h3>Why now?</h3>\n<p>For a number of years now Wasmtime has had a page in its documentation for \"What about <code>#[no_std]</code>?\", so I think a fair question is why would we revert this and reconsider this previous decision at this point in time. The embedded space has become more interested in WebAssembly over time and there are a fair number of users today. The general feedback is that Wasmtime is not suitable in these environments, and one primary reason is that it's difficult to get Wasmtime working in these environments. Work such as <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7995\">https://github.com/bytecodealliance/wasmtime/pull/7995</a> is to obscure for others to productively use as-is without being able to slot more idiomatically into the <code>no_std</code> ecosystem. More-or-less there's interest to use WebAssembly on platforms Wasmtime cannot easily target, and <code>no_std</code> support is intended to be a step towards making Wasmtime support on these platforms easier. </p>\n<h3>Was the previous rationale wrong?</h3>\n<p>In my opinion, the current documentation Wasmtime has for not supporting <code>no_std</code> is both right and wrong. Supporting <code>no_std</code> is not \"free\", it's something we'll have to maintain over time as a project and explicitly test in CI and consider for all new features. This cost wasn't necessarily justifiable earlier on in Wasmtime's development. Nowadays, though, Wasmtime has many more compile-time features and it's more clear what a <code>no_std</code> build of Wasmtime might look like. Supporting <code>no_std</code> is, however, idiomatic and the best way to support non-standard platforms in Rust. While it's theoretically possible to change how the standard library looks in upstream rust-lang/rust that's basically not happening any time soon.</p>\n<h2>What does <code>no_std</code> for Wasmtime mean?</h2>\n<p>With some of the more rationale-facing questions out of the way, I want to dive into some more details as to what <code>no_std</code> means for Wasmtime. If you read the title of this issue and say \"wow finally it's about time Wasmtime had support\" you're probably not going to be too interested in this section. This section is intended to outline what I learned from my experience of porting Wasmtime to <code>no_std</code>. I have two branches which ports the <code>wasmparser</code> crate to <code>no_std</code> as well as the <code>runtime</code> feature of the <code>wasmtime</code> crate:</p>\n<ul>\n<li><a href=\"https://github.com/alexcrichton/wasm-tools/tree/nostd\">https://github.com/alexcrichton/wasm-tools/tree/nostd</a></li>\n<li><a href=\"https://github.com/alexcrichton/wasmtime/tree/no-std\">https://github.com/alexcrichton/wasmtime/tree/no-std</a></li>\n</ul>\n<h3>Features of Wasmtime and <code>no_std</code></h3>\n<p>Primarily the first part to mention is that I don't think we'll want to support every single feature of Wasmtime in the <code>no_std</code> configuration. Instead we'll want a few features explicitly listed as \"this supports <code>no_std</code>\" but everything else will implicitly enable a dependency on the <code>std</code> feature and the standard library. An example of this is that the <code>runtime</code> feature, the ability to execute WebAssembly modules, won't depend on std but the <code>cache</code> feature, which writes to a filesystem, would depend on the standard library. Notably, for the initial implementation, I'd also expect that <code>cranelift</code> itself would require the standard library. There's no inherent reason to do so, but that's how I wrote things originally.</p>\n<h3>Usage of the <code>alloc</code> crate</h3>\n<p>I also personally think it's worth clarifying that <code>no_std</code> for Wasmtime means <code>core</code> and <code>alloc</code> will be used. Notably this means that Wasmtime will still assume that all allocations succeed at all times and a failing allocation will cause a process abort and/or unrecoverable error. Wasmtime can't really feasibly be ported to an <code>alloc</code>-less build at this time, although if that's of interest to folks then it's something that might be worth investigating later on. I'm not sure how we'd support this in Wasmtime, though, so I'd prefer to defer such a question to a future issue. In the meantime the rest here will assume that <code>no_std</code> means that <code>alloc</code> can be used.</p>\n<h3>Technical details of what support looks like to users</h3>\n<p>To end users and consumers of Wasmtime what I'd propose is that the <code>wasmtime</code> crate will grow <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L203\">a compile-time Cargo feature called <code>std</code></a>. This feature is <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L100\">enabled by default</a> and is additionally enabled by any other feature which depends on standard library support, <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/wasmtime/Cargo.toml#L130\">such as <code>cache</code></a>. If all of Wasmtime's features are disabled, however, then a small set of features, such as <code>runtime</code> and <code>component-model</code>, can be enabled without enabling the <code>std</code> feature of Wasmtime. This will prevent use of the <code>std</code> crate on some platforms.</p>\n<p>The <code>wasmtime-runtime</code> crate will, by default, use the standard library on platforms that are known to have the standard library. For example on Linux the <code>wasmtime-runtime</code> crate <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/runtime/src/lib.rs#L7-L9\">will continue to use <code>std</code> as necessary</a>. If <code>wasmtime-runtime</code> is compiled for an unknown platform, however, then the custom platform support added in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7995\">https://github.com/bytecodealliance/wasmtime/pull/7995</a> will be enabled by default. This means that Wasmtime will not work out-of-the-box since <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/examples/min-platform/embedding/wasmtime-platform.h\">this header file</a> will need to be implemented. This will be mentioned as part of Wasmtime's documentation and will be the escape hatch to enable embedders to implement custom logic to implement Wasmtime's runtime needs.</p>\n<p>Put together, the general workflow for embedders using Wasmtime in <code>no_std</code> mode would look like:</p>\n<ul>\n<li>Usage of <code>wasmtime</code> is audited to confirm that only <code>no_std</code>-compatible features of Wasmtime are used (e.g. not <code>cache</code>)</li>\n<li>Wasmtime is compiled for a custom target that's not Linux, for example. This is then integrated as normal into other build systems as required.</li>\n<li>Platform support for Wasmtime's runtime needs, such as mmap, the Rust <code>GlobalAlloc</code> trait, etc, must be provided by the embedder. For now this'll be a header file for Wasmtime's runtime needs and otherwise it's up to the embedder to fix compile errors about <code>GlobalAlloc</code> for example.</li>\n</ul>\n<p>My intent would be that we'd have at least one or two examples in the repository doing all this, like the current <code>min-platform</code> example.</p>\n<h3>Technical details of what support looks like to Wasmtime developers</h3>\n<p>To those who develop Wasmtime this issue is effectively asking more development cost to be taken on by the project. Despite having community norms and expectations the <code>no_std</code> development mode in Rust is not the standard development mode and may serve as a road bump to contributions and/or developers. Here I'd like to outline the specific issues I've found when porting Wasmtime to <code>no_std</code>:</p>\n<ol>\n<li>Imports <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/runtime/src/lib.rs#L17-L22\">now come from <code>core</code> and <code>alloc</code></a>, not <code>std</code>. This is mostly a muscle memory thing to get over, but it's a downside in that only some parts of the project will do this. For example in <code>wasmtime-cache</code> we'll probably still have <code>use std::mem;</code> whereas in <code>wasmtime-runtime</code> that would be spelled <code>use core::mem;</code>.</li>\n<li>The <a href=\"https://doc.rust-lang.org/stable/std/prelude/index.html\">prelude</a> is different for <code>#![no_std]</code> mode. Notably collections like <code>Vec</code> and <code>String</code> are not present. To work around this <a href=\"https://github.com/alexcrichton/wasmtime/blob/aa633ced871cfdadc959b3455c179d56e21007bb/crates/environ/src/lib.rs#L15-L30\">I've created a <code>mod prelude { ... }</code> in the <code>wasmtime-environ</code> crate</a> which is reexported at all other crate roots. Most modules in crate then have <code>use crate::prelude::*;</code> instead of individually importing common types like <code>String</code> and <code>Vec</code>.</li>\n<li>Hash maps are different. The Rust standard library does not provide <code>HashMap</code> in the <code>alloc</code><br>\n[message truncated]</li>\n</ol>\n</blockquote>",
        "id": 437327535,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715024928
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341#issuecomment-2096787471\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8341\">issue #8341</a>:</p>\n<blockquote>\n<p>With <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8555\">https://github.com/bytecodealliance/wasmtime/pull/8555</a> I believe that all the necessary pieces are now in place, so I'm going to close this.</p>\n</blockquote>",
        "id": 437327536,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715024929
    }
]