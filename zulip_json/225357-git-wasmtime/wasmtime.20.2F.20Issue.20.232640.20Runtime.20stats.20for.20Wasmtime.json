[
    {
        "content": "<p>acfoltzer opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640\">Issue #2640</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>To use Wasmtime in production, we will need to gather statistics from the runtime to feed into monitoring systems.</p>\n<p>We have inserted some metrics in a private fork of Lucet in order to support our current production use, and while this has proven useful, we would like to have first-class, open source support for such things in Wasmtime.</p>\n<h4>Benefit</h4>\n<p>The ability to monitor the runtime performance and load of Wasmtime is a requirement for it to be used in many production environments.</p>\n<h4>Implementation</h4>\n<p>I'll describe the stats we gather from Lucet. I'm less sure how best to fit them into the Wasmtime API, but I have described the kind of callback interface I would like to provide as a client of Wasmtime.</p>\n<p>The ones in bold are ones that we've found very important for monitoring platform health and performance. The others would be nice to have, but less critical. This list also shouldn't rule out other opportunities for stat gathering, this is solely what we've found useful in Lucet.</p>\n<h5>Counters</h5>\n<p>Sometimes we just need to count how many times something has happened. For Lucet, this is a handful of internal error conditions that we are able to handle without presenting an error to the end user, but want to keep track of internally nonetheless. There is certainly room for more of these:</p>\n<ul>\n<li><strong>Number of retries needed on <code>userfaultfd</code> operations due to <code>ENOENT</code> errors</strong></li>\n<li><strong>Number of <code>EEXIST</code> errors that the <code>userfaultfd</code> fault handler saw and tracked</strong></li>\n<li><strong>Number of times the <code>userfaultfd</code> fault handler got a read event on its file descriptor, but was not able to read an event.</strong></li>\n</ul>\n<p>This would be a simple callback per event:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">record_event</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Bump a counter</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<h5>Gauges and timers</h5>\n<p>For measuring operations with distinct start and end points, we use gauges and timing histograms. A gauge is a number that, if incremented, usually has a corresponding decrement at some point in the future. A timer adds a timing component to this, so that the time between the beginning and end of an operation can be measured. These could be implemented with a callback that returns an RAII-style guard:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">start_operation</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Guard</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Increment gauge</span>\n<span class=\"w\">    </span><span class=\"c1\">// Create `Guard` with initial timestamp</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Guard</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Guard</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">finish</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// The operation finished normally, so record timing information</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Guard</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Decrement gauge</span>\n<span class=\"w\">        </span><span class=\"c1\">// Optionally record timing information</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Using the drop for the gauge provides some assurance that the gauge remains accurate even if an error occurs between the start and end of an operation. For the timing information, though, we do not necessarily want the timing of errors to be recorded, so having an explicit <code>finish</code> method lets us know that the operation was successful.</p>\n<p>In Lucet we currently use gauges and timers to measure:</p>\n<ul>\n<li><strong>Evaluating a future on behalf of a Wasm program (similarly to <a href=\"https://github.com/bytecodealliance/rfcs/pull/2\">RFC 2</a>)</strong></li>\n<li><strong>Instantiating a module (setting up memory protections, copying in initial heap values)</strong></li>\n<li><strong>Freeing an instance (resetting memory protections, freeing other resources)</strong></li>\n<li>Expanding a Wasm heap on behalf of an instance</li>\n<li>Acquiring an instance slot from a memory region</li>\n<li>Returning a freed instance slot to a region</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Most of the stats we gather for production are taken from outside the boundaries of the Lucet runtime API. To the extent that these operations can be exposed as discrete steps that the library client could measure them, we do not need to add invasive stats interfaces. The stats described here are the ones where in Lucet a significant API refactoring would be required to expose as discrete measurable operations, and would potentially be undesirable for safety or ergonomics.</p>\n<p>Instead of a callback-based approach, we could maintain stats internally within Wasmtime and let them be queried by the embedding application. This would put more of a maintenance and design burden on Wasmtime, however, and would limit the flexibility of the client's stat-gathering interfaces.</p>\n</blockquote>",
        "id": 225370803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612567020
    },
    {
        "content": "<p>peterhuene <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640#issuecomment-774342066\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640\">Issue #2640</a>:</p>\n<blockquote>\n<p>Have we looked at the <a href=\"https://github.com/metrics-rs/metrics\">metrics crate</a> as a possible way to generically instrument <code>wasmtime</code> and <code>wasmtime-runtime</code>?</p>\n</blockquote>",
        "id": 225371371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612567546
    },
    {
        "content": "<p>acfoltzer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640#issuecomment-774342454\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640\">Issue #2640</a>:</p>\n<blockquote>\n<p>I did not know about that crate! That looks very interesting indeed</p>\n</blockquote>",
        "id": 225371449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612567620
    },
    {
        "content": "<p>acfoltzer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640#issuecomment-774343724\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2640\">Issue #2640</a>:</p>\n<blockquote>\n<p>It looks like <code>metrics</code> ticks many of the boxes for the requirements we have, but it doesn't appear to have an RAII interface for gauges. In practice we have found that to be _very_ useful to avoid missing decrements due to surprise control flow. Maybe they'd be open to an upstream contribution, though?</p>\n</blockquote>",
        "id": 225371708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612567859
    }
]