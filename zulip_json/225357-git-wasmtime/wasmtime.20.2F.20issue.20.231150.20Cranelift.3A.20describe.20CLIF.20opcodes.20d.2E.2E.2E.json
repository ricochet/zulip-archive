[
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1150\">issue #1150</a>:</p>\n<blockquote>\n<h3>Motivation</h3>\n<p>Cranelift's IR went through a huge overall from the original python generator to one written in Rust. This has made it easier to work on it as we're using the same language to generate the code that used in the rest of the project. However it is still not ideal in terms of contributing new instructions or changing existing instructions as it is not clear what steps are required, and which parts of the meta code generator need to be modified to correctly add an instruction.</p>\n<p>This could be partially solved by providing better documentation, however documentation doesn't improve the experience of contributing to the codebase itself, and documentation is likely to fall out of date as time goes on similar to the current situation, as there's no strict link between an instruction and its documentation besides what's available in <code>InstBuilder</code>.</p>\n<p>Instead I would like to propose rewriting at least some of the meta code generator with a greater focus on data locality, so that if someone wants to contribute to the IR, the number of overall steps is reduced. This should also help with documenting the IR format, as the documentation can be more closely coupled.</p>\n<h3>Proposed Solution</h3>\n<p>I would like to propose something along the lines of using a data format to encode information about a instruction and how it is encoded. I've used YAML to illustrate what this could look like, though I'm not advocating for the use of YAML specifically.</p>\n<div class=\"codehilite\" data-code-language=\"YAML\"><pre><span></span><code><span class=\"nn\">---</span><span class=\"w\"></span>\n<span class=\"nt\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">jump</span><span class=\"w\"></span>\n<span class=\"nt\">doc</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p p-Indicator\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">Jump.</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"no\">Unconditionally jump to an extended basic block, passing the specified</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">EBB arguments. The number and types of arguments must match the</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">destination EBB.</span><span class=\"w\"></span>\n<span class=\"nt\">attributes</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">terminator</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">branch</span><span class=\"w\"></span>\n<span class=\"nt\">operands_in</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">Ebb</span><span class=\"w\"> </span><span class=\"c1\"># This would also imply `args`</span><span class=\"w\"></span>\n<span class=\"nt\">encodings</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># Encode from recipe</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">x86</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nt\">recipe</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">x86_JMP</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># If this was YAML specifically you could use anchors for recipes. e.g.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">x86</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"l l-Scalar l-Scalar-Plain\">&lt;&lt; *X86_JMP</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># Or encode directly</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">riscv</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nt\">emit</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p p-Indicator\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">let dest = i64::from(func.offsets[destination]);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">let disp = dest - i64::from(sink.offset());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">put_uj(bits, disp, 0, sink);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The main advantage to this approach is that moves the current imperative style of <code>cranelift-codegen</code> into something that is more declarative and data oriented. To me this provides more clarity around how a instruction is defined and used, if you wanted to create a new instruction one could simply copy and paste from another already working instruction.</p>\n<h3>Drawbacks</h3>\n<p>While the goal of this proposal is to simplify working on the IR language itself it could make the underlying meta code more complex, as well potentially increasing the compile time to build <code>cranelift-codegen</code> since there would now be a deserialisation step that wasn't there before.</p>\n<h3>Alternatives</h3>\n<p>Instead of changing the system there could be a greater focus on building resources for contributing to cranelift that try to explain how to use the current system.<br>\n</p>\n</blockquote>",
        "id": 281213072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651695042
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1150\">issue #1150</a>:</p>\n<blockquote>\n<h3>Motivation</h3>\n<p>Cranelift's IR went through a huge overall from the original python generator to one written in Rust. This has made it easier to work on it as we're using the same language to generate the code that used in the rest of the project. However it is still not ideal in terms of contributing new instructions or changing existing instructions as it is not clear what steps are required, and which parts of the meta code generator need to be modified to correctly add an instruction.</p>\n<p>This could be partially solved by providing better documentation, however documentation doesn't improve the experience of contributing to the codebase itself, and documentation is likely to fall out of date as time goes on similar to the current situation, as there's no strict link between an instruction and its documentation besides what's available in <code>InstBuilder</code>.</p>\n<p>Instead I would like to propose rewriting at least some of the meta code generator with a greater focus on data locality, so that if someone wants to contribute to the IR, the number of overall steps is reduced. This should also help with documenting the IR format, as the documentation can be more closely coupled.</p>\n<h3>Proposed Solution</h3>\n<p>I would like to propose something along the lines of using a data format to encode information about a instruction and how it is encoded. I've used YAML to illustrate what this could look like, though I'm not advocating for the use of YAML specifically.</p>\n<div class=\"codehilite\" data-code-language=\"YAML\"><pre><span></span><code><span class=\"nn\">---</span><span class=\"w\"></span>\n<span class=\"nt\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">jump</span><span class=\"w\"></span>\n<span class=\"nt\">doc</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p p-Indicator\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">Jump.</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"no\">Unconditionally jump to an extended basic block, passing the specified</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">EBB arguments. The number and types of arguments must match the</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"no\">destination EBB.</span><span class=\"w\"></span>\n<span class=\"nt\">attributes</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">terminator</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">branch</span><span class=\"w\"></span>\n<span class=\"nt\">operands_in</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">Ebb</span><span class=\"w\"> </span><span class=\"c1\"># This would also imply `args`</span><span class=\"w\"></span>\n<span class=\"nt\">encodings</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># Encode from recipe</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">x86</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nt\">recipe</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">x86_JMP</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># If this was YAML specifically you could use anchors for recipes. e.g.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">x86</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"l l-Scalar l-Scalar-Plain\">&lt;&lt; *X86_JMP</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\"># Or encode directly</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">riscv</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nt\">emit</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p p-Indicator\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">let dest = i64::from(func.offsets[destination]);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">let disp = dest - i64::from(sink.offset());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"no\">put_uj(bits, disp, 0, sink);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The main advantage to this approach is that moves the current imperative style of <code>cranelift-codegen</code> into something that is more declarative and data oriented. To me this provides more clarity around how a instruction is defined and used, if you wanted to create a new instruction one could simply copy and paste from another already working instruction.</p>\n<h3>Drawbacks</h3>\n<p>While the goal of this proposal is to simplify working on the IR language itself it could make the underlying meta code more complex, as well potentially increasing the compile time to build <code>cranelift-codegen</code> since there would now be a deserialisation step that wasn't there before.</p>\n<h3>Alternatives</h3>\n<p>Instead of changing the system there could be a greater focus on building resources for contributing to cranelift that try to explain how to use the current system.<br>\n</p>\n</blockquote>",
        "id": 281213083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651695047
    }
]