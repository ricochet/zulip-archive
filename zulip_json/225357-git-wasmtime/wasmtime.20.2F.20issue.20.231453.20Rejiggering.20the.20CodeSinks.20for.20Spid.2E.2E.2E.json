[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1453#issuecomment-1117999170\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1453\">issue #1453</a>:</p>\n<blockquote>\n<p>I'm doing some gardening on old issues and I think the above may not be as relevant anymore: we've removed some of the old-backend-isms from the emission and sink design, IIRC. Updated suggestions based on the current state of our implementation are certainly welcome! In the meantime I will go ahead and close this issue.</p>\n</blockquote>",
        "id": 281230028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651703962
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1453\">issue #1453</a>:</p>\n<blockquote>\n<p>Cranelift is used in Spidermonkey, as part of an integration called Baldrdash. In Baldrdash, we're currently barely using the <code>RelocSink</code> capabilities, because the information it provides us is incomplete:</p>\n<ol>\n<li>when tracking call relocations, we'd need to get the source loc information. This is useful for stack frame iteration, e.g. displaying the wasm bytecode offset in stack traces, when an error occurs.</li>\n<li>indirect calls don't have relocations, but Spidermonkey needs to track the call site during stack frame iteration, again (the return address is used as a key for a mapping from call sites to call metadata, including the wasm bytecode offset).</li>\n<li>stack maps in Spidermonkey are keyed by the address of the instruction following the instruction to which the stack map relates. This is because when we want to get a stack map for a call/software interrupt, we're usually in the middle of stack frame iteration, and we only have access to the return address for calls, or the address of the next value of PC for software interrupts. Currently, the StackMapSink doesn't offer the information of the next instruction's address, so we have to do something very manual for this (iterate over every instruction, if it's a safepoint remember it for the next instruction, if there was a remembered safepoint add the stackmap with the instruction+size offset to the list of stackmaps). An example may help understanding here:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Cranelift</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">safepoint</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"cp\">$</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">iadd</span><span class=\"w\"></span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">safepoint</span><span class=\"w\"> </span><span class=\"n\">generates</span><span class=\"w\"> </span><span class=\"n\">nothing</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">reloc</span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">effectively</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">above</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"n\">looking</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">during</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"w\"> </span><span class=\"n\">iteration</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p>For the new backend integration, we won't be able to do this anymore, for several reasons:</p>\n<ul>\n<li>in general, the new backend will be much more likely to generate several machine instructions for a single Cranelift IR opcode, which means we can't use the <code>InstOffsetIter</code> correctly anymore, and rely on this to give us precise offset information.</li>\n<li>the new backend doesn't implement <code>encinfo</code>, it doesn't have a notion of <code>Diversions</code> (regalloc does the right thing now!), etc.</li>\n</ul>\n<p>My proposal is the following:</p>\n<ul>\n<li>Pass the current SourceLoc to <code>MemoryCodeSink::reloc_external</code>, so it addresses item 1.</li>\n<li>Add a method <code>RelocSink::track_call_site</code> (or create a new sink for this), that is called with: IR opcode, source location, address of next instruction (= return address). This will be sufficient to address item 2, and could be generally useful for all kinds of calls. At the limit, we don't even need to pass the SourceLoc to <code>reloc_external</code> as proposed in the previous bullet point, since the <code>RelocSink</code> impl could take care of realizing it's notified with both a direct call site here <em>and</em> an external reloc for this call site, but it feels less ergonomic an API to use.</li>\n<li>Among wasmtime + cranelift crates and Spidermonkey, all users are NullStackmapSink, except for Spidermonkey. So I'd propose that we do something very ad-hoc here, by adding the address of the next instruction following the instruction to which the stack map applies. This would address item 3 in the above requirements.</li>\n</ul>\n<p>Alternatives I've considered:</p>\n<ul>\n<li>for all the bullet points, add a generic <code>InstSink</code> which would be called for each instruction with the IR opcode, machine function-start relative offset, machine instruction size, source location. It feels overly generic for the problem we have at hand, but then we have a very general mechanism that might help for more use cases. I'm not sure it'd deal well with the 1 -&gt; N mapping between IR opcode and machine instructions (in the new backend), unless the client had some knowledge of the machine instructions (which doesn't seem very ergonomic), or we passed the machine encoding (which we don't have in the new backend).</li>\n<li>for 3, spidermonkey could remember the stackmap, and when inserting it in our own Spidermonkey relocations, pattern-match the machine instruction's encoding + size. It means one pattern-matching for each possible machine instruction after the stack map (currently, this means 3: software trap, call, call indirect), times the number of different architectures (currently 1, x86_64). That seems awful.</li>\n</ul>\n<p>I will implement my proposal locally, but I'd be happy to read what people think of it!</p>\n</blockquote>",
        "id": 281230029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651703963
    }
]