[
    {
        "content": "<p>Jake-Shadle opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Currently, wasmtime hooks various signals in traphandlers on Unix platforms before executing wasm code so that it can catch and handle various runtime issues without actually crashing the host program. However, on MacOS there is an additional error handling mechanism, <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>. By default a Mach exception will be turned into a unix signal, however, if the application binds their own exception port via <code>task_set_exception_ports</code> or similar, it's up to that handler to actual forward to the default signal mechanism, but in most cases they will probably just abort the process instead, even though wasmtime would have successfully recovered program execution in its signal handler.</p>\n<h4>Feature</h4>\n<p>The feature I'm proposing would be for wasmtime's traphandler to use exception ports when targeting MacOS (and I guess iOS, but I would assume that target is not relevant for wasmtime due to its code execution rules?), forwarding exceptions to whatever previously registered exception port if the exception is not one of the one's wasmtime wants to handle.</p>\n<h4>Benefit</h4>\n<p>The application could have previously registered signal handlers or exception ports on Mac and still function as expected whenever wasmtime executes exceptional wasm code.</p>\n<h4>Implementation</h4>\n<ul>\n<li>I think basically the implementation is mostly conceptually the same as the current signal handling approach, but basically it would be something like...</li>\n</ul>\n<ol>\n<li>Store the previous exception port(s)</li>\n<li>Set exception port to wasmtime's own handler</li>\n<li>When entering trap handling, signal to the handler thread (shared memory, ipc, whatever) that the handler should treat the exceptions it can handle (the equivalents of the SIGILL etc) as runtime errors, but all other exceptions, or when not executing wasm code, should be forwarded to the previous exception port(s)</li>\n<li>When exiting trap handling, tell the handler thread to always forward exceptions</li>\n</ol>\n<p>Also, one thing that would possibly make this easier would just be to directly signal the thread, similar to Mac's own ux_handler code as seen <a href=\"https://opensource.apple.com/source/xnu/xnu-201.5/bsd/uxkern/ux_exception.c.auto.html\">here</a>.</p>\n<ul>\n<li>All of this information is gleaned from <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>, <a href=\"https://flylib.com/books/en/3.126.1.110/1/\">Signas</a>, and <a href=\"https://github.com/google/breakpad/blob/master/src/client/mac/handler/exception_handler.cc\">Breakpad's Exception Handler</a>, as the official Apple documentation is, frankly, garbage.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>The alternative would just be to not do this at all, but in that case I think having a warning in the documentation somewhere so that people running wasmtime on a Mac are aware that having <code>task*_set_exception_ports</code> in their program might mean that wasmtime's normal behavior of catching and handling exception wasm code won't even execute depending on how the user exception handler is implemented.<br>\n</p>\n</blockquote>",
        "id": 218156089,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606555353
    },
    {
        "content": "<p>Jake-Shadle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735186949\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Oh and yes, I found this because I added <a href=\"https://github.com/google/breakpad\">breakpad</a> to our project so we can report crashes effectively, but then someone on mac had a panic in some of their WASM code, so I had to go down this rabbit hole.</p>\n</blockquote>",
        "id": 218156151,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606555457
    },
    {
        "content": "<p>Jake-Shadle edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Currently, wasmtime hooks various signals in traphandlers on Unix platforms before executing wasm code so that it can catch and handle various runtime issues without actually crashing the host program. However, on MacOS there is an additional error handling mechanism, <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>. By default a Mach exception will be turned into a unix signal, however, if the application binds their own exception port via <code>task_set_exception_ports</code> or similar, it's up to that handler to actual forward to the default signal mechanism, but in most cases they will probably just abort the process instead, even though wasmtime would have successfully recovered program execution in its signal handler.</p>\n<h4>Feature</h4>\n<p>The feature I'm proposing would be for wasmtime's traphandler to use exception ports when targeting MacOS (and I guess iOS, but I would assume that target is not relevant for wasmtime due to its code execution rules?), forwarding exceptions to whatever previously registered exception port if the exception is not one of the one's wasmtime wants to handle.</p>\n<h4>Benefit</h4>\n<p>The application could have previously registered signal handlers or exception ports on Mac and still function as expected whenever wasmtime executes exceptional wasm code.</p>\n<h4>Implementation</h4>\n<p>\\* I think basically the implementation is mostly conceptually the same as the current signal handling approach, but basically it would be something like...</p>\n<ol>\n<li>Store the previous exception port(s)</li>\n<li>Set exception port to wasmtime's own handler</li>\n<li>When entering trap handling, signal to the handler thread (shared memory, ipc, whatever) that the handler should treat the exceptions it can handle (the equivalents of the SIGILL etc) as runtime errors, but all other exceptions, or when not executing wasm code, should be forwarded to the previous exception port(s)</li>\n<li>When exiting trap handling, tell the handler thread to always forward exceptions</li>\n</ol>\n<p>Also, one thing that would possibly make this easier would just be to directly signal the thread, similar to Mac's own ux_handler code as seen <a href=\"https://opensource.apple.com/source/xnu/xnu-201.5/bsd/uxkern/ux_exception.c.auto.html\">here</a>.</p>\n<p>\\* All of this information is gleaned from <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>, <a href=\"https://flylib.com/books/en/3.126.1.110/1/\">Signas</a>, and <a href=\"https://github.com/google/breakpad/blob/master/src/client/mac/handler/exception_handler.cc\">Breakpad's Exception Handler</a>, as the official Apple documentation is, frankly, garbage.</p>\n<h4>Alternatives</h4>\n<p>The alternative would just be to not do this at all, but in that case I think having a warning in the documentation somewhere so that people running wasmtime on a Mac are aware that having <code>task*_set_exception_ports</code> in their program might mean that wasmtime's normal behavior of catching and handling exception wasm code won't even execute depending on how the user exception handler is implemented.<br>\n</p>\n</blockquote>",
        "id": 218156627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606556336
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735855200\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Thanks for the report! This seems like something that might be worthwhile to investigate, but somewhat orthogonally the signal handling in wasmtime <em>should</em> forward signals to the previous signal handler if any is registered. Did you find this to not work, however? If so could you describe a bit more about the bug that's happening with the signal handlers today?</p>\n</blockquote>",
        "id": 218301341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606750032
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735857887\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>I think what happens is that the exception gets delivered to an exception port registered by the application before the wasmtime signal handler has the chance to run, thus causing all exceptions that should be handled by wasmtime to instead go to the exception port registered by the application.</p>\n</blockquote>",
        "id": 218301918,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606750262
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735857887\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>I think the problem is that the exception gets delivered to an exception port registered by the application before the wasmtime signal handler has the chance to run, thus causing all exceptions that should be handled by wasmtime to instead go to the exception port registered by the application.</p>\n</blockquote>",
        "id": 218301972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606750287
    },
    {
        "content": "<p>Jake-Shadle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735947992\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Yes, exactly what @bjorn3 said, I've worked around this by instead changing our breakpad fork to just not register the exception ports and instead hook all of the signals that the exception handler used to cover, which works nicely since it can seamlessly work with wasmtime, but it seems like having this in wasmtime would make sense so that it's not at the mercy of whatever other exception handler can be registered that doesn't play nicely.</p>\n<p>I was actually surprised that breakpad didn't have an option to change this, but I guess having both breakpad alongside a piece of code like wasmtime that depends on handling signals is fairly niche or something.</p>\n</blockquote>",
        "id": 218322514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606759410
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-735973400\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Supporting this makes sense to me. Probably faster too, not that it really matters in this particular case <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> </p>\n</blockquote>",
        "id": 218328580,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606762250
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-736105874\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Ah yes thanks for clarifying! Also, yes, agreed we should add this to Wasmtime! Just need to figure out how...</p>\n</blockquote>",
        "id": 218358515,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606777096
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-737458019\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>The old SignalHandlers.cpp file removed in #1365 theoretically had code to do this, though the code is in C++; it may help show what needs to be done here.</p>\n</blockquote>",
        "id": 218609737,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1606938731
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-738083667\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>I was poking around this a bit last night (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/22641de629914ff956c9132638fcc755ff7efc13/crates/runtime/signalhandlers/SignalHandlers.cpp\">here's the file in its full glory</a>), and one snag is going to be that the exception handler runs on a separate thread because a different thread receives the mach message. Our determination of whether a wasm trap ocurred, however, requires access to thread-local state (e.g. to read the store's map of registered JIT addresses and see if we collide with any of them). If we're running the handler on a separate thread, though, I'm not sure how the mach exception handling thread will know how to associated a store's JIT data with the exception that it just received.</p>\n<p>One possible solution is to have a global map that's updated on entry/exit into wasm, but that would require mutex-like synchronization which could be somewhat expensive too.</p>\n</blockquote>",
        "id": 218710178,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607009737
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-742724767\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Looking at SpiderMonkey, it appears that registers code segments in a process-global map which has synchronized access. I think the answer for wasmtime is likely the same. Somehow we'll need to have cheap-ish \"is this a jit region\" test and then some way to go from the register state to the thread-local information about the <code>Store</code> and such.</p>\n</blockquote>",
        "id": 219517377,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607626546
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-772822452\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>I've got a prototype of this at <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2632\">https://github.com/bytecodealliance/wasmtime/pull/2632</a> now. @Jake-Shadle if you're still interested mind giving that a spin and seeing if it works for your use case?</p>\n</blockquote>",
        "id": 225081690,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612386333
    },
    {
        "content": "<p>Jake-Shadle <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456#issuecomment-772836020\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>We'd be happy to try this out, though I probably can't get to it this week, but next week!</p>\n</blockquote>",
        "id": 225084950,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1612387662
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2456\">Issue #2456</a>:</p>\n<blockquote>\n<p>Currently, wasmtime hooks various signals in traphandlers on Unix platforms before executing wasm code so that it can catch and handle various runtime issues without actually crashing the host program. However, on MacOS there is an additional error handling mechanism, <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>. By default a Mach exception will be turned into a unix signal, however, if the application binds their own exception port via <code>task_set_exception_ports</code> or similar, it's up to that handler to actual forward to the default signal mechanism, but in most cases they will probably just abort the process instead, even though wasmtime would have successfully recovered program execution in its signal handler.</p>\n<h4>Feature</h4>\n<p>The feature I'm proposing would be for wasmtime's traphandler to use exception ports when targeting MacOS (and I guess iOS, but I would assume that target is not relevant for wasmtime due to its code execution rules?), forwarding exceptions to whatever previously registered exception port if the exception is not one of the one's wasmtime wants to handle.</p>\n<h4>Benefit</h4>\n<p>The application could have previously registered signal handlers or exception ports on Mac and still function as expected whenever wasmtime executes exceptional wasm code.</p>\n<h4>Implementation</h4>\n<p>\\* I think basically the implementation is mostly conceptually the same as the current signal handling approach, but basically it would be something like...</p>\n<ol>\n<li>Store the previous exception port(s)</li>\n<li>Set exception port to wasmtime's own handler</li>\n<li>When entering trap handling, signal to the handler thread (shared memory, ipc, whatever) that the handler should treat the exceptions it can handle (the equivalents of the SIGILL etc) as runtime errors, but all other exceptions, or when not executing wasm code, should be forwarded to the previous exception port(s)</li>\n<li>When exiting trap handling, tell the handler thread to always forward exceptions</li>\n</ol>\n<p>Also, one thing that would possibly make this easier would just be to directly signal the thread, similar to Mac's own ux_handler code as seen <a href=\"https://opensource.apple.com/source/xnu/xnu-201.5/bsd/uxkern/ux_exception.c.auto.html\">here</a>.</p>\n<p>\\* All of this information is gleaned from <a href=\"https://flylib.com/books/en/3.126.1.109/1/\">Mach Exceptions</a>, <a href=\"https://flylib.com/books/en/3.126.1.110/1/\">Signas</a>, and <a href=\"https://github.com/google/breakpad/blob/master/src/client/mac/handler/exception_handler.cc\">Breakpad's Exception Handler</a>, as the official Apple documentation is, frankly, garbage.</p>\n<h4>Alternatives</h4>\n<p>The alternative would just be to not do this at all, but in that case I think having a warning in the documentation somewhere so that people running wasmtime on a Mac are aware that having <code>task*_set_exception_ports</code> in their program might mean that wasmtime's normal behavior of catching and handling exception wasm code won't even execute depending on how the user exception handler is implemented.<br>\n</p>\n</blockquote>",
        "id": 230701367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1615992204
    }
]