[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194041689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586962072
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-393957760\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-393957760\">PR Review</a>.</p>",
        "id": 194061675,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586970282
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-393957760\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-393957760\">PR Review</a>.</p>",
        "id": 194061676,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586970282
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r408989718\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r408989718\">PR Review Comment</a>:</p>\n<blockquote>\n<p>\"emit\" -&gt; \"omit\"?</p>\n</blockquote>",
        "id": 194061677,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586970283
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194204733,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586973794
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194206592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586974763
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194507683,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587162296
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194732593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587416366
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194844514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587494262
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/sunfishcode\" title=\"https://github.com/sunfishcode\">sunfishcode</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a>.</p>",
        "id": 194844541,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587494273
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-397711553\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-397711553\">PR Review</a>.</p>",
        "id": 194870647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-397711553\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-397711553\">PR Review</a>.</p>",
        "id": 194870648,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412525807\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412525807\">PR Review Comment</a>:</p>\n<blockquote>\n<p>typo: a -&gt; at</p>\n</blockquote>",
        "id": 194870649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412529627\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412529627\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Code-quote <code>LinearMemory</code>.</p>\n</blockquote>",
        "id": 194870650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412532109\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412532109\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Because wasm sometimes measures sizes in pages, we should clarify that this is a size in bytes.</p>\n</blockquote>",
        "id": 194870651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412529109\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412529109\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This first-to-last property is interesting, as optimizers could be tempted to optimize memory accesses in ways that could change the access order -- for example optimizing <code>load.i32(x) &amp; 0xff000000</code> into a one-byte load from the last byte. Could you add some text to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/cranelift/docs/ir.md#memory-operation-flags\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/cranelift/docs/ir.md#memory-operation-flags\">https://github.com/bytecodealliance/wasmtime/blob/master/cranelift/docs/ir.md#memory-operation-flags</a> that says that when an access is not <code>notrap</code>, the bytes are defined to be accessed first-to-last, so that we at least document it?</p>\n</blockquote>",
        "id": 194870652,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412530132\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412530132\">PR Review Comment</a>:</p>\n<blockquote>\n<p>One subtlety that would be good to clarify here is that this is talking about reserving address space, not necessarily actual memory.</p>\n</blockquote>",
        "id": 194870654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412538728\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412538728\">PR Review Comment</a>:</p>\n<blockquote>\n<p>This could produce a value which is <em>lower</em> than the given <code>val</code>, but I guess that's ok here because it'd be an unusably large value in either case.</p>\n</blockquote>",
        "id": 194870655,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412538997\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412538997\">PR Review Comment</a>:</p>\n<blockquote>\n<p>\"size in bytes\", and so on below.</p>\n</blockquote>",
        "id": 194870656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>sunfishcode created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412535578\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r412535578\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The page size will always be a power of 2, so we can do <code>val &amp; -page_size</code>.</p>\n</blockquote>",
        "id": 194870657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587508713
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194946064,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587568355
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398304724\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398304724\">PR Review</a>.</p>",
        "id": 194947426,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587568957
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413078573\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413078573\">PR Review Comment</a>:</p>\n<blockquote>\n<p>So thinking more about this, I think I just carried this comment over from somewhere that I didn't fully understand. I think this property isn't actually necessary (and may not be necessary to document).</p>\n<p>The main assumption I think we can make is that all our accesses are smaller than the size of a page (e.g. the minimum size of the guard region). In that case the first byte is either:</p>\n<ul>\n<li>in wasm memory which is normal-bounds-checked and all remaining bytes are either in wasm memory or the guard-page</li>\n<li>in the guard page, in which case the bounds check will fail.</li>\n</ul>\n<p>Does that sound right to you as well? If so I'll reword this to and probably throw in an assert that the <code>width</code> is less than 1k or something like that with a doc comment explaining.</p>\n</blockquote>",
        "id": 194947427,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587568958
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398305026\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398305026\">PR Review</a>.</p>",
        "id": 194947458,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587568975
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413078824\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413078824\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Ah true yeah, but I was mostly just striving to do something reasonable-ish here.</p>\n</blockquote>",
        "id": 194947459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587568975
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 194947594,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587569043
    },
    {
        "content": "<p>eust-dfinity submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398698423\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-398698423\">PR Review</a>.</p>",
        "id": 195010527,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587605224
    },
    {
        "content": "<p>eust-dfinity created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413442490\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413442490\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Actually that example is allocating one guard page</p>\n</blockquote>",
        "id": 195010528,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587605224
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 195078473,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587655901
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-399219905\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-399219905\">PR Review</a>.</p>",
        "id": 195078490,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587655909
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413899224\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413899224\">PR Review Comment</a>:</p>\n<blockquote>\n<p>I went ahead and tried to update the comment with my thinking here.</p>\n</blockquote>",
        "id": 195078491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587655909
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-399220402\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-399220402\">PR Review</a>.</p>",
        "id": 195078578,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587655941
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413899607\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r413899607\">PR Review Comment</a>:</p>\n<blockquote>\n<p>True yeah, I was mostly just getting this test to pass. Since the JIT is configured that there might not be a guard page then the guard page allocation here shouldn't be necessary.</p>\n</blockquote>",
        "id": 195078579,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1587655941
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a> from <code>configurable-memory-bounds</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit was initially motivated by looking more into #1501, but it<br>\nended up balooning a bit after finding a few issues. The high-level<br>\nitems in this commit are:</p>\n<ul>\n<li>\n<p>New configuration options via <code>wasmtime::Config</code> are exposed to<br>\n  configure the tunable limits of how memories are allocated and such.</p>\n</li>\n<li>\n<p>The <code>MemoryCreator</code> trait has been updated to accurately reflect the<br>\n  required allocation characteristics that JIT code expects.</p>\n</li>\n<li>\n<p>A bug has been fixed in the cranelift wasm code generation where if no<br>\n  guard page was present bounds checks weren't accurately performed.</p>\n</li>\n</ul>\n<p>The new <code>Config</code> methods allow tuning the memory allocation<br>\ncharacteristics of wasmtime. Currently 64-bit platforms will reserve 6GB<br>\nchunks of memory for each linear memory, but by tweaking various config<br>\noptions you can change how this is allocate, perhaps at the cost of<br>\nslower JIT code since it needs more bounds checks. The methods are<br>\nintended to be pretty thoroughly documented as to the effect they have<br>\non the JIT code and what values you may wish to select. These new<br>\nmethods have been added to the spectest fuzzer to ensure that various<br>\nconfiguration values for these methods don't affect correctness.</p>\n<p>The <code>MemoryCreator</code> trait previously only allocated memories with a<br>\n<code>MemoryType</code>, but this didn't actually reflect the guarantees that JIT<br>\ncode expected. JIT code is generated with an assumption about the<br>\nminimum size of the guard region, as well as whether memory is static or<br>\ndynamic (whether the base pointer can be relocated). These properties<br>\nmust be upheld by custom allocation engines for JIT code to perform<br>\ncorrectly, so extra parameters have been added to<br>\n<code>MemoryCreator::new_memory</code> to reflect this.</p>\n<p>Finally the fuzzing with <code>Config</code> turned up an issue where if no guard<br>\npages present the wasm code wouldn't correctly bounds-check memory<br>\naccesses. The issue here was that with a guard page we only need to<br>\nbounds-check the first byte of access, but without a guard page we need<br>\nto bounds-check the last byte of access. This meant that the code<br>\ngeneration needed to account for the size of the memory operation<br>\n(load/store) and use this as the offset-to-check in the no-guard-page<br>\nscenario. I've attempted to make the various comments in cranelift a bit<br>\nmore exhaustive too to hopefully make it a bit clearer for future<br>\nreaders!</p>\n<p>Closes #1501</p>\n<p>&lt;!--</p>\n<p>Please ensure that the following steps are all taken care of before submitting<br>\nthe PR.</p>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.</p>\n</li>\n<li>\n<p>[ ] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n</li>\n<li>\n<p>[ ] This PR contains test cases, if meaningful.</p>\n</li>\n<li>[ ] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</li>\n</ul>\n<p>Please ensure all communication adheres to the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\" title=\"https://github.com/bytecodealliance/wasmtime/blob/master/CODE_OF_CONDUCT.md\">code of\nconduct</a>.<br>\n--&gt;</p>\n</blockquote>",
        "id": 195759380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588188836
    },
    {
        "content": "<p>sunfishcode merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">PR #1513</a>.</p>",
        "id": 195785963,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588205403
    },
    {
        "content": "<p>plicease submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-406082507\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#pullrequestreview-406082507\">PR Review</a>.</p>",
        "id": 196353168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588706172
    },
    {
        "content": "<p>plicease created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r420346865\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513#discussion_r420346865\">PR Review Comment</a>:</p>\n<blockquote>\n<p>After testing this from Perl, I think the <code>_set</code> suffix was accidentally omitted from this declaration.  Same for <code>wasmtime_config_dynamic_memory_guard_size</code> below.</p>\n</blockquote>",
        "id": 196353169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588706172
    }
]