[
    {
        "content": "<p>AldaronLau opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Ability to import memory before sending state to wasmtime API.</p>\n<h4>Benefit</h4>\n<p>Prevent having to use an <code>Option</code> or <code>MaybeUninit</code> in the state to store <code>Memory</code> in state when it's always going to be <code>Some</code> or initialized by the time a function call from WASM happens.</p>\n<h4>Implementation</h4>\n<p>Most likely would require postponing when the state is shared with wasmtime (so the memory can be imported from the wasm module and stored into a state).  This could occur after instantiating, possibly with another type.</p>\n<h4>Alternatives</h4>\n<ul>\n<li>\n<p>Keep using <code>Option</code> or <code>MaybeUninit</code></p>\n</li>\n<li>\n<p>Possibly change <code>Func::call</code> so that it needs to manually pass in the user state as an additional parameter</p>\n</li>\n</ul>\n</blockquote>",
        "id": 299382270,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663470366
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1250208116\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>Instantiating needs the state as it calls the start function of the wasm module, which can call back to the host functions that use the state AFAIK.</p>\n</blockquote>",
        "id": 299396225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663485136
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>There's a circular dependency here where the <code>Store</code> needs to be created to instantiate a module, which needs the store's data. Your embedder data needs the instantiated module's memory, however, hence the two depend on each other. Unfortunately I'm not sure if there's anything that can be done here.</p>\n<blockquote>\n<p>Possibly change Func::call so that it needs to manually pass in the user state as an additional parameter</p>\n</blockquote>\n<p>This is effectively already done with the passing of the equivalent of <code>&amp;mut Store&lt;T&gt;</code> into this function.</p>\n</blockquote>",
        "id": 299573074,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663597008
    },
    {
        "content": "<p>AldaronLau <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251792565\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>Thanks, that makes sense.</p>\n<p>Would it be possible to add an API to wasmtime similar to <a href=\"https://docs.rs/wasmi/latest/wasmi/struct.InstancePre.html#method.ensure_no_start\"><code>wasmi::InstancePre::ensure_no_start()</code></a>, which additionally would not require the user provided state until after instantiation?</p>\n<p>Or considering this from the WASM spec:</p>\n<blockquote>\n<p>The component of a module declares the <a href=\"https://www.w3.org/TR/wasm-core-2/syntax/modules.html#syntax-funcidx\">function index</a> of a start function that is automatically invoked when the module is <a href=\"https://www.w3.org/TR/wasm-core-2/exec/modules.html#exec-instantiation\">instantiated</a>, after <a href=\"https://www.w3.org/TR/wasm-core-2/syntax/modules.html#syntax-table\">tables</a> and <a href=\"https://www.w3.org/TR/wasm-core-2/syntax/modules.html#syntax-mem\">memories</a> have been initialized.</p>\n</blockquote>\n<p>Since memories and tables are initialized <em>before</em> the start function is called, would it be possible to split into a two-stage initialization?  I'm assuming memories and tables wouldn't require the user's state, and that the state would only be required right before the invocation of the start function.</p>\n</blockquote>",
        "id": 299678859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663644696
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1253787621\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>While that could be theoretically done I don't think I understand fully why we would do that. Is having an <code>Option</code> onerous to represent the pre-instantiated and post-instantiated state?</p>\n</blockquote>",
        "id": 299965512,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663770217
    },
    {
        "content": "<p>AldaronLau <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1253836511\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>My specific use case can be very I/O bound, so if the <code>Option</code> can be removed that's possibly around 1000+ branches in unwraps / second (for calls back to the host, all of which need to read/write the memory exported by the wasm module).  It would help for both battery life and efficiency, if it can be safely proved at compile time that it would be initialized.</p>\n</blockquote>",
        "id": 299975552,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663772388
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1253846320\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>The branch will likely be correctly predicted in the fast majority of the cases, which means that the overhead is very small. The overhead to call from wasm into host code is much bigger.</p>\n</blockquote>",
        "id": 299977281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663772850
    },
    {
        "content": "<p>AldaronLau <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1253855086\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>Maybe it's not as big of a deal as I was initially thinking.  I would just prefer to move checks from runtime to compile time if possible.</p>\n</blockquote>",
        "id": 299978708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663773252
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1253872836\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>What you're proposing is effectively a major new feature and change to the API of instantiation and how embedder state is managed. I would personally expect an appropriate level of motivation to be required for such a change, so I would recommend measuring performance impact and differences to see if it matters for your use case.</p>\n<p>My personal intuition is that a few <code>.unwrap()</code> statements on internal state will never really show up in a profile.</p>\n</blockquote>",
        "id": 299981660,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663774111
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1334596202\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>I'm going to close this as I think it was answered above.</p>\n</blockquote>",
        "id": 313402459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1669939290
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Ability to import memory before sending state to wasmtime API.</p>\n<h4>Benefit</h4>\n<p>Prevent having to use an <code>Option</code> or <code>MaybeUninit</code> in the state to store <code>Memory</code> in state when it's always going to be <code>Some</code> or initialized by the time a function call from WASM happens.</p>\n<h4>Implementation</h4>\n<p>Most likely would require postponing when the state is shared with wasmtime (so the memory can be imported from the wasm module and stored into a state).  This could occur after instantiating, possibly with another type.</p>\n<h4>Alternatives</h4>\n<ul>\n<li>\n<p>Keep using <code>Option</code> or <code>MaybeUninit</code></p>\n</li>\n<li>\n<p>Possibly change <code>Func::call</code> so that it needs to manually pass in the user state as an additional parameter</p>\n</li>\n</ul>\n</blockquote>",
        "id": 313402460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1669939290
    },
    {
        "content": "<p>Lohann <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-2461558993\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>Hello, can we reopen this issue? I had a lot of trouble and work to get Wasmtime store working with <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html\">MaybeUnit</a>, this simple solution segfaults:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">uninit</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// segfaults below</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Instance</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">imports</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Then I realized the issue is that there's no way for me transmute only the <code>State</code>, I need to transmute the <code>Store</code> which is not recommended, once rust <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1\">doesn't guarantee the same memory layout</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of <code>Option</code> and <code>unwraps</code> in the code, once it bloats the binary with panic data.</p>\n</blockquote>",
        "id": 481063208,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730966437
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-2462573563\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4922\">issue #4922</a>:</p>\n<blockquote>\n<p>It's best to open a new issue for questions like this, as I see you've done on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">https://github.com/bytecodealliance/wasmtime/issues/9579</a>, so I'll answer over there.</p>\n</blockquote>",
        "id": 481148727,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730994394
    }
]