[
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>This is a follow up to <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4431\">https://github.com/bytecodealliance/wasmtime/pull/4431</a></p>\n<p>In that PR we don't save entry SP and exit FP/return pointer for calls into/out of components because they use a different set of trampolines. However, simply saving the entry SP and exit FP/return pointer isn't something we can simply add to the existing component trampolines because they are defined in CLIF and CLIF doesn't have a way to talk about these particular architecture-specific details. Mach insts do via operand constraints given to regalloc, but CLIF itself doesn't. So we would need to either have two layered trampolines that bounce from the first to the second when calling into / out of components (very not ideal) or we need to add an instruction to CLIF or something to grab the current SP/FP/return pointer (probably we should do this, but it requires some thought/design).</p>\n</blockquote>",
        "id": 290939555,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658861587
    },
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>This is a follow up to <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4431\">https://github.com/bytecodealliance/wasmtime/pull/4431</a></p>\n<p>In that PR we don't save entry SP and exit FP/return pointer for calls into/out of components because they use a different set of trampolines. However, simply saving the entry SP and exit FP/return pointer isn't something we can simply add to the existing component trampolines because they are defined in CLIF and CLIF doesn't have a way to talk about these particular architecture-specific details. Mach insts do via operand constraints given to regalloc, but CLIF itself doesn't. So we would need to either have two layered trampolines that bounce from the first to the second when calling into / out of components (very not ideal) or we need to add an instruction to CLIF or something to grab the current SP/FP/return pointer (probably we should do this, but it requires some thought/design).</p>\n</blockquote>",
        "id": 290939556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658861587
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1195861256\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>Also when fixing this we need to re-enable the <code>attempt_to_leave_during_malloc</code> component model test.</p>\n</blockquote>",
        "id": 290939631,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658861627
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197071127\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>To elaborate a bit more on the issue here -- this will be a repeat for me/@fitzgen but wanted to write stuff down anyway.</p>\n<p>The stack unwinding in #4431 relies on precisely knowing the stack pointer when we enter WebAssembly along with the frame pointer and last program counter when we exit WebAssembly. This is not generally available in Rust itself so we are relying on handwritten assembly trampolines for these purposes instead. </p>\n<h3>Entry into WebAssembly</h3>\n<p>Entry into WebAssembly happens via one of two routes:</p>\n<ol>\n<li>A \"typed\" route using the <code>wasmtime::TypedFunc</code> API or when invoking an core instance's <code>start</code> function (which has a known fixed signature of no inputs and no outputs). In these cases Rust does an indirect call directly to the Cranelift-generated code for the corresponding wasm function.</li>\n<li>An \"untyped\" route which is used by <code>wasmtime::Func::call</code> as well as <code>wasmtime::component::{Func,TypedFunc}::call</code>. In this situation Rust will call a Cranelift-compiled trampoline. The Cranelift trampoline will load arguments from a stack parameter and then make an indirect call to the actual Cranelift-compiled wasm function which is also supplied as an argument.</li>\n</ol>\n<p>Today this all records the entry stack pointer via the <code>host_to_wasm_trampoline</code> defined in inline assembly. Concretely Wasmtime will \"prepare\" an invocation which stores the Cranelift-generated function to call (be it a raw function in case (1) or a trampoline for case (2)) into the <code>VMContext::callee</code> field and then invoke the <code>host_to_wasm_trampoline</code> inline asm symbol.</p>\n<p>This entry isn't too relevant to the component model since we're already doing what's necessary for the stack unwinding, recording the sp on entry. Nevertheless I want to describe the situation so I want to describe some oddities here as well:</p>\n<ul>\n<li>The actual trampoline used in (2) to load arguments from the stack is not actually always defined by Cranelift. Instead sometimes it's a monomorphized Rust function <code>host_to_wasm_trampoline</code> from the <code>Func::wrap</code> API. This means we unfortunately cannot rely on Cranelift to supply all these trampolines which means we can't rely on the trampolines to do things that Rust itself can't do.</li>\n<li>The entry trampoline currently requires the ability to tail-call to the actual callee. This is a technical limitation due to using the exact same trampoline for every single entry point, regardless of signature.</li>\n</ul>\n<p>Ideally we would always enter WebAssembly via a Cranelift-compiled trampoline. That would mean we could do anything in the trampoline that Cranelift would do and ideally remove the need to have inline asm for this. We might still need multiple trampolines for untyped entry points and typed entry points, but overall we should ideally be able to do better here.</p>\n<h3>Exiting WebAssembly</h3>\n<p>Exiting back to the host happens in a few locations, and this is the focus of this issue where it's missing support in the component model:</p>\n<ol>\n<li>Exiting from core wasm will either end up in something defined by <code>Func::wrap</code> or <code>Func::new</code> (roughly). Both of these use a <code>VMHostFunctionContext</code> which internally has two function pointers. One is the <code>VMCallerCheckedAnyfunc</code> which wasm actually calls and the other is the actual host function pointer defined in Rust being invoked. The function pointer contained within the <code>VMCallerCheckedAnyfunc</code> is a trampoline written in inline assembly which spills the fp/pc combo into <code>VMRuntimeLimits</code>. The function pointer to invoke contained within the <code>VMHostFunctionContext</code> has the \"system-v ABI\" since it receives arguments in native platform registers. For <code>Func::wrap</code> this is a Rust function and for <code>Func::new</code> this is a Cranelift-generated trampoline which spills arguments to the stack and then calls a static address specified at compile time (using <code>Func::new</code> requires Cranelift at runtime).</li>\n<li>Exiting from a component will always exits via a lowered host function. Concretely what happens is that a <code>VMComponentContext</code> has an array <code>lowering_anyfuncs: [VMCallerCheckedAnyfunc; component.num_lowerings]</code>. This array is what core wasm actually calls and is exclusively populated by Cranelift-compiled trampolines (via <code>compile_lowered_trampoline</code>). These trampolines are similar to the Cranelift-compiled trampolines for <code>Func::new</code> but call a host function of type signature <code>VMLoweringCallee</code>. <strong>This is where fp/pc are not recorded while we exit wasm</strong>. There's not clear way to use the same trick as <code>Func::{wrap,new}</code> which have a singular inline asm trampoline for all signatures since the callee to defer to depends on the <code>LoweringIndex</code>.</li>\n<li>Finally exiting wasm can also happen via libcalls implemented in Wasmtime. Currently each libcall gets a unique inline-asm-defined trampoline that records the pc/fp combo and then does a direct tail-call to the actual libcall itself.</li>\n</ol>\n<h3>Proposal to fix this issue</h3>\n<p>Overall I find the current trampoline story as pretty complicated and also pretty inefficient. There's typically at least one extra indirect call for all of these transitions and additionally there's very little cache-locality. The fix I'm going to propose here isn't a silver bullet though and will only solve some issues, but I think is still worth pursuing.</p>\n<p>I think we should add few new pseudo-instructions to Cranelift:</p>\n<ul>\n<li>Something to get the current frame pointer</li>\n<li>Something to get the current stack pointer</li>\n<li>Something to get the return address of the current function</li>\n<li>Something to get the address of a label in a function (this may already exist, not sure)</li>\n</ul>\n<p>With these tools we can start trying to eventually move all of the trampolines above to Cranelift exclusively and remove both Rust-defined and inline-asm defined trampolines:</p>\n<ol>\n<li>For components, and this issue, <code>compile_lowered_trampoline</code> could be updated to use the cranelift instructions to record the pc/fp combo into the <code>VMRuntimeLimits</code>. This would remove the need for any extra trampoline when exiting a component and would solve the issue at hand.</li>\n<li>For libcalls we could use the cranelift instructions to manually save fp/pc just before a libcall out to the runtime. This would remove all trampolines related to libcalls.</li>\n<li>For <code>Func::new</code> the cranelift-generated trampoline could act similar to <code>compile_lowered_trampoline</code> and store the fp/pc combo to <code>VMRuntimeLimits</code> and avoid the need for two trampolines.</li>\n<li>Untyped host-to-wasm trampolines could do the sp-saving internally rather than relying on the external trampoline to do so.</li>\n</ol>\n<p>Those are at least the easy ones we could knock out with more Cranelift features. Otherwise there are still a number of places that we are requiring trampolines:</p>\n<ul>\n<li>Exit trampolines with <code>Func::wrap</code> could ideally be generated by Cranelift but would still require two indirect calls. One call to get to the trampoline from the original core wasm and then a second call from the trampoline to the host function itself. The main problem here is getting a trampoline. Assuming trampolines are provided by Cranelift then they become available at runtiem when modules are loaded, which means <code>Func::wrap</code> needs to, at some point, dynamically look up a trampoline and find a corresponding one in a previous module's compiled image. This is not trivial.</li>\n<li>Entry trampolines to <code>TypedFunc</code> are similarly somewhat nontrivial, but I think surmountable. Today a <code>Store</code> has a registry of untyped trampolines per-function signature, and I think it could also have a registry of typed trampolines per-function signature. This typed trampoline would then be used to enter wasm instead of today's calling the raw wasm function. In this situation the callee would be passed as an argument to the trampoline in the same manner untyped trampolines receive the callee.</li>\n</ul>\n<hr>\n<p>Anyway that's a long winded way of saying that we need a few cranelift instructions  to modify <code>compile_lowered_trampoline</code> to fix the original issue here. I do not want to lose sight of how complicated our trampoline story is today though. We're already taking a hit to call overhead into and out of wasm as part of #4431 which we have no means of recovering right now, and I think reducing the trampolines in play and focusing more on Cranelift-generated trampolines is the way forward (e.g. inlining two trampolines into one). Otherwise I also think we will need fancier trampolines for other features such as the out-of-band fuel checking (requires a pinned register) and exceptions (which may require before/after stuff in the trampoline instead of just \"before stuff\" they do today).</p>\n</blockquote>",
        "id": 291080202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658942473
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197102449\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>You kind of mentioned this above, but to be super explicit: the hard part in my mind is deciding what we want to do when</p>\n<ul>\n<li>the <code>cranelift</code> feature is not enabled, so we don't have a JIT at our disposal,</li>\n<li>and then the embedder does <code>let f = Func::wrap(...); f.call(...)</code></li>\n</ul>\n<p>In this scenario, there is no already-compiled Wasm module for us to pluck trampolines from, and because we don't have a JIT available, we can't just create the necessary trampolines.</p>\n<p>But also, in this scenario we don't actually <em>need</em> any trampolines because there isn't actually any Wasm involved (in #4431, this would show up as an empty contiguous sequence of Wasm frames). So maybe we can somehow relax things a bit (<em>waves hands</em>) to allow skipping the trampolines when both caller and callee are the host?</p>\n<p>If one of caller or callee <em>was</em> Wasm, then we would be able to use trampolines from that Wasm. We would just need to figure out how we would lazily connect the trampolines to the <code>Func</code> if the <code>Func::wrap</code> happened before the Wasm module was loaded into the engine.</p>\n<hr>\n<p>But yeah, agreed that we should simplify and improve our trampolines story, but this issue was originally supposed to just track support for saving entry SP and exit FP/return pointer for component trampolines <em>at all</em>. Might need to split this into two issues.</p>\n</blockquote>",
        "id": 291084507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658944290
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535#issuecomment-1197120445\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>Definitely agreed on that I went overboard and should split this to a separate issue, while we're here talking about it though the other issue we identified was <code>FuncRef::from(Func::wrap(...))</code> because right now a <code>FuncRef</code> is a glorified <code>*mut VMCallerCheckedAnyfunc</code> which is \"ready to be called by wasm\" and that's not possible to do with a statically available trampoline today since wasm, if it calls the <code>funcref</code>, must call the trampoline which we won't have until that <code>FuncRef</code> makes its way into a module.</p>\n<p>(I know <code>FuncRef</code> isn't really a type in Wasmtime but it's basically that we currently have to be able to get a <code>*mut VMCallerCheckedAnyfunc</code> from a <code>Func</code> at any time which isn't possible if trampolines are required to be in <code>Module</code> images)</p>\n</blockquote>",
        "id": 291087179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1658945359
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4535\">issue #4535</a>:</p>\n<blockquote>\n<p>This is a follow up to <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4431\">https://github.com/bytecodealliance/wasmtime/pull/4431</a></p>\n<p>In that PR we don't save entry SP and exit FP/return pointer for calls into/out of components because they use a different set of trampolines. However, simply saving the entry SP and exit FP/return pointer isn't something we can simply add to the existing component trampolines because they are defined in CLIF and CLIF doesn't have a way to talk about these particular architecture-specific details. Mach insts do via operand constraints given to regalloc, but CLIF itself doesn't. So we would need to either have two layered trampolines that bounce from the first to the second when calling into / out of components (very not ideal) or we need to add an instruction to CLIF or something to grab the current SP/FP/return pointer (probably we should do this, but it requires some thought/design).</p>\n</blockquote>",
        "id": 292023653,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659626852
    }
]