[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a> from <code>fitzgen:rooting-api</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Rooting prevents GC objects from being collected while they are actively being used.</p>\n<p>We have a few sometimes-conflicting goals with our GC rooting APIs:</p>\n<ol>\n<li>\n<p>Safety: It should never be possible to get a use-after-free bug because the user misused the rooting APIs, the collector \"mistakenly\" determined an object was unreachable and collected it, and then the user tried to access the object. This is our highest priority.</p>\n</li>\n<li>\n<p>Moving GC: Our rooting APIs should moving collectors (such as generational and compacting collectors) where an object might get relocated after a collection and we need to update the GC root's pointer to the moved object. This means we either need cooperation and internal mutability from individual GC roots as well as the ability to enumerate all GC roots on the native Rust stack, or we need a level of indirection.</p>\n</li>\n<li>\n<p>Performance: Our rooting APIs should generally be as low-overhead as possible. They definitely shouldn't require synchronization and locking to create, access, and drop GC roots.</p>\n</li>\n<li>\n<p>Ergonomics: Our rooting APIs should be, if not a pleasure, then at least not a burden for users. Additionally, the API's types should be <code>Sync</code> and <code>Send</code> so that they work well with async Rust.</p>\n</li>\n</ol>\n<p>For example, goals (3) and (4) are in conflict when we think about how to support (2). Ideally, for ergonomics, a root would automatically unroot itself when dropped. But in the general case that requires holding a reference to the store's root set, and that root set needs to be held simultaneously by all GC roots, and they each need to mutate the set to unroot themselves. That implies <code>Rc&lt;RefCell&lt;...&gt;&gt;</code> or <code>Arc&lt;Mutex&lt;...&gt;&gt;</code>! The former makes the store and GC root types not <code>Send</code> and not <code>Sync</code>. The latter imposes synchronization and locking overhead. So we instead make GC roots indirect and require passing in a store context explicitly to unroot in the general case. This trades worse ergonomics for better performance and support for moving GC and async Rust.</p>\n<p>Okay, with that out of the way, this module provides two flavors of rooting API. One for the common, scoped lifetime case, and another for the rare case where we really need a GC root with an arbitrary, non-LIFO/non-scoped lifetime:</p>\n<ol>\n<li>\n<p><code>RootScope</code> and <code>Rooted&lt;T&gt;</code>: These are used for temporarily rooting GC objects for the duration of a scope. Upon exiting the scope, they are automatically unrooted. The internal implementation takes advantage of the LIFO property inherent in scopes, making creating and dropping <code>Rooted&lt;T&gt;</code>s and <code>RootScope</code>s super fast and roughly equivalent to bump allocation.</p>\n<p>This type is vaguely similar to V8's [<code>HandleScope</code>].</p>\n<p>[<code>HandleScope</code>]: <a href=\"https://v8.github.io/api/head/classv8_1_1HandleScope.html\">https://v8.github.io/api/head/classv8_1_1HandleScope.html</a></p>\n<p>Note that <code>Rooted&lt;T&gt;</code> can't be statically tied to its context scope via a lifetime parameter, unfortunately, as that would allow the creation and use of only one <code>Rooted&lt;T&gt;</code> at a time, since the <code>Rooted&lt;T&gt;</code> would take a borrow of the whole context.</p>\n<p>This supports the common use case for rooting and provides good ergonomics.</p>\n</li>\n<li>\n<p><code>ManuallyRooted&lt;T&gt;</code>: This is the fully general rooting API used for holding onto non-LIFO GC roots with arbitrary lifetimes. However, users must manually unroot them. Failure to manually unroot a <code>ManuallyRooted&lt;T&gt;</code> before it is dropped will result in the GC object (and everything it transitively references) leaking for the duration of the <code>Store</code>'s lifetime.</p>\n<p>This type is roughly similar to SpiderMonkey's [<code>PersistentRooted&lt;T&gt;</code>], although they avoid the manual-unrooting with internal mutation and shared references. (Our constraints mean we can't do those things, as mentioned explained above.)</p>\n<p>[<code>PersistentRooted&lt;T&gt;</code>]: <a href=\"http://devdoc.net/web/developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_reference/JS::PersistentRooted.html\">http://devdoc.net/web/developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_reference/JS::PersistentRooted.html</a></p>\n</li>\n</ol>\n<p>At the end of the day, both <code>Rooted&lt;T&gt;</code> and <code>ManuallyRooted&lt;T&gt;</code> are just tagged indices into the store's <code>RootSet</code>. This indirection allows working with Rust's borrowing discipline (we use <code>&amp;mut Store</code> to represent mutable access to the GC heap) while still allowing rooted references to be moved around without tying up the whole store in borrows. Additionally, and crucially, this indirection allows us to update the <em>actual</em> GC pointers in the <code>RootSet</code> and support moving GCs (again, as mentioned above).</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 423823790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128754
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/elliottt\">elliottt</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423823792,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128755
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423823795,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128755
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423823800,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128756
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423823801,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128756
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1969045327\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>Part of <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5032\">https://github.com/bytecodealliance/wasmtime/issues/5032</a></p>\n</blockquote>",
        "id": 423823886,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128785
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423824324,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709128903
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423827131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709129712
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423830184,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709130649
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423837773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709132624
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 423837977,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709132673
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1969517455\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen, @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"fuzzing\", \"wasmtime:api\", \"wasmtime:c-api\", \"wasmtime:ref-types\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing, wasmtime:ref-types</li>\n<li>peterhuene: wasmtime:api, wasmtime:c-api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 423870455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709142288
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1907314454\">PR review</a>:</p>\n<blockquote>\n<p>At a high level this all looks good to me. I think there's work we can do to build confidence in the internals, though. While I realize we can't remove all <code>unsafe</code> here I suspect we don't need quite so many just-a-typed-<code>transmute</code> functions. Those are really difficult to reason about the safety.</p>\n<p>Additionally I think this is definitely an area where we're going to be leaning on miri pretty heavily. Can you ensure that there's tests that run in miri doing all the various bits and bobs with the API other than actually calling in to wasm?</p>\n</blockquote>",
        "id": 423906378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1907314454\">PR review</a>:</p>\n<blockquote>\n<p>At a high level this all looks good to me. I think there's work we can do to build confidence in the internals, though. While I realize we can't remove all <code>unsafe</code> here I suspect we don't need quite so many just-a-typed-<code>transmute</code> functions. Those are really difficult to reason about the safety.</p>\n<p>Additionally I think this is definitely an area where we're going to be leaning on miri pretty heavily. Can you ensure that there's tests that run in miri doing all the various bits and bobs with the API other than actually calling in to wasm?</p>\n</blockquote>",
        "id": 423906380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506598580\">PR review comment</a>:</p>\n<blockquote>\n<p>Given the clones of <code>VMExternRef</code> this seems like this method should either not exist or should at least be marked <code>unsafe</code>?</p>\n</blockquote>",
        "id": 423906381,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506601956\">PR review comment</a>:</p>\n<blockquote>\n<p>For this style of lifetime management you'll want to use <code>impl Into&lt;StoreContext&lt;'a, T&gt;&gt;</code> rather than <code>AsContext</code> and then <code>'a</code> is the lifetime that you want</p>\n</blockquote>",
        "id": 423906382,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506641089\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this <code>debug_assert!</code> the return value is <code>Some</code>?</p>\n</blockquote>",
        "id": 423906384,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506606153\">PR review comment</a>:</p>\n<blockquote>\n<p>If possible, these tests should definitely try to run under miri since they're not dealing with wasm compilation</p>\n</blockquote>",
        "id": 423906385,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506636538\">PR review comment</a>:</p>\n<blockquote>\n<p>I realize that this is probably copied from somewhere else, but reading over this again, this doesn't actually buy us anything right? The return value of this function is an unrooted pointer so for this assertion to be correct it'd actually have to be at a higher scope, right?</p>\n<p>Put another way, this function should probably assert it's in a \"assert no gc scope\", right? (as opposed to creating a temporary assert-no-gc-scope)</p>\n</blockquote>",
        "id": 423906386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506637933\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind updating the docs just above this to reflect the current state? (they were already outdated for the prior <code>AtomicUsize</code> too)</p>\n</blockquote>",
        "id": 423906388,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506628276\">PR review comment</a>:</p>\n<blockquote>\n<p>To confirm, while this is fine to be explicit I don't think that this is a different signature than before, just elaborated.</p>\n</blockquote>",
        "id": 423906389,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506664775\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think this can be a safe function because there's no guarantee that <code>inner</code> belongs to <code>store</code>, right?</p>\n</blockquote>",
        "id": 423906390,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506631727\">PR review comment</a>:</p>\n<blockquote>\n<p>For a future PR, and with more GC types, I think it'd be reasonable to move these impls to the <code>gc_ref.rs</code> module to avoid the <code>#[cfg]</code> here</p>\n</blockquote>",
        "id": 423906391,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506655742\">PR review comment</a>:</p>\n<blockquote>\n<p>Can this be a method on <code>VMGcRef</code>?</p>\n<p>Also, this implementation only seems correct when we only have one gc reference type, so could this perhaps assert somehow that there's only one? Something like <code>assert!(ONLY_EXTERNREF_IMPLEMENTED_YET)</code> and then we delete that <code>const</code> when more than one type is implemented and all callsites are updated?</p>\n</blockquote>",
        "id": 423906392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506666395\">PR review comment</a>:</p>\n<blockquote>\n<p>Technically doesn't this API example leak the <code>externref</code> for the entire lifetime of <code>store</code>? If so can this perhaps show using a <code>RootScope</code> to not do that?</p>\n</blockquote>",
        "id": 423906393,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506654706\">PR review comment</a>:</p>\n<blockquote>\n<p>Could this be a method on <code>VMExternRef</code>?</p>\n</blockquote>",
        "id": 423906394,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506668149\">PR review comment</a>:</p>\n<blockquote>\n<p>While I'm not certain that this would work, one thing worth trying to solve some of the lifetime issues I mentioned above is to change this method signature to:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">get_gc_ref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">StoreOpaque</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">VMGcRef</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 423906395,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506663016\">PR review comment</a>:</p>\n<blockquote>\n<p>Personally I'm very wary of these functions in addition to the <code>ref_from_raw</code> functions in the runtime crate. Can these be removed entirely? I would like to ideally rely on natural lifetime stuff in rustc to avoid any need to do this sort of transmute.</p>\n<p>For example there's basically no way to locally reason that this <code>transmute</code> is correct, so I need to build a total understanding of the whole GC as a result to know when it's safe and when it's not safe to use this.</p>\n</blockquote>",
        "id": 423906396,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506674029\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this needs to be <code>unsafe</code> since there's no guarantee <code>gc_ref</code> is valid or belongs to this store?</p>\n</blockquote>",
        "id": 423906397,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506672176\">PR review comment</a>:</p>\n<blockquote>\n<p>Since this is on the hot path of calls out of wasm, perhaps <code>#[inline]</code>?</p>\n</blockquote>",
        "id": 423906398,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506670060\">PR review comment</a>:</p>\n<blockquote>\n<p>Can this not be a defaulted method? <code>transmute</code> in general is \"really scary\" and we should avoid it at all times if we can, and if we can't I think that it should ideally fall into the category of \"should be trivial to verify this is correct\". In that sense this is not trivial as I would have to audit all implementations of <code>GcRefImpl</code>. If, however, this was located on every impl of <code>GcRefImpl</code> I could take a look at the type, see it's <code>#[repr(transparent)]</code>, and conclude that it's correct.</p>\n<p>also in the local impls I think it would be neat to do something like:</p>\n<p><code>assert!(matches!(self, Self(GcRootIndex { ... })))</code> to trigger an error if the structure ever changes.</p>\n</blockquote>",
        "id": 423906399,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506676854\">PR review comment</a>:</p>\n<blockquote>\n<p>Could these be omitted for now? Deferred instead to something like <code>ref_eq</code>?</p>\n</blockquote>",
        "id": 423906400,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506672721\">PR review comment</a>:</p>\n<blockquote>\n<p>Since this is on the wasm call hot path, could this be <code>#[inline]</code> with a \"fast path\" of \"ok nothing changed\" and then have a slow path for \"ok gotta <code>drain</code>\"</p>\n</blockquote>",
        "id": 423906401,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155820
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506677176\">PR review comment</a>:</p>\n<blockquote>\n<p>Similar to above, could these become freestanding methods on <code>Rooted</code>?</p>\n</blockquote>",
        "id": 423906402,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506681324\">PR review comment</a>:</p>\n<blockquote>\n<p>I commented on this elsewhere a bit, but this would be, IMO, a good location for something like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">debug_assert_gc_not_allowed</span><span class=\"p\">();</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 423906403,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506682101\">PR review comment</a>:</p>\n<blockquote>\n<p>Sort of along the lines of my comment above, it's sort of a \"bug\", not practically but morally, that there's no <code>AutoAssertNoGc</code> marker here?</p>\n</blockquote>",
        "id": 423906404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506685275\">PR review comment</a>:</p>\n<blockquote>\n<p>I commented below on this but I want to be sure to leave a comment on this as well before I forget. More-or-less I think we should try to remove this method, I'm not a huge fan of methods whose bodies are just <code>transmute</code></p>\n</blockquote>",
        "id": 423906405,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506687210\">PR review comment</a>:</p>\n<blockquote>\n<p>Also for an example of this there's <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html#method.data\"><code>Memory::data</code></a> and <code>data_mut</code> for mutable versions.</p>\n</blockquote>",
        "id": 423906406,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1506638792\">PR review comment</a>:</p>\n<blockquote>\n<p>Also, I was expecting to see changes to the codegen for manipulating this reference count, but I don't think that's in this PR. Is that something you'd like to defer to a future PR?</p>\n</blockquote>",
        "id": 423906407,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709155821
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1908825895\">PR review</a>.</p>",
        "id": 424015071,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212035
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1507547264\">PR review comment</a>:</p>\n<blockquote>\n<p>I think so, yeah. I just wrote this all out to help convince myself of the safety of what was going on here, felt like it would be useful for future readers.</p>\n</blockquote>",
        "id": 424015073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212036
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1908826407\">PR review</a>.</p>",
        "id": 424015104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212051
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1507547548\">PR review comment</a>:</p>\n<blockquote>\n<p>That's a good idea.</p>\n</blockquote>",
        "id": 424015106,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212051
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1908839947\">PR review</a>.</p>",
        "id": 424016295,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212445
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1507555561\">PR review comment</a>:</p>\n<blockquote>\n<p>This scope is sufficient to catch the particular instance of this larger bug that we actually hit, and which caused the writing of this comment. It was specifically that inserting the reference into the activations table (happens just below this comment) that would trigger a GC and the above bug. So this scope would catch that particular instance of the bug from happening again, but you are correct that we need to prevent GC in a larger scope than what this actually guards against. I don't think this is really so terrible, it really is the nature of debug assertions: we often can't assert the precise invariant we want to hold, but can assert something a little looser that is implied by that invariant. That said, in this case I think we can thread an <code>AutoAssertNoGC</code> through the <code>into_abi</code> method.</p>\n</blockquote>",
        "id": 424016296,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709212445
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1908922796\">PR review</a>.</p>",
        "id": 424021506,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709214197
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1507605105\">PR review comment</a>:</p>\n<blockquote>\n<p>Heh, and it turns out we had an <code>AutoAssertNoGc</code> for the larger scope already: didn't have to adjust callers when changing <code>into_abi</code> to take an <code>AutoAssertNoGc</code> instead of a store.</p>\n</blockquote>",
        "id": 424021508,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709214198
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1507634384\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also, I was expecting to see changes to the codegen for manipulating this reference count, but I don't think that's in this PR. Is that something you'd like to defer to a future PR?</p>\n</blockquote>\n<p>Nah, that was just an oversight.</p>\n</blockquote>",
        "id": 424025139,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709215325
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1908971061\">PR review</a>.</p>",
        "id": 424025140,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709215325
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424063873,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709225569
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1971557767\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>@alexcrichton I think I've addressed everything in your review.</p>\n<p>Going to start rebasing on <code>main</code>, but I think you can take another look now.</p>\n</blockquote>",
        "id": 424063988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709225607
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424078804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709230098
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424080049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709230538
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424080203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709230584
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424080662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709230745
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424083514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709231754
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424110020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709241479
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1910126780\">PR review</a>.</p>",
        "id": 424285577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311450
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1910126780\">PR review</a>.</p>",
        "id": 424285578,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311450
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1508361917\">PR review comment</a>:</p>\n<blockquote>\n<p>I like this idea of using this as the type, nice! <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 424285579,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311450
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509214975\">PR review comment</a>:</p>\n<blockquote>\n<p>The more I think about this the more I'm realizing that this is I think a pretty big footgun. The safety of <code>VMExternRef</code> relies on doing things on the \"store thread\" to ensure that the non-atomic updates are all ok. Other mutations like <code>clone_from_gc_ref</code> are <code>unsafe</code> but there's no way we can mark <code>drop</code> as unsafe here. That means that it's sort of pretty unsafe just to have a <code>VMExternRef</code> in your hand and there's not much we can do about that (e.g. easy to forget during review too).</p>\n<p>This is going to go away in the future though, right? In the future the reference count here will go away and we'll rely on tracing instead to find this, so no <code>Drop</code> will be required?</p>\n</blockquote>",
        "id": 424285580,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509210938\">PR review comment</a>:</p>\n<blockquote>\n<p>Sorry I know I'm harping on this a lot, but I think we should avoid <code>std::mem::transmute</code> as much as possible if we can given that it's got so many footguns and I always forget the whole set of footguns. Some suggestions here:</p>\n<ul>\n<li>Could this (and the one below) move to the <code>VMExternRef</code> type? That way it'll be easy to see that <code>VMExternRef</code> is a <code>#[repr(transparent)]</code></li>\n<li>Could this perhaps have a debug assert that the size/align are the same?</li>\n<li>Instead of <code>std::mem::transmute</code>, could this do <code>&amp;*(self as *const _).cast()</code></li>\n</ul>\n<p>I realize that it can be sort of six-to-one-half-dozen or another but I'm at least personally wary of using <code>transmute</code> unless we absolutely have to (e.g. the only way to go from <code>usize</code> to <code>fn()</code> is <code>transmute</code>, but pointers can be casted/etc)</p>\n</blockquote>",
        "id": 424285581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509215588\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this perhaps call <code>from_gc_ref</code> below?</p>\n</blockquote>",
        "id": 424285582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509218344\">PR review comment</a>:</p>\n<blockquote>\n<p>s/<code>from_raw</code>/<code>from_gc_ref</code>/ I think?</p>\n</blockquote>",
        "id": 424285583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509217173\">PR review comment</a>:</p>\n<blockquote>\n<p>Whiel you're here, mind removing <code>as</code> casts where possible and replacing them with <code>.cast()</code>?</p>\n</blockquote>",
        "id": 424285584,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1508360643\">PR review comment</a>:</p>\n<blockquote>\n<p>With the lack of type parameter here now mind throwing <code>#[inline]</code> on this and the above methods?</p>\n</blockquote>",
        "id": 424285585,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509219155\">PR review comment</a>:</p>\n<blockquote>\n<p>Could this an <code>clone_from_gc_ref</code> assert that vmexternref is the only implemented type?</p>\n</blockquote>",
        "id": 424285586,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509216400\">PR review comment</a>:</p>\n<blockquote>\n<p>Could this debug print be <code>self.0.as_ptr()</code> since <code>&amp;self</code> changes enough that its pointer value probably isn't too interesting?</p>\n</blockquote>",
        "id": 424285587,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509221872\">PR review comment</a>:</p>\n<blockquote>\n<p>Oh and now I also realize that these same concerns apply to <code>Clone</code> above, that seems like a footgun that it's safe since there's no easy way to audit callers are all happening in the same thread.</p>\n</blockquote>",
        "id": 424285588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1509231367\">PR review comment</a>:</p>\n<blockquote>\n<p>Is it actually even possible to safely call this method? </p>\n<p>This only exist for the C API, and there's no rooting in the C API, so thinking about this it seems like we should remove this because it basically can't be used correctly</p>\n</blockquote>",
        "id": 424285589,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709311451
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914272618\">PR review</a>.</p>",
        "id": 424650023,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709557698
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511137271\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think that would be helpful here since the difference between a pointer to a <code>VMExternData</code> and a <code>VMExternRef</code> is that the latter does refcounting operations, but it is an invariant that if we called this function, then the refcount is zero. So if we did <code>from_gc_ref</code> here, we would have to <code>std::mem::forget</code> the result so that the drop impl didn't try to decrement the refcount when we know it is already zero and we are deallocating the <code>VMExternData</code> it points to.</p>\n</blockquote>",
        "id": 424650024,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709557698
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914275695\">PR review</a>.</p>",
        "id": 424650302,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709557794
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511139094\">PR review comment</a>:</p>\n<blockquote>\n<p>This is a method on <code>VMExternData</code>, not <code>VMExternRef</code>, so <code>&amp;self</code> is the interesting pointer value.</p>\n</blockquote>",
        "id": 424650303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709557794
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914345877\">PR review</a>.</p>",
        "id": 424656992,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709559830
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511182604\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>This only exist for the C API</p>\n</blockquote>\n<p>We use this to convert <code>ValRaw</code>s back to <code>ExternRef</code>s, and the untyped function call path internally uses <code>ValRaw</code>s, so we can't just remove this without affecting non-C-API things.</p>\n<blockquote>\n<p>there's no rooting in the C API</p>\n</blockquote>\n<p>There isn't explicit control of rooting, no, I haven't added C-API stuff for <code>RootScope</code> and <code>Rooted</code> vs <code>ManuallyRooted</code>. But we do root things in the C-API implementation nonetheless, for example a <code>wasm_ref_t</code> is a <code>ManuallyRooted&lt;Ref&gt;</code> under the hood and you could use this method safely in combination with that type.</p>\n</blockquote>",
        "id": 424656993,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709559830
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424660097,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709560537
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914380128\">PR review</a>.</p>",
        "id": 424661013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709560745
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511203498\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, it is definitely a footgun, and this isn't how I would design this from scratch. It is just the intermediate stepping stone on the way to the next PR, which introduces a proper <code>GcHeap</code> that is passed in to GC hooks/barriers which are proof of safe access to the heap and its objects (similar to what store does at the embedder API level).</p>\n<p>I don't really know how to avoid this intermediate state without fusing this PR together with the next.</p>\n</blockquote>",
        "id": 424661015,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709560745
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914754742\">PR review</a>.</p>",
        "id": 424694996,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569407
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511433883\">PR review comment</a>:</p>\n<blockquote>\n<p>Ok if this is just a stepping stone I think that's ok. If you're ok with it though I think it'd be best at this point to land this PR tomorrow at the earliest since the 19.0.0 branch point will happen tonight and I think it would be best to not have this pair of PRs get straddled across a release</p>\n</blockquote>",
        "id": 424694997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569407
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914760518\">PR review</a>.</p>",
        "id": 424695551,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569562
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511437561\">PR review comment</a>:</p>\n<blockquote>\n<p>Oh right yeah, but the untyped/unchecked path basically only exists for the C API. I'm definitely not saying that we should add a bunch of rooting-related things to the C API, but I'm wondering if we should basically forbid externref in the C API as a result of this (or at least in the <code>ValRaw</code> parts bound in the C API). </p>\n<p>This seems like it might be too big of a footgun to expose in the C API where you can very easily get an unrooted value and there's no way to go from that unrooted value to a rooted value, so even if you want to \"do the right thing\" you can't</p>\n</blockquote>",
        "id": 424695557,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569562
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914775883\">PR review</a>.</p>",
        "id": 424696818,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569914
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511445846\">PR review comment</a>:</p>\n<blockquote>\n<p>That makes sense to me.</p>\n</blockquote>",
        "id": 424696819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709569914
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914780949\">PR review</a>.</p>",
        "id": 424697330,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709570053
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511449000\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it does make sense to expose the rooting stuff in the C API eventually, it's just not a priority at the moment. Given that, I think we can forbid it in the C API in the meantime, yeah. How would you like to do this? Propagating errors or asserting? I think the former could be difficult/annoying because of the amount of places that are currently infallible but which would need to become fallible...</p>\n</blockquote>",
        "id": 424697332,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709570053
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1914787994\">PR review</a>.</p>",
        "id": 424698045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709570238
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1511453349\">PR review comment</a>:</p>\n<blockquote>\n<p>Perhaps removing the <code>externref</code> field from the header (and the tag for that enum)? And then using <code>unreachable!()</code> everywhere inside of the C bindings since they shouldn't be triggerable?</p>\n</blockquote>",
        "id": 424698046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709570238
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424902793,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709654568
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424902884,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709654589
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1917465181\">PR review</a>.</p>",
        "id": 424902929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709654600
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#discussion_r1513089262\">PR review comment</a>:</p>\n<blockquote>\n<p>Done.</p>\n</blockquote>",
        "id": 424902930,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709654600
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#pullrequestreview-1917686215\">PR review</a>.</p>",
        "id": 424921987,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709659894
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424924339,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709660573
    },
    {
        "content": "<p>fitzgen has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424924380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709660590
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424973346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709679627
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424973879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709679881
    },
    {
        "content": "<p>fitzgen has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424973933,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709679910
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424982460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709684372
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424982462,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709684372
    },
    {
        "content": "<p>fitzgen has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424982475,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709684380
    },
    {
        "content": "<p>fitzgen merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>.</p>",
        "id": 424986912,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709687315
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1984857354\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>Handling the fallout for this in the wasmtime-cpp repository I think that the requirement to take a <code>wasmtime_context_t</code> as an argument for value operations invalidates the preexisting <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/include/wasmtime.hh#L1900-L1904\">copy constructor</a> and <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/include/wasmtime.hh#L1918-L1925\">copy assignment operator</a>. Not an issue per se, but it appears that removing those also invalidates <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/examples/gcd.cc#L27\">this pattern</a> where arguments can't be constructed as <code>{6, 27}</code> any more. I'll admit I'm not C++ expert and the wall of error messages I'm looking at don't exactly explain why it's related to the copy constructor/assignment.</p>\n<p>Anyway that's a long way of asking, do you think we're going to indefinitely want to have a context argument on these functios into the future, even with the idea of an indexed heap?</p>\n</blockquote>",
        "id": 425424343,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709859176
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1985771514\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<blockquote>\n<p>Anyway that's a long way of asking, do you think we're going to indefinitely want to have a context argument on these functios into the future, even with the idea of an indexed heap?</p>\n</blockquote>\n<p>Yes, unfortunately, I do. At least in Rust. I could see a C/C++ specific approach to alleviating this, however...</p>\n<p>Indexed GC heaps are orthogonal to the rooting approach here.</p>\n<p>In order to support moving GCs, we need to either:</p>\n<ol>\n<li>\n<p>Be able to precisely identify raw (whether pointer or index) GC roots <em>and mutate them</em> after an object moves.</p>\n</li>\n<li>\n<p>Or support pinning GC references temporarily such that they do not move while rooted. This allows us to avoid the need to update GC roots after an object moves.</p>\n</li>\n</ol>\n<p>Option (2) is a pretty big constraint on GC implementations. We would have to <em>really</em> bend over backwards to support that in our planned copying collector.</p>\n<p>So focusing on option (1), there are basically two approaches we can take:</p>\n<ol>\n<li>\n<p>Indirection. Store the raw GC references in some sort of table (aka our <code>GcRoots</code>) and have the user's root type index into that table (aka our <code>Rooted&lt;T&gt;</code>/<code>ManuallyRooted&lt;T&gt;</code>). This is nice, and works well with Rust and its move semantics, because we don't need to track down where all the <code>Rooted&lt;T&gt;</code>s and <code>ManuallyRooted&lt;T&gt;</code>s are in memory and we don't need to pin them or do any sort of updates on move so that we can update their internal GC reference after an object moves. Instead, the GC refs are all in the table and we can just do a pass over the table to update the GC refs, and all the <code>Rooted&lt;T&gt;</code>s index into the table and get the moved GC ref the next time they do some operation on their referent. The downside is that all constructing and dropping GC roots in this scheme requires access to the table, in the general case, as you've found.</p>\n</li>\n<li>\n<p>Intrusive lists/some other intrusive data structure. This is the approach that SpiderMonkey takes, for example. All the user's roots hold raw GC references and are additionally members of an intrusive list that is associated with their GC heap. This allows the GC to walk the intrusive list and update all rooted GC references after moving objects. But this means that you need to pin the GC root type or have move constructors that keep the intrusive list valid as the GC root is moved in memory. This works well with C++ but very much not so well with Rust, which is why we went with the first option.</p>\n</li>\n</ol>\n<p>So, if we wanted to make the C/C++ API a little more ergonomic, we <em>could</em> support the intrusive list option. Ideally not in the Rust embedder API, but maybe with some <code>doc(hidden)</code> stuff that is feature gated for when we are building the C API crate. FWIW, this is also fairly unsafe not just in terms of the invariants around maintianing the intrusive list, but in that right now with the table/indirect approach we only ever use indices and we bounds check their accesses into the table so \"use after free\"-style bugs are still memory safe, which limits how bad things can go wrong. That is not the case with the intrusive list approach.</p>\n</blockquote>",
        "id": 425526821,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709907319
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1985771514\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<blockquote>\n<p>Anyway that's a long way of asking, do you think we're going to indefinitely want to have a context argument on these functios into the future, even with the idea of an indexed heap?</p>\n</blockquote>\n<p>Yes, unfortunately, I do. At least in Rust. I could see a C/C++ specific approach to alleviating this, however...</p>\n<p>Indexed GC heaps are orthogonal to the rooting approach here.</p>\n<p>In order to support moving GCs, we need to either:</p>\n<ol>\n<li>\n<p>Be able to precisely identify raw (whether pointer or index) GC roots <em>and mutate them</em> after an object moves.</p>\n</li>\n<li>\n<p>Or support pinning GC references temporarily such that they do not move while rooted. This allows us to avoid the need to update GC roots after an object moves.</p>\n</li>\n</ol>\n<p>Option (2) is a pretty big constraint on GC implementations. We would have to <em>really</em> bend over backwards to support that in our planned copying collector.</p>\n<p>So focusing on option (1), there are basically two approaches available to us for implementing rooting APIs:</p>\n<ol>\n<li>\n<p>Indirection. Store the raw GC references in some sort of table (aka our <code>GcRoots</code>) and have the user's root type index into that table (aka our <code>Rooted&lt;T&gt;</code>/<code>ManuallyRooted&lt;T&gt;</code>). This is nice, and works well with Rust and its move semantics, because we don't need to track down where all the <code>Rooted&lt;T&gt;</code>s and <code>ManuallyRooted&lt;T&gt;</code>s are in memory and we don't need to pin them or do any sort of updates on move so that we can update their internal GC reference after an object moves. Instead, the GC refs are all in the table and we can just do a pass over the table to update the GC refs, and all the <code>Rooted&lt;T&gt;</code>s index into the table and get the moved GC ref the next time they do some operation on their referent. The downside is that all constructing and dropping GC roots in this scheme requires access to the table, in the general case, as you've found.</p>\n</li>\n<li>\n<p>Intrusive lists/some other intrusive data structure. This is the approach that SpiderMonkey takes, for example. All the user's roots hold raw GC references and are additionally members of an intrusive list that is associated with their GC heap. This allows the GC to walk the intrusive list and update all rooted GC references after moving objects. But this means that you need to pin the GC root type or have move constructors that keep the intrusive list valid as the GC root is moved in memory. This works well with C++ but very much not so well with Rust, which is why we went with the first option.</p>\n</li>\n</ol>\n<p>So, if we wanted to make the C/C++ API a little more ergonomic, we <em>could</em> support the intrusive list option. Ideally not in the Rust embedder API, but maybe with some <code>doc(hidden)</code> stuff that is feature gated for when we are building the C API crate. FWIW, this is also fairly unsafe not just in terms of the invariants around maintianing the intrusive list, but in that right now with the table/indirect approach we only ever use indices and we bounds check their accesses into the table so \"use after free\"-style bugs are still memory safe, which limits how bad things can go wrong. That is not the case with the intrusive list approach.</p>\n</blockquote>",
        "id": 425527117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709907400
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1986393681\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>Ok nah that all sounds good, no need to go the intrusive list route just yet, I think it's ok if things are slightly less ergonomic in the C++ bindings API unless a C++ wizard more adept than I can figure out a better solution</p>\n</blockquote>",
        "id": 425604549,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709930819
    },
    {
        "content": "<p>rockwotj <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1998111958\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<blockquote>\n<p>Not an issue per se, but it appears that removing those also invalidates <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/examples/gcd.cc#L27\">this pattern</a> where arguments can't be constructed as {6, 27} any more</p>\n</blockquote>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/include/wasmtime.hh#L2457C32-L2458\">https://github.com/bytecodealliance/wasmtime-cpp/blob/da579e78f799aca0a472875b7e348f74b3a04145/include/wasmtime.hh#L2457C32-L2458</a></p>\n<p>The function you're calling takes a <code>std::vector</code> and you're passing in an initializer_list, which copies things out of the vector: <a href=\"https://godbolt.org/z/h844YKxYq\">https://godbolt.org/z/h844YKxYq</a></p>\n<p>You'll need to use a move iterator to force moving out of the container. One of the annoying bits about C++ iterators. You could use ranges/views to make this more seemless.</p>\n<p>As for dropping the copy constructor/assignment I think that's fine, but it can be useful to have an explicit copy function that takes a context.</p>\n</blockquote>",
        "id": 426607685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710442347
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1998464834\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>Makes sense! In <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/pull/48\">https://github.com/bytecodealliance/wasmtime-cpp/pull/48</a> I ended up adding overloaded versions for <code>std::initializer_list</code> and <code>std::vector</code> with a \"base\" version that takes an iterator. That being said I don't know how to best generically take an iterator in C++</p>\n</blockquote>",
        "id": 426626694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710449532
    },
    {
        "content": "<p>rockwotj <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011#issuecomment-1998487483\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8011\">PR #8011</a>:</p>\n<blockquote>\n<p>Added a suggestion here: <a href=\"https://github.com/bytecodealliance/wasmtime-cpp/pull/48/files#r1525490495\">https://github.com/bytecodealliance/wasmtime-cpp/pull/48/files#r1525490495</a></p>\n</blockquote>",
        "id": 426629498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710450550
    }
]