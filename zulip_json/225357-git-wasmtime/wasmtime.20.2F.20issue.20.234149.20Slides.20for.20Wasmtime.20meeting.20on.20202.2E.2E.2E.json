[
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149#issuecomment-1125307324\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149\">issue #4149</a>:</p>\n<blockquote>\n<p>Why must <code>current_length</code> be atomically incremented for all modules at the same time? Having a global lock for memory growing and then incrementing <code>current_length</code> on memory growing for each module individually would work fine, right? Any normal module would wait with using the extra memory until the memory grow operation returned, so no problems in that case. If a module tries to access the memory without waiting for the memory grow operation to return, it would have to do so on a different thread in which case missing synchronization would already allow spuriously crashing anyway.</p>\n</blockquote>",
        "id": 282152726,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652380673
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149#issuecomment-1125389148\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149\">issue #4149</a>:</p>\n<blockquote>\n<blockquote>\n<p>in which case missing synchronization would already allow spuriously crashing anyway</p>\n</blockquote>\n<p>Not sure I understand exactly what you mean?</p>\n</blockquote>",
        "id": 282166128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652386925
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149#issuecomment-1125431017\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149\">issue #4149</a>:</p>\n<blockquote>\n<p>If you don't synchronize with the memory grow operation trying to access the new memory could cause a crash if you accessed it too early. That is before the other thread actually performed the memory grow operation. This means any memory allocator that wants to be crash free has to synchronize with the memory grow operation and thus would work independently of the <code>current_length</code> field being atomically updated across wasm modules or not.</p>\n</blockquote>",
        "id": 282172797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652390240
    },
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149#issuecomment-1125480701\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/4149\">issue #4149</a>:</p>\n<blockquote>\n<p>I think I see what you mean now. Yeah, in the memory allocator scenario you mention there may need to be another level of synchronization so why even protect the <code>current_length</code> field? Well, discussion in the threads proposal seems to come to the conclusion that synchronization is needed (<a href=\"https://github.com/WebAssembly/threads/issues/26#issuecomment-433930711\">quote</a>):</p>\n<blockquote>\n<p>For clarity, nothing has changed about the semantics of memory.size (which guarantees no subsequent OOB up to the bound it observes, requiring the lock implementation described above or some other synchronization).</p>\n</blockquote>\n<p>My take on this is that we cannot allow the <code>memory.grow</code> to make more pages accessible and update the length field in such a way that <code>memory.size</code> could \"pick up\" the updated length while the pages are not yet accessible. One way to do this is with the <code>RwLock</code> I suggested but we did mention using atomics (but the <code>memory.size</code> would have to be atomic as well, right? Maybe not if we assume is always a lower, valid value...) or even lazily updating the length field (though I think we backed away from that).</p>\n<p>But the other side of this is what @fitzgen suggested:</p>\n<blockquote>\n<p>interesting case where mprotect happens before length field increments, other threads observe working accesses but read smaller memory.size; need lock to protect size too (need memory.size hostcall for correctness)</p>\n</blockquote>\n<p>He's getting at the fact that we want <code>memory.size</code> to be consistent with those <code>memory.grow</code> operations. These two points, as well as observing that SpiderMonkey ends up <a href=\"https://github.com/WebAssembly/threads/issues/26#issuecomment-424678704\">using a lock here</a>, suggests to me that a lock is probably the safest, simplest way to go.</p>\n<hr>\n<p>My initial understanding of this comes from the proposal:</p>\n<blockquote>\n<p>Note: When <a href=\"https://tc39.github.io/ecma262/#sec-issharedarraybuffer\">IsSharedArrayBuffer</a> (<code>M.[[BufferObject]]</code>) is true, the return value should be the result of an atomic read-modify-write of the new size to the internal <a href=\"http://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object\">[[ArrayBufferByteLength]]</a> slot. The ret value will be the value in pages read from the internal <a href=\"http://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object\">[[ArrayBufferByteLength]]</a> slot before the modification to the resized size, which will be the current size of the memory.</p>\n</blockquote>\n<p>This is TC39-related, but my reading of it is that since modifying the length field is atomic, the reads of that field must be synchronized.</p>\n</blockquote>",
        "id": 282180622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652395030
    }
]