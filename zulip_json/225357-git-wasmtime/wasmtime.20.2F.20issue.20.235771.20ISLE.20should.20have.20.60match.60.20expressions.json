[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>If I want to match on something in an RHS, I have to split the continuation out into a new rule:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">A</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">B</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span> <span class=\"err\">I</span> <span class=\"err\">J</span> <span class=\"err\">K</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">C</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">a_to_b</span> <span class=\"p\">(</span><span class=\"err\">A</span><span class=\"p\">)</span> <span class=\"err\">B</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">extern</span> <span class=\"err\">constructor</span> <span class=\"err\">a_to_b</span> <span class=\"err\">my_a_to_b_impl</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">foo</span> <span class=\"p\">(</span><span class=\"err\">A</span><span class=\"p\">)</span> <span class=\"err\">C</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">a_to_b</span> <span class=\"err\">a</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B</span><span class=\"p\">)</span> <span class=\"err\">C</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.I</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.J</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.K</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>I wish that I didn't need to define a new term, and could instead match on <code>(a_to_b a)</code> directly inside <code>foo</code>:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"err\">match</span> <span class=\"p\">(</span><span class=\"err\">a_to_b</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.I</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.J</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.K</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>Some things to think about: partiality and side effects.</p>\n<p>But since we can already write this today, just with two terms instead of one, I don't think we should have any show stoppers here.</p>\n</blockquote>",
        "id": 327637368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676319156
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>If I want to match on something in an RHS, I have to split the continuation out into a new rule:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">A</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">B</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span> <span class=\"err\">I</span> <span class=\"err\">J</span> <span class=\"err\">K</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"err\">C</span> <span class=\"err\">extern</span> <span class=\"p\">(</span><span class=\"err\">enum</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">a_to_b</span> <span class=\"p\">(</span><span class=\"err\">A</span><span class=\"p\">)</span> <span class=\"err\">B</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">extern</span> <span class=\"err\">constructor</span> <span class=\"err\">a_to_b</span> <span class=\"err\">my_a_to_b_impl</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">foo</span> <span class=\"p\">(</span><span class=\"err\">A</span><span class=\"p\">)</span> <span class=\"err\">C</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">a_to_b</span> <span class=\"err\">a</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"err\">decl</span> <span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B</span><span class=\"p\">)</span> <span class=\"err\">C</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.I</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.J</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span><span class=\"mi\">2</span> <span class=\"p\">(</span><span class=\"err\">B.K</span><span class=\"p\">))</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>I wish that I didn't need to define a new term, and could instead match on <code>(a_to_b a)</code> directly inside <code>foo</code>:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"err\">rule</span> <span class=\"p\">(</span><span class=\"err\">foo</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"err\">match</span> <span class=\"p\">(</span><span class=\"err\">a_to_b</span> <span class=\"err\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.I</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.J</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)</span>\n    <span class=\"p\">((</span><span class=\"err\">B.K</span><span class=\"p\">)</span> <span class=\"err\">...</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>Some things to think about: partiality and side effects.</p>\n<p>But since we can already write this today, just with two terms instead of one, I don't think we should have any show stoppers here.</p>\n</blockquote>",
        "id": 327637369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676319156
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430394429\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>I think this is an interesting proposal, and could be nice to have!</p>\n<p>One observation that came up when we discussed this (and fleshes out your \"partiality and side-effects\" note) was that it's sort of a dual to <code>if-let</code>: <code>if-let</code> is an embedded sub-match that happens on the left-hand side, and so must have no side-effects (we constrain its sub-RHS to pure ctors only) but can fail a match, because we're prior to the backtracking commit-point. On the other hand, this <code>match</code> happens on the right-hand side, so can have side-effects (can invoke any ctor) but cannot cause a match failure; or can, but only if this is a rule for a partial ctor, because we've already committed.</p>\n<p>An alternative that occurs to me now is that we could instead make the separation between pure LHS and impure RHS phases more flexible: one could continue to use pure ctors, and <code>match</code>es, in the RHS up until the point that one uses the first impure ctor. Only at that point would one no longer be allowed to use <code>match</code>es. It does make the backtracking harder to predict though (we can now backtrack from the RHS? in a sense we're defining the RHS semantically rather than syntactically now). Needs more thought...</p>\n</blockquote>",
        "id": 327875873,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676409670
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430431969\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>Yep, all very good points.</p>\n<p>But also I don't think we absolutely need to answer all those questions yet, since this is just syntactic sugar for something you can already write today.</p>\n</blockquote>",
        "id": 327881960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676412038
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430453411\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>Ah, that's interesting; so the proposal is to actually desugar to a separate internally-generated helper term? That could work; it's potentially a little tricky both for plumbing reasons (sema-lowering an expression AST can now create new terms) and because one has to compute the closure-capture when defining the signature of that helper term (all used variable bindings need to be passed in). At that point it doesn't seem too much worse to natively represent a <code>sema::Match</code> and then handle it in codegen (lowering as we do if-lets)...</p>\n</blockquote>",
        "id": 327884592,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676413172
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430456281\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>It's not exactly syntactic sugar unless you're proposing that match expressions make synthetic terms... (Oh, Chris beat me to this point.) I would want to take this new syntax as an opportunity to generate better code, anyway: the more we can fold into a single match tree, the more opportunities for sharing computations we'll find.</p>\n<p>This is a digression from the main issue, but I want to respond to one point: I think it's useful to maintain the current syntactic restriction that back-tracking can only occur due to failures on the LHS.</p>\n<p>It turns out we almost never use partial constructors on the RHS of a rule. As a data point, there are currently two instances across all backends:</p>\n<ul>\n<li>On aarch64, <code>(rule (lower (vhigh_bits vec @ (value_type $I64X2))) ...</code> contains a call to <code>(lshl_from_u64 $I64 1)</code>, which is declared partial but I think can't actually fail on that input.</li>\n<li>On s390x, there's a single-rule term <code>(rule (memarg_symbol_offset x) (memarg_symbol_offset_sum x 0))</code> which is effectively a macro. Since <code>memarg_symbol_offset_sum</code> is partial, the \"macro\" is too.</li>\n</ul>\n<p>It's easier to find these in ISLE's new codegen because now this is the only case where the generated code uses the <code>?</code> operator; searching for <code>?;</code> does the job.</p>\n</blockquote>",
        "id": 327884901,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676413296
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430496292\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<blockquote>\n<p>It's not exactly syntactic sugar unless you're proposing that match expressions make synthetic terms...</p>\n</blockquote>\n<p>Yes: when I want to match in an RHS, I am forced to make a synthetic term. I don't want to do that myself, since it is 100% mechanical. The compiler should do it for me.</p>\n<p>If, as an optimization, it represents it some other way internally that is great, but irrelevant from a semantics POV.</p>\n</blockquote>",
        "id": 327889026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676415063
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430496292\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<blockquote>\n<p>It's not exactly syntactic sugar unless you're proposing that match expressions make synthetic terms...</p>\n</blockquote>\n<p>Yes: when I want to match in an RHS, I am forced to make a synthetic term. I don't want to do that myself, since it is 100% mechanical. The compiler should do it for me.</p>\n<p>If, as an optimization, the compiler represents it some other way internally that is great, but irrelevant from a semantics POV.</p>\n</blockquote>",
        "id": 327889075,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676415091
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771#issuecomment-1430511899\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5771\">issue #5771</a>:</p>\n<blockquote>\n<p>It's mechanical but it's not completely straightforward -- computing the captured closure to pass args to the synthetic term takes some semantic analysis, and splitting the match arms into separate rules is also the first time we have a \"fork\" in control flow. I'm not saying we shouldn't do it, but I guess my position is that it if the desugaring approach involves this significant additional complexity anyway, it might be worth thinking of doing it \"the right way\" from the start.</p>\n</blockquote>",
        "id": 327891577,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676416095
    }
]