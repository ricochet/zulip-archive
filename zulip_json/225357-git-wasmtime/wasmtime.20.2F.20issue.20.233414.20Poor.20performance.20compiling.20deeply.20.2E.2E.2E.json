[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>This was found recently via a fuzz-generated test case, but it appears that Wasmtime has relatively poor performance compiling functions that have deeply nested blocks with little actual branching in them.</p>\n<p>This wasm file: <a href=\"https://github.com/bytecodealliance/wasmtime/files/7280553/bar.wasm.gz\">bar.wasm.gz</a> currently takes ~10ms to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\">  </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"mi\">254</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"mf\">0.016</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Execution with fuzzing is 20-30x slower than normal execution, and the original file that this came from had ~100 copies of this function. Fuzzing also disables parallel compilation, which means that it's a 2000-3000x slowdown from the measurement here, which accounts for the roughly 30s the original module takes to compile with fuzzing enabled, leading to the timeout.</p>\n<p>This is probably a case that will be helped by the new register allocator (eventually), but I suspect there's a lot of low-hanging fruit for improving this codegen as well.</p>\n</blockquote>",
        "id": 256112368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1633373620
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>This was found recently via a fuzz-generated test case, but it appears that Wasmtime has relatively poor performance compiling functions that have deeply nested blocks with little actual branching in them.</p>\n<p>This wasm file: <a href=\"https://github.com/bytecodealliance/wasmtime/files/7280553/bar.wasm.gz\">bar.wasm.gz</a> currently takes ~10ms to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\">  </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"mi\">254</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"mf\">0.016</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Execution with fuzzing is 20-30x slower than normal execution, and the original file that this came from had ~100 copies of this function. Fuzzing also disables parallel compilation, which means that it's a 2000-3000x slowdown from the measurement here, which accounts for the roughly 30s the original module takes to compile with fuzzing enabled, leading to the timeout.</p>\n<p>This is probably a case that will be helped by the new register allocator (eventually), but I suspect there's a lot of low-hanging fruit for improving this codegen as well.</p>\n</blockquote>",
        "id": 256112369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1633373620
    },
    {
        "content": "<p>jlb6740 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>This was found recently via a fuzz-generated test case, but it appears that Wasmtime has relatively poor performance compiling functions that have deeply nested blocks with little actual branching in them.</p>\n<p>This wasm file: <a href=\"https://github.com/bytecodealliance/wasmtime/files/7280553/bar.wasm.gz\">bar.wasm.gz</a> currently takes ~10ms to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\">  </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"mi\">254</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"mf\">0.016</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Execution with fuzzing is 20-30x slower than normal execution, and the original file that this came from had ~100 copies of this function. Fuzzing also disables parallel compilation, which means that it's a 2000-3000x slowdown from the measurement here, which accounts for the roughly 30s the original module takes to compile with fuzzing enabled, leading to the timeout.</p>\n<p>This is probably a case that will be helped by the new register allocator (eventually), but I suspect there's a lot of low-hanging fruit for improving this codegen as well.</p>\n</blockquote>",
        "id": 261210184,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1636690031
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>This was found recently via a fuzz-generated test case, but it appears that Wasmtime has relatively poor performance compiling functions that have deeply nested blocks with little actual branching in them.</p>\n<p>This wasm file: <a href=\"https://github.com/bytecodealliance/wasmtime/files/7280553/bar.wasm.gz\">bar.wasm.gz</a> currently takes ~10ms to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\">  </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"mi\">254</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"mf\">0.016</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Execution with fuzzing is 20-30x slower than normal execution, and the original file that this came from had ~100 copies of this function. Fuzzing also disables parallel compilation, which means that it's a 2000-3000x slowdown from the measurement here, which accounts for the roughly 30s the original module takes to compile with fuzzing enabled, leading to the timeout.</p>\n<p>This is probably a case that will be helped by the new register allocator (eventually), but I suspect there's a lot of low-hanging fruit for improving this codegen as well.</p>\n</blockquote>",
        "id": 270065929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1643648502
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414#issuecomment-1109906289\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>I'm going to close this given the discussion on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4060\">https://github.com/bytecodealliance/wasmtime/issues/4060</a>, these sorts of outliers are expected and eventually we'll want to tweak fuzzers to not generate these patterns of code.</p>\n</blockquote>",
        "id": 280222928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650985230
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3414\">issue #3414</a>:</p>\n<blockquote>\n<p>This was found recently via a fuzz-generated test case, but it appears that Wasmtime has relatively poor performance compiling functions that have deeply nested blocks with little actual branching in them.</p>\n<p>This wasm file: <a href=\"https://github.com/bytecodealliance/wasmtime/files/7280553/bar.wasm.gz\">bar.wasm.gz</a> currently takes ~10ms to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">disable</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\">  </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"mf\">0.02</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"mi\">254</span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"mf\">0.016</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Execution with fuzzing is 20-30x slower than normal execution, and the original file that this came from had ~100 copies of this function. Fuzzing also disables parallel compilation, which means that it's a 2000-3000x slowdown from the measurement here, which accounts for the roughly 30s the original module takes to compile with fuzzing enabled, leading to the timeout.</p>\n<p>This is probably a case that will be helped by the new register allocator (eventually), but I suspect there's a lot of low-hanging fruit for improving this codegen as well.</p>\n</blockquote>",
        "id": 280222931,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1650985230
    }
]