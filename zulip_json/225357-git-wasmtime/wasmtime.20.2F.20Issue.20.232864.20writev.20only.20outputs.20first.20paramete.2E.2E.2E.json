[
    {
        "content": "<p>expnkx labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<h3>Test Case</h3>\n<p>#include&lt;fast_io.h&gt;</p>\n<p>int main()<br>\n{<br>\n    print(fast_io::out(),\"Hello World\\n\",fast_io::posix_clock_gettime(fast_io::posix_clock_id::realtime));<br>\n}</p>\n<h3>Expected Results</h3>\n<p>It should output all results.</p>\n<h3>Actual Results</h3>\n<p>It only outputs the first one</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: main</p>\n<p>Operating system: windows</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>-stdlib=libstdc++</p>\n</blockquote>",
        "id": 236553551,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619633575
    },
    {
        "content": "<p>expnkx opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<h3>Test Case</h3>\n<p>#include&lt;fast_io.h&gt;</p>\n<p>int main()<br>\n{<br>\n    print(fast_io::out(),\"Hello World\\n\",fast_io::posix_clock_gettime(fast_io::posix_clock_id::realtime));<br>\n}</p>\n<h3>Expected Results</h3>\n<p>It should output all results.</p>\n<h3>Actual Results</h3>\n<p>It only outputs the first one</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: main</p>\n<p>Operating system: windows</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>-stdlib=libstdc++</p>\n</blockquote>",
        "id": 236553553,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619633576
    },
    {
        "content": "<p>expnkx edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<h3>Test Case</h3>\n<p><a href=\"https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512\">https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512</a></p>\n<p>#include&lt;fast_io.h&gt;</p>\n<p>int main()<br>\n{<br>\n    print(fast_io::out(),\"Hello World\\n\",fast_io::posix_clock_gettime(fast_io::posix_clock_id::realtime));<br>\n}</p>\n<h3>Expected Results</h3>\n<p>It should output all results.</p>\n<h3>Actual Results</h3>\n<p>It only outputs the first one</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: main</p>\n<p>Operating system: windows</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>-stdlib=libstdc++</p>\n</blockquote>",
        "id": 236553650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619633620
    },
    {
        "content": "<p>expnkx edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<h3>Test Case</h3>\n<p><a href=\"https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512\">https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512</a></p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"cpf\">&lt;fast_io.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">out</span><span class=\"p\">(),</span><span class=\"s\">\"Hello World</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">posix_clock_gettime</span><span class=\"p\">(</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">posix_clock_id</span><span class=\"o\">::</span><span class=\"n\">realtime</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h3>Expected Results</h3>\n<p>It should output all results.</p>\n<h3>Actual Results</h3>\n<p>It only outputs the first one</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: main</p>\n<p>Operating system: windows</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>-stdlib=libstdc++</p>\n</blockquote>",
        "id": 236553667,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619633629
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828676944\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>As with POSIX <code>writev</code>, <code>__wasi_fd_write</code> may write fewer bytes than requested. It should return the number of bytes read, so that you can call it again with the unwritten portion of the buffer(s).</p>\n</blockquote>",
        "id": 236554738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619634074
    },
    {
        "content": "<p>expnkx <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828765181\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>As with POSIX <code>writev</code>, <code>__wasi_fd_write</code> may write fewer bytes than requested. It should return the number of bytes read, so that you can call it again with the unwritten portion of the buffer(s).</p>\n</blockquote>\n<p>The problem is that these approaches break the atomicity of syscalls. And it might in a situation it only writes zero-bytes example. Also it leads to binary bloat.</p>\n<p>It requires a fix in wasmtime tbh.</p>\n<p><a href=\"https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613\">https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613</a><br>\nHere is my implementation on windows. Use LockFile to lock the file</p>\n</blockquote>",
        "id": 236575060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619642678
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828765181\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>As with POSIX <code>writev</code>, <code>__wasi_fd_write</code> may write fewer bytes than requested. It should return the number of bytes read, so that you can call it again with the unwritten portion of the buffer(s).</p>\n</blockquote>\n<p>The problem is that these approaches break the atomicity of syscalls. And it might in a situation it only writes zero-bytes example, the users have no idea how to deal with it. Also, it leads to binary bloat.</p>\n<p>It requires a fix in wasmtime tbh.</p>\n<p><a href=\"https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613\">https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613</a><br>\nHere is my implementation on windows. Use LockFile to lock the file</p>\n</blockquote>",
        "id": 236575102,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619642698
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828772297\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>What if part of the data could be written and then an error is returned? It would be incorrect to suggest that no data was written by returning an error. Returning only how many bytes werw actually written would still require the loop. The error could be EWOULDBLOCK for example which in case of async usage indicates that it will be possible in the future to write more data. In that case the application needs to know how many bytes were written and try again later. Moving thr write loop into the write/writev call also doesn't match the expectations of pretty much every unix application.</p>\n</blockquote>",
        "id": 236576303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619643191
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828774528\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example, the users have no idea how to deal with it.</p>\n</blockquote>\n<p>I don't think that is possible. For read itbis possible though and indicates EOF.</p>\n</blockquote>",
        "id": 236576860,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619643410
    },
    {
        "content": "<p>expnkx <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828776095\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example, the users have no idea how to deal with it.</p>\n</blockquote>\n<p>I don't think that is possible. For read itbis possible though and indicates EOF.</p>\n</blockquote>\n<p>This is not readv or read. This is writev. It does not mean it is EOF.</p>\n</blockquote>",
        "id": 236577153,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619643561
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828776095\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example, the users have no idea how to deal with it.</p>\n</blockquote>\n<p>I don't think that is possible. For read itbis possible though and indicates EOF.</p>\n</blockquote>\n<p>This is not readv or read. This is writev. It does not mean it is EOF.<br>\nChecking size is very bad idea imo for this since it can lead to block of the process.</p>\n</blockquote>",
        "id": 236577226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619643602
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828774528\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example, the users have no idea how to deal with it.</p>\n</blockquote>\n<p>I don't think that is possible. For read it is possible though and indicates EOF.</p>\n</blockquote>",
        "id": 236577325,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619643610
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828781557\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>The code bloat is a consequence of POSIX here; no implementation on a POSIX host can guarantee that it'll write all of all the buffers atomically without being interrupted. There has to be a loop somewhere, and if we follow POSIX, we can't put the loop in the WASI implementation because that would make it non-atomic.</p>\n<p>WASI is working on some new I/O facilities which don't follow POSIX as closely, and when those are available we may have other options here. But right now, we have <code>__wasi_fd_write</code> and it does follow POSIX, and POSIX requires you to have a loop if you want all the buffers printed.</p>\n</blockquote>",
        "id": 236579681,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644127
    },
    {
        "content": "<p>expnkx <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828784425\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>The code bloat is a consequence of POSIX here; no implementation on a POSIX host can guarantee that it'll write all of all the buffers atomically without being interrupted. There has to be a loop somewhere, and if we follow POSIX, we can't put the loop in the WASI implementation because that would make it non-atomic.</p>\n<p>WASI is working on some new I/O facilities which don't follow POSIX as closely, and when those are available we may have other options here. But right now, we have <code>__wasi_fd_write</code> and it does follow POSIX, and POSIX requires you to have a loop if you want all the buffers printed.</p>\n</blockquote>\n<p>this has nothing to do with the code works on Linux but not on windows. Windows can work as long as you lock the file.<br>\nIt is absolutely the project's fault, not POSIX. POSIX never said you can provide a buggy implementation.</p>\n</blockquote>",
        "id": 236580959,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644450
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828784425\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>The code bloat is a consequence of POSIX here; no implementation on a POSIX host can guarantee that it'll write all of all the buffers atomically without being interrupted. There has to be a loop somewhere, and if we follow POSIX, we can't put the loop in the WASI implementation because that would make it non-atomic.</p>\n<p>WASI is working on some new I/O facilities which don't follow POSIX as closely, and when those are available we may have other options here. But right now, we have <code>__wasi_fd_write</code> and it does follow POSIX, and POSIX requires you to have a loop if you want all the buffers printed.</p>\n</blockquote>\n<p>this has nothing to do with the code works on Linux but not on windows. Windows can work as long as you lock the file. I write the same code too and I never have any issues on windows.<br>\nIt is absolutely the project's fault, not POSIX. POSIX never said you can provide a buggy implementation.</p>\n</blockquote>",
        "id": 236581131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644478
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828784425\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>The code bloat is a consequence of POSIX here; no implementation on a POSIX host can guarantee that it'll write all of all the buffers atomically without being interrupted. There has to be a loop somewhere, and if we follow POSIX, we can't put the loop in the WASI implementation because that would make it non-atomic.</p>\n<p>WASI is working on some new I/O facilities which don't follow POSIX as closely, and when those are available we may have other options here. But right now, we have <code>__wasi_fd_write</code> and it does follow POSIX, and POSIX requires you to have a loop if you want all the buffers printed.</p>\n</blockquote>\n<p>this has nothing to do with the code works on Linux but not on windows. Windows can work as long as you lock the file. I write the same code too and I never have any issues on windows.<br>\nIt is absolutely the project's fault, not POSIX. POSIX never said you can provide a buggy implementation.</p>\n<p>Atomicity of syscalls cannot be guaranteed with writev either. an example is a remote console or pipe on Linux. writev is not atomic either. However, file operations beside NFS are always atomic.</p>\n</blockquote>",
        "id": 236581897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644690
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828784425\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>The code bloat is a consequence of POSIX here; no implementation on a POSIX host can guarantee that it'll write all of all the buffers atomically without being interrupted. There has to be a loop somewhere, and if we follow POSIX, we can't put the loop in the WASI implementation because that would make it non-atomic.</p>\n<p>WASI is working on some new I/O facilities which don't follow POSIX as closely, and when those are available we may have other options here. But right now, we have <code>__wasi_fd_write</code> and it does follow POSIX, and POSIX requires you to have a loop if you want all the buffers printed.</p>\n</blockquote>\n<p>this has nothing to do with the code works on Linux but not on windows. Windows can work as long as you lock the file. I write the same code too and I never have any issues on windows.<br>\nIt is absolutely the project's fault, not POSIX. POSIX never said you can provide a buggy implementation.</p>\n<p>Atomicity of syscalls cannot be guaranteed with writev either. an example is a remote console or pipe on Linux. writev is not atomic either. However, file operations besides NFS are always atomic.</p>\n<p>The code works just fine on windows and it ensures atomicity for file operations.<br>\n<a href=\"https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613\">https://github.com/expnkx/fast_io/blob/725695664091bc4e8fbb05df446aaad93642bbf5/include/fast_io_hosted/platforms/win32.h#L613</a></p>\n</blockquote>",
        "id": 236582137,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644767
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828788376\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>The implementation is not buggy on windows. It can behave in exactly the same way on linux too. You are just lucky that your the amount of text you are printing is smaller than the pipe buffer size (64k on linux) and that your terminal immediately empties the pipe as soon as data gets received. If you were to write more than 64k at once, you are guaranteed to only get a partial write and when your terminal is too slow, you may get a partial write. This is just the semantics of the write function as defined by POSIX.</p>\n</blockquote>",
        "id": 236582611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619644888
    },
    {
        "content": "<p>iximeow <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828795107\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example</p>\n</blockquote>\n<p>i also don't think this is possible - wasi-libc, wasmtime, and cap-std just pass the iovecs to Rust's stdlib. the <code>default_write_vectored</code> impl there selects the first _nonempty_ iovec for writing. if <code>write_vectored</code> returns zero it's because the system returned zero; either the iovec selected for writing was zero-length (and all iovs were zero-length), or a non-empty vector was selected for writing and the OS itself wrote zero bytes.</p>\n</blockquote>",
        "id": 236584869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619645683
    },
    {
        "content": "<p>iximeow edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828795107\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example</p>\n</blockquote>\n<p>i also don't think this is possible - wasi-libc, wasmtime, and cap-std currently just pass the iovecs to Rust's stdlib. the <code>default_write_vectored</code> impl there selects the first _nonempty_ iovec for writing. if <code>write_vectored</code> returns zero it's because the system returned zero; either the iovec selected for writing was zero-length (and all iovs were zero-length), or a non-empty vector was selected for writing and the OS itself wrote zero bytes.</p>\n</blockquote>",
        "id": 236584939,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619645728
    },
    {
        "content": "<p>expnkx <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828796967\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example</p>\n</blockquote>\n<p>i also don't think this is possible - wasi-libc, wasmtime, and cap-std currently just pass the iovecs to Rust's stdlib. the <code>default_write_vectored</code> impl there selects the first _nonempty_ iovec for writing. if <code>write_vectored</code> returns zero it's because the system returned zero; either the iovec selected for writing was zero-length (and all iovs were zero-length), or a non-empty vector was selected for writing and the OS itself wrote zero bytes.</p>\n</blockquote>\n<p>wraps around rust's stdlib are not something that is supposed to work with wasm imo. WASI is to abstract OS interface, not to abstract language interface.</p>\n</blockquote>",
        "id": 236585240,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619645892
    },
    {
        "content": "<p>expnkx edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828796967\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>And it might in a situation it only writes zero-bytes example</p>\n</blockquote>\n<p>i also don't think this is possible - wasi-libc, wasmtime, and cap-std currently just pass the iovecs to Rust's stdlib. the <code>default_write_vectored</code> impl there selects the first _nonempty_ iovec for writing. if <code>write_vectored</code> returns zero it's because the system returned zero; either the iovec selected for writing was zero-length (and all iovs were zero-length), or a non-empty vector was selected for writing and the OS itself wrote zero bytes.</p>\n</blockquote>\n<p>wraps around rust's stdlib are not something that is supposed to work with wasm imo. WASI is to abstract OS interface, not to abstract language interface.<br>\nBTW I do see IO performance bottleneck with using Rust stdlib.</p>\n</blockquote>",
        "id": 236585373,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619645994
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828805900\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>POSIX <a href=\"https://pubs.opengroup.org/onlinepubs/007904875/functions/write.html\">says</a> \"If write() is interrupted by a signal after it successfully writes some data, it shall return the number of bytes written\". So even on Linux, where things may appear to work, they're not guaranteed to work in all cases. The system call could still be interrupted in some circumstances, and could perform an incomplete write in some circumstances. Consequently, Wasm code needs a loop if it wants all the buffers printed.</p>\n<p>In theory, a <code>__wasi_fd_write</code> call could return zero. But this shouldn't be any different from it returning any other number less than the requested number. If the wasm code has a loop, the zero case isn't special.</p>\n<p>WASI today is a synchronous API. It blocks. Many people are obviously interested in async I/O; various approaches are <a href=\"https://github.com/WebAssembly/stack-switching\">in development</a>, but not available yet. So for now, it's a blocking API, and adding a loop around it doesn't introduce any new blocking.</p>\n</blockquote>",
        "id": 236586850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619646873
    },
    {
        "content": "<p>expnkx <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828808714\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>POSIX <a href=\"https://pubs.opengroup.org/onlinepubs/007904875/functions/write.html\">says</a> \"If write() is interrupted by a signal after it successfully writes some data, it shall return the number of bytes written\". So even on Linux, where things may appear to work, they're not guaranteed to work in all cases. The system call could still be interrupted in some circumstances, and could perform an incomplete write in some circumstances. Consequently, Wasm code needs a loop if it wants all the buffers printed.</p>\n<p>In theory, a <code>__wasi_fd_write</code> call could return zero. But this shouldn't be any different from it returning any other number less than the requested number. If the wasm code has a loop, the zero case isn't special.</p>\n<p>WASI today is a synchronous API. It blocks. Many people are obviously interested in async I/O; various approaches are <a href=\"https://github.com/WebAssembly/stack-switching\">in development</a>, but not available yet. So for now, it's a blocking API, and adding a loop around it doesn't introduce any new blocking.</p>\n</blockquote>\n<p>if the API keeps returning 0, you get a block.</p>\n</blockquote>",
        "id": 236587337,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619647203
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-828817963\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<blockquote>\n<p>if the API keeps returning 0, you get a block.</p>\n</blockquote>\n<p>That is correct. The API itself can also block.</p>\n</blockquote>",
        "id": 236589264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1619648293
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864#issuecomment-834693027\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>The implementation is working as intended. To write a complete string reliably with the current WASI APIs, it's necessary to wrap the <code>__wasi_fd_write</code> call in a loop, as libc does.</p>\n</blockquote>",
        "id": 237872825,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1620413726
    },
    {
        "content": "<p>sunfishcode closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2864\">Issue #2864</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<h3>Test Case</h3>\n<p><a href=\"https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512\">https://github.com/expnkx/fast_io/blob/02cc01ceea5cba4a40e35dc4ae1fd64e68148e2d/include/fast_io_hosted/platforms/posix.h#L1512</a></p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"cpf\">&lt;fast_io.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">out</span><span class=\"p\">(),</span><span class=\"s\">\"Hello World</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">posix_clock_gettime</span><span class=\"p\">(</span><span class=\"n\">fast_io</span><span class=\"o\">::</span><span class=\"n\">posix_clock_id</span><span class=\"o\">::</span><span class=\"n\">realtime</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h3>Expected Results</h3>\n<p>It should output all results.</p>\n<h3>Actual Results</h3>\n<p>It only outputs the first one</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: main</p>\n<p>Operating system: windows</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p>-stdlib=libstdc++</p>\n</blockquote>",
        "id": 237872826,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1620413726
    }
]