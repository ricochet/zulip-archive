[
    {
        "content": "<p>ZetaNumbers opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types like <code>Memory</code> or <code>Instance</code> are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?<br>\n</p>\n</blockquote>",
        "id": 266572404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641066866
    },
    {
        "content": "<p>ZetaNumbers edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types like <code>Memory</code> or <code>Instance</code> are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a null store concept.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?<br>\n</p>\n</blockquote>",
        "id": 266579953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641076881
    },
    {
        "content": "<p>ZetaNumbers edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types like <code>Memory</code> or <code>Instance</code> are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a concept of a null store which cannot be accessed or instantiated.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?<br>\n</p>\n</blockquote>",
        "id": 266580590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641077775
    },
    {
        "content": "<p>ZetaNumbers edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types (<code>Global</code>, <code>Table</code>, <code>Func</code>, <code>Instance</code>, <code>Memory</code>) are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<p>Adds a default constructor for these types in <code>wasmtime-cpp</code> bindings.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a concept of a null store which cannot be accessed or instantiated.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?<br>\n</p>\n</blockquote>",
        "id": 266582917,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641081066
    },
    {
        "content": "<p>ZetaNumbers edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types (<code>Global</code>, <code>Table</code>, <code>Func</code>, <code>Instance</code>, <code>Memory</code>) are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<p>Adds ability to create these types inside of the const context (static definitions, const functions).</p>\n<p>Adds default constructors for these types in <code>wasmtime-cpp</code> bindings.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a concept of a null store which cannot be accessed or instantiated.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?<br>\n</p>\n</blockquote>",
        "id": 266584278,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641082735
    },
    {
        "content": "<p>ZetaNumbers <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633#issuecomment-1003641263\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<p>Implementation for the first method is partially complete on <a href=\"https://github.com/ZetaNumbers/wasmtime/tree/null-stored\">my fork</a>.</p>\n</blockquote>",
        "id": 266584435,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641082981
    },
    {
        "content": "<p>ZetaNumbers edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types (<code>Global</code>, <code>Table</code>, <code>Func</code>, <code>Instance</code>, <code>Memory</code>) are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<p>Adds ability to create these types inside of the const context (static definitions, const functions).</p>\n<p>Adds default constructors for these types in <code>wasmtime-cpp</code> bindings.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a concept of a null store which cannot be accessed or instantiated.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?</p>\n<p>Anyway this is a marginal problem, so i could just use <code>Option&lt;Memory&gt;</code>.</p>\n</blockquote>",
        "id": 266604760,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641115843
    },
    {
        "content": "<p>ZetaNumbers <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633#issuecomment-1003689184\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<p>After some thought, i think it's better to stick with <code>Option&lt;Memory&gt;</code>. Perhaps we could add a trait to implement <code>Memory</code>'s interface on <code>Option&lt;Memory&gt;</code> too, but it feels like there's a lot more to explore with this design (like branded types). Perhaps the right path for now would be to add guard types, instead of having <code>store: impl AsContext[Mut]</code> argument on every function.</p>\n</blockquote>",
        "id": 266605284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641116735
    },
    {
        "content": "<p>ZetaNumbers closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3633\">issue #3633</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Null value for stored types. Underlying data of handle types (<code>Global</code>, <code>Table</code>, <code>Func</code>, <code>Instance</code>, <code>Memory</code>) are owned by <code>Store</code>, so to operate on these handles you pass <code>impl AsContext[Mut]</code> as an argument. I think it would be useful to add a support for null handle types, which do not have any instance of <code>Store</code> they're handle to.</p>\n<h4>Benefit</h4>\n<p>I am trying to access memory inside of the import function. I am using import memory, so <code>Caller::get_export</code> is not an option. I could store <code>Memory</code> handle inside of the <code>Store::data</code>, but to instantiate memory handle you need the <code>Store</code>. I could use <code>Option&lt;Memory&gt;</code>, but for example <code>Memory::read</code> already panics if this memory doesn’t belong to store. So I thought perhaps more idiomatic way to solve this would be to create a dummy <code>Memory</code> for a dummy <code>Store</code>, create an actual <code>Store</code> with this dummy <code>Memory</code> inside, create an actual <code>Memory</code> using the actual <code>Store</code>, and replace the dummy <code>Memory</code> with an actual one. This process could be simplified if there was something like <code>Memory::null</code>.</p>\n<p>Adds ability to create these types inside of the const context (static definitions, const functions).</p>\n<p>Adds default constructors for these types in <code>wasmtime-cpp</code> bindings.</p>\n<h4>Implementation</h4>\n<p><code>wasmtime::store::data::Stored&lt;T&gt;</code> is used to create handles to a <code>Store</code>.</p>\n<ul>\n<li>We could add <code>Stored&lt;T&gt;</code> null value. If <code>store_id == 0</code> then it's null. Adds a concept of a null store which cannot be accessed or instantiated.</li>\n<li>We could replace use of <code>Stored&lt;T&gt;</code> for <code>Option&lt;Stored&lt;T&gt;&gt;</code> and also focus  <code>impl&lt;T&gt; Index&lt;Option&lt;Stored&lt;T&gt;&gt;&gt; for StoreData</code>. Perhaps also remove old interface like <code>impl&lt;T&gt; Index&lt;Stored&lt;T&gt;&gt; for StoreData</code>? Because <code>Stored::&lt;T&gt;::store_id: NonZeroU64</code>, size of <code>Option&lt;Stored&lt;T&gt;&gt;</code> is same as <code>Stored&lt;T&gt;</code>.</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Perhaps something like <code>&lt;Store&lt;T&gt;&gt;::map_data</code> or <code>RawStore</code> without type params could also help my problem, if that's possible?</p>\n<p>Anyway this is a marginal problem, so i could just use <code>Option&lt;Memory&gt;</code>.</p>\n</blockquote>",
        "id": 266608466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1641121280
    }
]