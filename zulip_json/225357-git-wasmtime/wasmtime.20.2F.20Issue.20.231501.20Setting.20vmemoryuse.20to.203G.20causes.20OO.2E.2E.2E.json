[
    {
        "content": "<p>plicease opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue?</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ulimit -v 3145728\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat hello.rs\nfn main() {\n  println!(&quot;Hello, world!&quot;);\n}\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc hello.rs --target wasm32-wasi\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ./wasmtime hello.wasm\nError: failed to run main module `hello.wasm`\n\nCaused by:\n    0: failed to instantiate &quot;hello.wasm&quot;\n    1: Insufficient resources: Cannot allocate memory (os error 12)\n</pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>I don't expect such a high virtual memory limit to cause an OOM on such a small program. </p>\n<ul>\n<li>Which Wasmtime version / commit hash / branch are you using?</li>\n</ul>\n<p>This is the using the <code>0.15.0</code> tarball, but I have been able to reproduce it also using the <code>0.15.0</code> c-api via Perl/FFI, see <a href=\"https://github.com/perlwasm/Wasm/issues/22\" title=\"https://github.com/perlwasm/Wasm/issues/22\">https://github.com/perlwasm/Wasm/issues/22</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>I was able to reproduce on my Debian Linux x864_64 box:</p>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc --version\nrustc 1.42.0 (b8cedc004 2020-03-09)\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat /etc/debian_version\n9.12\n</pre></div>\n\n\n<p>cpantesters use a variety of platforms, with the binary wasmtime tarball, so I am not sure that it is matters</p>\n</blockquote>",
        "id": 193714183,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586699779
    },
    {
        "content": "<p>plicease labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue?</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ulimit -v 3145728\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat hello.rs\nfn main() {\n  println!(&quot;Hello, world!&quot;);\n}\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc hello.rs --target wasm32-wasi\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ./wasmtime hello.wasm\nError: failed to run main module `hello.wasm`\n\nCaused by:\n    0: failed to instantiate &quot;hello.wasm&quot;\n    1: Insufficient resources: Cannot allocate memory (os error 12)\n</pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>I don't expect such a high virtual memory limit to cause an OOM on such a small program. </p>\n<ul>\n<li>Which Wasmtime version / commit hash / branch are you using?</li>\n</ul>\n<p>This is the using the <code>0.15.0</code> tarball, but I have been able to reproduce it also using the <code>0.15.0</code> c-api via Perl/FFI, see <a href=\"https://github.com/perlwasm/Wasm/issues/22\" title=\"https://github.com/perlwasm/Wasm/issues/22\">https://github.com/perlwasm/Wasm/issues/22</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>I was able to reproduce on my Debian Linux x864_64 box:</p>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc --version\nrustc 1.42.0 (b8cedc004 2020-03-09)\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat /etc/debian_version\n9.12\n</pre></div>\n\n\n<p>cpantesters use a variety of platforms, with the binary wasmtime tarball, so I am not sure that it is matters</p>\n</blockquote>",
        "id": 193714184,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586699779
    },
    {
        "content": "<p>plicease edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue?</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ulimit -v 3145728\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat hello.rs\nfn main() {\n  println!(&quot;Hello, world!&quot;);\n}\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc hello.rs --target wasm32-wasi\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ./wasmtime hello.wasm\nError: failed to run main module `hello.wasm`\n\nCaused by:\n    0: failed to instantiate &quot;hello.wasm&quot;\n    1: Insufficient resources: Cannot allocate memory (os error 12)\n</pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>I don't expect such a high virtual memory limit to cause an OOM on such a small program. </p>\n<ul>\n<li>Which Wasmtime version / commit hash / branch are you using?</li>\n</ul>\n<p>This is the using the <code>0.15.0</code> tarball, but I have been able to reproduce it also using the <code>0.15.0</code> c-api via Perl/FFI, see <a href=\"https://github.com/perlwasm/Wasm/issues/22\" title=\"https://github.com/perlwasm/Wasm/issues/22\">https://github.com/perlwasm/Wasm/issues/22</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>I was able to reproduce on my Debian Linux x864_64 box:</p>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc --version\nrustc 1.42.0 (b8cedc004 2020-03-09)\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat /etc/debian_version\n9.12\n</pre></div>\n\n\n<p>cpantesters use a variety of platforms, with the binary wasmtime tarball, so I am not sure that this matters, but including for completeness.</p>\n</blockquote>",
        "id": 193714192,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586699809
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612620119\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612620119\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>I think <code>ulimit -v</code> expects a byte value, not a kilobyte value as you expected. For example running <code>ulimit -v 100</code> crashes my shell, while it only consumes ~15kb of memory.</p>\n</blockquote>",
        "id": 193714526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586700342
    },
    {
        "content": "<p>bjorn3 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612620119\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612620119\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>I think <code>ulimit -v</code> expects a byte value, not a kilobyte value as you expected. For example running <code>ulimit -v 100</code> crashes my shell, while it only consumes ~15kb of memory. This means that you limited Wasmtime to 3MiB not 3GiB.</p>\n</blockquote>",
        "id": 193714570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586700384
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612623832\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612623832\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>The interface seems to vary from shell to shell, but both bash and tcsh are reporting kbytes for me:</p>\n<div class=\"codehilite\"><pre><span></span>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ulimit -a\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 14549\nmax locked memory       (kbytes, -l) 64\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 1024\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 14549\nvirtual memory          (kbytes, -v) 3145728\nfile locks                      (-x) unlimited\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ tcsh\nmuse% limit\ncputime      unlimited\nfilesize     unlimited\ndatasize     unlimited\nstacksize    8192 kbytes\ncoredumpsize 0 kbytes\nmemoryuse    unlimited\nvmemoryuse   3145728 kbytes\ndescriptors  1024\nmemorylocked 64 kbytes\nmaxproc      14549\nmaxlocks     unlimited\nmaxsignal    14549\nmaxmessage   819200\nmaxnice      0\nmaxrtprio    0\nmaxrttime    unlimited\n</pre></div>\n\n\n</blockquote>",
        "id": 193715322,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586701641
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612624719\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612624719\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>The cpantesters were using <code>BSD::Resource::RLIMIT_AS</code> set to <code>3*1024*1024*1024</code></p>\n<p>I am not tbh familiar with <code>BSD::Resource</code> module, but I am fairly confident that they are not setting the limit to 3MB, they test tones of Perl modules every day and the results wouldn't be very useful with such a low limit.</p>\n<p><a href=\"https://github.com/eserte/srezic-misc/blob/127d3e2c7dc58ed15aa925a199c4ed004936fd13/scripts/cpan_smoke_modules#L1599\" title=\"https://github.com/eserte/srezic-misc/blob/127d3e2c7dc58ed15aa925a199c4ed004936fd13/scripts/cpan_smoke_modules#L1599\">https://github.com/eserte/srezic-misc/blob/127d3e2c7dc58ed15aa925a199c4ed004936fd13/scripts/cpan_smoke_modules#L1599</a><br>\n<a href=\"https://github.com/perlwasm/Wasm/issues/22#issuecomment-612620036\" title=\"https://github.com/perlwasm/Wasm/issues/22#issuecomment-612620036\">https://github.com/perlwasm/Wasm/issues/22#issuecomment-612620036</a></p>\n</blockquote>",
        "id": 193715498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586701965
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612625323\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612625323\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>I experimentally tried to run <code>ulimit -v</code> in bash and then running <code>ps</code> to report the amount of memory used by <code>ps</code>. It worked fine when I set it to exactly the amount of <code>VSZ</code> used by <code>ps</code> (7560 bytes), but it gave an OOM when setting it exactly 1 less than that. This confirms that it is measured in bytes, not kilobytes.</p>\n<blockquote>\n<p>3<em>1024</em>1024*1024</p>\n</blockquote>\n<p>That is 3GiB, not 3MiB</p>\n</blockquote>",
        "id": 193715633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586702170
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>My man page documents that ps indicates VSZ is in kilobytes:</p>\n<div class=\"codehilite\"><pre><span></span>vsz         VSZ       virtual memory size of the process in KiB (1024-byte units).  Device mappings are currently excluded; this is subject to change.  (alias vsize).\n``\n\nMaybe yours is different?  My bash man page also says that ulimit -v is in 1024 byte increments:\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>          If limit is given, and the -a option is not used, limit is the new value of the specified resource.  If no option is given, then -f is assumed.  Values are in  1024-byte\n          increments, except for -t, which is in seconds; -p, which is in units of 512-byte blocks; -P, -T, -b, -k, -n, and -u, which are unscaled values; and, when in Posix mode,\n          -c and -f, which are in 512-byte increments.  The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>The outputs of `ulimit -a` and tcsh `limit` do also seem to indicate kbyes.\n~~~\n</pre></div>\n\n\n</blockquote>",
        "id": 193716171,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586703123
    },
    {
        "content": "<p>plicease edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>My man page documents that ps indicates VSZ is in kilobytes:</p>\n<div class=\"codehilite\"><pre><span></span>vsz         VSZ       virtual memory size of the process in KiB (1024-byte units).  Device mappings are currently excluded; this is subject to change.  (alias vsize).\n</pre></div>\n\n\n<p>Maybe yours is different?  My bash man page also says that ulimit -v is in 1024 byte increments:</p>\n<div class=\"codehilite\"><pre><span></span>          If limit is given, and the -a option is not used, limit is the new value of the specified resource.  If no option is given, then -f is assumed.  Values are in  1024-byte\n          increments, except for -t, which is in seconds; -p, which is in units of 512-byte blocks; -P, -T, -b, -k, -n, and -u, which are unscaled values; and, when in Posix mode,\n          -c and -f, which are in 512-byte increments.  The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>The outputs of `ulimit -a` and tcsh `limit` do also seem to indicate kbyes.\n~~~\n</pre></div>\n\n\n</blockquote>",
        "id": 193716811,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586704122
    },
    {
        "content": "<p>plicease edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612628254\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>My man page documents that ps indicates VSZ is in kilobytes:</p>\n<div class=\"codehilite\"><pre><span></span>vsz         VSZ       virtual memory size of the process in KiB (1024-byte units).  Device mappings are currently excluded; this is subject to change.  (alias vsize).\n</pre></div>\n\n\n<p>Maybe yours is different?  My bash man page also says that ulimit -v is in 1024 byte increments:</p>\n<div class=\"codehilite\"><pre><span></span>              If limit is given, and the -a option is not used, limit is the new value of the specified resource.  If no option is given, then -f is assumed.  Values are in  1024-byte\n              increments, except for -t, which is in seconds; -p, which is in units of 512-byte blocks; -P, -T, -b, -k, -n, and -u, which are unscaled values; and, when in Posix mode,\n              -c and -f, which are in 512-byte increments.  The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.\n</pre></div>\n\n\n<p>The outputs of <code>ulimit -a</code> and tcsh <code>limit</code> do also seem to indicate kbyes.</p>\n</blockquote>",
        "id": 193716822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586704145
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612631269\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612631269\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>IIUC, this is probably caused by an optimization Wasmtime/Cranelift, just as some other WebAssembly runtimes, employs: instead of doing explicit bounds checks for all memory accesses, the runtime reserves 8GB of guard pages before and after a Wasm instance's memory, which are marked as <code>PROT_NONE</code>, triggering a trap on access, which is then handled by the runtime. For more details, see <a href=\"https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit#!\" title=\"https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit#!\">this write-up an implementation plan for V8</a>.</p>\n<p>CC @sunfishcode, who knows infinitely more about this than me :)</p>\n<p>As an aside, Perlwasm is very exciting! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n</blockquote>",
        "id": 193716944,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586704369
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612633893\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612633893\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<blockquote>\n<p>My man page documents that ps indicates VSZ is in kilobytes:</p>\n</blockquote>\n<p>Ok, my bad.</p>\n</blockquote>",
        "id": 193717590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586705495
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612652139\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-612652139\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<blockquote>\n<p>IIUC, this is probably caused by an optimization Wasmtime/Cranelift, just as some other WebAssembly runtimes, employs: instead of doing explicit bounds checks for all memory accesses, the runtime reserves 8GB of guard pages before and after a Wasm instance's memory, which are marked as <code>PROT_NONE</code>, triggering a trap on access, which is then handled by the runtime. For more details, see <a href=\"https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit#!\" title=\"https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit#!\">this write-up an implementation plan for V8</a>.</p>\n</blockquote>\n<p>Thanks, this is very helpful.  It looks like <code>ulimit -v</code> (and the equivalent which cpantesters use) limits the virtual address space as a way to restrain an out of control process from consuming swap (I am not sure but I don't think <code>ulimit -m</code> works in practice), but includes in its accounting <code>PROT_NONE</code> pages which don't actually consume any resources, at least not the way Wasmtime is using them.  This is a deliberate, and probably reasonable design decision, though I am not sure how to configure cpantesters to get the memory limits they need.</p>\n<blockquote>\n<p>As an aside, Perlwasm is very exciting! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n</blockquote>\n<p>As an aside, I am pretty excited about Wasmtime, and bringing WebAssembly into the Perl ecosystem.</p>\n</blockquote>",
        "id": 193722644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586713722
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-614085140\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-614085140\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>I've posted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1513\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1513\">https://github.com/bytecodealliance/wasmtime/pull/1513</a> which should allow tuning, at runtime, the allocation characteristics of wasm memories. Notably @plicease you'll be able to use the C API to say that memories should <em>not</em> be allocated as 6GB of virtual memory, but rather you can configure memories to be precisely allocated with zero extra overhead. This'll come at the cost of runtime performance of the JIT code, but should help you get tests passing in CI!</p>\n</blockquote>",
        "id": 194041890,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586962136
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-614100377\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-614100377\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<blockquote>\n<p>I've posted #1513 which should allow tuning, at runtime, the allocation characteristics of wasm memories. Notably @plicease you'll be able to use the C API to say that memories should _not_ be allocated as 6GB of virtual memory, but rather you can configure memories to be precisely allocated with zero extra overhead. This'll come at the cost of runtime performance of the JIT code, but should help you get tests passing in CI!</p>\n</blockquote>\n<p>Very cool, I look forward to testing this :)</p>\n</blockquote>",
        "id": 194046241,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1586963697
    },
    {
        "content": "<p>sunfishcode closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<ul>\n<li>What are the steps to reproduce the issue?</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ulimit -v 3145728\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat hello.rs\nfn main() {\n  println!(&quot;Hello, world!&quot;);\n}\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc hello.rs --target wasm32-wasi\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ ./wasmtime hello.wasm\nError: failed to run main module `hello.wasm`\n\nCaused by:\n    0: failed to instantiate &quot;hello.wasm&quot;\n    1: Insufficient resources: Cannot allocate memory (os error 12)\n</code></pre></div>\n\n\n<ul>\n<li>What do you expect to happen? What does actually happen? Does it panic, and<br>\n  if so, with which assertion?</li>\n</ul>\n<p>I don't expect such a high virtual memory limit to cause an OOM on such a small program. </p>\n<ul>\n<li>Which Wasmtime version / commit hash / branch are you using?</li>\n</ul>\n<p>This is the using the <code>0.15.0</code> tarball, but I have been able to reproduce it also using the <code>0.15.0</code> c-api via Perl/FFI, see <a href=\"https://github.com/perlwasm/Wasm/issues/22\" title=\"https://github.com/perlwasm/Wasm/issues/22\">https://github.com/perlwasm/Wasm/issues/22</a></p>\n<ul>\n<li>If relevant, can you include some extra information about your environment?<br>\n  (Rust version, operating system, architecture...)</li>\n</ul>\n<p>I was able to reproduce on my Debian Linux x864_64 box:</p>\n<div class=\"codehilite\"><pre><span></span><code>ollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ rustc --version\nrustc 1.42.0 (b8cedc004 2020-03-09)\nollisg@muse:~/test/wasmtime/wasmtime-v0.15.0-x86_64-linux$ cat /etc/debian_version\n9.12\n</code></pre></div>\n\n\n<p>cpantesters use a variety of platforms, with the binary wasmtime tarball, so I am not sure that this matters, but including for completeness.</p>\n</blockquote>",
        "id": 195785956,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588205402
    },
    {
        "content": "<p>plicease <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-624251121\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501#issuecomment-624251121\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1501\" title=\"https://github.com/bytecodealliance/wasmtime/issues/1501\">Issue #1501</a>:</p>\n<blockquote>\n<p>Looks like <code>wasmtime_config_static_memory_guard_size</code> and <code>wasmtime_config_dynamic_memory_guard_size</code> are missing the _set suffix that the other config setters have.</p>\n</blockquote>",
        "id": 196352626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1588705933
    }
]