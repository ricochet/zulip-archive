[
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the pulley label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">Issue #9747</a>.</p>",
        "id": 486394732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433373
    },
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a></li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a></li>\n</ul>\n</blockquote>",
        "id": 486394733,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433375
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747#issuecomment-2521467200\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"pulley\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: pulley</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 486394828,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433426
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a></li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a></li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n</ul>\n</blockquote>",
        "id": 486395043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433503
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a></li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a></li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.<br>\n```[tasklist]</li>\n</ul>\n<h3>Tasks</h3>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 486395092,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433539
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"err\">```</span><span class=\"p\">[</span><span class=\"n\">tasklist</span><span class=\"p\">]</span>\n<span class=\"p\">###</span><span class=\"w\"> </span><span class=\"n\">Tasks</span>\n</code></pre></div>\n</blockquote>",
        "id": 486395264,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433606
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 486395294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733433619
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[ ] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 486403664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733437448
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747#issuecomment-2521676831\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>Notes for big-endian:</p>\n<ul>\n<li>Need to add big-endian targets for Cranelift --  <a href=\"https://github.com/bytecodealliance/target-lexicon/pull/115\">https://github.com/bytecodealliance/target-lexicon/pull/115</a></li>\n<li>Pulley loads/stores will all have annotated endianness, nothing is \"native endian\"</li>\n<li>New big-endian loads/stores to get added under the \"extended\" opcode space</li>\n<li>Cranelift will use its configuration to select the appropriate pulley instruction, e.g. \"native endianness\" is whatever the configured target uses</li>\n</ul>\n</blockquote>",
        "id": 486409109,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733439970
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[ ] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 486409200,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733440024
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 486605367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733524767
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits?</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487305328,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733851630
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487305507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733851683
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487305654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733851734
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/pulley/CONTRIBUTING.md\">Get all <code>.wast</code> tests passing under Pulley!</a></li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487307845,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733852418
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/pulley/CONTRIBUTING.md\">**Get all <code>.wast</code> tests passing under Pulley!**</a></li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487307884,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733852434
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/pulley/CONTRIBUTING.md\">**Get all <code>.wast</code> tests passing under Pulley!**</a></li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487307928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733852452
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/pulley/CONTRIBUTING.md\">**Get all <code>.wast</code> tests passing under Pulley!!!!**</a></li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 487308036,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733852502
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9783\">https://github.com/bytecodealliance/wasmtime/issues/9783</a></li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488109899,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733926916
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488125644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733930909
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488197315,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733954657
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support</li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488197432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733954708
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488197469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733954728
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[ ] Better debugging support, e.g. print the register state between instructions and print each instruction.</li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488197486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733954737
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488516919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733957642
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target - <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9759\">https://github.com/bytecodealliance/wasmtime/pull/9759</a></li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488516998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733957676
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target - <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9759\">https://github.com/bytecodealliance/wasmtime/pull/9759</a></li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488526742,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733962047
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[ ] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488537196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1733969059
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[ ] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488658966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734017297
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[ ] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488920029,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734123656
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details</li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 488921680,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734124288
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<p>```[tasklist]</p>\n<h3>Tasks</h3>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[ ] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity</li>\n</ul>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 489352350,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734386466
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[ ] Run the full <code>all</code> test suite on 32-bit platforms</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n</ul>\n</blockquote>",
        "id": 489363202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734390177
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n</ul>\n</blockquote>",
        "id": 489380131,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734398074
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Support building Wasmtime with the Pulley interpreter but not the Pulley compiler</li>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n</ul>\n</blockquote>",
        "id": 489570863,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1734469067
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[ ] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[ ] Implement the wide-arithmetic proposal</li>\n</ul>\n</blockquote>",
        "id": 492164077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736189832
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[ ] Implement the wide-arithmetic proposal</li>\n</ul>\n</blockquote>",
        "id": 492184632,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736197394
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[ ] Implement the wide-arithmetic proposal</li>\n<li>[ ] Fuzz pulley</li>\n</ul>\n</blockquote>",
        "id": 492184661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736197405
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[ ] Fuzz pulley</li>\n</ul>\n</blockquote>",
        "id": 492391588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736285802
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 492810265,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736453842
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493011166,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736536603
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493011178,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736536606
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493011189,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736536608
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\"</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493011193,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736536610
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[x] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\" <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9994\">https://github.com/bytecodealliance/wasmtime/pull/9994</a></li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493400465,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736787541
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\" <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9994\">https://github.com/bytecodealliance/wasmtime/pull/9994</a></li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 493424077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736794278
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[x] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\" <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9994\">https://github.com/bytecodealliance/wasmtime/pull/9994</a></li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 494017220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736975362
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9747\">issue #9747</a>:</p>\n<blockquote>\n<p>I'd like a place to throw small items as I see them and to collect various TODO items during the development of Pulley. For now this will serve that location. My hope is that this list is TODO items which pertain to code in-tree and are less-so about wishlist items of what's yet to fill in. For example this won't track missing pulley work (e.g. all wasm proposals at this time). Unsure if this style of issue will work out.</p>\n<ul>\n<li>[ ] Evaluate 32-bit platforms and the decision to \"only write low 32-bits\". If we write the full 64-bit width of registers does it actually have a performance loss? Is it worth burning opcode space for opcodes that only write the low-32 instead of high 64? Should we split opcodes like <code>xconst8</code> into one that writes 64-bits and one that writes 32-bits? Should we remove <code>xload8_s32_offset32</code> instead?</li>\n<li>[ ] Add support for Pulley to <code>#[wasmtime_test]</code></li>\n<li>[x] Move sp/fp/lr/special regs out of the general purpose register set; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188\">https://github.com/bytecodealliance/wasmtime/pull/9658#pullrequestreview-2482824188</a> for details (also cc <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9806\">https://github.com/bytecodealliance/wasmtime/pull/9806</a>)</li>\n<li>[x] Explore adding new addressing modes (e.g. register + register). Should be based on an evaluation of what wasm loads/stores do probably. Perhaps even fold a trapping arithmetic into one macro-op for \"do the wasm load on 32-bit\" and \"do the wasm load on 64-bit\" <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9994\">https://github.com/bytecodealliance/wasmtime/pull/9994</a></li>\n<li>[x] Assert in call lowering that pulley&lt;-&gt;pulley is always tail-to-tail or similar; see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050\">https://github.com/bytecodealliance/wasmtime/pull/9665#discussion_r1871969050</a> for details -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9836\">https://github.com/bytecodealliance/wasmtime/pull/9836</a></li>\n<li>[x] Better debugging support, e.g. print the register state between instructions and print each instruction. <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9796\">https://github.com/bytecodealliance/wasmtime/pull/9796</a></li>\n<li>[x] Support big-endian - will need to add <code>pulley{64,32}be</code> targets to target-lexicon, then add big-endian loads/stores, then update the CLIF backend to delegate to the right endianness based on the target</li>\n<li>[x] Need to restore callee-save state when a trap happens somehow (either via explicit saves or by removing callee-save state in that situation) <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Enable Cranelift <code>runtest</code> support <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9795\">https://github.com/bytecodealliance/wasmtime/pull/9795</a></li>\n<li>[X] Run the full <code>all</code> test suite on 32-bit platforms -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9837\">https://github.com/bytecodealliance/wasmtime/pull/9837</a></li>\n<li>[x] Figure out story for threading -- loads/stores all need to be at least with a \"relaxed\" atomicity -- <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9818\">https://github.com/bytecodealliance/wasmtime/pull/9818</a></li>\n<li>[x] Implement the wide-arithmetic proposal <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9944\">https://github.com/bytecodealliance/wasmtime/pull/9944</a></li>\n<li>[x] Fuzz pulley <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9966\">https://github.com/bytecodealliance/wasmtime/pull/9966</a></li>\n</ul>\n</blockquote>",
        "id": 494017232,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736975365
    }
]