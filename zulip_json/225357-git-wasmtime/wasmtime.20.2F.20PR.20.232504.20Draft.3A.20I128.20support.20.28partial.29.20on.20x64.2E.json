[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219747312,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607841144
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219747394,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607841281
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550890041\">PR Review</a>.</p>",
        "id": 219747900,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607842292
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550890041\">PR Review</a>.</p>",
        "id": 219747901,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607842293
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541860023\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Can regalloc insert an instruction in between?</p>\n</blockquote>",
        "id": 219747902,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607842293
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550893109\">PR Review</a>.</p>",
        "id": 219749386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607844970
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541867624\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Regalloc is specifically disallowed from inserting any instructions that change the condition codes.  This is specified in comments in the <code>regalloc.rs</code> interface.</p>\n</blockquote>",
        "id": 219749387,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607844970
    },
    {
        "content": "<p>julian-seward1 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541867624\">PR Review Comment</a>.</p>",
        "id": 219749601,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607845408
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550894390\">PR Review</a>.</p>",
        "id": 219750015,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607846191
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541870768\">PR Review Comment</a>:</p>\n<blockquote>\n<p>@cfallin Is it really so bad that we have to duplicate these circa 50 lines per-target, to do <code>mul.i128</code>?  It would be even shorter if rustfmt didn't insist on laying out the calls in this space-inefficient way.</p>\n<p>There will be roughly equivalent length sequences for 128-bit left/right shifts, and for 128-bit comparisons.  For 128-bit division, we'll have to call a helper on all targets.  On 32-bit targets, we'll probably have to use a helper for multiplies, shifts and comparisons too.</p>\n</blockquote>",
        "id": 219750016,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607846191
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550914558\">PR Review</a>.</p>",
        "id": 219759274,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607861757
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541913522\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Could this be a <code>Result</code> with something like <code>struct OnlyRegError;</code> as error type? That would give a better panic message when unwrapping.</p>\n</blockquote>",
        "id": 219759275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607861757
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550947930\">PR Review</a>.</p>",
        "id": 219774003,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607885146
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-550947930\">PR Review</a>.</p>",
        "id": 219774004,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607885146
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981083\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>                let arg_regs = put_input_in_regs(ctx, *input);\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 219774005,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607885146
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981117\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>                abi.emit_copy_regs_to_arg(ctx, i, arg_regs);\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 219774006,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607885146
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r541981047\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>                let retval_regs = get_output_reg(ctx, *output);\n                abi.emit_copy_retval_to_regs(ctx, i, retval_regs);\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 219774007,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607885146
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219790559,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607906866
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219793289,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607911550
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219793341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607911636
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219795030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607914314
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551012607\">PR Review</a>.</p>",
        "id": 219795222,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607914560
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542078087\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Thanks!</p>\n</blockquote>",
        "id": 219795223,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607914561
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219795364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607914714
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219801411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607922876
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 219801424,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607922947
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551081854\">PR Review</a>.</p>",
        "id": 219805611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607928494
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542148134\">PR Review Comment</a>:</p>\n<blockquote>\n<p><code>StructArgument</code> indicates that the argument is a pointer to a piece of memory with the given size that needs to be passed as on the stack in the arguments area. On the caller side you will need to memcpy it to the right place, on the callee side you need to get the address.</p>\n</blockquote>",
        "id": 219805612,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607928494
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551083046\">PR Review</a>.</p>",
        "id": 219805709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607928672
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542149191\">PR Review Comment</a>:</p>\n<blockquote>\n<p>The old backend didn't handle this either, but the system-v abi defines a specific register for this argument. In addition kn x86_64 at least I think you also need to regurn this value in a different register. (I guess to reduce the need for saving it on the caller side.)</p>\n</blockquote>",
        "id": 219805710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607928672
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551103984\">PR Review</a>.</p>",
        "id": 219807863,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931400
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542167903\">PR Review Comment</a>:</p>\n<blockquote>\n<p>OK, yes, this is making more sense now. Do you think you would be up for attempting an implementation? (My bandwidth is somewhat stretched thin at the moment, but I can come back to this at ... some point, eventually, if needed. Incidentally this is similar to what I think we also need for Windows fastcall, which is one of the other remaining new-backend TODOs...).</p>\n</blockquote>",
        "id": 219807864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931400
    },
    {
        "content": "<p>julian-seward1 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104062\">PR Review</a>.</p>",
        "id": 219807870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931409
    },
    {
        "content": "<p>julian-seward1 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542167981\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Would it be preferable here to key it on the word size of the target that the resulting CL will be compiling for?  Is that even possible, given the limitations of the Rust config etc system?</p>\n</blockquote>",
        "id": 219807871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931409
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104517\">PR Review</a>.</p>",
        "id": 219807909,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931463
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542168422\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Such an option does exist, but the wrench in the works is cross-compilation -- e.g. <code>clif-utils</code> is normally built with all targets enabled (so we need to support arm32 compilation even on an x64 host, etc).</p>\n</blockquote>",
        "id": 219807910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931463
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551104894\">PR Review</a>.</p>",
        "id": 219807967,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931507
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542168706\">PR Review Comment</a>:</p>\n<blockquote>\n<p>(Ah, sorry, actually I misread your comment -- pointer size of target, not host; I don't think we have a config option for that as we have custom features for each backend.)</p>\n</blockquote>",
        "id": 219807968,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607931507
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-551161980\">PR Review</a>.</p>",
        "id": 219814351,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607936489
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r542215584\">PR Review Comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>            emit_reloc(sink, state, Reloc::ElfX86_64TlsGd, symbol, -4);\n            sink.put4(0);\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 219814352,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607936489
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221045974,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609143517
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#pullrequestreview-559046352\">PR Review</a>.</p>",
        "id": 221046930,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609144712
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504#discussion_r549262245\">PR Review Comment</a>:</p>\n<blockquote>\n<p>Thanks!</p>\n</blockquote>",
        "id": 221046931,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609144712
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221093977,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609192361
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221106212,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609207607
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221120392,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609231860
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221123542,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609236062
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221123756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609236287
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221172323,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609279956
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221491204,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609739029
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221491806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609739918
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a> from <code>multi-reg-result-2</code> to <code>main</code>:</p>\n<blockquote>\n<p>This PR generalizes all of the <code>MachInst</code> framework to reason about SSA <code>Value</code>s as being located in <em>multiple</em> registers (one, two or four, currently, in an efficient packed form). This is necessary in order to handle CLIF with values wider than the machine width (<code>I128</code> on 64/32-bit machines and <code>I64</code> on 32-bit machines), unless we legalize it beforehand.</p>\n<p>It also adds support for some basic 128-bit ALU ops to the x64 backend, loewring these directly to open-coded instruction sequences (add/adc, sub/sbb, etc.).</p>\n<p>@julian-seward1 and @bnjbvr: this is the approach we had discussed a long time ago (in January, I think!). It follows from the \"every backend accepts the same IR\" philosophy, with the idea that maybe we will get to the point where legalization is largely not necessary.</p>\n<p><em>However</em>: I must say that I'm not super-happy with the level of complexity this has added to the framework. The fact that the work we do in the x64 backend to support this will have to be repeated on aarch64 is kind of unfortunate; and this all feels somewhat silly given that we still have the legalization framework's narrowing support, and could use that instead. Philosophically, I think that legalization is actually the right approach here: we should be able to factor out \"general machine-independent algorithm for 128-bit multiply with 64-bit pieces\" from the specific machine backends.</p>\n<p>So I'm inclined <em>not</em> to go in this direction, but (i) want to see what thoughts anyone might have, and (ii) save this for the record, in case we wire up the old legalizations for now but reconsider or need multi-reg values in the future.</p>\n</blockquote>",
        "id": 221491969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609740169
    },
    {
        "content": "<p>cfallin closed without merge <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2504\">PR #2504</a>.</p>",
        "id": 221676960,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1609868400
    }
]