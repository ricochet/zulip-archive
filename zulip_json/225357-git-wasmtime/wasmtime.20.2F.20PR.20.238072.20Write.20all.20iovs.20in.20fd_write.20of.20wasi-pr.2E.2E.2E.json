[
    {
        "content": "<p>ospencer opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a> from <code>ospencer:oscar/fix-fd-write-iovs</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;<br>\nI noticed that the implementation of <code>fd_write</code> in the preview1 adapter only writes the first iov in the list passed. This change writes all of them. I'm happy to add a test for this, though I couldn't find any tests for the adapter. I tested this locally via wasm-tools.</p>\n</blockquote>",
        "id": 425627816,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709944245
    },
    {
        "content": "<p><strong>ospencer</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>.</p>",
        "id": 425627817,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709944245
    },
    {
        "content": "<p><strong>ospencer</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>.</p>",
        "id": 425627818,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709944245
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-1986869318\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<p>Writing in a loop is incompatible with POSIX. POSIX mandates that each writev is an atomic operation. While it may only write the first n bytes, it has to write all n bytes at once without the possibility of any other write getting interleaved with it. If you want to write everything, you did have to copy all buffers into one large buffer and then write this large buffer, which may actually be slower than both the status quo and your PR. See also <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973512565\">https://github.com/bytecodealliance/wasmtime/issues/8037#issuecomment-1973512565</a></p>\n</blockquote>",
        "id": 425690456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1709993896
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-1988561009\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<p>To add another case I would be worried about in addition to what @bjorn3 already mentioned: in the PR as-is if you have 4 buffers and successfully write the first two but then fail writing the third then the fact that the first two were successfully written is lost. At that point you've got a number of successfully written bytes plus an error and it's not clear which should be returned since only one can be returned.</p>\n</blockquote>",
        "id": 425919496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710166920
    },
    {
        "content": "<p>ospencer <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-2002001799\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<p>That makes sense. It looks like some implementations of <code>readv</code>/<code>writev</code> do allocate a temporary large buffer in the case that the number of provided iovs exceeds the limit of the system, so that probably makes sense here too.</p>\n<p>I agree that the current implementation we have of <code>fd_write</code> is technically correct, but I think the (totally allowable) behavior change from older preview1 versions of wasmtime is a little surprising to less resilient code, shown by the couple of issues/PRs opened about this.</p>\n<p>I attempted to implement this so we could at least test it out/consider this approach, but I forgot that the adapter can't really use <code>Vec</code>s because of the panics. I'm not quite a seasoned-enough Rustacean to know how to do this without vecs in safe Rust, but if someone could give me a pointer that'd be much appreciated.</p>\n</blockquote>",
        "id": 426895266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710598991
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-2004130835\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<p>I agree it's unfortunate that this is causing issues, but IMO our hands are unfortunately tied here to the point that there's not much we can do. I think there's one thing we can do, which is to have a statically allocated or somewhere slice of bytes which the adapter copies into and then calls out to perform a single write. That would respect the semantics desired for languages and such here, at the cost of copying data. It's not clear to me when the copy is worth it vs when not, so I'm not sure how to best make such a decision.</p>\n<p>The adapter has various bits and pieces of scratch space in its <code>State</code> and we can put a fixed-size buffer in there for copying if necessary.</p>\n</blockquote>",
        "id": 427503297,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710773523
    },
    {
        "content": "<p>titzer <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-2461102893\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<blockquote>\n<p>I agree it's unfortunate that this is causing issues, but IMO our hands are unfortunately tied here to the point that there's not much we can do. I think there's one thing we can do, which is to have a statically allocated or somewhere slice of bytes which the adapter copies into and then calls out to perform a single write. That would respect the semantics desired for languages and such here, at the cost of copying data. It's not clear to me when the copy is worth it vs when not, so I'm not sure how to best make such a decision.</p>\n</blockquote>\n<p>I hit this recently and thought I had made a mistake using the API; multiple iovecs are supported in at least three other engines. Though they are rare, supporting that functionality for application migration, even if the writes are not atomic, would be an improvement in the status quo and make the ecosystem more uniform. Given that I think these are rare, if we would like to make the POSIX atomicity guarantee, it seems like a copy into a temporary buffer would be a reasonable implementation--especially if the I/O is large, it's likely to be a small relative overhead.</p>\n</blockquote>",
        "id": 481025767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730940973
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072#issuecomment-2462673981\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8072\">PR #8072</a>:</p>\n<blockquote>\n<p>I definitely agree that this can be a footgun, so I don't mean to discount that. That being said I continue to think \"just call write twice\" is not an acceptable solution. While that solves the footgun it means that if anyone tries to robustly handle errors/atomicity it's impossible to do so. I'm not sure @titzer if your issue is derivative of the same file changed in this PR, but this PR changes an adapter which converts WASIp1 to WASIp2. The WASIp1 APIs \"looked like POSIX\" and had its semantics, and callers may not even realize they're being wrapped to work in a WASIp2 world. In that sense callers with it can't be known in this context if callers with multiple iovecs care about atomicity or not.</p>\n<p>This is why I mention that one possible solution is to copy some data. Perhaps when it's below a certain threshold or something like that it's copied into a different space and then issued as a single write. That doesn't have any atomicity issues and it's just a minor perf loss. I think it'd be reasonable to prototype that out and see what it would look like.</p>\n</blockquote>",
        "id": 481156099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730996715
    }
]