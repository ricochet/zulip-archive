[
    {
        "content": "<p>mgattozzi opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220\">PR #3220</a> from <code>mgattozzi/a-fix-that-spans-awaits</code> to <code>main</code>:</p>\n<blockquote>\n<ul>\n<li>\n<p>[ ] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.<br>\n  This was an issue that @pchickey stumbled on internally at work when testing<br>\n  out some things and I was asked to take a look at it and figure out what was going on</p>\n</li>\n<li>\n<p>[X] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n<p>Fixes incorrect behavior with spans generated by wiggle in asynchronous code.</p>\n</li>\n<li>\n<p>[X] This PR contains test cases, if meaningful.</p>\n<p>N/A but have confirmed in internal testing that this does indeed fix the issue and doesn't break<br>\nfunctionality, just changes the function signatures.</p>\n</li>\n<li>\n<p>[X] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</p>\n<p>@pchickey asked for me to tag him for review when I put this PR up.</p>\n</li>\n</ul>\n<h2>Commit Message Follows:</h2>\n<p>Up to this point when using wiggle to generate functions we could end up<br>\nwith two types of functions an async or sync one with this proc macro</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"cp\">#[allow(unreachable_code)]</span><span class=\"w\"> </span><span class=\"c1\">// deals with warnings in noreturn functions</span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span>#<span class=\"n\">asyncness</span><span class=\"w\"> </span><span class=\"k\">fn</span> #<span class=\"n\">ident</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">impl</span><span class=\"w\"> </span>#<span class=\"p\">(</span>#<span class=\"n\">bounds</span><span class=\"p\">)</span><span class=\"o\">+*</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">GuestMemory</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">      </span>#<span class=\"p\">(</span>#<span class=\"n\">abi_params</span><span class=\"p\">),</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span>#<span class=\"n\">abi_ret</span><span class=\"p\">,</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">Trap</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">convert</span>::<span class=\"n\">TryFrom</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_span</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">tracing</span>::<span class=\"n\">span</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">          </span>#<span class=\"n\">rt</span>::<span class=\"n\">tracing</span>::<span class=\"n\">Level</span>::<span class=\"n\">TRACE</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"s\">\"wiggle abi\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">mod_name</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">func_name</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_enter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_span</span><span class=\"p\">.</span><span class=\"n\">enter</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">      </span>#<span class=\"n\">body</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now this might seem fine, we just create a span and enter it and run the<br>\nbody code and we get async versions as well. However, this is where the<br>\nsource of our problem lies. The impetus for this fix was seeing multiple<br>\nrequest IDs output in the logs for a single function call of a generated<br>\nfunction. Something was clearly happening that shouldn't have been. If<br>\nwe take a look at the tracing docs here we can see why the above code<br>\nwill not work in asynchronous code.</p>\n<p><a href=\"https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html#in-asynchronous-code\">https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html#in-asynchronous-code</a></p>\n<blockquote>\n<p>Warning: in asynchronous code that uses async/await syntax,<br>\nSpan::enter should be used very carefully or avoided entirely.<br>\nHolding the drop guard returned by Span::enter across .await points<br>\nwill result in incorrect traces.</p>\n</blockquote>\n<p>The above documentation provides some more information, but what could<br>\nhappen is that the <code>#body</code> itself could contain code that would await<br>\nand mess up the tracing that occurred and causing output that would be<br>\ncompletely nonsensical. The code itself should work fine in the<br>\nsynchronous case though and in cases where await was not called again<br>\ninside the body as the future would poll to completion as if it was a<br>\nsynchronous function.</p>\n<p>The solution then is to use the newer <code>Instrument</code> trait which can make<br>\nsure that the span will be entered on every poll of the future. In order<br>\nto make sure that we have the same behavior as before we generate<br>\nsynchronous functions and the ones that were async instead return a<br>\nfuture that uses the instrument trait. This way we can guarantee that<br>\nthe span is created in synchronous code before being passed into a<br>\nfuture. This does change the function signature, but the functionality<br>\nitself is exactly as before and so we should see no actual difference in<br>\nhow it's used by others. We also just to be safe call the synchronous<br>\nversion's body with <code>in_scope</code> now as per the docs recommendation even<br>\nthough it's more intended for calling sync code inside async functions.<br>\nFunctionally it's the same as before with the call to enter. We also<br>\nbump the version of tracing uses so that wiggle can reexport tracing<br>\nwith the instrument changes.</p>\n</blockquote>",
        "id": 250127689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629471045
    },
    {
        "content": "<p>mgattozzi edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220\">PR #3220</a> from <code>mgattozzi/a-fix-that-spans-awaits</code> to <code>main</code>:</p>\n<blockquote>\n<ul>\n<li>\n<p>[x] This has been discussed in issue #..., or if not, please tell us why<br>\n  here.<br>\n  This was an issue that @pchickey stumbled on internally at work when testing<br>\n  out some things and I was asked to take a look at it and figure out what was going on</p>\n</li>\n<li>\n<p>[X] A short description of what this does, why it is needed; if the<br>\n  description becomes long, the matter should probably be discussed in an issue<br>\n  first.</p>\n<p>Fixes incorrect behavior with spans generated by wiggle in asynchronous code.</p>\n</li>\n<li>\n<p>[X] This PR contains test cases, if meaningful.</p>\n<p>N/A but have confirmed in internal testing that this does indeed fix the issue and doesn't break<br>\nfunctionality, just changes the function signatures.</p>\n</li>\n<li>\n<p>[X] A reviewer from the core maintainer team has been assigned for this PR.<br>\n  If you don't know who could review this, please indicate so. The list of<br>\n  suggested reviewers on the right can help you.</p>\n<p>@pchickey asked for me to tag him for review when I put this PR up.</p>\n</li>\n</ul>\n<h2>Commit Message Follows:</h2>\n<p>Up to this point when using wiggle to generate functions we could end up<br>\nwith two types of functions an async or sync one with this proc macro</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"cp\">#[allow(unreachable_code)]</span><span class=\"w\"> </span><span class=\"c1\">// deals with warnings in noreturn functions</span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span>#<span class=\"n\">asyncness</span><span class=\"w\"> </span><span class=\"k\">fn</span> #<span class=\"n\">ident</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">ctx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">impl</span><span class=\"w\"> </span>#<span class=\"p\">(</span>#<span class=\"n\">bounds</span><span class=\"p\">)</span><span class=\"o\">+*</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">memory</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">dyn</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">GuestMemory</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">      </span>#<span class=\"p\">(</span>#<span class=\"n\">abi_params</span><span class=\"p\">),</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span>#<span class=\"n\">abi_ret</span><span class=\"p\">,</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">Trap</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">convert</span>::<span class=\"n\">TryFrom</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_span</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">rt</span>::<span class=\"n\">tracing</span>::<span class=\"n\">span</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">          </span>#<span class=\"n\">rt</span>::<span class=\"n\">tracing</span>::<span class=\"n\">Level</span>::<span class=\"n\">TRACE</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"s\">\"wiggle abi\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">mod_name</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>#<span class=\"n\">func_name</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_enter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_span</span><span class=\"p\">.</span><span class=\"n\">enter</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">      </span>#<span class=\"n\">body</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now this might seem fine, we just create a span and enter it and run the<br>\nbody code and we get async versions as well. However, this is where the<br>\nsource of our problem lies. The impetus for this fix was seeing multiple<br>\nrequest IDs output in the logs for a single function call of a generated<br>\nfunction. Something was clearly happening that shouldn't have been. If<br>\nwe take a look at the tracing docs here we can see why the above code<br>\nwill not work in asynchronous code.</p>\n<p><a href=\"https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html#in-asynchronous-code\">https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html#in-asynchronous-code</a></p>\n<blockquote>\n<p>Warning: in asynchronous code that uses async/await syntax,<br>\nSpan::enter should be used very carefully or avoided entirely.<br>\nHolding the drop guard returned by Span::enter across .await points<br>\nwill result in incorrect traces.</p>\n</blockquote>\n<p>The above documentation provides some more information, but what could<br>\nhappen is that the <code>#body</code> itself could contain code that would await<br>\nand mess up the tracing that occurred and causing output that would be<br>\ncompletely nonsensical. The code itself should work fine in the<br>\nsynchronous case though and in cases where await was not called again<br>\ninside the body as the future would poll to completion as if it was a<br>\nsynchronous function.</p>\n<p>The solution then is to use the newer <code>Instrument</code> trait which can make<br>\nsure that the span will be entered on every poll of the future. In order<br>\nto make sure that we have the same behavior as before we generate<br>\nsynchronous functions and the ones that were async instead return a<br>\nfuture that uses the instrument trait. This way we can guarantee that<br>\nthe span is created in synchronous code before being passed into a<br>\nfuture. This does change the function signature, but the functionality<br>\nitself is exactly as before and so we should see no actual difference in<br>\nhow it's used by others. We also just to be safe call the synchronous<br>\nversion's body with <code>in_scope</code> now as per the docs recommendation even<br>\nthough it's more intended for calling sync code inside async functions.<br>\nFunctionally it's the same as before with the call to enter. We also<br>\nbump the version of tracing uses so that wiggle can reexport tracing<br>\nwith the instrument changes.</p>\n</blockquote>",
        "id": 250127704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629471051
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#pullrequestreview-735126615\">PR review</a>.</p>",
        "id": 250130044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629472018
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#pullrequestreview-735126615\">PR review</a>.</p>",
        "id": 250130045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629472018
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#discussion_r693019662\">PR review comment</a>:</p>\n<blockquote>\n<p>Since this call is somewhat nontrivial could this call to <code>span!</code> get pulled out of the two branches of this <code>if</code> and something like <code>let _span = #mk_span;</code> be used in both macros?</p>\n</blockquote>",
        "id": 250130046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629472018
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#discussion_r693019352\">PR review comment</a>:</p>\n<blockquote>\n<p>I think the indentation may be a bit off here and below? (to match the indentation above)</p>\n</blockquote>",
        "id": 250130047,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629472018
    },
    {
        "content": "<p>mgattozzi submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#pullrequestreview-735144888\">PR review</a>.</p>",
        "id": 250132519,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473122
    },
    {
        "content": "<p>mgattozzi created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#discussion_r693032758\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah! I can do that <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>🏻 </p>\n</blockquote>",
        "id": 250132521,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473122
    },
    {
        "content": "<p>mgattozzi updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220\">PR #3220</a> from <code>mgattozzi/a-fix-that-spans-awaits</code> to <code>main</code>.</p>",
        "id": 250133213,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473421
    },
    {
        "content": "<p>mgattozzi submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#pullrequestreview-735150453\">PR review</a>.</p>",
        "id": 250133386,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473490
    },
    {
        "content": "<p>mgattozzi created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#discussion_r693037061\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah cargo fmt can't really handle things inside macros. I think I got it fixed up in the most recent commit as well.</p>\n</blockquote>",
        "id": 250133387,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473490
    },
    {
        "content": "<p>mgattozzi updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220\">PR #3220</a> from <code>mgattozzi/a-fix-that-spans-awaits</code> to <code>main</code>.</p>",
        "id": 250133822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629473671
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220#pullrequestreview-735162773\">PR review</a>.</p>",
        "id": 250135225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629474321
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3220\">PR #3220</a>.</p>",
        "id": 250139790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1629476439
    }
]