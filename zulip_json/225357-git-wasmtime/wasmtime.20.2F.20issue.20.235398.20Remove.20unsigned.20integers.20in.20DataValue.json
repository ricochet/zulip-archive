[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see for example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly, for example. If a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 314718682,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670518181
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see as an example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly. For example if a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 314719531,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670518432
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see as an example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly. For example if a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<p>Overall this is quite confusing in the interpreter and causes a bunch of casting between types that could probably be avoided.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 314719687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670518465
    },
    {
        "content": "<p>jameysharp labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see as an example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly. For example if a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<p>Overall this is quite confusing in the interpreter and causes a bunch of casting between types that could probably be avoided.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 314745787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670525076
    },
    {
        "content": "<p>jameysharp labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see as an example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly. For example if a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<p>Overall this is quite confusing in the interpreter and causes a bunch of casting between types that could probably be avoided.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 314745788,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670525076
    },
    {
        "content": "<p>bahildebrand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398#issuecomment-1345426523\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p>Is this still available? If so I'd like to take a crack at it.</p>\n</blockquote>",
        "id": 315145969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670721443
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398#issuecomment-1345520080\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p>As far as I'm aware no one has started working on it yet!</p>\n</blockquote>",
        "id": 315188785,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670755887
    },
    {
        "content": "<p>tnachen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398#issuecomment-1346088432\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p>@bahildebrand I'm looking to do this but if you already started let me know, can defer this to you</p>\n</blockquote>",
        "id": 315312621,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670834012
    },
    {
        "content": "<p>bahildebrand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398#issuecomment-1348523973\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p>@tnachen I have already started, but it seems like you might have as well.</p>\n</blockquote>",
        "id": 315588266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1670937516
    },
    {
        "content": "<p>afonso360 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5398\">issue #5398</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>We should remove the unsigned variants of the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/codegen/src/data_value.rs#L8-L29\">DataValue</a> structure.</p>\n<h4>Benefit</h4>\n<p>This brings this structure closer to CLIF's idea of a DataValue, which does not distinguish between signed and unsigned in types. Instead in CLIF we only have that distinction in the operations that are performed (see as an example <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.sdiv\"><code>sdiv</code></a> vs <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/trait.InstBuilder.html#method.udiv\"><code>udiv</code></a>)</p>\n<p>It can also bring some issues to the interpreter if not handled correctly. For example if a operation returns a unsigned <code>DataValue</code> it can cause a test failure such as <code>Failed test: run: %usubof_i64(0, 0) == 0, actual: 0</code> since we parse the values in test cases as signed integers.</p>\n<p>Overall this is quite confusing in the interpreter and causes a bunch of casting between types that could probably be avoided.</p>\n<h4>Implementation</h4>\n<p>As far as I'm aware the only user of these values is the interpreter. Which casts values to unsigned when it needs to perform operations as unsigned, and then has to cast them back to signed values before returning them.</p>\n<p>We can instead separate those operations like we do in CLIF instructions. As an example right now we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0456c1d2131e53f4b00542548bb061b11d62f1f0/cranelift/interpreter/src/value.rs#L539-L557\"><code>Value::div</code></a> which does signed or unsigned division based on the signedness of the input DataValue, but we can change that to have <code>Value::sdiv</code> and <code>Value::udiv</code> like we have for CLIF instructions.</p>\n<h4>Alternatives</h4>\n<p>We can keep using this system and changing the PartialEq implementation to fix some of the issues above, but that does not sound like the best solution to me.</p>\n<p>See the following <a href=\"#narrow/stream/217117-cranelift/topic/DataValue.20eq/near/314592339\">zulip thread</a> for some additional context.</p>\n</blockquote>",
        "id": 350806939,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1681829912
    }
]