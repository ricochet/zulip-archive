[
    {
        "content": "<p><a href=\"https://github.com/afonso360\">afonso360</a> added the cranelift label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">Issue #7215</a>.</p>",
        "id": 396124099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697040845
    },
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This was something that @jameysharp brought up during today's cranelift meeting.</p>\n<h4>Feature</h4>\n<p>We could add support to our runtests to allocate a heap memory region and pass it to the function under test.</p>\n<h4>Benefit</h4>\n<p>This allows us to do two things:</p>\n<ul>\n<li>\n<p>We can start testing load fusion for vector instructions in the cranelift fuzzer for x64. We can't do this currently because they require the address to be aligned to 16bytes, and we can't guarantee that yet for stack addresses.</p>\n</li>\n<li>\n<p>We can test our alias analysis memflags using this. We could for example map different heaps to a different alias analysis bits, and ensure that our optimizations work.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>We used to have something similar to this in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3302\">https://github.com/bytecodealliance/wasmtime/pull/3302</a> that was then removed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5386\">https://github.com/bytecodealliance/wasmtime/pull/5386</a></p>\n<p>We had an annotation like <code>; heap: static, size=0x1000, ptr=vmctx+0, bound=vmctx+8</code> which would pass the address of the heap via the <code>vmctx</code> parameter.</p>\n<p>That used to involve some special handling for <code>vmctx</code> parameters that I think is incompatible with what we do today (don't quote me on this).</p>\n<p>But we could do something similar like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span> <span class=\"p\">{</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"o\">=</span><span class=\"mi\">8</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n</code></pre></div>\n<p>And the <code>&lt;heap0&gt;</code> annotation would be resolved with the address of the heap when calling the test.</p>\n<h4>Alternatives</h4>\n<p>An alternative to testing load fusion for vectors, is to add stack alignment flags to our stack slots. But doing the alias analysis bits is slightly harder although there are probably workarounds there too.</p>\n</blockquote>",
        "id": 396124101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697040846
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This was something that @jameysharp brought up during today's cranelift meeting.</p>\n<h4>Feature</h4>\n<p>We could add support to our runtests to allocate a heap memory region and pass it to the function under test.</p>\n<h4>Benefit</h4>\n<p>This allows us to do two things:</p>\n<ul>\n<li>\n<p>We can start testing load fusion for vector instructions in the cranelift fuzzer for x64. We can't do this currently because they require the address to be aligned to 16bytes, and we can't guarantee that yet for stack addresses.</p>\n</li>\n<li>\n<p>We can test our alias analysis memflags using this. We could for example map different heaps to a different alias analysis bits, and ensure that our optimizations work.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>We used to have something similar to this in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3302\">https://github.com/bytecodealliance/wasmtime/pull/3302</a> that was then removed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5386\">https://github.com/bytecodealliance/wasmtime/pull/5386</a></p>\n<p>We had an annotation like <code>; heap: static, size=0x1000, ptr=vmctx+0, bound=vmctx+8</code> which would pass the address of the heap via the <code>vmctx</code> parameter.</p>\n<p>That used to involve some special handling for <code>vmctx</code> parameters that I think is incompatible with what we do today (don't quote me on this).</p>\n<p>But we could do something similar like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span> <span class=\"p\">{</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"o\">=</span><span class=\"mi\">8</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n</code></pre></div>\n<p>And the <code>&lt;heap0&gt;</code> annotation would be resolved with the address of the heap when calling the test.</p>\n<h4>Alternatives</h4>\n<p>An alternative to testing load fusion for vectors, is to add stack alignment flags to our stack slots. But doing the alias analysis bits is slightly harder although there are probably workarounds there too.</p>\n</blockquote>",
        "id": 396124270,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697040905
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This was something that @jameysharp brought up during today's cranelift meeting.</p>\n<h4>Feature</h4>\n<p>We could add support to our runtests to allocate a heap memory region and pass it to the function under test.</p>\n<h4>Benefit</h4>\n<p>This allows us to do two things:</p>\n<ul>\n<li>\n<p>We can start testing load fusion for vector instructions in the cranelift fuzzer for x64. We can't do this currently because they require the address to be aligned to 16bytes, and we can't guarantee that yet for stack addresses.</p>\n</li>\n<li>\n<p>We can test our alias analysis memflags in the fuzzer using this. We could for example map different heaps to a different alias analysis bits, and ensure that our optimizations work.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>We used to have something similar to this in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3302\">https://github.com/bytecodealliance/wasmtime/pull/3302</a> that was then removed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5386\">https://github.com/bytecodealliance/wasmtime/pull/5386</a></p>\n<p>We had an annotation like <code>; heap: static, size=0x1000, ptr=vmctx+0, bound=vmctx+8</code> which would pass the address of the heap via the <code>vmctx</code> parameter.</p>\n<p>That used to involve some special handling for <code>vmctx</code> parameters that I think is incompatible with what we do today (don't quote me on this).</p>\n<p>But we could do something similar like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span> <span class=\"p\">{</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"o\">=</span><span class=\"mi\">8</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n</code></pre></div>\n<p>And the <code>&lt;heap0&gt;</code> annotation would be resolved with the address of the heap when calling the test.</p>\n<h4>Alternatives</h4>\n<p>An alternative to testing load fusion for vectors, is to add stack alignment flags to our stack slots. But doing the alias analysis bits is slightly harder although there are probably workarounds there too.</p>\n</blockquote>",
        "id": 396124719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697041030
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This was something that @jameysharp brought up during today's cranelift meeting.</p>\n<h4>Feature</h4>\n<p>We could add support to our runtests to allocate a heap memory region and pass it to the function under test.</p>\n<h4>Benefit</h4>\n<p>This allows us to do a few things:</p>\n<ul>\n<li>\n<p>We can start testing load fusion for vector instructions in the cranelift fuzzer for x64. We can't do this currently because they require the address to be aligned to 16bytes, and we can't guarantee that yet for stack addresses.</p>\n</li>\n<li>\n<p>We can test our alias analysis memflags in the fuzzer using this. We could for example map different heaps to a different alias analysis bits, and ensure that our optimizations work.</p>\n</li>\n<li>\n<p>We can also fuzz global values better. Since the heap is passed in via an argument, we can mark that argument as <code>vmctx</code> and start issuing global value loads based on that.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>We used to have something similar to this in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3302\">https://github.com/bytecodealliance/wasmtime/pull/3302</a> that was then removed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5386\">https://github.com/bytecodealliance/wasmtime/pull/5386</a></p>\n<p>We had an annotation like <code>; heap: static, size=0x1000, ptr=vmctx+0, bound=vmctx+8</code> which would pass the address of the heap via the <code>vmctx</code> parameter.</p>\n<p>That used to involve some special handling for <code>vmctx</code> parameters that I think is incompatible with what we do today (don't quote me on this).</p>\n<p>But we could do something similar like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span> <span class=\"p\">{</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"o\">=</span><span class=\"mi\">8</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n</code></pre></div>\n<p>And the <code>&lt;heap0&gt;</code> annotation would be resolved with the address of the heap when calling the test.</p>\n<h4>Alternatives</h4>\n<p>An alternative to testing load fusion for vectors, is to add stack alignment flags to our stack slots. But doing the alias analysis bits is slightly harder although there are probably workarounds there too.</p>\n</blockquote>",
        "id": 396125204,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697041157
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This was something that @jameysharp brought up during today's cranelift meeting.</p>\n<h4>Feature</h4>\n<p>We could add support to our runtests to allocate a heap memory region and pass it to the function under test.</p>\n<h4>Benefit</h4>\n<p>This allows us to do a few things:</p>\n<ul>\n<li>\n<p>We can start testing load+op fusion for vector instructions in the cranelift fuzzer for x64. We can't do this currently because they require the address to be aligned to 16bytes, and we can't guarantee that yet for stack addresses.</p>\n</li>\n<li>\n<p>We can test our alias analysis memflags in the fuzzer using this. We could for example map different heaps to a different alias analysis bits, and ensure that our optimizations work.</p>\n</li>\n<li>\n<p>We can also fuzz global values better. Since the heap is passed in via an argument, we can mark that argument as <code>vmctx</code> and start issuing global value loads based on that.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<p>We used to have something similar to this in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3302\">https://github.com/bytecodealliance/wasmtime/pull/3302</a> that was then removed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5386\">https://github.com/bytecodealliance/wasmtime/pull/5386</a></p>\n<p>We had an annotation like <code>; heap: static, size=0x1000, ptr=vmctx+0, bound=vmctx+8</code> which would pass the address of the heap via the <code>vmctx</code> parameter.</p>\n<p>That used to involve some special handling for <code>vmctx</code> parameters that I think is incompatible with what we do today (don't quote me on this).</p>\n<p>But we could do something similar like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span> <span class=\"p\">{</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n<span class=\"p\">}</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">heap</span>: <span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"o\">=</span><span class=\"mi\">8</span>\n<span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">run</span>: <span class=\"o\">%</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">heap0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n</code></pre></div>\n<p>And the <code>&lt;heap0&gt;</code> annotation would be resolved with the address of the heap when calling the test.</p>\n<h4>Alternatives</h4>\n<p>An alternative to testing load fusion for vectors, is to add stack alignment flags to our stack slots. But doing the alias analysis bits is slightly harder although there are probably workarounds there too.</p>\n</blockquote>",
        "id": 396125994,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697041376
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215#issuecomment-1759950442\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p>Your observations in #7225 reminded me that, in both fuzz tests and runtests, we can theoretically pass pointers from one function to another.</p>\n<p>So one approach in runtests would be to get a stackslot pointer in one function and pass it to a callee, which can then treat the pointer as heap or vmctx or whatever. In fuzzgen, we could add a fake \"address\" type to the set of function parameter types we might generate; callers would fill such arguments in using the same selection logic as addresses for loads and stores, and callees would add those arguments to the set of addresses which loads and stores can choose from.</p>\n<p>Since we don't do any inter-procedural optimization, that ensures that code generation can't do any hypothetical optimizations that would rely on knowing the pointer refers to the stack.</p>\n<p>We still need the ability to specify alignment on stack slots though.</p>\n</blockquote>",
        "id": 396323701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697127715
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215#issuecomment-1760217482\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7215\">issue #7215</a>:</p>\n<blockquote>\n<p>That's a great idea. We might not even have to do anything too hacky since we don't yet use reftypes for anything we could use those to signal, this is a valid address for loads and stores.</p>\n</blockquote>",
        "id": 396348529,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1697137498
    }
]