[
    {
        "content": "<p>glaebhoerl opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>(This is not really an issue but a heads-up; a discussion would've been more appropriate had those been enabled. Feel free to close for any reason.)</p>\n<p>I was reading <a href=\"https://github.com/bytecodealliance/rfcs/pull/27\">https://github.com/bytecodealliance/rfcs/pull/27</a>, and was pleasantly surprised to find a \"scoped hashmap\" data structure being used in the wild.</p>\n<p>A couple of years ago I wrote an optimized version of such a structure, with the motivating use case being the lexically-scoped context in a compiler: <a href=\"https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03\">https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03</a>. Feel free to take this and use it if you think it's worthwhile.</p>\n<p>I'm not really sure of all the tradeoffs w.r.t. wasmtime's <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/scoped_hash_map.rs\">own implementation</a>, especially as regards the particular use case, although what's visible at a glance is that the wasmtime version requires a loop when decrementing a level (leaving a scope) to restore the previous state, whereas the other doesn't (unless there is shadowing, which is N/A here), that having been the whole motivation for its existence.</p>\n<p>The basic idea is reminiscent of a generational arena: upon popping a scope, stale entries aren't physically removed (or even touched); rather, based on what is effectively a generation ID (called a scope ID in the code), they're ignored/overwritten in subsequent gets/inserts.</p>\n<p>(The version in the gist builds on hashbrown's RawTable to make the hash table aware of stale entries on a low level; there was <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9a06ccbe73b999f68d6d723b3ad6901\">also</a> an earlier sketch without that integration which was simpler and didn't involve <code>unsafe</code> code.)</p>\n</blockquote>",
        "id": 288320210,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656844251
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371#issuecomment-1175233425\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>Thanks for letting us know @glaebhoerl!</p>\n<p>I haven't gotten to the point in the egraph exploration yet where I'm doing detailed performance evaluation and tuning, but when I do, I'll keep this in mind.</p>\n</blockquote>",
        "id": 288552336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657037256
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>(This is not really an issue but a heads-up; a discussion would've been more appropriate had those been enabled. Feel free to close for any reason.)</p>\n<p>I was reading <a href=\"https://github.com/bytecodealliance/rfcs/pull/27\">https://github.com/bytecodealliance/rfcs/pull/27</a>, and was pleasantly surprised to find a \"scoped hashmap\" data structure being used in the wild.</p>\n<p>A couple of years ago I wrote an optimized version of such a structure, with the motivating use case being the lexically-scoped context in a compiler: <a href=\"https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03\">https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03</a>. Feel free to take this and use it if you think it's worthwhile.</p>\n<p>I'm not really sure of all the tradeoffs w.r.t. wasmtime's <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/scoped_hash_map.rs\">own implementation</a>, especially as regards the particular use case, although what's visible at a glance is that the wasmtime version requires a loop when decrementing a level (leaving a scope) to restore the previous state, whereas the other doesn't (unless there is shadowing, which is N/A here), that having been the whole motivation for its existence.</p>\n<p>The basic idea is reminiscent of a generational arena: upon popping a scope, stale entries aren't physically removed (or even touched); rather, based on what is effectively a generation ID (called a scope ID in the code), they're ignored/overwritten in subsequent gets/inserts.</p>\n<p>(The version in the gist builds on hashbrown's RawTable to make the hash table aware of stale entries on a low level; there was <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9a06ccbe73b999f68d6d723b3ad6901\">also</a> an earlier sketch without that integration which was simpler and didn't involve <code>unsafe</code> code.)</p>\n</blockquote>",
        "id": 288552423,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657037286
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>(This is not really an issue but a heads-up; a discussion would've been more appropriate had those been enabled. Feel free to close for any reason.)</p>\n<p>I was reading <a href=\"https://github.com/bytecodealliance/rfcs/pull/27\">https://github.com/bytecodealliance/rfcs/pull/27</a>, and was pleasantly surprised to find a \"scoped hashmap\" data structure being used in the wild.</p>\n<p>A couple of years ago I wrote an optimized version of such a structure, with the motivating use case being the lexically-scoped context in a compiler: <a href=\"https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03\">https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03</a>. Feel free to take this and use it if you think it's worthwhile.</p>\n<p>I'm not really sure of all the tradeoffs w.r.t. wasmtime's <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/scoped_hash_map.rs\">own implementation</a>, especially as regards the particular use case, although what's visible at a glance is that the wasmtime version requires a loop when decrementing a level (leaving a scope) to restore the previous state, whereas the other doesn't (unless there is shadowing, which is N/A here), that having been the whole motivation for its existence.</p>\n<p>The basic idea is reminiscent of a generational arena: upon popping a scope, stale entries aren't physically removed (or even touched); rather, based on what is effectively a generation ID (called a scope ID in the code), they're ignored/overwritten in subsequent gets/inserts.</p>\n<p>(The version in the gist builds on hashbrown's RawTable to make the hash table aware of stale entries on a low level; there was <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9a06ccbe73b999f68d6d723b3ad6901\">also</a> an earlier sketch without that integration which was simpler and didn't involve <code>unsafe</code> code.)</p>\n</blockquote>",
        "id": 288552424,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657037286
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>(This is not really an issue but a heads-up; a discussion would've been more appropriate had those been enabled. Feel free to close for any reason.)</p>\n<p>I was reading <a href=\"https://github.com/bytecodealliance/rfcs/pull/27\">https://github.com/bytecodealliance/rfcs/pull/27</a>, and was pleasantly surprised to find a \"scoped hashmap\" data structure being used in the wild.</p>\n<p>A couple of years ago I wrote an optimized version of such a structure, with the motivating use case being the lexically-scoped context in a compiler: <a href=\"https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03\">https://gist.github.com/glaebhoerl/d62d2b19365ae0d7c29102d0a5a6ab03</a>. Feel free to take this and use it if you think it's worthwhile.</p>\n<p>I'm not really sure of all the tradeoffs w.r.t. wasmtime's <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/codegen/src/scoped_hash_map.rs\">own implementation</a>, especially as regards the particular use case, although what's visible at a glance is that the wasmtime version requires a loop when decrementing a level (leaving a scope) to restore the previous state, whereas the other doesn't (unless there is shadowing, which is N/A here), that having been the whole motivation for its existence.</p>\n<p>The basic idea is reminiscent of a generational arena: upon popping a scope, stale entries aren't physically removed (or even touched); rather, based on what is effectively a generation ID (called a scope ID in the code), they're ignored/overwritten in subsequent gets/inserts.</p>\n<p>(The version in the gist builds on hashbrown's RawTable to make the hash table aware of stale entries on a low level; there was <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9a06ccbe73b999f68d6d723b3ad6901\">also</a> an earlier sketch without that integration which was simpler and didn't involve <code>unsafe</code> code.)</p>\n</blockquote>",
        "id": 288552441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657037291
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371#issuecomment-1175234866\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>As the author of the current scoped hashmap implementation, I can confirm that it isn't anything fancy <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>. It was just the simplest thing that would support the features needed by the GVN algorithm. When it comes time to tune that, it'd be cool to see someone take a look at this optimized hashmap implementation!</p>\n</blockquote>",
        "id": 288552534,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1657037344
    },
    {
        "content": "<p>Amanieu <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371#issuecomment-1255956651\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4371\">issue #4371</a>:</p>\n<blockquote>\n<p>I've found that you don't actually need a scoped hashmap for GVN: if you include the basic block of the defining instruction in the map then you can use a dominance check (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/be690a468d1aee92f8ec072d97decc45278b1529/cranelift/codegen/src/dominator_tree.rs#L584\">2 compares</a>) to quickly filter out \"out of scope\" entries.</p>\n<p>In the end the implementation is surprisingly simple: <a href=\"https://gist.github.com/Amanieu/c7d43dfdeebc094494cfdfcf55bc9c7a\">https://gist.github.com/Amanieu/c7d43dfdeebc094494cfdfcf55bc9c7a</a> [^1] [^2]</p>\n<p>[^1]: You can ignore the code in <code>begin_block</code>, that's just there because my IR needs to support multiple entry points.<br>\n[^2]: On a somewhat unrelated note, this code isn't run as a separate GVN pass. It's instead used during IR lowering just before register allocation, which allows for much finer-grained instruction reuse.</p>\n</blockquote>",
        "id": 300315966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1663923314
    }
]