[
    {
        "content": "<p>avanhatt opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">isub</span> <span class=\"p\">(</span><span class=\"nv\">i32</span> <span class=\"nv\">i32</span><span class=\"p\">)</span> <span class=\"nv\">B</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span> <span class=\"p\">(</span><span class=\"nv\">isub</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span><span class=\"p\">)</span>\n           <span class=\"p\">(</span><span class=\"nv\">B.B</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span><span class=\"p\">))</span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span> <span class=\"nv\">isub</span> <span class=\"p\">(</span><span class=\"nv\">Value</span> <span class=\"nv\">Value</span><span class=\"p\">)</span> <span class=\"nv\">Inst</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span>\n    <span class=\"p\">(</span><span class=\"nv\">isub</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nv\">inst_data</span> <span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span> <span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">value_array_2</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span><span class=\"p\">)))</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</blockquote>",
        "id": 280685270,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651264686
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">(</span><span class=\"nv\">B.B</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Value</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Inst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">inst_data</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">value_array_2</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 281773687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652154466
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">(</span><span class=\"nv\">B.B</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Value</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Inst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">inst_data</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">value_array_2</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 281773688,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652154466
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">(</span><span class=\"nv\">B.B</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Value</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Inst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">inst_data</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">value_array_2</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 281773689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652154466
    },
    {
        "content": "<p>cfallin unlabeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">(</span><span class=\"nv\">B.B</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Value</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Inst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">inst_data</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">value_array_2</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 281773690,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652154476
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4089\">issue #4089</a>:</p>\n<blockquote>\n<h4>Feature:</h4>\n<p>I'm working on a PR to add a flag for optionally _not_ expand internal constructors.</p>\n<p>As discussed in an ISLE-verification-focused meeting earlier this week, we'd like to be able to add semantic annotations to terms that are defined with internal extractors. That is, if we have a term like:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">B</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">(</span><span class=\"nv\">B.B</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We would like to be able to refer to <code>isub</code> in annotations. Currently, this is not possible, because the <code>sema::Pattern</code> representation already has the internal extractor expanded in place (like a macro). </p>\n<h4>Benefit</h4>\n<p>(a) This will enable easier downstream verification.<br>\n(b) From our discussion, ISLE may want to use this option in the codegen phase as well in the future in some circumstances. </p>\n<h4>Implementation</h4>\n<p>I have a WIP PR that adds this flag to the <code>TermEnv</code> and uses it in <code>translate_pattern</code>. When the flag is set to false, we can treat the internal extractor like an external one instead of expanding it. </p>\n<p>In addition to sema's <code>compile</code>, I'm adding an <code>envs_for_analysis</code> that sets this flag to <code>false</code> and returns the type and term environments. I added a unit test for this but need to improve it (this is the WIP part). </p>\n<h4>Alternatives</h4>\n<p>We could now allow annotations on internal extractors, however, this introduces a lot of complexity around the underlying, large enums for CLIF and MInst opcodes. </p>\n<p>For example, the actual CLIF <code>isub</code> expands like this, where the <code>inst_data</code> expression is harder to translate to something like SMT:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nv\">decl</span><span class=\"w\"> </span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Value</span><span class=\"w\"> </span><span class=\"nv\">Value</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">Inst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">(</span><span class=\"nv\">extractor</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">isub</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">inst_data</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">InstructionData.Binary</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">Opcode.Isub</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">value_array_2</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n</blockquote>",
        "id": 281773729,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1652154483
    }
]