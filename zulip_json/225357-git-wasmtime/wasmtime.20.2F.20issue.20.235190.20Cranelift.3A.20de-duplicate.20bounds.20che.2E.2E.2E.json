[
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1303894403\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>Trevor and I investigated the failing test on aarch64 and this ultimately led us<br>\nto the conclusion that this patch shouldn't actually land.</p>\n<p>Fundamentally, this PR changes the semantics of <code>heap_addr</code> from \"calculate the<br>\nbase address of the given memory access <em>or trap if it is out of bounds</em>\" to<br>\n\"calculate the base address of the given memory access *or return an address<br>\nthat will trap when accessed*\". And this semantic change only happens when<br>\ndynamic memories and spectre mitigations are enabled. In other configurations<br>\n<code>heap_addr</code> still has the old semantics.</p>\n<p>This leads us into a bit of a mess:</p>\n<ul>\n<li>\n<p>If the result of an out of bounds <code>heap_addr</code> is never loaded from or stored<br>\n  to, then the trap never happens. Not even \"eventually\". This very much does<br>\n  not match <code>heap_addr</code>'s documented semantics.</p>\n</li>\n<li>\n<p>Piggybacking off the spectre mitigation, this PR use <code>0</code> as the address that<br>\n  will trap when accessed. However, I'm not sure that this will always work in<br>\n  the face of large offsets? There is a bit of code emitted from<br>\n<code>cranelift-wasm</code> that does a <code>heap_addr</code> to get a base address and then adds<br>\n  offsets to that base. Need more investigation here.</p>\n</li>\n<li>\n<p>Also according to <code>heap_addr</code>'s documented semantics today, it would be valid<br>\n  to mark a load as <code>notrap</code> when given the result of a <code>heap_addr</code> because if<br>\n  we got to the load then <code>heap_addr</code> already verified that the address is in<br>\n  bounds for us:</p>\n<p><code>\nv0 = heap_addr ...\nv1 = load.i32 little heap notrap v0\n</code></p>\n<p>The <code>notrap</code> flag would become incorrect under these semantic changes.</p>\n<p>That said, I think <code>heap_addr</code> does have roughly the \"or return an address<br>\nthat will trap when accessed\" semantics when we are using static memories? So<br>\nmaybe we actually can make this semantic change to <code>heap_addr</code> and then this<br>\nwould actually make it more consistent across dynamic and static memories? And<br>\nthen the <code>notrap</code> flag would be invalid here.</p>\n</li>\n</ul>\n<p>I'm not sure how to resolve these issues and still deduplicate the bounds checks<br>\n(without going full value range analysis). Given that last point, it might<br>\nactually be better to change <code>heap_addr</code>'s semantics to \"or return an address<br>\nthat will trap when accessed\". We would need to be careful to check that all<br>\nlibcalls that take an address do explicit bounds checks on that address rather<br>\nthan assuming that the JIT code already did one via its <code>heap_addr</code>. This is a<br>\nlittle bit scary since it means that valid assumptions code could have been<br>\nwritten under no longer hold. (Although I don't <em>think</em> we generally make this<br>\nassumption in the code base and <em>usually</em> we take wasm addresses rather than the<br>\nresults of <code>heap_addr</code>s for libcalls; need to take a census to be more sure<br>\nabout this).</p>\n<p>Interested in folks thoughts on this.</p>\n<hr>\n<p>Separately, Trevor and I discovered the following issues / not necessarily<br>\nissues but maybe things we should tighten up:</p>\n<ul>\n<li>\n<p><code>validate_atomic_addr</code> in <code>libcalls.rs</code> only validates a single byte address,<br>\n  not a full size of the access. This means that a bounds check could \"succeed\"<br>\n  when the first byte being accessed is the last byte of memory and then the<br>\n  other bytes of the access are out of bounds. In practice we don't have this<br>\n  bug, because all callers call <code>validate_atomic_addr</code> with <code>base +\n  size_of_access</code> but this is a bit of a foot gun waiting to bite us. Would be<br>\n  nicer to pass the <code>base</code> and <code>size_of_access</code> into <code>validate_atomic_addr</code>,<br>\n  similar to the <code>heap_addr</code> instruction.</p>\n</li>\n<li>\n<p>The heap access spectre mitigation--at least for dynamic memories, I haven't<br>\n  looked at static memories yet--only checks the first byte of the access, not<br>\n  the last byte. This means that speculative execution could do an <code>i64</code> load<br>\n  beginning at the last byte of memory and bring (the cache line for) seven out<br>\n  of bounds bytes into cache.</p>\n</li>\n<li>\n<p>The <code>heap_addr</code> instruction should have <code>.can_trap(true)</code> in the meta crate,<br>\n  according to its documented semantics. It doesn't currently have<br>\n  this. However, this would also prevent <code>heap_addr</code>s from being GVN'd or<br>\n  LICM'd, which we definitely want to happen, we just want to make sure that any<br>\n  load of a <code>heap_addr</code>'d address is still <code>heap_addr</code>'d. Open to suggestions<br>\n  here.</p>\n<p>Although if we do change <code>heap_addr</code>'s semantics to \"or returns an address<br>\nthat will trap when accessed\" we don't need to mark it <code>can_trap(true)</code> and<br>\nthis problem goes away.</p>\n</li>\n</ul>\n<p>cc @cfallin @elliottt @jameysharp </p>\n</blockquote>",
        "id": 308006774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667581704
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1303925192\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>Fundamentally, this PR changes the semantics of heap_addr from \"calculate the<br>\nbase address of the given memory access or trap if it is out of bounds\" to<br>\n\"calculate the base address of the given memory access or return an address<br>\nthat will trap when accessed\".</p>\n</blockquote>\n<p>I think it changes the semantics for dynamic heaps, but this doesn't change the semantics for static heaps I think? In that sense all our libcalls should already be guarded against \"this address is in bounds and should not segfault\" I think?</p>\n</blockquote>",
        "id": 308012166,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667583427
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1303928774\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>Thanks for digging into this; a few thoughts:</p>\n<ul>\n<li>\n<p>I think that, as you suggest, we are already relying on the trap happening when the address is accessed, in the static-memory case. It makes the most sense to me to update the documentation for <code>heap_addr</code> in that light.</p>\n</li>\n<li>\n<p>I was somewhat concerned about this point:</p>\n<blockquote>\n<p>There is a bit of code emitted from<br>\ncranelift-wasm that does a heap_addr to get a base address and then adds<br>\noffsets to that base. Need more investigation here.</p>\n</blockquote>\n<p>and looked into it a bit; are you referring to the code in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/387426e7f4dd740cbee2375079a64e35fc996ed5/cranelift/wasm/src/code_translator.rs#L2179\"><code>prepare_addr</code></a>? If so I think that should generally be safe: its optimization (using <code>heap_addr</code> with the same offset of <code>1</code> for every load with an actual offset potentially larger) is triggered only when it knows that the heap is using a large-enough guard region.</p>\n<p>Arguably such an optimization should be a rewrite rule in Cranelift instead -- translate all <code>heap_addr</code>s on a heap-with-guard-region to use <code>offset=0</code> so they can be GVN'd together -- but I don't think this will cause a correctness issue in the short term, unless I'm misunderstanding or missing some other code...</p>\n</li>\n<li>\n<p>Re: this</p>\n<blockquote>\n<p>We would need to be careful to check that all<br>\nlibcalls that take an address do explicit bounds checks on that address rather<br>\nthan assuming that the JIT code already did one via its heap_addr. This is a<br>\nlittle bit scary since it means that valid assumptions code could have been<br>\nwritten under no longer hold. </p>\n</blockquote>\n<p>if the address will trap when executed, then we're fine safety-wise (this won't be a backdoor around the heap sandbox) but I agree it will cause problems in other ways -- specifically it will result in a SIGSEGV in the runtime rather than in guest code, which will (usually) kill the process. So I agree we should verify that libcalls take Wasm addresses.</p>\n<p>I think this is an issue today though, as (as you noted) the guard-region case already relies on \"actual load/store traps, not <code>heap_addr</code>\". (That increases the importance of doing the above verification, to be clear.)</p>\n</li>\n</ul>\n<hr>\n<p>Overall, I think I'm not as pessimistic on this: it basically changes <code>heap_addr</code> to work in the dynamic-memory case like it does in the static-memory case, and Wasmtime is already well-tested with its page-protection-based bounds checking. As long as the address-0 page is unmapped (as it is on all of our platforms), we are basically using it as a one-page-sized guard region.</p>\n</blockquote>",
        "id": 308012498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667583532
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1303985906\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>are you referring to the code in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/387426e7f4dd740cbee2375079a64e35fc996ed5/cranelift/wasm/src/code_translator.rs#L2179\"><code>prepare_addr</code></a>? If so I think that should generally be safe: its optimization (using <code>heap_addr</code> with the same offset of <code>1</code> for every load with an actual offset potentially larger) is triggered only when it knows that the heap is using a large-enough guard region.</li>\n</ul>\n</blockquote>\n<p>Yeah, and I agree it is safe, it just makes me a little nervous to produce CLIF that has <code>heap_addr</code>s that aren't immediately followed by the associated memory access. As you allude to, I would be more comfortable having this kind of thing done in the mid-end.</p>\n</blockquote>",
        "id": 308025454,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667586839
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304110769\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>I guess the biggest unknown in my mind is how large of a NULL guard page region we can rely on? Because this PR bakes in assumptions that the spectre guard already makes about <code>0 + offset</code> will always trap <em>for any 32-bit Wasm offset immediate</em>.</p>\n<p>For example, given</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">module</span>\n  <span class=\"p\">(</span><span class=\"k\">memory</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"memory\"</span><span class=\"p\">)</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"f\"</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">param</span> <span class=\"kt\">i32</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"k\">result</span> <span class=\"kt\">i32</span><span class=\"p\">)</span>\n    <span class=\"nb\">local.get</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">i32.load</span> <span class=\"k\">offset</span><span class=\"o\">=</span><span class=\"mh\">0xfffffff0</span><span class=\"p\">))</span>\n</code></pre></div>\n<p>We lower that Wasm to this clif:</p>\n<div class=\"codehilite\" data-code-language=\"Scheme\"><pre><span></span><code><span class=\"nv\">v4</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">heap_addr</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">heap0,</span><span class=\"w\"> </span><span class=\"nv\">v2,</span><span class=\"w\"> </span><span class=\"nv\">0x8000_0000</span><span class=\"w\"></span>\n<span class=\"nv\">v5</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iadd_imm</span><span class=\"w\"> </span><span class=\"nv\">v4,</span><span class=\"w\"> </span><span class=\"nv\">0xffff_fff0</span><span class=\"w\"></span>\n<span class=\"nv\">v6</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"k\">load</span><span class=\"o\">.</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">little</span><span class=\"w\"> </span><span class=\"nv\">heap</span><span class=\"w\"> </span><span class=\"nv\">v5</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then (with static memories (but smaller than 4GiB guard region) + spectre guards) legalize that clif to this clif:</p>\n<div class=\"codehilite\" data-code-language=\"Scheme\"><pre><span></span><code><span class=\"c1\">;; check if the pointer is larger than the static memory size (including both</span><span class=\"w\"></span>\n<span class=\"c1\">;; wasm memory and guard pages, I think?)</span><span class=\"w\"></span>\n<span class=\"nv\">v7</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">uextend</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"w\"></span>\n<span class=\"nv\">v8</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">icmp_imm</span><span class=\"w\"> </span><span class=\"nv\">ugt</span><span class=\"w\"> </span><span class=\"nv\">v7,</span><span class=\"w\"> </span><span class=\"nv\">0x8000_0000</span><span class=\"w\"></span>\n<span class=\"nv\">trapnz</span><span class=\"w\"> </span><span class=\"nv\">v8,</span><span class=\"w\"> </span><span class=\"nv\">heap_oob</span><span class=\"w\"></span>\n<span class=\"nv\">v9</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iconst</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">0x8000_0000</span><span class=\"w\"></span>\n<span class=\"c1\">;; gv4 is the memory base</span><span class=\"w\"></span>\n<span class=\"nv\">v10</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">global_value</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">gv4</span><span class=\"w\"></span>\n<span class=\"nv\">v11</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iadd</span><span class=\"w\"> </span><span class=\"nv\">v10,</span><span class=\"w\"> </span><span class=\"nv\">v7</span><span class=\"w\"></span>\n<span class=\"nv\">v12</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iconst</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"nv\">v13</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">icmp</span><span class=\"w\"> </span><span class=\"nv\">ugt</span><span class=\"w\"> </span><span class=\"nv\">v7,</span><span class=\"w\"> </span><span class=\"nv\">v9</span><span class=\"w\">  </span><span class=\"c1\">; v9 = 0x8000_0000</span><span class=\"w\"></span>\n<span class=\"nv\">v4</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">select_spectre_guard</span><span class=\"w\"> </span><span class=\"nv\">v13,</span><span class=\"w\"> </span><span class=\"nv\">v12,</span><span class=\"w\"> </span><span class=\"nv\">v11</span><span class=\"w\">  </span><span class=\"c1\">; v12 = 0</span><span class=\"w\"></span>\n<span class=\"nv\">v5</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iadd_imm</span><span class=\"w\"> </span><span class=\"nv\">v4,</span><span class=\"w\"> </span><span class=\"nv\">0xffff_fff0</span><span class=\"w\"></span>\n<span class=\"nv\">v6</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"k\">load</span><span class=\"o\">.</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">little</span><span class=\"w\"> </span><span class=\"nv\">heap</span><span class=\"w\"> </span><span class=\"nv\">v5</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Do we guarantee a 4GiB-sized NULL guard region? Because doing the spectre guard on the base (<code>v11</code>) rather than base plus offset (<code>v5</code>) makes that assumption. This doesn't seem like something we can rely on, especially across platforms?</p>\n<p>This becomes even more problematic when we look at the legalization of that lowered Wasm's initial clif, this time configured with dynamic memories and spectre guards, and using this patch which removes the dynamic memory's bounds check in favor of the spectre guard's bounds check:</p>\n<div class=\"codehilite\" data-code-language=\"Scheme\"><pre><span></span><code><span class=\"c1\">;; extend wasm i32 pointer to native i64 pointer</span><span class=\"w\"></span>\n<span class=\"nv\">v7</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">uextend</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">v2</span><span class=\"w\"></span>\n<span class=\"c1\">;; gv4 is the base of memory</span><span class=\"w\"></span>\n<span class=\"nv\">v8</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">global_value</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">gv4</span><span class=\"w\"></span>\n<span class=\"c1\">;; overflow check for pointer + offset</span><span class=\"w\"></span>\n<span class=\"nv\">v9</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iconst</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">0xffff_0000</span><span class=\"w\"></span>\n<span class=\"nv\">v10</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">uadd_overflow_trap</span><span class=\"w\"> </span><span class=\"nv\">v7,</span><span class=\"w\"> </span><span class=\"nv\">v9,</span><span class=\"w\"> </span><span class=\"nv\">heap_oob</span><span class=\"w\">  </span><span class=\"c1\">; v9 = 0xffff_0000</span><span class=\"w\"></span>\n<span class=\"c1\">;; gv5 is the length of memory</span><span class=\"w\"></span>\n<span class=\"nv\">v11</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">global_value</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"nv\">gv5</span><span class=\"w\"></span>\n<span class=\"nv\">v12</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iadd</span><span class=\"w\"> </span><span class=\"nv\">v11,</span><span class=\"w\"> </span><span class=\"nv\">v7</span><span class=\"w\"></span>\n<span class=\"nv\">v13</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iconst</span><span class=\"o\">.</span><span class=\"nv\">i64</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"nv\">v14</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">icmp</span><span class=\"w\"> </span><span class=\"nv\">ugt</span><span class=\"w\"> </span><span class=\"nv\">v10,</span><span class=\"w\"> </span><span class=\"nv\">v8</span><span class=\"w\"></span>\n<span class=\"nv\">v4</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">select_spectre_guard</span><span class=\"w\"> </span><span class=\"nv\">v14,</span><span class=\"w\"> </span><span class=\"nv\">v13,</span><span class=\"w\"> </span><span class=\"nv\">v12</span><span class=\"w\">  </span><span class=\"c1\">; v13 = 0</span><span class=\"w\"></span>\n<span class=\"nv\">v5</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"nv\">iadd_imm</span><span class=\"w\"> </span><span class=\"nv\">v4,</span><span class=\"w\"> </span><span class=\"nv\">0xffff_fff0</span><span class=\"w\"></span>\n<span class=\"nv\">v6</span><span class=\"w\"> </span><span class=\"nb\">=</span><span class=\"w\"> </span><span class=\"k\">load</span><span class=\"o\">.</span><span class=\"nv\">i32</span><span class=\"w\"> </span><span class=\"nv\">little</span><span class=\"w\"> </span><span class=\"nv\">heap</span><span class=\"w\"> </span><span class=\"nv\">v5</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We're baking in that same assumption. Now we aren't just letting speculative execution access the hopefully-null-guard-page-protected region of memory in 0..4GiB, but regular Wasm execution as well.</p>\n<p>I think we can fix all this ambiguity by effectively doing <code>select_spectre_guard(base + offset)</code> instead of <code>select_spectre_guard(base) + offset</code>?</p>\n</blockquote>",
        "id": 308038884,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667591902
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304156356\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think we can fix all this ambiguity by effectively doing <code>select_spectre_guard(base + offset)</code> instead of <code>select_spectre_guard(base) + offset</code>?</p>\n</blockquote>\n<p>This requires changes to <code>heap_addr</code> where it will need to be given not the accumulated access size (wasm offset + <code>size_of(type)</code>) but those individual components, so that it can return the native address of the translated wasm address, so that we can spectre guard that rather than the native base.</p>\n</blockquote>",
        "id": 308041651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667592984
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304187257\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>I don't think we can guarantee a 4GB null guard. Memory may be mapped within this range, whether explicitly using mmal or because the executable has a fixed position within this range. Only 4096 bytes is guaranteed on linux as this is the default value for <code>vm.mmap_min_addr</code>.</p>\n</blockquote>",
        "id": 308043495,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667593727
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304244255\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>If I understand the code correctly, I think we handle all of this already -- first, <a href=\"https://github.com/bytecodealliance/wasmtime/blob/387426e7f4dd740cbee2375079a64e35fc996ed5/cranelift/wasm/src/code_translator.rs#L2188\">here</a> we get <code>offset_guard_size</code> from the heap spec, and in the return-NULL-to-trap configuration we should have a guard size of 0 as with any dynamically-bounds-checked memory (or maybe it's a small nominal amount, I don't remember, but certainly not 4GiB). Then, <a href=\"https://github.com/bytecodealliance/wasmtime/blob/387426e7f4dd740cbee2375079a64e35fc996ed5/cranelift/wasm/src/code_translator.rs#L2286\">here</a> we include that offset on the <code>heap_addr</code>, and it will bounds-check appropriately taking the offset into consideration.</p>\n<p>Or I guess all of this is a long way of saying: I don't think we actually lower into that CLIF if dynamic memory is configured. This is subtly different from</p>\n<blockquote>\n<p>This becomes even more problematic when we look at the legalization of that lowered Wasm's initial clif, this time configured with dynamic memories and spectre guards</p>\n</blockquote>\n<p>I think -- if I understand your methodology correct, you took the CLIF generated by translation with static memories enabled, then compiled it with dynamic memories enabled? With the above-linked code I think doing the <em>translation</em> with dynamic memories enabled should result in code that does not assume a 4GiB guard at address 0.</p>\n</blockquote>",
        "id": 308047448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595284
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304246491\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>(And to answer the immediate question, no, we definitely can't assume a 4GiB guard region at address 0! That would be an un-portable mess, as you observe.)</p>\n</blockquote>",
        "id": 308047572,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595344
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304252472\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think -- if I understand your methodology correct, you took the CLIF generated by translation with static memories enabled, then compiled it with dynamic memories enabled? With the above-linked code I think doing the _translation_ with dynamic memories enabled should result in code that does not assume a 4GiB guard at address 0.</p>\n</blockquote>\n<p>No, this is generated from the original input Wasm.</p>\n</blockquote>",
        "id": 308047989,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595500
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304257984\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>Then, <a href=\"https://github.com/bytecodealliance/wasmtime/blob/387426e7f4dd740cbee2375079a64e35fc996ed5/cranelift/wasm/src/code_translator.rs#L2286\">here</a> we include that offset on the <code>heap_addr</code>, and it will bounds-check appropriately taking the offset into consideration.</p>\n</blockquote>\n<p>This still doesn't prevent speculated execution from reading 0..4GiB though, because the generated code ultimately does</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">spectre_guard</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"></span>\n</code></pre></div>\n<p>rather than</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">spectre_guard</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 308048615,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595781
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304252472\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think -- if I understand your methodology correct, you took the CLIF generated by translation with static memories enabled, then compiled it with dynamic memories enabled? With the above-linked code I think doing the _translation_ with dynamic memories enabled should result in code that does not assume a 4GiB guard at address 0.</p>\n</blockquote>\n<p>No, each different legalization example is generated from the original input Wasm with different flags passed to Wasmtime. I was not working with just the CLIF. Always using the original Wasm as input.</p>\n</blockquote>",
        "id": 308048769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667595842
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304265442\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>Ah, OK, I am misreading your concern, sorry. I had thought you were saying that the actual bounds-check (the non-speculative behavior that should result in a trap) was wrong; and was very confused because the result of the <code>uadd_overflow_trap</code> was fed into the <code>icmp</code>, so all seemed to account for the offset.</p>\n<p>But indeed, the select is picking the base prior to the offset addition. We should fix that by reordering the ops, as you suggest, and providing <code>heap_addr</code> with separate offset and size as you've noted.</p>\n<p>Once we do that, are there any other issues with this approach?</p>\n</blockquote>",
        "id": 308050301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667596407
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304267259\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>I had thought you were saying that the actual bounds-check (the non-speculative behavior that should result in a trap) was wrong;</p>\n</blockquote>\n<p>Today, actual execution is not affected by this.</p>\n<p>After this PR, actual execution <em>is</em> affected by this when dynamic memories and spectre guards are both enabled.</p>\n<blockquote>\n<p>But indeed, the select is picking the base prior to the offset addition. We should fix that by reordering the ops, as you suggest, and providing <code>heap_addr</code> with separate offset and size as you've noted.</p>\n<p>Once we do that, are there any other issues with this approach?</p>\n</blockquote>\n<p>Not that I am aware of.</p>\n<p>Currently working on the <code>heap_addr</code> changes. Looks like this is maybe gonna touch more than I anticipated (just got all the errors from non-<code>cranelift-codegen</code> crates, such as the interpreter, out of <code>rustc</code>; we'll see how deep the rabbit hole goes).</p>\n</blockquote>",
        "id": 308050738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667596570
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304267259\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>I had thought you were saying that the actual bounds-check (the non-speculative behavior that should result in a trap) was wrong;</p>\n</blockquote>\n<p>Today, actual execution is not affected by this.</p>\n<p>After this PR as currently written, actual execution <em>is</em> affected by this when dynamic memories and spectre guards are both enabled.</p>\n<blockquote>\n<p>But indeed, the select is picking the base prior to the offset addition. We should fix that by reordering the ops, as you suggest, and providing <code>heap_addr</code> with separate offset and size as you've noted.</p>\n<p>Once we do that, are there any other issues with this approach?</p>\n</blockquote>\n<p>Not that I am aware of.</p>\n<p>Currently working on the <code>heap_addr</code> changes. Looks like this is maybe gonna touch more than I anticipated (just got all the errors from non-<code>cranelift-codegen</code> crates, such as the interpreter, out of <code>rustc</code>; we'll see how deep the rabbit hole goes).</p>\n</blockquote>",
        "id": 308050877,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667596637
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304270579\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>Today, actual execution is not affected by this.</p>\n<p>After this PR as currently written, actual execution is affected by this when dynamic memories and spectre guards are both enabled.</p>\n</blockquote>\n<p>Right, sorry, makes sense now; not sure why I missed that!</p>\n</blockquote>",
        "id": 308051290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667596850
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1304271770\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>not sure why I missed that!</p>\n</blockquote>\n<p>No worries, this stuff is pretty subtle, it has basically taken me all day just to write these comments and read through the code enough to understand what is happening here :-p</p>\n</blockquote>",
        "id": 308051516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667596952
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1310603624\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>@cfallin I've rebased this on top of <code>main</code> and the recent bounds checking related PRs I've landed and all tests are passing now and this should be good to land. Just wanted to flag you to see if you wanted to give it one last once over.</p>\n</blockquote>",
        "id": 309032568,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1668099590
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1311071449\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<p>Just realized @cfallin is going to be OoO for a few days, @jameysharp would you mind taking a look?</p>\n</blockquote>",
        "id": 309108021,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1668126146
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190#issuecomment-1315590290\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5190\">issue #5190</a>:</p>\n<blockquote>\n<blockquote>\n<p>It's unfortunate that the extensive comments in <code>cranelift/filetests/filetests/isa/x64/heap.clif</code> haven't been maintained since @abrown wrote them in #4841. If you have a chance to fix them up before merging this I think that'd be great, but I wouldn't block merging on that.</p>\n</blockquote>\n<p>I plan on fixing up a lot of <code>heap_addr</code> related things, I'll add this to my list.</p>\n</blockquote>",
        "id": 310242870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1668530886
    }
]