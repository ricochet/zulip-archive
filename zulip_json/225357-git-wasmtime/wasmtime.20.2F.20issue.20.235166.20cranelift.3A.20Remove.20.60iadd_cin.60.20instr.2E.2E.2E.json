[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two add's chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Is there any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n</blockquote>",
        "id": 307291634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667302234
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two add's chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n</blockquote>",
        "id": 307291790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667302308
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two add's chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n<hr>\n<p>For reference here's the <a href=\"https://godbolt.org/z/Eb8xn683W\">llvm output for this instruction</a>, and as far as I can tell, it doesn't seem to be doing anything particularly special for any of the arches that we support.</p>\n<p>For the <code>carry &amp; 1</code> it does emit the <code>and</code> instruction + two <code>add</code>'s, and for the <code>carry != 0</code> it does do something special on aarch64 and x86, but we can also pattern match <code>iadd+icmp not zero</code> and emit that same code?</p>\n</blockquote>",
        "id": 307293514,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667302986
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two add's chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n<hr>\n<p>For reference here's the <a href=\"https://godbolt.org/z/Eb8xn683W\">llvm output for this instruction</a>, and as far as I can tell, it doesn't seem to be doing anything particularly special for any of the arches that we support.</p>\n<p>For the <code>carry &amp; 1</code> it does emit the <code>and</code> instruction + two <code>add</code>'s.</p>\n<p>And for the <code>carry != 0</code> it does do something special on aarch64 and x86, but we can also pattern match <code>iadd+icmp not zero</code> and emit that same code?</p>\n</blockquote>",
        "id": 307293563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667303007
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two add's chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n<hr>\n<p>For reference here's the <a href=\"https://godbolt.org/z/Eb8xn683W\">llvm output for this instruction</a>, and as far as I can tell, it doesn't seem to be doing anything particularly special for any of the arches that we support.</p>\n<p>For the <code>carry &amp; 1</code> it does emit the <code>and</code> instruction + two <code>add</code>'s.</p>\n<p>And for the <code>carry != 0</code> it does do something special on aarch64 and x86, but we can also pattern match <code>iadd+icmp not zero</code> and emit that same code.</p>\n</blockquote>",
        "id": 307293588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667303017
    },
    {
        "content": "<p>afonso360 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two <code>add</code>'s chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n<hr>\n<p>For reference here's the <a href=\"https://godbolt.org/z/Eb8xn683W\">llvm output for this instruction</a>, and as far as I can tell, it doesn't seem to be doing anything particularly special for any of the arches that we support.</p>\n<p>For the <code>carry &amp; 1</code> it does emit the <code>and</code> instruction + two <code>add</code>'s.</p>\n<p>And for the <code>carry != 0</code> it does do something special on aarch64 and x86, but we can also pattern match <code>iadd+icmp not zero</code> and emit that same code.</p>\n</blockquote>",
        "id": 307294099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667303237
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298402418\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>What would be the purpose of removing iadd_cin while keeping iadd_carry? It is useful for terminating a bigint addition.</p>\n</blockquote>",
        "id": 307294549,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667303426
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298411454\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>I'm proposing removing <code>iadd_cin</code> because that one feels a bit redundant to me.</p>\n<p>However <code>iadd_carry</code> does have the carry bit output, which makes it quite different, It essentially outputs the carry if either of the two <code>add</code>'s overflows, and as you mentioned it is very useful. We also have specialized instructions in hardware to represent that operation. Which is not the case for our <code>iadd_cin</code>.</p>\n<p><code>iadd_cout</code> is also not a substitute of <code>iadd_carry</code> since that one computes the overflow over a single add.</p>\n</blockquote>",
        "id": 307295935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667304031
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298411454\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>I'm proposing removing <code>iadd_cin</code> because that one feels a bit redundant to me.</p>\n<p>However <code>iadd_carry</code> does have the carry bit output, which makes it quite different.</p>\n<p>It outputs the carry if either of the two <code>add</code>'s overflows, and as you mentioned it is very useful. We also have specialized instructions in hardware to represent that operation. Which is not the case for our <code>iadd_cin</code>.</p>\n<p><code>iadd_cout</code> is also not a substitute of <code>iadd_carry</code> since that one computes the overflow over a single add.</p>\n</blockquote>",
        "id": 307296008,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667304061
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298411454\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>I'm proposing removing <code>iadd_cin</code> because that one feels a bit redundant to me since it could be replaced with two <code>add</code>'s as mentioned above.</p>\n<p>However <code>iadd_carry</code> does have the carry bit output, which makes it quite different.</p>\n<p>It outputs the carry if either of the two <code>add</code>'s overflows, and as you mentioned it is very useful. We also have specialized instructions in hardware to represent that operation. Which is not the case for our <code>iadd_cin</code>.</p>\n<p><code>iadd_cout</code> is also not a substitute of <code>iadd_carry</code> since that one computes the overflow over a single add.</p>\n</blockquote>",
        "id": 307296558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667304288
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298411454\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>I'm proposing removing <code>iadd_cin</code> because that one feels a bit redundant to me since it could be replaced with two <code>add</code>'s as mentioned above.</p>\n<p>However <code>iadd_carry</code> does have the carry bit <strong>output</strong>, which makes it quite different.</p>\n<p>It outputs the carry if either of the two <code>add</code>'s overflows, and as you mentioned it is very useful. We also have specialized instructions in hardware to represent that operation. Which is not the case for our <code>iadd_cin</code>.</p>\n<p><code>iadd_cout</code> is also not a substitute of <code>iadd_carry</code> since that one computes the overflow over a single add.</p>\n</blockquote>",
        "id": 307296590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667304306
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298420407\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>iadd_cin is iadd_carry except that it doesn't materialize the carry flag. In other words iadd_cin can be implemented using a single adc instruction on x86 while iadd_carry must be implemented as adc+setc if not fused with the instruction using the output carry flag.</p>\n</blockquote>",
        "id": 307297334,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667304567
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298430789\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<blockquote>\n<p>In other words iadd_cin can be implemented using a single adc instruction on x86 </p>\n</blockquote>\n<p>Right, but in our case we have no guarantee that the previous input has set the carry flag unless we pattern match some previous instruction.</p>\n<p>So we need to pattern mach the carry input of <code>iadd_cin</code> in order to lower it to an <code>adc</code>. And if we are doing that, we can also do that on <code>iadd</code> and use <code>adc</code> there.</p>\n</blockquote>",
        "id": 307298872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667305145
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298449231\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>What I'm proposing is replacing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add1</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cin</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add2</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In the <code>v3 = iadd v1, v2</code> line, we know that <code>v2</code> is a carry output, so we can pattern match <code>(iadd _ (iadd_cout _ _))</code> and avoid materializing the carry flag by doing the <code>adc</code> instruction there.</p>\n<hr>\n<p>We actually can't yet do this exact pattern matching since ISLE can't match two output instructions, but the same goes for <code>iadd_cin</code>.</p>\n</blockquote>",
        "id": 307301687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667306266
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298449231\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>What I'm proposing is replacing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add1</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cin</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add2</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In the <code>v3 = iadd v1, v2</code> line, we know that <code>v2</code> is a carry output, so we can pattern match <code>(iadd _ (iadd_cout _ _))</code> and avoid materializing the carry flag by doing the <code>adc</code> instruction there.</p>\n<hr>\n<p>We actually can't do this exact pattern matching yet, since ISLE can't match two output instructions, but the same goes for <code>iadd_cin</code>.</p>\n</blockquote>",
        "id": 307301819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667306302
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1298449231\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>What I'm proposing is replacing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add1</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cin</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">add2</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i8</span><span class=\"p\">)</span>:\n    <span class=\"nc\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>~In the <code>v3 = iadd v1, v2</code> line, we know that <code>v2</code> is a carry output, so we can pattern match <code>(iadd _ (iadd_cout _ _))</code> and avoid materializing the carry flag by doing the <code>adc</code> instruction there.~</p>\n<p>Edit: In the <code>v4 = iadd v1, v3</code> line, we can pattern match <code>(iadd _ (iadd _ (iadd_cout _ _)))</code> and avoid materializing the carry flag by doing the <code>adc</code> instruction there.</p>\n<hr>\n<p>We actually can't do this exact pattern matching yet, since ISLE can't match two output instructions, but the same goes for <code>iadd_cin</code>.</p>\n</blockquote>",
        "id": 307302627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667306629
    },
    {
        "content": "<p>scottmcm <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-1828510266\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>Maybe the value is more clear here for wider integers?</p>\n<p>It seems like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>\n<span class=\"w\">    </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cin</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span>\n</code></pre></div>\n<p>would, in general, need to be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">v4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd_cout</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>\n<span class=\"w\">    </span><span class=\"n\">v7</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uextend</span><span class=\"w\"> </span><span class=\"n\">v5</span>\n<span class=\"w\">    </span><span class=\"n\">v8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>\n<span class=\"w\">    </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"w\"> </span><span class=\"n\">v8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v7</span>\n</code></pre></div>\n<p>in order to not have <code>iadd_cin</code>.  Though that's certainly still pattern-matchable, just increasing the number of permutations that would need to be matched.</p>\n<p>(but it's also possible that I completely don't understand cranelift's type expectations)<br>\n</p>\n</blockquote>",
        "id": 404483189,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1701116236
    },
    {
        "content": "<p>afonso360 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<p>This operation is essentially two <code>add</code>'s chained together, I think that any optimizations that we make based on this operation can also be made on the <code>iadd</code> instruction, so there doesn't seem to be any benefit of keeping this around other than frontend convenience. And if that is important, maybe we should just move this to a frontend helper that expands to two <code>iadd</code>'s + some masking for the carry input?</p>\n<p>Additionally since the removal of booleans, the input for the carry bit seems a bit under-specified. We need some form of masking on the carry input, either <code>carry &amp; 1</code> or <code>carry != 0</code>. (This also affects the <code>iadd_carry</code> instruction).</p>\n<p>We discussed carry operations last week in #5123 and also in the cranelift weekly meeting (<a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2022/cranelift-10-26.md\">notes</a>) but nothing concrete about <code>iadd_cin</code> I think.</p>\n<p>Some <a href=\"https://github.com/bytecodealliance/wasmtime/pull/3233#discussion_r695919017\">previous discussion about this</a> mentions that cg-clif may need <code>iadd_cin</code> to \"efficiently implement certain llvm intrinsics used by core::arch intrinsics that are stabilized\" and points to the <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/9f5b52045c928157b12bec1d670e220fc7597375/src/intrinsics/llvm.rs#L145-L181\">current implementation</a> but that seems to be implementing <code>iadd_carry</code> which I agree probably needs to remain.</p>\n<p>@bjorn3 Do you know of any operation that cg-clif would need to do, that needs <code>iadd_cin</code> but couldn't efficiently be replaced with <code>iadd+iadd</code>?</p>\n<hr>\n<p>For reference here's the <a href=\"https://godbolt.org/z/Eb8xn683W\">llvm output for this instruction</a>, and as far as I can tell, it doesn't seem to be doing anything particularly special for any of the arches that we support.</p>\n<p>For the <code>carry &amp; 1</code> it does emit the <code>and</code> instruction + two <code>add</code>'s.</p>\n<p>And for the <code>carry != 0</code> it does do something special on aarch64 and x86, but we can also pattern match <code>iadd+icmp not zero</code> and emit that same code.</p>\n</blockquote>",
        "id": 468281468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1725653474
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166#issuecomment-2334742220\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5166\">issue #5166</a>:</p>\n<blockquote>\n<p>Fixed by #9199</p>\n</blockquote>",
        "id": 468281469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1725653475
    }
]