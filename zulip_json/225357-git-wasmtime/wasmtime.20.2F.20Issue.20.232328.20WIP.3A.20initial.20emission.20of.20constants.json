[
    {
        "content": "<p>abrown <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2328#issuecomment-718107110\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2328\">Issue #2328</a>:</p>\n<blockquote>\n<blockquote>\n<p>At a high level: I think we can actually do things with one less level of indirection</p>\n</blockquote>\n<p>If we want to retain the de-duplication of constants from the constant pool AND avoid comparing long byte sequences, we need to keep track of what <code>Constant</code> handles have been used during lowering. Even if I reserve the next range of <code>MachLabel</code>s after the number of blocks for constants, we still need to keep track of a map of <code>Constant</code> to <code>MachLabel</code> so I can see if we've used a constant previously.</p>\n<p>Additionally, some structure needs to map those <code>MachLabel</code>s back to their constant data so they can actually be emitted once we have a <code>MachBuffer</code> available during <code>VCode::emit</code>. So we need another map of <code>MachLabel</code> to <code>ConstantData</code> so that we can then call <code>MachBuffer::defer_constant</code> after all instructions have been emitted. This map must be separate from the <code>Constant</code> to <code>MachLabel</code> map because during lowering we can generate new constants that will not have a <code>Constant</code> handle (since we can't modify the <code>ConstantPool</code> in <code>self.f.dfg</code>).</p>\n<p>Now, where we put these two maps is debatable (they could go in the same struct, different structs, be attached to <code>Lower</code>, etc.) but I don't see how we get rid of either of them. What do you think?</p>\n</blockquote>",
        "id": 214874751,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1603907731
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2328#issuecomment-719070715\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/2328\">Issue #2328</a>:</p>\n<blockquote>\n<p>Hmm, yes, you're right; I hadn't been considering how deduplication would work. I agree that we need some sort of remapping in order to redirect duplicated constants to the original copy.</p>\n<p>I do think that it would be good to find a way to make the deduplication optional; I want to keep the \"only do the barebones fast code emission\" path as true to that original spirit as possible. Given that many constants will be coming from the CLIF anyway, where they're deduplicated already, I would <em>hope</em> not to lose too much by omitting this (though we can certainly measure!). From your design here, it seems that we could do this with a hybrid data-structure of some sort; maybe an enum with <code>VCodeConstantTable::List { constants: Vec&lt;ConstantData&gt; }</code> and <code>VCodeConstantTable::Deduped { constants: HashMap&lt;ConstantData, VCodeConstant&gt; }</code> ?</p>\n</blockquote>",
        "id": 215039210,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1604012323
    }
]