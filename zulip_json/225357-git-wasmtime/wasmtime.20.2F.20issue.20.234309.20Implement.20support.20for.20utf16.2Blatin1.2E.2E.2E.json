[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4309\">issue #4309</a>:</p>\n<blockquote>\n<p>Currently support for utf16+latin1 is not implemented in Wasmtime, but we'll need to finish this and test it before the component model is considered done.</p>\n<p>In general I'd expect that this would use the <a href=\"https://crates.io/crates/encoding_rs\"><code>encoding_rs</code> crate</a> for the internal details of latin1 to avoid open-coding that in Wasmtime itself.</p>\n<h2>Lowering</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1075-L1077\">Lowering a string into wasm</a> is currently unimplemented. I think that this is required to implement the <code>store_string_to_latin1_or_utf16</code> function in the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\">canonical ABI explainer</a>. My current understanding is that even if we could implement something more optimal in Rust we can't do that because the semantics of lowering are already specified.</p>\n<p>I believe the pseudo-code there does most of the fiddly bits but some small helpers in <code>encoding_rs</code> are probably going to be required.</p>\n<h2>Lifting</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1104\">Calculation of the byte length</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1146\">actually getting the string</a> are unimplemented. I think that we're free to use <code>encoding_rs</code> here however we see fit. Probably the <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> function will be useful here. </p>\n<h2>Other notes</h2>\n<p>I am personally unfamilar with <code>latin1</code> as an encoding. I don't know if an arbitrary list of types are guaranteed to be valid latin1 or not. (the infallibility of <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> seems odd to me). </p>\n<p>Using <code>encoding_rs</code> may be a better option for utf16 decoding we currently do (and maybe even utf8 since <code>encoding_rs</code> can probably do simd things that the standard library can't). If someone's intrepid it might be interesting to try to benchmark this and see if it's beneficial to use <code>encoding_rs</code> for almost everything.</p>\n</blockquote>",
        "id": 287262625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656020787
    },
    {
        "content": "<p>alexcrichton labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4309\">issue #4309</a>:</p>\n<blockquote>\n<p>Currently support for utf16+latin1 is not implemented in Wasmtime, but we'll need to finish this and test it before the component model is considered done.</p>\n<p>In general I'd expect that this would use the <a href=\"https://crates.io/crates/encoding_rs\"><code>encoding_rs</code> crate</a> for the internal details of latin1 to avoid open-coding that in Wasmtime itself.</p>\n<h2>Lowering</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1075-L1077\">Lowering a string into wasm</a> is currently unimplemented. I think that this is required to implement the <code>store_string_to_latin1_or_utf16</code> function in the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\">canonical ABI explainer</a>. My current understanding is that even if we could implement something more optimal in Rust we can't do that because the semantics of lowering are already specified.</p>\n<p>I believe the pseudo-code there does most of the fiddly bits but some small helpers in <code>encoding_rs</code> are probably going to be required.</p>\n<h2>Lifting</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1104\">Calculation of the byte length</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1146\">actually getting the string</a> are unimplemented. I think that we're free to use <code>encoding_rs</code> here however we see fit. Probably the <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> function will be useful here. </p>\n<h2>Other notes</h2>\n<p>I am personally unfamilar with <code>latin1</code> as an encoding. I don't know if an arbitrary list of types are guaranteed to be valid latin1 or not. (the infallibility of <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> seems odd to me). </p>\n<p>Using <code>encoding_rs</code> may be a better option for utf16 decoding we currently do (and maybe even utf8 since <code>encoding_rs</code> can probably do simd things that the standard library can't). If someone's intrepid it might be interesting to try to benchmark this and see if it's beneficial to use <code>encoding_rs</code> for almost everything.</p>\n</blockquote>",
        "id": 287262626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1656020787
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4309\">issue #4309</a>:</p>\n<blockquote>\n<p>Currently support for utf16+latin1 is not implemented in Wasmtime, but we'll need to finish this and test it before the component model is considered done.</p>\n<p>In general I'd expect that this would use the <a href=\"https://crates.io/crates/encoding_rs\"><code>encoding_rs</code> crate</a> for the internal details of latin1 to avoid open-coding that in Wasmtime itself.</p>\n<h2>Lowering</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1075-L1077\">Lowering a string into wasm</a> is currently unimplemented. I think that this is required to implement the <code>store_string_to_latin1_or_utf16</code> function in the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\">canonical ABI explainer</a>. My current understanding is that even if we could implement something more optimal in Rust we can't do that because the semantics of lowering are already specified.</p>\n<p>I believe the pseudo-code there does most of the fiddly bits but some small helpers in <code>encoding_rs</code> are probably going to be required.</p>\n<h2>Lifting</h2>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1104\">Calculation of the byte length</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/87007c58393813f0257f710a92006024c4909a67/crates/wasmtime/src/component/func/typed.rs#L1146\">actually getting the string</a> are unimplemented. I think that we're free to use <code>encoding_rs</code> here however we see fit. Probably the <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> function will be useful here. </p>\n<h2>Other notes</h2>\n<p>I am personally unfamilar with <code>latin1</code> as an encoding. I don't know if an arbitrary list of types are guaranteed to be valid latin1 or not. (the infallibility of <a href=\"https://docs.rs/encoding_rs/latest/encoding_rs/mem/fn.decode_latin1.html\"><code>decode_latin1</code></a> seems odd to me). </p>\n<p>Using <code>encoding_rs</code> may be a better option for utf16 decoding we currently do (and maybe even utf8 since <code>encoding_rs</code> can probably do simd things that the standard library can't). If someone's intrepid it might be interesting to try to benchmark this and see if it's beneficial to use <code>encoding_rs</code> for almost everything.</p>\n</blockquote>",
        "id": 292421840,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1659974519
    }
]