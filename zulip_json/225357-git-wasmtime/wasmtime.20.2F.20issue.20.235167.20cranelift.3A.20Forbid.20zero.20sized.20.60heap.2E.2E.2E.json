[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167#issuecomment-1298908643\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167\">issue #5167</a>:</p>\n<blockquote>\n<p>Really interesting question here!</p>\n<p>My first impulse is actually slightly different: in general I don't like edge cases or discontinuities, and for the same reason that I like, e.g., zero-sized slices to be possible, I think that a <code>heap_addr</code> with a size of <code>0</code> should be legal. It should execute without a trap if the base address given is less than <em>or equal to</em> the length of the heap.</p>\n<p>In other words, the <code>base + size - 1</code> computation finds the address of the last byte of the thing being accessed, and this implicitly assumes there <em>is</em> a last byte (i.e. it's like a <code>vec.last().unwrap()</code>). Instead of <code>base + size - 1 &lt; heap.base + heap.len</code>, I might suggest <code>base + size &lt;= heap.base + heap.len</code>. That naturally handles the zero-sized case, and feels like the right answer for \"limit of behavior as size approaches zero\". (In general I'm also slightly allergic to <code>- 1</code> and <code>+ 1</code> in offset computations; they feel like a sign that we haven't found the most natural expression of the computation. For the same reasons that 0-based array indexing makes more sense etc etc)</p>\n<p>FWIW, the instruction docs just below the quoted part do seem consistent with this: \"If <code>p + Size</code> is greater than the heap bound, generate a trap.\" (Inverting \"greater than\" we get \"less than or equal\", and \"heap bound\" is <code>heap.base + heap.len</code>.)</p>\n<p>Of course it's invalid to actually <em>use</em> the computed pointer to do any access of size greater than zero (that is, any access at all); but that's perfectly fine. That does mean that the tests that you're correcting here are illegal anyway, as they do <code>v + 8</code> and <code>v + 128</code> on the resulting pointers. So separately, we should update those tests to use appropriate <code>Size</code>s (though it doesn't actually matter for the properties we're testing).</p>\n<p>Thoughts?</p>\n</blockquote>",
        "id": 307372055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667325774
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167#issuecomment-1300219709\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167\">issue #5167</a>:</p>\n<blockquote>\n<p>That sounds reasonable! </p>\n<p>And I think we can enforce some of that via the verifier. If we can compute all of the offsets, and that a <code>load</code>/<code>store</code>  is directly referencing a <code>heap_addr</code>,  we can probably check if the access is legal. This still misses a bunch of cases, but I think it might catch the most common ones.</p>\n<p>I'm going to give this a try.</p>\n</blockquote>",
        "id": 307506587,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667390384
    },
    {
        "content": "<p>afonso360 edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167#issuecomment-1300219709\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/5167\">issue #5167</a>:</p>\n<blockquote>\n<p>That sounds reasonable! </p>\n<p>And I think we can enforce some of that via the verifier. If we can compute all of the offsets, and that a <code>load</code>/<code>store</code>  is directly referencing a <code>heap_addr</code>,  we can probably check if the access is legal. This still misses a bunch of cases, but I think it might catch the most common ones.</p>\n<p>I'm going to give that a try.</p>\n</blockquote>",
        "id": 307510797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1667391849
    }
]