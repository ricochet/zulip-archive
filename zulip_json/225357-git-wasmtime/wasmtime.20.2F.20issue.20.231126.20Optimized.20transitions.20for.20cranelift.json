[
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1126#issuecomment-1118024001\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1126\">issue #1126</a>:</p>\n<blockquote>\n<p>It looks like this issue's purpose was mainly to establish answers to the above questions; it looks like there is also a pending question of whether the invariants should be documented. However, it doesn't strike me that they are particularly noteworthy beyond what is already documented: the question is basically whether Cranelift follows the calling convention (restores callee-saved registers), and whether the dataflow of its output is correct (never reads an uninitialized register). These fall out of \"correct compiler that follows the spec\" and aren't any special additional guarantee. So I'll go ahead and close, but please feel free to ask for other clarifications as needed!</p>\n</blockquote>",
        "id": 281234500,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651706914
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1126\">issue #1126</a>:</p>\n<blockquote>\n<p>This bug is in the context of use of Cranelift to generate wasm sandboxed libraries for use in Firefox - i.e. this is a non web embedding. Full details available here <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1562797\">https://bugzilla.mozilla.org/show_bug.cgi?id=1562797</a></p>\n<p>We are using lucet as our wasm compiler which uses Cranelift under the covers. For performance reasons, we need to optimize transitions between native code and wasm sandboxed code beyond what lucet provides out of the box. Key to this is generating efficient trampoline functions that minimize overhead.</p>\n<p>To this end we have rewritten trampolines that make a few assumptions based on \" properties derivable from the WASM spec about register and stack use of a WASM compiler\". These assumptions reduces overhead when using a sandboxed version of libGraphite by several 100's of percent. </p>\n<p>Since this is something indirectly implied from the WASM spec, I am hoping that Cranelift can guarantee these and wanted to confirm if these are OK.</p>\n<p>There are 3 assumptions - one about stacks, and two about register use</p>\n<p>1) Assembly functions generated by Cranelift WASM never underflows the stack</p>\n<div class=\"codehilite\"><pre><span></span><code>- This is guaranteed from the WASM spec due to the fact that WASM functions are proper stack machines\n- This would allow us to use the same stack for the application and wasm module\n- However, our reliance on this depends on how bug-free we think Cranelift&#39;s conversion from the WASM stack machine\n</code></pre></div>\n\n<p>2) Assembly functions generated by Cranelift never reads an uninitialized register</p>\n<div class=\"codehilite\"><pre><span></span><code>- This is an outcome of all function calls to WASM and within WASM (including indirect jumps) being typesafe.\n- This means there should never be code generated that reads from a scratch register prior to writing to it.\n- This also means there should never be code generate for a function that takes 2 parameters, that attempts to read a value from the register that would hold a third parameter (if it had existed)\n- This allows us to avoid clearing scratch and unused parameter registers during WASM function invocation.\n</code></pre></div>\n\n<p>3) Assembly functions generated by Cranelift always restore callee save registers</p>\n<div class=\"codehilite\"><pre><span></span><code>- Like point 2, this is an outcome of all functions being typesafe combined with the fact that WASM is a stack machine, which cannot manipulate the stack in a way that affects register spills. \n- This means that there should no path through the function that would result in a callee save register not being restored\n- This allows us to avoid explicitly restoring registers on the way out\n</code></pre></div>\n\n</blockquote>",
        "id": 281234501,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651706914
    },
    {
        "content": "<p>shravanrn <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1126#issuecomment-1119095008\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1126\">issue #1126</a>:</p>\n<blockquote>\n<p>Sounds good. I had initially raised this question as we are relying on a performance optimization that made the above assumptions. If it is of interest, we have subsequently shown with formal semantics, that any spec conforming Wasm compiler must automatically meet the above restrictions, as well as the workloads and performance benefits we get. Details available <a href=\"https://dl.acm.org/doi/pdf/10.1145/3498688\">here</a></p>\n</blockquote>",
        "id": 281366696,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651789110
    }
]