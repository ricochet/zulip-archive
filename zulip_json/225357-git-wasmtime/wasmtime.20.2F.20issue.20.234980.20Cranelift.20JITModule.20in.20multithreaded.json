[
    {
        "content": "<p>mokhaled2992 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples (<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs</a>) and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files</a>). Now I instantiate one single instance for each thread from that JIT struct and use each only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n</blockquote>",
        "id": 301470328,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664466237
    },
    {
        "content": "<p>mokhaled2992 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">(jit-minimal)</a> and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">cranelift-call rust function</a>). Now I instantiate one single instance for each thread from that JIT struct and use each only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n</blockquote>",
        "id": 301470564,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664466299
    },
    {
        "content": "<p>mokhaled2992 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">(jit-minimal)</a> and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">cranelift-call rust function</a>). Now I instantiate one single instance for each thread from that JIT struct and use each independently only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n</blockquote>",
        "id": 301470720,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664466350
    },
    {
        "content": "<p>mokhaled2992 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">(jit-minimal)</a> and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">cranelift-call rust function</a>). Now I instantiate one single instance for each thread from that JIT struct and use each independently only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n<p>I even tried without calling free_memory at all and still the same problem (only when running in multiple threads as mentioned)</p>\n</blockquote>",
        "id": 301472475,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664466867
    },
    {
        "content": "<p>mokhaled2992 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">(jit-minimal)</a> and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">cranelift-call rust function</a>). Now I instantiate one single instance for each thread from that JIT struct and use each independently only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n<p>I even tried without calling free_memory at all and still the same problem (only when running in multiple threads as mentioned)</p>\n<p>Random guessing, Is there anything shared across JITModules? Perhaps something related to thos relocation tables?</p>\n</blockquote>",
        "id": 301476058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664467815
    },
    {
        "content": "<p>mokhaled2992 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Hi everyone,</p>\n<p>This is asking for help/advice. I have JIT struct very similar to the one in the toy demo. I only generate code that builds a wrapper function that only calls a rust function. Mainly following those examples <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/jit/examples/jit-minimal.rs\">(jit-minimal)</a> and (<a href=\"https://github.com/bytecodealliance/cranelift-jit-demo/pull/60/files\">cranelift-call rust function</a>). Now I instantiate one single instance for each thread from that JIT struct and use each independently only in their own thread to call the function through the pointer I get from that respective JITModule instance. The problem is that I'm getting segmentation faults randomly (as in sometimes they happen sometimes not) when I try to call the functions through the returned pointers and this happens only in multi threaded testing, I never had this issue a single time when I tested my code in single threaded environment. Are there any limitations to using the JITModule in multithreaded environments or any common pitfalls that I should watch for? If needed, I can try to write a minimal example (although wouldn't be very different from the samples above). </p>\n<p>I even tried without calling free_memory at all and still the same problem (only when running in multiple threads as mentioned)</p>\n<p>Random guessing, Is there anything shared across JITModules? Perhaps something related to those relocation tables?</p>\n</blockquote>",
        "id": 301476114,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664467830
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980#issuecomment-1262551310\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Nothing is shared between JITModule's. Instantiating a single JITModule per thread should be just fine. Have you tried getting a backtrace and referenced address for the crashes? Two things I could think of is that either somehow two memory mappings got more than 2GB apart from each without causing an immediate panic, or the memory allocator can't handle the fact that we change memory protection for allocated memory in multi threaded scenarios. Could you try enabling the <code>selinux-fix</code> feature to see if that fixes it? This switches from malloc to mmap.</p>\n</blockquote>",
        "id": 301486045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664470643
    },
    {
        "content": "<p>mokhaled2992 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980#issuecomment-1262640044\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Thanks for getting back so quickly! I will try this feature. I thought about panics but shouldn't I see this before invoking the function pointer? I mean at the steps of compiling/loading? Regarding the addresses, here is what I did already, I print the address I get from get_finalized_function, attach the debugger, get bt from the thread that received the signal. The last address in the bt is the same as the printed one.</p>\n</blockquote>",
        "id": 301501909,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664475063
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980#issuecomment-1262682124\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>The panic I was talking about should happen during <code>finalize_definitions</code>. If it didn't happen at that point, it won't happen at all.</p>\n<p>Can you check if the memory at the the function address is mapped as r-x and not as rw-? You can check the <code>/proc/&lt;pid of crashing process&gt;/maps</code> file while the debugger is attached.</p>\n</blockquote>",
        "id": 301509303,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664477365
    },
    {
        "content": "<p>mokhaled2992 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980#issuecomment-1262689352\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4980\">issue #4980</a>:</p>\n<blockquote>\n<p>Yea verifying the permissions sounds like something worth checking. So are you suggesting that somehow setting the proper permissions fails silently? That would be really strange given that the segfault happens randomly, sometimes everything just works out in all threads. But I will check that, I already started a build with <code>selinux-fix</code>.</p>\n</blockquote>",
        "id": 301510594,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1664477798
    }
]