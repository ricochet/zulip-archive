[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>E.g. it may make sense for the <code>cg_clif</code> (the cranelift-based backend for rustc) to have its own peephole optimizations pass that contains optimizations specific to code generated by <code>cg_clif</code>.</p>\n</blockquote>",
        "id": 197595030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589479646
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>E.g. it may make sense for the <code>cg_clif</code> (the cranelift-based backend for rustc) to have its own peephole optimizations pass that contains optimizations specific to code generated by <code>cg_clif</code>.</p>\n</blockquote>",
        "id": 197595031,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589479646
    },
    {
        "content": "<p>fitzgen labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>E.g. it may make sense for the <code>cg_clif</code> (the cranelift-based backend for rustc) to have its own peephole optimizations pass that contains optimizations specific to code generated by <code>cg_clif</code>.</p>\n</blockquote>",
        "id": 197595033,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589479647
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-628800398\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift:area:peepmatic\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: cranelift:area:peepmatic</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 197595053,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589479658
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-628800401\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @bnjbvr</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>bnjbvr: cranelift</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 197595054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1589479659
    },
    {
        "content": "<p>MaxGraey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659061599\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>Regarding other peepmatic transform rules I'm wondering is it possible implement such simplification for integers which actually behave as boolean? Something like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">=&gt;</span> <span class=\"p\">(</span><span class=\"k\">when</span> <span class=\"p\">(</span><span class=\"n\">icmp_imm</span> <span class=\"n\">eq</span> <span class=\"mi\">0</span> <span class=\"n\">$x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"n\">bit-width</span> <span class=\"n\">$x</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"n\">bxor_imm</span> <span class=\"mi\">1</span> <span class=\"n\">$x</span><span class=\"p\">))</span>\n</code></pre></div>\n\n\n<p>and other thansforms which have <code>i1</code> (boolean) type. Or it doesn't make sense for peepmatic?</p>\n</blockquote>",
        "id": 204024584,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594854755
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659092495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>Although there is a <code>b1</code> type for 1-bit booleans, there isn't really an <code>i1</code> type for 1-bit integers.</p>\n<p>As for specifically replacing an <code>icmp_imm</code> with an <code>bxor_imm</code>, I'm not convinced it would improve codegen since both instructions have a single uop and latency of 1 cycle on x86_64 (I don't know about aarch64).</p>\n<p>On the more general topic of \"what kind of optimizations make sense for peepmatic?\": I don't think it makes sense to focus on adding one-off peepmatic optimizations to Cranelift at this time. Instead, I am planning on writing</p>\n<ul>\n<li>a left-hand side extractor, that extracts candidate LHSes from clif IR into <a href=\"https://github.com/google/souper/\">Souper</a> IR, and</li>\n<li>a Souper optimization to peepmatic DSL translator.</li>\n</ul>\n<p>With these two bits in hand, we will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes. This should be much more fruitful (and less buggy!) than writing optimizations by hand.</p>\n<p>But of course by the time we have these synthesized optimizations from Souper, we need a way to hook them into Cranelift, which is what resolving this issue should provide :)</p>\n<p>If you're interested in helping out with this stuff, let me know and I can try and divide up these tasks into smaller bits! Also, I probably didn't explain everything super well, so if you have questions about what I am talking about, don't hesitate to ask questions.</p>\n</blockquote>",
        "id": 204032830,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594861168
    },
    {
        "content": "<p>MaxGraey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659223055\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>a left-hand side extractor, that extracts candidate LHSes from clif IR into Souper IR<br>\nwe will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes</p>\n</blockquote>\n<p>That's sound very cool! As I understand it's working in this <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">repo</a> currently?</p>\n</blockquote>",
        "id": 204054375,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594885498
    },
    {
        "content": "<p>MaxGraey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659223055\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>a left-hand side extractor, that extracts candidate LHSes from clif IR into Souper IR<br>\nwe will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes</p>\n</blockquote>\n<p>That's sound very cool! As I understand progress going <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">here</a>?</p>\n</blockquote>",
        "id": 204054744,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594885804
    },
    {
        "content": "<p>MaxGraey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659223055\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>a left-hand side extractor, that extracts candidate LHSes from clif IR into Souper IR<br>\nwe will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes</p>\n</blockquote>\n<p>That's sound very cool! As I understand progress going <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">here</a>?</p>\n<blockquote>\n<p>As for specifically replacing an icmp_imm with an bxor_imm, I'm not convinced it would improve codegen since both instructions have a single uop and latency of 1 cycle on x86_64 (I don't know about aarch64).</p>\n</blockquote>\n<p>Thanks for explanation. I just ask about this due to LLVM's cost model it seems always prefer bit-wise <code>xor</code> for <code>i1</code> types</p>\n</blockquote>",
        "id": 204054921,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594885953
    },
    {
        "content": "<p>MaxGraey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659223055\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>a left-hand side extractor, that extracts candidate LHSes from clif IR into Souper IR<br>\nwe will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes</p>\n</blockquote>\n<p>That's sound very cool! As I understand progress going <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">here</a>?</p>\n<blockquote>\n<p>As for specifically replacing an icmp_imm with an bxor_imm, I'm not convinced it would improve codegen since both instructions have a single uop and latency of 1 cycle on x86_64 (I don't know about aarch64).</p>\n</blockquote>\n<p>Thanks for explanation. I just ask about this due to LLVM's cost model it seems always prefer bit-wise <code>xor</code> for <code>i1</code>/<code>b1</code> types</p>\n</blockquote>",
        "id": 204054940,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594885979
    },
    {
        "content": "<p>MaxGraey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-659223055\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>a left-hand side extractor, that extracts candidate LHSes from clif IR into Souper IR<br>\nwe will be able to automatically find missing optimizations, and generate the optimal RHS for each of our given LHSes</p>\n</blockquote>\n<p>That's sound very cool! As I understand progress going <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">here</a>?</p>\n<blockquote>\n<p>As for specifically replacing an icmp_imm with an bxor_imm, I'm not convinced it would improve codegen since both instructions have a single uop and latency of 1 cycle on x86_64 (I don't know about aarch64).</p>\n</blockquote>\n<p>Thanks for explanation. I just ask about this due to LLVM's cost model it seems always prefer bit-wise <code>xor</code> for <code>i1</code>/<code>b1</code> types in this case</p>\n</blockquote>",
        "id": 204054962,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1594886002
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-660216202\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>That's sound very cool! As I understand progress going <a href=\"https://github.com/jubitaneja/cranelift-peepholes\">here</a>?</p>\n</blockquote>\n<p>Sort of. Jubi and I are working closely together, but her project is taking a slightly different path (translating Souper optimizations into Rust source code that implements a peephole pass directly, rather than using peepmatic, which didn't exist when she started). That said, we are sharing notes and brainstorming together.</p>\n<p>I haven't started working on the extractor or the Souper-to-peepmatic stuff yet, because I've been busy with reference types.</p>\n<blockquote>\n<p>I just ask about this due to LLVM's cost model it seems always prefer bit-wise <code>xor</code> for <code>i1</code>/<code>b1</code> types in this case</p>\n</blockquote>\n<p>It could be canonicalization, like you mentioned in the other thread. Or perhaps on some microarchs it makes a difference.</p>\n</blockquote>",
        "id": 204229882,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595004331
    },
    {
        "content": "<p>MaxGraey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-660303644\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>I haven't started working on the extractor or the Souper-to-peepmatic stuff yet, because I've been busy with reference types</p>\n</blockquote>\n<p>Ah, got it. Yeah, implementing reference types is really puzzled for vm and compilers. I heard llvm / lld has some difficulties with that.</p>\n</blockquote>",
        "id": 204249719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595014892
    },
    {
        "content": "<p>MaxGraey edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-660303644\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<blockquote>\n<p>I haven't started working on the extractor or the Souper-to-peepmatic stuff yet, because I've been busy with reference types</p>\n</blockquote>\n<p>Ah, got it. Yeah, implementing reference types is really puzzled for vm and compilers. I heard llvm / lld has some difficulties with that as well</p>\n</blockquote>",
        "id": 204249735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595014906
    },
    {
        "content": "<p>MaxGraey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709#issuecomment-660452896\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1709\">Issue #1709</a>:</p>\n<blockquote>\n<p>I'm wondering is it make sense add optimization for double equal to zero? For example binaryen (wasm target) when optimize for size usually prefer <code>(i32.eqz (i32.eqz (local.get $x)))</code> instead <code>(i32.ne (local.get $x) (i32.const 0)))</code> due to first version one byte smaller</p>\n</blockquote>",
        "id": 204292318,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1595062873
    }
]