[
    {
        "content": "<p><a href=\"https://github.com/jameysharp\">jameysharp</a> added the isle label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8651\">Issue #8651</a>.</p>",
        "id": 439292549,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715980417
    },
    {
        "content": "<p>jameysharp opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8651\">issue #8651</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Instead of emitting a function call when a constructor or extractor is used, under some circumstances ISLE should inline the body of the term at the call site. It currently does this for all internal extractors, but not for anything else.</p>\n<p>Which terms are useful to inline varies depending on whether the ISLE source is being used for code generation or for formal verification, so we should figure out how best to specify that.</p>\n<h4>Benefit</h4>\n<p>If inlining is done before building the \"trie-again\" representation, then overlap checking can be more precise, allowing fewer rules to have priorities. The following step, of serializing the trie-again sea of nodes into a decision tree, also relies on overlap checking for optimization and can generate better code.</p>\n<p>For the purposes of formal verification, inlining a term means that term does not need a hand-written spec because it can just be incorporated into a larger verification query.</p>\n<p>See also #8599.</p>\n<h4>Implementation</h4>\n<p>With our current representations, inlining a term preserves semantics as long as the term is declared either <code>partial</code> or <code>multi</code>, or we can prove that for every possible input there is some rule in the term which will match that input. A reasonable approximation to the latter condition is to check if there is some rule which can match all inputs. If we add the ability to represent cases where terms currently may panic then we can inline all terms, but we can cover a lot of useful cases without doing that.</p>\n<p>Our current strategy for building a <code>trie_again::RuleSet</code> doesn't give us an easy way to inline terms which are defined by more than one rule. I'd like to see a first implementation of inlining supporting only single-rule terms; let's come back to the multi-rule terms later.</p>\n<p>In <code>sema.rs</code>, the <code>Rule::visit</code> method is almost exactly what we need for inlining a rule. The key difference is that instead of calling <code>visitor.add_arg</code> to create a fresh <code>PatternId</code> for each argument, we need to provide a <code>PatternId</code> from the caller. This method will then return an <code>Expr</code> to the caller, which it can use in subsequent bindings. <a href=\"https://github.com/bytecodealliance/wasmtime/blob/7e8abe388e7bd6ae28d4335a3cd89c8692c5c98f/cranelift/isle/isle/src/sema.rs#L870\">https://github.com/bytecodealliance/wasmtime/blob/7e8abe388e7bd6ae28d4335a3cd89c8692c5c98f/cranelift/isle/isle/src/sema.rs#L870</a></p>\n<p>For multi-rule terms, I think the relatively simplest thing to do is add \"push\" and \"pop\" operations to the visitor traits. In <code>trie_again</code>'s implementation of those traits, instead of keeping a single current rule, it would keep a collection of rules. <code>push</code> would clone all of them and keep a stack of pending partial rules; <code>pop</code> would add all the current rules to the rule set and restore the top group from the stack as the new current rules; and all the other visitor methods would apply to all rules in the current rules group.</p>\n<p>In the future though, I'd like to explore unifying alternatives within bindings and constraints. I think it's always possible to introduce \"union\" binding/constraints over a list of alternatives, and have later parts of the rule use only the values introduced by the union binding. That way there's no combinatorial explosion from inlining. It makes overlap checking and serialization more confusing though.</p>\n<p>cc: @avanhatt @mmcloughlin</p>\n</blockquote>",
        "id": 439292553,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715980418
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8651#issuecomment-2118391305\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8651\">issue #8651</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 439292631,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1715980455
    }
]