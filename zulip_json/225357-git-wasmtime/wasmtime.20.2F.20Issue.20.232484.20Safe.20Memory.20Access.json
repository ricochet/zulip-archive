[
    {
        "content": "<p>theduke opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from resorting <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 219096183,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356048
    },
    {
        "content": "<p>theduke edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from resorting <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 219096341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356109
    },
    {
        "content": "<p>theduke edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from needing <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 219096401,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356133
    },
    {
        "content": "<p>theduke edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from needing <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase or the complications this would involve, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 219096432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356151
    },
    {
        "content": "<p>theduke edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints and may even be unfeasible, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from needing <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase or the complications this would involve, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 219096753,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356291
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484#issuecomment-740010778\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<p>Thanks for the report! It should definitely be safe to add these, and no locking necessary at this time even! The main thing is handling long-lived borrows and reentrancy into wasm, but these clearly wouldn't be reentrant, so they should be safe to implement.</p>\n<p>Would you be up for making a PR for these?</p>\n</blockquote>",
        "id": 219098274,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607356938
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484#issuecomment-740087202\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<p>Taking both a <code>Range</code> and a slice as arguments mean the length to read/write is specified in both arguments. Instead of specifying the range, specify an offset.</p>\n<p>Additionally - there's some amount of overlap between this functionality and what the <code>wiggle</code> family of crates provides. Have you tried using wiggle to abstract over access to wasm memory?</p>\n</blockquote>",
        "id": 219115893,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607364608
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484#issuecomment-740124003\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<p>While this is currently safe now, as long as no one has a live <code>unsafe { memory.data_unchecked() }</code> borrow active, as soon as we implement threading this will become unsafe because of potential data races.</p>\n<ul>\n<li>\n<p>Do we expect to just mark it <code>unsafe</code> once we add threading support?</p>\n</li>\n<li>\n<p>Or assert that the memory is not shared and panic if it is? We could even do this now, even though it is technically safe to do with a shared memories today since we don't support threading.</p>\n<p>* Also we could check for shared memory and return an error rather than panicking.</p>\n</li>\n</ul>\n<p>I think the check-for-shared-memory-and-return-error is probably the best approach, and it is future compatible.</p>\n</blockquote>",
        "id": 219124953,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607368590
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484#issuecomment-740147891\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<p>Ah that's a good point yeah we'd just need an <code>offset</code> rather than a whole <code>Range</code> @pchickey!</p>\n<p>@fitzgen I think this could even be safe for shared memories? It's basically just a <code>memory.copy</code> but for the host? It does mean we can't use <code>memcpy</code> for atomic memories (we'd have to do a loop with large-width atomics probably, or maybe even LLVM's atomic memcpy intrinsic if that's ever stabilized), but we should still be able to do whatever the JIT does safely.</p>\n</blockquote>",
        "id": 219130763,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607371322
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484#issuecomment-740149825\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<p>If we gave it the <code>memory.copy</code> semantics that could work yeah. But yeah we can't <code>memcpy</code> for shared memories. Sounds good to me.</p>\n</blockquote>",
        "id": 219131267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1607371548
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2484\">Issue #2484</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently the only way to access instance memory is with <code>data_unchecked[_mut]</code> or <code>data_ptr</code>.</p>\n<p>It would be very convenient to have methods that can atomically read or write a range of bytes, with internal locking and safety guarantees provided by the implementation.</p>\n<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">data_read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buffer</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">data_write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span>: <span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">MemoryAccessError</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'd assume this doesn't exist to prevent the need for internal locking or other implementation constraints and may even be unfeasible, but it would be a very helpful feature.</p>\n<h4>Benefit</h4>\n<p>Prevent users from needing <code>unsafe</code> and make wasmtime easier to use.</p>\n<h4>Implementation</h4>\n<p>I'm not familiar with the codebase or the complications this would involve, but I'd be happy to contribute if I get some pointers.</p>\n</blockquote>",
        "id": 224052055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1611673761
    }
]