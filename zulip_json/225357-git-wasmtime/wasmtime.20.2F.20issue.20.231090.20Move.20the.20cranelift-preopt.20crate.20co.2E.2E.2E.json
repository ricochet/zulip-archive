[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090\">issue #1090</a>:</p>\n<blockquote>\n<p>I think cranelift-preopt was separated from cranelift-codegen because we assume that, in general, the input IR has been generated by an optimizing compiler (namely, one that ran constant folding). This being said, in our use case, when translating wasm to clif, we're likely to introduce redundancies and constant-foldable instructions that aren't obvious to catch (because we're operating on one wasm binary opcode at a time). There was also another instance of constant-foldable operations being emitted by legalization recently.</p>\n<p>In principle, every pass that takes IR and augments it (by adding more IR nodes) is likely to introduce redundancies / constant-foldable instructions. I'd like someone to get more data on this, but how would people feel about putting the cranelift-preopt constant folding facilities into codegen instead?</p>\n</blockquote>",
        "id": 281218124,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651697709
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090#issuecomment-1405463071\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090\">issue #1090</a>:</p>\n<blockquote>\n<p>This could be merged into the egraph impl, right?</p>\n</blockquote>",
        "id": 323814756,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1674759564
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090#issuecomment-1405492024\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090\">issue #1090</a>:</p>\n<blockquote>\n<p>I didn't know cranelift-preopt existed. Wow. Looks like 1) most of it is covered by <code>cprop.isle</code> in the egraph work already; 2) the cranelift-preopt rules for <code>udiv</code> are wrong in two ways I think?</p>\n<p>We should add appropriate floating-point rules to <code>cprop.isle</code>, but even without that I'd be inclined to just delete this crate, unless somebody has objections.</p>\n</blockquote>",
        "id": 323819913,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1674761007
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090#issuecomment-1405535647\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090\">issue #1090</a>:</p>\n<blockquote>\n<p>No objections from me. I don't use it in cg_clif.</p>\n</blockquote>",
        "id": 323824461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1674762366
    },
    {
        "content": "<p>jameysharp closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1090\">issue #1090</a>:</p>\n<blockquote>\n<p>I think cranelift-preopt was separated from cranelift-codegen because we assume that, in general, the input IR has been generated by an optimizing compiler (namely, one that ran constant folding). This being said, in our use case, when translating wasm to clif, we're likely to introduce redundancies and constant-foldable instructions that aren't obvious to catch (because we're operating on one wasm binary opcode at a time). There was also another instance of constant-foldable operations being emitted by legalization recently.</p>\n<p>In principle, every pass that takes IR and augments it (by adding more IR nodes) is likely to introduce redundancies / constant-foldable instructions. I'd like someone to get more data on this, but how would people feel about putting the cranelift-preopt constant folding facilities into codegen instead?</p>\n</blockquote>",
        "id": 323913261,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1674768756
    }
]