[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>Currently, CLIF has three kinds of endianness for memory loads and stores: big, little, and native. The meaning of a native-endian operation depends on the platform on which the CLIF executes.</p>\n<p>The purpose of this three-option design, as we discussed in #2124, was to allow for convenience at the CLIF producer side: loads and stores that are meant to access platform-native values (such as pointers in a stack frame or data passed to and from code produced by other compilers) can simply use the \"native\" option, and the CLIF becomes parametric to endianness, working correctly on platforms of both endians.</p>\n<p>It appears that, in the discussion in #2124, we initially (<a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735932166\">comment</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735943287\">comment</a>) were leaning toward a strict two-option (big/little), always-explicit endianness flag on memory ops, but then it became apparent that this would require some more plumbing to know the endianness upfront.</p>\n<p>The new forcing function that we have, however, is the CLIF interpreter. Because we now have an interpreter that is platform-independent, it becomes important to define what result a given CLIF execution should provide. It seems very important that this should be the same result regardless of the platform we happen to be running on. Otherwise, if a CLIF program can have multiple results depending on platform, then many other endianness issues could occur at higher levels of the system.</p>\n<p>In essence, we're late-binding endianness, after the CLIF is produced. In contrast, other compilers, such as LLVM, use a form of early-binding: e.g., the <a href=\"https://llvm.org/docs/LangRef.html#data-layout\">data layout</a> that is a part of a program in LLVM IR specifies the endianness assumed by the IR.</p>\n<p>In this issue I'm suggesting that we consider doing the same: it would provide well-defined CLIF semantics, and <em>shouldn't</em> impact the ergonomics of most CLIF producers, requiring a bit more info when creating a builder (target platform) but then using the target's native endianness where \"native\" would have been used before.</p>\n<p>One alternative is to disallow (i.e., declare to be undefined behavior) any CLIF that has a native-endian load/store interact with another access in a way that exposes endian-dependent behavior, but that seems much more problematic, because many real programs do this (e.g., Rust compiled via <code>cg_clif</code> can perfectly legally store a <code>u32</code> to memory and load its first byte). Another alternative is to bias the interpreter toward one endianness or another (e.g., the interpreter always behaves like a little-endian machine), but then the results differ between interpretation and native execution on opposite-endianness machines (e.g. big-endian), which is also undesirable.</p>\n<p>This is a continuation of the discussion in #3329; cc @uweigand @afonso360 @fitzgen and others. Thoughts?</p>\n</blockquote>",
        "id": 253814190,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631916549
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369#issuecomment-922109186\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>To make the proposal a bit more concrete, this would involve two changes:</p>\n<ul>\n<li>Require either a specific target, or at least an endianness, when creating a function or instruction builder. (Probably \"full target\" rather than \"endianness\" as the latter is a low-level detail to most users; and probably when creating the function rather than a particular builder.)</li>\n<li>Make the load/store metadata support only the two endianness options.</li>\n</ul>\n</blockquote>",
        "id": 253814593,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631916748
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369#issuecomment-922112467\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>Those two changes sound great to me! <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 253815505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631917275
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369#issuecomment-922208413\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>The clif ir has to be target dependent one way or another as you have to use the right pointer size.</p>\n</blockquote>",
        "id": 253842449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1631944335
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369#issuecomment-922853989\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>@cfallin maybe we can <em>both</em> make architecture features like byte order (or pointer size?) explicit in the IR <em>and</em> reduce the amount of changes to be introduced, by declaring global architecture properties just once in the IR, along the lines of how LLVM IR has a datalayout statement just once per file?</p>\n</blockquote>",
        "id": 254036136,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632138356
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369#issuecomment-923016207\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>@bjorn3:</p>\n<blockquote>\n<p>The clif ir has to be target dependent one way or another as you have to use the right pointer size.</p>\n</blockquote>\n<p>Yes, that would probably be a part of the information too, like LLVM's <code>DataLayout</code>. (That said, varying pointer width is a different sort of nondeterminism concern than endianness because while changing endianness directly alters the semantics of loads/stores, changing pointer width just means that code with baked-in 32-bit-layout assumptions may overflow; but the semantics of each individual instruction are still well-defined. So from a \"can the interpreter arrive at the one correct answer according to the semantics\" perspective, it's not quite the same.)</p>\n<p>@uweigand:</p>\n<blockquote>\n<p>declaring global architecture properties just once in the IR, along the lines of how LLVM IR has a datalayout statement just once per file?</p>\n</blockquote>\n<p>Maybe, though I do like the aspect of CLIF that all attributes are per-function currently (which I suppose arose from the parallel-compilation-compatible design of keeping all IR data per function). Purely to keep to that principle I think it might be simpler to have a <code>big_endian</code> / <code>little_endian</code> attribute and a <code>pointer32</code> / <code>pointer64</code> attribute (among others?) on the function itself.<br>\n</p>\n</blockquote>",
        "id": 254065094,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1632150556
    },
    {
        "content": "<p>akirilov-arm labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>Currently, CLIF has three kinds of endianness for memory loads and stores: big, little, and native. The meaning of a native-endian operation depends on the platform on which the CLIF executes.</p>\n<p>The purpose of this three-option design, as we discussed in #2124, was to allow for convenience at the CLIF producer side: loads and stores that are meant to access platform-native values (such as pointers in a stack frame or data passed to and from code produced by other compilers) can simply use the \"native\" option, and the CLIF becomes parametric to endianness, working correctly on platforms of both endians.</p>\n<p>It appears that, in the discussion in #2124, we initially (<a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735932166\">comment</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735943287\">comment</a>) were leaning toward a strict two-option (big/little), always-explicit endianness flag on memory ops, but then it became apparent that this would require some more plumbing to know the endianness upfront.</p>\n<p>The new forcing function that we have, however, is the CLIF interpreter. Because we now have an interpreter that is platform-independent, it becomes important to define what result a given CLIF execution should provide. It seems very important that this should be the same result regardless of the platform we happen to be running on. Otherwise, if a CLIF program can have multiple results depending on platform, then many other endianness issues could occur at higher levels of the system.</p>\n<p>In essence, we're late-binding endianness, after the CLIF is produced. In contrast, other compilers, such as LLVM, use a form of early-binding: e.g., the <a href=\"https://llvm.org/docs/LangRef.html#data-layout\">data layout</a> that is a part of a program in LLVM IR specifies the endianness assumed by the IR.</p>\n<p>In this issue I'm suggesting that we consider doing the same: it would provide well-defined CLIF semantics, and <em>shouldn't</em> impact the ergonomics of most CLIF producers, requiring a bit more info when creating a builder (target platform) but then using the target's native endianness where \"native\" would have been used before.</p>\n<p>One alternative is to disallow (i.e., declare to be undefined behavior) any CLIF that has a native-endian load/store interact with another access in a way that exposes endian-dependent behavior, but that seems much more problematic, because many real programs do this (e.g., Rust compiled via <code>cg_clif</code> can perfectly legally store a <code>u32</code> to memory and load its first byte). Another alternative is to bias the interpreter toward one endianness or another (e.g., the interpreter always behaves like a little-endian machine), but then the results differ between interpretation and native execution on opposite-endianness machines (e.g. big-endian), which is also undesirable.</p>\n<p>This is a continuation of the discussion in #3329; cc @uweigand @afonso360 @fitzgen and others. Thoughts?</p>\n</blockquote>",
        "id": 255810168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1633123785
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>Currently, CLIF has three kinds of endianness for memory loads and stores: big, little, and native. The meaning of a native-endian operation depends on the platform on which the CLIF executes.</p>\n<p>The purpose of this three-option design, as we discussed in #2124, was to allow for convenience at the CLIF producer side: loads and stores that are meant to access platform-native values (such as pointers in a stack frame or data passed to and from code produced by other compilers) can simply use the \"native\" option, and the CLIF becomes parametric to endianness, working correctly on platforms of both endians.</p>\n<p>It appears that, in the discussion in #2124, we initially (<a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735932166\">comment</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735943287\">comment</a>) were leaning toward a strict two-option (big/little), always-explicit endianness flag on memory ops, but then it became apparent that this would require some more plumbing to know the endianness upfront.</p>\n<p>The new forcing function that we have, however, is the CLIF interpreter. Because we now have an interpreter that is platform-independent, it becomes important to define what result a given CLIF execution should provide. It seems very important that this should be the same result regardless of the platform we happen to be running on. Otherwise, if a CLIF program can have multiple results depending on platform, then many other endianness issues could occur at higher levels of the system.</p>\n<p>In essence, we're late-binding endianness, after the CLIF is produced. In contrast, other compilers, such as LLVM, use a form of early-binding: e.g., the <a href=\"https://llvm.org/docs/LangRef.html#data-layout\">data layout</a> that is a part of a program in LLVM IR specifies the endianness assumed by the IR.</p>\n<p>In this issue I'm suggesting that we consider doing the same: it would provide well-defined CLIF semantics, and <em>shouldn't</em> impact the ergonomics of most CLIF producers, requiring a bit more info when creating a builder (target platform) but then using the target's native endianness where \"native\" would have been used before.</p>\n<p>One alternative is to disallow (i.e., declare to be undefined behavior) any CLIF that has a native-endian load/store interact with another access in a way that exposes endian-dependent behavior, but that seems much more problematic, because many real programs do this (e.g., Rust compiled via <code>cg_clif</code> can perfectly legally store a <code>u32</code> to memory and load its first byte). Another alternative is to bias the interpreter toward one endianness or another (e.g., the interpreter always behaves like a little-endian machine), but then the results differ between interpretation and native execution on opposite-endianness machines (e.g. big-endian), which is also undesirable.</p>\n<p>This is a continuation of the discussion in #3329; cc @uweigand @afonso360 @fitzgen and others. Thoughts?</p>\n</blockquote>",
        "id": 281218897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651698091
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3369\">issue #3369</a>:</p>\n<blockquote>\n<p>Currently, CLIF has three kinds of endianness for memory loads and stores: big, little, and native. The meaning of a native-endian operation depends on the platform on which the CLIF executes.</p>\n<p>The purpose of this three-option design, as we discussed in #2124, was to allow for convenience at the CLIF producer side: loads and stores that are meant to access platform-native values (such as pointers in a stack frame or data passed to and from code produced by other compilers) can simply use the \"native\" option, and the CLIF becomes parametric to endianness, working correctly on platforms of both endians.</p>\n<p>It appears that, in the discussion in #2124, we initially (<a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735932166\">comment</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2124#issuecomment-735943287\">comment</a>) were leaning toward a strict two-option (big/little), always-explicit endianness flag on memory ops, but then it became apparent that this would require some more plumbing to know the endianness upfront.</p>\n<p>The new forcing function that we have, however, is the CLIF interpreter. Because we now have an interpreter that is platform-independent, it becomes important to define what result a given CLIF execution should provide. It seems very important that this should be the same result regardless of the platform we happen to be running on. Otherwise, if a CLIF program can have multiple results depending on platform, then many other endianness issues could occur at higher levels of the system.</p>\n<p>In essence, we're late-binding endianness, after the CLIF is produced. In contrast, other compilers, such as LLVM, use a form of early-binding: e.g., the <a href=\"https://llvm.org/docs/LangRef.html#data-layout\">data layout</a> that is a part of a program in LLVM IR specifies the endianness assumed by the IR.</p>\n<p>In this issue I'm suggesting that we consider doing the same: it would provide well-defined CLIF semantics, and <em>shouldn't</em> impact the ergonomics of most CLIF producers, requiring a bit more info when creating a builder (target platform) but then using the target's native endianness where \"native\" would have been used before.</p>\n<p>One alternative is to disallow (i.e., declare to be undefined behavior) any CLIF that has a native-endian load/store interact with another access in a way that exposes endian-dependent behavior, but that seems much more problematic, because many real programs do this (e.g., Rust compiled via <code>cg_clif</code> can perfectly legally store a <code>u32</code> to memory and load its first byte). Another alternative is to bias the interpreter toward one endianness or another (e.g., the interpreter always behaves like a little-endian machine), but then the results differ between interpretation and native execution on opposite-endianness machines (e.g. big-endian), which is also undesirable.</p>\n<p>This is a continuation of the discussion in #3329; cc @uweigand @afonso360 @fitzgen and others. Thoughts?</p>\n</blockquote>",
        "id": 281218904,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651698095
    }
]