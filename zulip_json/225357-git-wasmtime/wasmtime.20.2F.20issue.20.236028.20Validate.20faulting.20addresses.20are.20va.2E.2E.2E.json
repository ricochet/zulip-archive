[
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1470886798\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @peterhuene</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>peterhuene: wasmtime:api</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 342172735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1678916704
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1470989244\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 342188525,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1678923890
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1472113639\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<blockquote>\n<p>A high-level question as well: a pagefault from within a hostcall won't trigger the warning, right? Or do we enter the handler if an instance in the store is on the stack at all?</p>\n</blockquote>\n<p>Correct, yeah. We've actually got tests which ensure that a host-triggered segfault isn't caught by Wasmtime and aborts the process (as you'd expect a segfault in a language like Rust to do so). The first thing the signal handlers do is test whether the faulting pc is a wasm pc, and it defers to the default behavior of each signal if it's not a wasm pc. If it's a wasm pc though we fully catch the trap assuming it's expected that the wasm instruction had the kind of fault.</p>\n</blockquote>",
        "id": 342333538,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1678977778
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1472787301\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<p>@uweigand I was wondering if I could enlist your help to debug a failure here. This has <a href=\"https://github.com/bytecodealliance/wasmtime/actions/runs/4441496969/jobs/7796650018\">failed in CI</a> with this error:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">----</span><span class=\"w\"> </span><span class=\"n\">traps</span>::<span class=\"n\">wasm_fault_address_reported_by_default</span><span class=\"w\"> </span><span class=\"n\">stdout</span><span class=\"w\"> </span><span class=\"o\">----</span>\n<span class=\"n\">thread</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">traps</span>::<span class=\"n\">wasm_fault_address_reported_by_default</span><span class=\"o\">'</span><span class=\"w\"> </span><span class=\"n\">panicked</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">bad</span><span class=\"w\"> </span><span class=\"n\">error</span>: <span class=\"nc\">error</span><span class=\"w\"> </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">executing</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">backtrace</span>:\n    <span class=\"mi\">0</span>:   <span class=\"mh\">0x25</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">unknown</span><span class=\"o\">&gt;!</span><span class=\"n\">start</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">memory</span><span class=\"w\"> </span><span class=\"n\">fault</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"w\"> </span><span class=\"mh\">0xdeadb000</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">linear</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"mh\">0x10000</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>: <span class=\"nc\">wasm</span><span class=\"w\"> </span><span class=\"n\">trap</span>: <span class=\"nc\">out</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"o\">'</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tests</span><span class=\"o\">/</span><span class=\"n\">all</span><span class=\"o\">/</span><span class=\"n\">traps</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">1308</span>:<span class=\"mi\">5</span>\n</code></pre></div>\n<p>where this is the module being executed:</p>\n<div class=\"codehilite\" data-code-language=\"wasm\"><pre><span></span><code>            (module\n                (memory 1)\n                (func $start\n                    i32.const 0xdeadbeef\n                    i32.load\n                    drop)\n                (start $start)\n            )\n</code></pre></div>\n<p>and the test is asserting:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">format!</span><span class=\"p\">(</span><span class=\"s\">\"{err:?}\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"fm\">assert!</span><span class=\"p\">(</span>\n<span class=\"w\">        </span><span class=\"n\">err</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"s\">\"memory fault at wasm address 0xdeadbeef in linear memory of size 0x10000\"</span><span class=\"p\">),</span>\n<span class=\"w\">        </span><span class=\"s\">\"bad error: {err}\"</span>\n<span class=\"w\">    </span><span class=\"p\">);</span>\n</code></pre></div>\n<p>so it seems like s390x is reporting the faulting address of the load instruction is something page-rounded (or something like that?). I don't know how to hook up gdb to qemu but in theory this means that the address coming out of <code>siginfo_t</code>'s <code>si_addr</code> field in the signal handler doesn't have the <code>0xeef</code> at the end and instead ends in <code>0x000</code> (I think).</p>\n<p>Do you know if this is an s390x-specific behavior? Are faulting addresses reported at their page aligned boundary instead of the address itself?</p>\n</blockquote>",
        "id": 342428077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679003091
    },
    {
        "content": "<p>uweigand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1473845279\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<blockquote>\n<p>Do you know if this is an s390x-specific behavior? Are faulting addresses reported at their page aligned boundary instead of the address itself?</p>\n</blockquote>\n<p>Yes, this is correct.  Faulting addresses are rounded to their 4k page boundary on s390x.</p>\n</blockquote>",
        "id": 342561654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679059668
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028#issuecomment-1473929314\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6028\">issue #6028</a>:</p>\n<blockquote>\n<p>Ok good to know it's expected! I'll disable this particular test for s390x in that case.</p>\n</blockquote>",
        "id": 342577079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679063313
    }
]