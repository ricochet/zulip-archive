[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">PR #1237</a> from <code>memory-arg</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit adds a first-class way to access a caller's memory when<br>\ndefining a <code>Func</code> implemented by the host. This is a very common usage<br>\nscenario where the wasm module calls a host function with pointers to<br>\nits own wasm memory, and the host function needs to read that<br>\ninformation.</p>\n<p>Currently, however, it's pretty roundabout to implement this<br>\nfunctionality in wasm. Typically you'll have to set up an<br>\n<code>Rc&lt;RefCell&lt;Option&lt;Memory&gt;&gt;&gt;</code>, close over that in your function imports,<br>\nand then fill it in once the instance is created. The goal of this PR is<br>\nto make it more ergonomic to implement this.</p>\n<p>Note that eventually this is intended to be supplanted by interface<br>\ntypes which automatically and safely convert from wasm memory to host<br>\nobjects. Interface types though is still aways out and it seemed like it<br>\nwould be prudent to have this functionality for users today.</p>\n<p>Currently the shape of this functionality is to allow adding an argument<br>\nto <code>Func::wrap*</code> closures of <code>Option&lt;Memory&gt;</code>. If available this option<br>\nwill be filled in with <code>Some</code> of the <em>caller's</em> memory. This ends up<br>\nbeing <code>None</code> in a few places:</p>\n<ul>\n<li>The calling module may not actually have a memory</li>\n<li>There may not be a calling module in the case that you directly call<br>\n<code>Func::call</code> or similar.</li>\n</ul>\n<p>Note that this is also at least violating the spirit of the JS API,<br>\nsince there's no equivalent to this functionality there whatsoever.<br>\nAdditionally this breaks concepts of encapsulation because it means your<br>\nmemory can be accessed regardless of whether it's exported or not. To<br>\nmake matters even worse it has no way to cope with multi-memory, it<br>\nsimply returns <code>None</code> if there's more than one memory defined.</p>\n<p>Overall this is intended to be <em>a convenience</em> or an escape hatch. As a<br>\nhost you sort of get the power to do whatever you want with the module.<br>\nEmpirically there's at least one major use case of this today, WASI.<br>\nThere's also been mentions on Zulip of other needs for something like<br>\nthis as well. This feels like it's basically useful enough that we<br>\nshould provide it today, with an eye towards deprecating it once<br>\ninterface types are implemented.</p>\n</blockquote>",
        "id": 189821752,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583432944
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">PR #1237</a> from <code>memory-arg</code> to <code>master</code>:</p>\n<blockquote>\n<p>This commit adds a first-class way to access a caller's memory when<br>\ndefining a <code>Func</code> implemented by the host. This is a very common usage<br>\nscenario where the wasm module calls a host function with pointers to<br>\nits own wasm memory, and the host function needs to read that<br>\ninformation.</p>\n<p>Currently, however, it's pretty roundabout to implement this<br>\nfunctionality in wasm. Typically you'll have to set up an<br>\n<code>Rc&lt;RefCell&lt;Option&lt;Memory&gt;&gt;&gt;</code>, close over that in your function imports,<br>\nand then fill it in once the instance is created. The goal of this PR is<br>\nto make it more ergonomic to implement this.</p>\n<p>Note that eventually this is intended to be supplanted by interface<br>\ntypes which automatically and safely convert from wasm memory to host<br>\nobjects. Interface types though is still aways out and it seemed like it<br>\nwould be prudent to have this functionality for users today.</p>\n<p>Currently the shape of this functionality is to allow adding an argument<br>\nto <code>Func::wrap*</code> closures of <code>Option&lt;Memory&gt;</code>. If available this option<br>\nwill be filled in with <code>Some</code> of the <em>caller's</em> memory. This ends up<br>\nbeing <code>None</code> in a few places:</p>\n<ul>\n<li>The calling module may not actually have a memory</li>\n<li>There may not be a calling module in the case that you directly call<br>\n<code>Func::call</code> or similar.</li>\n</ul>\n<p>Note that this is also at least violating the spirit of the JS API,<br>\nsince there's no equivalent to this functionality there whatsoever.<br>\nAdditionally this breaks concepts of encapsulation because it means your<br>\nmemory can be accessed regardless of whether it's exported or not. To<br>\nmake matters even worse it has no way to cope with multi-memory, it<br>\nsimply returns <code>None</code> if there's more than one memory defined.</p>\n<p>Overall this is intended to be <em>a convenience</em> or an escape hatch. As a<br>\nhost you sort of get the power to do whatever you want with the module.<br>\nEmpirically there's at least one major use case of this today, WASI.<br>\nThere's also been mentions on Zulip of other needs for something like<br>\nthis as well. This feels like it's basically useful enough that we<br>\nshould provide it today, with an eye towards deprecating it once<br>\ninterface types are implemented.</p>\n</blockquote>",
        "id": 189824429,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583434584
    },
    {
        "content": "<p>alexcrichton closed without merge <a href=\"https://github.com/bytecodealliance/wasmtime/pull/1237\" target=\"_blank\" title=\"https://github.com/bytecodealliance/wasmtime/pull/1237\">PR #1237</a>.</p>",
        "id": 190289523,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1583938228
    }
]