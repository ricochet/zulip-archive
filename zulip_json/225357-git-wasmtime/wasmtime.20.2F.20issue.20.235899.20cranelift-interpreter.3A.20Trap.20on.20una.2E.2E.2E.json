[
    {
        "content": "<p>afonso360 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>aligned</code> flag, and always trap if the access is unaligned.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>By default, Cranelift memory instructions work with any unaligned effective address. If the aligned flag is set, the instruction is permitted to trap or return a wrong result if the effective address is misaligned.</p>\n</blockquote>\n<p>But, trapping in these cases seems like the best course of action because the CLIF is invalid/undefined.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L311-L316\"><code>State::checked_{load,store}</code></a>  check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.aligned\">aligned</a> flag set.</li>\n<li>If they do and the alignment of the address is smaller than the alignment of the type. We should return a <code>MemoryError</code><ul>\n<li>The interpreter uses a virtual addressing scheme, so we don't have proper \"alignment\", but we can use the <code>offset</code> field in the address which should be good enough!</li>\n</ul>\n</li>\n<li>We can't build the usual tests for this. <ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Fuzzgen never sets this flag wrongly (I hope), so this shouldn't affect the fuzzer. And the current implementation is legal so we can always just keep it.<br>\n</p>\n</blockquote>",
        "id": 338801218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668026
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>aligned</code> flag, and always trap if the access is unaligned.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>By default, Cranelift memory instructions work with any unaligned effective address. If the aligned flag is set, the instruction is permitted to trap or return a wrong result if the effective address is misaligned.</p>\n</blockquote>\n<p>But, trapping in these cases seems like the best course of action because the CLIF is invalid/undefined.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L311-L316\"><code>State::checked_{load,store}</code></a>  check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.aligned\">aligned</a> flag set.</li>\n<li>If they do and the alignment of the address is smaller than the alignment of the type. We should return a <code>MemoryError</code><ul>\n<li>The interpreter uses a virtual addressing scheme, so we don't have proper \"alignment\", but we can use the <code>offset</code> field in the address which should be good enough!</li>\n</ul>\n</li>\n<li>We can't build the usual tests for this. <ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Fuzzgen never sets this flag wrongly (I hope), so this shouldn't affect the fuzzer. And the current implementation is legal so we can always just keep it.<br>\n</p>\n</blockquote>",
        "id": 338801393,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668060
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>aligned</code> flag, and always trap if the access is unaligned.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>By default, Cranelift memory instructions work with any unaligned effective address. If the aligned flag is set, the instruction is permitted to trap or return a wrong result if the effective address is misaligned.</p>\n</blockquote>\n<p>But, trapping in these cases seems like the best course of action because the CLIF is invalid/undefined.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L311-L316\"><code>State::checked_{load,store}</code></a>  check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.aligned\">aligned</a> flag set.</li>\n<li>If they do and the alignment of the address is smaller than the alignment of the type. We should return a <code>MemoryError</code><ul>\n<li>The interpreter uses a virtual addressing scheme, so we don't have proper \"alignment\", but we can use the <code>offset</code> field in the address which should be good enough!</li>\n</ul>\n</li>\n<li>We can't build the usual tests for this. <ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Fuzzgen never sets this flag wrongly (I hope), so this shouldn't affect the fuzzer. And the current implementation is legal so we can always just keep it.<br>\n</p>\n</blockquote>",
        "id": 338801394,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668060
    },
    {
        "content": "<p>afonso360 labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>aligned</code> flag, and always trap if the access is unaligned.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>By default, Cranelift memory instructions work with any unaligned effective address. If the aligned flag is set, the instruction is permitted to trap or return a wrong result if the effective address is misaligned.</p>\n</blockquote>\n<p>But, trapping in these cases seems like the best course of action because the CLIF is invalid/undefined.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L311-L316\"><code>State::checked_{load,store}</code></a>  check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.aligned\">aligned</a> flag set.</li>\n<li>If they do and the alignment of the address is smaller than the alignment of the type. We should return a <code>MemoryError</code><ul>\n<li>The interpreter uses a virtual addressing scheme, so we don't have proper \"alignment\", but we can use the <code>offset</code> field in the address which should be good enough!</li>\n</ul>\n</li>\n<li>We can't build the usual tests for this. <ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Fuzzgen never sets this flag wrongly (I hope), so this shouldn't affect the fuzzer. And the current implementation is legal so we can always just keep it.<br>\n</p>\n</blockquote>",
        "id": 338801397,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1677668061
    },
    {
        "content": "<p>meithecatte <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899#issuecomment-1484080218\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p>Shouldn't this be closed, considering #5921 got merged?</p>\n</blockquote>",
        "id": 344649385,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679833234
    },
    {
        "content": "<p>afonso360 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899#issuecomment-1484110902\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p>That's right, thanks for the reminder!</p>\n</blockquote>",
        "id": 344670034,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679840403
    },
    {
        "content": "<p>afonso360 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5899\">issue #5899</a>:</p>\n<blockquote>\n<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Hey,</p>\n<h4>Feature</h4>\n<p>After #5893 we now have access to <code>MemFlags</code> when loading and storing to memory. We should check the <code>aligned</code> flag, and always trap if the access is unaligned.</p>\n<p>Technically the current behaviour of ignoring it and loading correctly anyway is allowed.</p>\n<blockquote>\n<p>By default, Cranelift memory instructions work with any unaligned effective address. If the aligned flag is set, the instruction is permitted to trap or return a wrong result if the effective address is misaligned.</p>\n</blockquote>\n<p>But, trapping in these cases seems like the best course of action because the CLIF is invalid/undefined.</p>\n<h4>Benefit</h4>\n<p>This gets us a better interpretation of CLIF semantics and allows whoever is using the interpreter to catch these cases sooner.</p>\n<h4>Implementation</h4>\n<ul>\n<li>In <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L311-L316\"><code>State::checked_{load,store}</code></a>  check if the memory flags have the <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/struct.MemFlags.html#method.aligned\">aligned</a> flag set.</li>\n<li>If they do and the alignment of the address is smaller than the alignment of the type. We should return a <code>MemoryError</code><ul>\n<li>The interpreter uses a virtual addressing scheme, so we don't have proper \"alignment\", but we can use the <code>offset</code> field in the address which should be good enough!</li>\n</ul>\n</li>\n<li>We can't build the usual tests for this. <ul>\n<li>Our <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/cranelift/filetests/filetests/runtests\"><code>runtests</code></a> don't support checking for traps (cc  #4781). </li>\n<li>What we can do instead is build a CLIF program and invoke the interpreter using the library API. See this <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c4a2c1e81893a41b363ba135b9fd79fb77eb0531/cranelift/interpreter/src/interpreter.rs#L893-L913\">example for a test case testing traps on <code>srem</code></a>, we can do something similar for load/store.</li>\n</ul>\n</li>\n</ul>\n<h4>Alternatives</h4>\n<p>Fuzzgen never sets this flag wrongly (I hope), so this shouldn't affect the fuzzer. And the current implementation is legal so we can always just keep it.<br>\n</p>\n</blockquote>",
        "id": 344670037,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1679840403
    }
]