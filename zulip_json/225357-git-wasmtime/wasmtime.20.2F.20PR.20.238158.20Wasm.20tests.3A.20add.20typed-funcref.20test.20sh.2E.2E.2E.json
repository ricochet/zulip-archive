[
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/jameysharp\">jameysharp</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>.</p>",
        "id": 426988848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710646158
    },
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a> from <code>cfallin:typed-funcref-ics-test</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>In order to have fast IC (inline cache) chains in AOT-compiled dynamic language Wasms, it would be great if we could make the \"call to a typed funcref at a constant table index\" pattern fast.</p>\n<p>This use-case was discussed at the most recent Wasmtime biweekly and @jameysharp is working on some optimizations; the intent of this PR is to provide a concrete test-case whose blessed output we can see improve over time.</p>\n<p>In particular, the following opts are still desirable:</p>\n<ul>\n<li>With the use of non-nullable typed funcrefs, there shouldn't be a null check (there currently is, as noted by a comment in the code due to lack of type information at the right spot).</li>\n<li>With the use of a constant table size and a constant index to the <code>table.get</code>, we should be able to load from the table without a bounds-check or any Spectre masking.</li>\n</ul>\n<p>Other further optimizations for this pattern might be possible if we rearrange the table and function-reference data structures, and the lazy-initialization scheme thereof, but the above should be agnostic to that.</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 426988850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710646158
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>.</p>",
        "id": 426988852,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710646158
    },
    {
        "content": "<p>jameysharp submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#pullrequestreview-1941375209\">PR review</a>:</p>\n<blockquote>\n<p>\"Chris,\" I whine to myself, \"stop working on a Saturday evening,\" as I approve your PR at 10pm</p>\n<p>Thanks for this! It's definitely the kind of thing I was hoping for.</p>\n<p>This example module initializes element zero of the table to point to a function, then calls through elements one and two. What is that supposed to do? Or am I misreading it?</p>\n</blockquote>",
        "id": 427010431,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710652121
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002526786\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><code>(table $ic-sites 100 100 (ref $ic-stub) (ref.func $ic1))</code></p>\n</blockquote>\n<p>This example module initializes element zero of the table to point to a function</p>\n</blockquote>\n<p>Oh this syntax is actually initializing the entire table with <code>(ref.func $ic1)</code>, it's new syntax/binary stuff introduced as part of the function-references proposal (basically folded into the gc proposal)</p>\n<hr>\n<p>Somewhat orthogonal question as well: I forget if I asked this in the past, but is the reason to use a typed table instead of typed globals to get the lazy initialization? If I change the above test to use two typed function globals it ends up codegenning (today)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">u0</span>:<span class=\"mi\">1</span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"nc\">fast</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">gv0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vmctx</span>\n<span class=\"w\">    </span><span class=\"n\">gv1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">readonly</span><span class=\"w\"> </span><span class=\"n\">gv0</span><span class=\"o\">+</span><span class=\"mi\">8</span>\n<span class=\"w\">    </span><span class=\"n\">gv2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">gv1</span>\n<span class=\"w\">    </span><span class=\"n\">gv3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vmctx</span>\n<span class=\"w\">    </span><span class=\"n\">sig0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"nc\">fast</span>\n<span class=\"w\">    </span><span class=\"n\">sig1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">uext</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">uext</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"nc\">uext</span><span class=\"w\"> </span><span class=\"n\">system_v</span>\n<span class=\"w\">    </span><span class=\"n\">sig2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">vmctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">uext</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"nc\">uext</span><span class=\"w\"> </span><span class=\"n\">system_v</span>\n<span class=\"w\">    </span><span class=\"n\">stack_limit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">gv2</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v4</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span>:\n                                    <span class=\"nc\">v8</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">v0</span>\n<span class=\"w\">                                    </span><span class=\"n\">v14</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">v0</span>\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">b</span><span class=\"w\">                               </span><span class=\"n\">v9</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"o\">+</span><span class=\"mi\">80</span>\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">brif</span><span class=\"w\"> </span><span class=\"n\">v9</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">block3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">block2</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block2</span><span class=\"w\"> </span><span class=\"n\">cold</span>:\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">trap</span><span class=\"w\"> </span><span class=\"n\">null_reference</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block3</span>:\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">v10</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">readonly</span><span class=\"w\"> </span><span class=\"n\">v9</span><span class=\"o\">+</span><span class=\"mi\">16</span>\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">v11</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">readonly</span><span class=\"w\"> </span><span class=\"n\">v9</span><span class=\"o\">+</span><span class=\"mi\">32</span>\n<span class=\"o\">@</span><span class=\"mi\">003</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">v12</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">call_indirect</span><span class=\"w\"> </span><span class=\"n\">sig0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v10</span><span class=\"p\">(</span><span class=\"n\">v11</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span><span class=\"p\">)</span>\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">c</span><span class=\"w\">                               </span><span class=\"n\">v15</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"o\">+</span><span class=\"mi\">96</span>\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">e</span><span class=\"w\">                               </span><span class=\"n\">brif</span><span class=\"w\"> </span><span class=\"n\">v15</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">block5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">block4</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block4</span><span class=\"w\"> </span><span class=\"n\">cold</span>:\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">e</span><span class=\"w\">                               </span><span class=\"n\">trap</span><span class=\"w\"> </span><span class=\"n\">null_reference</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block5</span>:\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">e</span><span class=\"w\">                               </span><span class=\"n\">v16</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">readonly</span><span class=\"w\"> </span><span class=\"n\">v15</span><span class=\"o\">+</span><span class=\"mi\">16</span>\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">e</span><span class=\"w\">                               </span><span class=\"n\">v17</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">readonly</span><span class=\"w\"> </span><span class=\"n\">v15</span><span class=\"o\">+</span><span class=\"mi\">32</span>\n<span class=\"o\">@</span><span class=\"mi\">004</span><span class=\"n\">e</span><span class=\"w\">                               </span><span class=\"n\">v18</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">call_indirect</span><span class=\"w\"> </span><span class=\"n\">sig0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v16</span><span class=\"p\">(</span><span class=\"n\">v17</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v5</span><span class=\"p\">)</span>\n<span class=\"o\">@</span><span class=\"mi\">0057</span><span class=\"w\">                               </span><span class=\"n\">jump</span><span class=\"w\"> </span><span class=\"n\">block1</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block1</span>:\n<span class=\"o\">@</span><span class=\"mi\">0052</span><span class=\"w\">                               </span><span class=\"n\">v19</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iadd</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v18</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v12</span>\n<span class=\"w\">                                    </span><span class=\"n\">v6</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">v19</span>\n<span class=\"o\">@</span><span class=\"mi\">0057</span><span class=\"w\">                               </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">v19</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>which is pretty good given that we've got <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5291\">https://github.com/bytecodealliance/wasmtime/issues/5291</a> in our pocket</p>\n</blockquote>",
        "id": 427156972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710692088
    },
    {
        "content": "<p>jameysharp <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002535045\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<p>Thanks Alex, now I understand!</p>\n<p>I'd forgotten about #5291; we just added a different use of memflags to indicate trap code so we have precedent now. But besides that, if I understood Chris correctly, this example is supposed to be typed as a non-nullable function reference. So if we thread that type information through correctly then we should be able to elide the null-check even without #5291, right?</p>\n</blockquote>",
        "id": 427163970,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710693909
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002542113\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<p>Indeed, this initializes everything then calls ICs 1 and 2, which were meant to be arbitrary -- I'll add some comments to make it clearer!</p>\n<blockquote>\n<p>is the reason to use a typed table instead of typed globals to get the lazy initialization?</p>\n</blockquote>\n<p>not quite; I realized once I progressed past \"IC caller\" logic to \"IC update\" logic that while AOT-compiling can produce bodies that have statically different code locations per IC head, the update logic is shared (polymorphic over IC index) and there's no \"set global N to V\" instruction. I could potentially finagle the IC-stub ABI to return a new funcref and always update in the statically-unique callsite sequence or something, but that's a lot of overhead if these are frequent; IMHO this is what tables are made for :-)</p>\n</blockquote>",
        "id": 427169432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710695384
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>.</p>",
        "id": 427170408,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710695633
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>.</p>",
        "id": 427171091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710695794
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>.</p>",
        "id": 427179843,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710698168
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002558118\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<p>Ah so the <code>call_ref</code> instructions are always done with a constant index, but the <code>table.set</code> instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all <code>call_ref</code> is done with a constant index or otherwise this codegen wouldn't be representative.</p>\n<blockquote>\n<p>So if we thread that type information through correctly then we should be able to elide the null-check even without <a href=\"https://github.com/bytecodealliance/wasmtime/issues/5291\">https://github.com/bytecodealliance/wasmtime/issues/5291</a>, right?</p>\n</blockquote>\n<p>True!</p>\n<p>Thinking a bit more on this, if the <code>table.get</code> plus <code>call_ref</code> pair were replaced with <code>call_indirect</code> we wouldn't have to solve the problem of propagating validator type information into lowering. In such a situation we could inspect the table's type and notice that it's non-nullable and skip the null check. I think it should be the case that <code>table.get</code> plus <code>call_ref</code> should be the same codegen as <code>call_indirect</code> at least ...</p>\n</blockquote>",
        "id": 427181342,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710698588
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002567541\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<p>This has inspired me to go off and do <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8159\">https://github.com/bytecodealliance/wasmtime/pull/8159</a> to handle the null check </p>\n</blockquote>",
        "id": 427187558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710700318
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>\n</blockquote>\n<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>\n<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>\n<blockquote>\n<p><code>call_indirect</code> instead</p>\n</blockquote>\n<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the \"typed funcref\" proposal; for some reason I had it pegged as \"old dynamic sig check\" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>\n<hr>\n<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>\n<p>IC sites always start as linked to the \"fallback IC\"; my planned use for this \"fast IC head\" mechanism was to have a conditional at very IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>\n<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc.</p>\n</blockquote>",
        "id": 427208914,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710706175
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>\n</blockquote>\n<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>\n<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>\n<blockquote>\n<p><code>call_indirect</code> instead</p>\n</blockquote>\n<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the \"typed funcref\" proposal; for some reason I had it pegged as \"old dynamic sig check\" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>\n<hr>\n<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>\n<p>IC sites always start as linked to the \"fallback IC\"; my planned use for this \"fast IC head\" mechanism was to have a conditional at every IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>\n<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc.</p>\n</blockquote>",
        "id": 427209188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710706242
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2002601881\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<blockquote>\n<p>Ah so the call_ref instructions are always done with a constant index, but the table.set instructions are done with a variable index? (if I'm understanding you right). I mostly wanted to confirm that all call_ref is done with a constant index or otherwise this codegen wouldn't be representative.</p>\n</blockquote>\n<p>Right; the hope/aspiration is that that constant index can trickle through a carefully-placed series of optimizations so this turns into something closer to the good codegen we see with globals.</p>\n<p>(Two other points that came to mind later re: use of tables: scalability is another factor -- the max of 100k (?) globals is a real limit if we use one for every IC site in a large program; and also, your point about lazy init, wherein we don't lazy-init globals and that'd be a big regression of instantiation latency on said ~100k-IC programs. The flipside is that we have the lazy-init dynamic checks on table load...)</p>\n<blockquote>\n<p><code>call_indirect</code> instead</p>\n</blockquote>\n<p>Ah! I hadn't realized that <code>call_indirect</code> also participated in the \"typed funcref\" proposal; for some reason I had it pegged as \"old dynamic sig check\" territory. All the better if it lets us apply the optimizations more easily; I'll update this test to use it.</p>\n<hr>\n<p>Thinking a bit more about lazy init: the overall behavior we want is that for a very large program with many ICs, we have fast instantiation and, once ICs are warmed up, fast IC invocation with as few dynamic checks as possible.</p>\n<p>IC sites always start as linked to the \"fallback IC\"; my planned use for this \"fast IC head\" mechanism was to have a conditional at every IC site testing whether the IC-stub struct is a fallback IC, invoking a traditional (C++) function pointer if so, and then (hitting a weval intrinsic that leads to) doing this typed-funcref thing if not. The upshot of that is that we always have some slowpath action (attaching an IC) before we do the typed funcref invocation.</p>\n<p>I guess what I'm getting at is: could we avoid the lazy-init checks if we had a <em>nullable</em> typed funcref table, with null as the default value? Then we do the usual init-the-anyfunc-before-you-take-its-address thing at the <code>ref.func</code> in the IC-attach path, and the just-instantiated state is a bunch of zeroes (kindly provided by mmap/madvise), and the invocation is load/load/call-reg. That's another new optimization but a special case for lazy-init instead. Stated succinctly: if a table's default funcref is null, don't do lazy-init, and make the <code>0</code> bit-pattern mean null rather than non-initialized-pointer-to-anyfunc. (EDIT: and this combines with #8159 to eliminate the null-check branch, to be clear.)</p>\n</blockquote>",
        "id": 427209598,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710706348
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158#issuecomment-2004124070\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8158\">PR #8158</a>:</p>\n<blockquote>\n<p>Makes sense! It's always possible we can use the same optimization techniques on globals as well as tables, nothing saying we have to keep everything as-is for example. If tables work then there's no need to change though.</p>\n<blockquote>\n<p>could we avoid the lazy-init checks if we had a nullable typed funcref table, with null as the default value</p>\n</blockquote>\n<p>I like this idea! </p>\n</blockquote>",
        "id": 427502719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1710773383
    }
]