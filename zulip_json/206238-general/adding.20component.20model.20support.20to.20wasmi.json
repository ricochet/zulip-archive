[
    {
        "content": "<p>gm, im wondering how hard it would be and what would be the best steps to add component model support to wasmi,<br>\nhope this is the right place to ask this question <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n<p>Zooming out I'm trying to use this lib  <a href=\"https://github.com/DelphinusLab/zkWasm\">https://github.com/DelphinusLab/zkWasm</a> which uses wamsi for execution traces, unfortunately wasmi doesn't support component model yet</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/DelphinusLab/zkWasm\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/79e838bc08d1e4b618c9af681439ab51dc8c4b00\\/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3530353332303332352f36663936633039302d353734302d343432362d616139622d386236643961613561303266)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/DelphinusLab/zkWasm\" title=\"GitHub - DelphinusLab/zkWasm\">GitHub - DelphinusLab/zkWasm</a></div><div class=\"message_embed_description\">Contribute to DelphinusLab/zkWasm development by creating an account on GitHub.</div></div></div>",
        "id": 373920931,
        "sender_full_name": "monkeyontheloose",
        "timestamp": 1688987658
    },
    {
        "content": "<p>I don't know whether wasmi directly interprets wasm opcodes or translates those to its own IR that it then interprets. the approach taken might vary depending on that.</p>\n<p>in general, first you'd need support for parsing the text format and decoding the binary format. I <em>think</em> wasmi uses our <code>wasm-tools</code> crates, so if that is true then this first step is already complete.</p>\n<p>at the runtime level, you'd need to either interpret the lifting and lowering instructions or translate those instructions to wasm opcodes or the internal IR if it exists and then interpret that. this is where the bulk of the effort will be.</p>\n<p>maybe <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> or others can add more details here / correct anythign I misrepresented.</p>",
        "id": 374320714,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689091700
    },
    {
        "content": "<p>I would agree that the hard part here is likely going to be the lifting/lowering and all of those semantics. I've found the representation of everything to be quite difficult to pin down in Wasmtime but that's also because I'm trying to be careful about allocations/speed/etc and less-optimized solutions which are simpler to understand are probably more in the wheelhouse of wasmi which may make that part much easier</p>",
        "id": 374326866,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689092984
    },
    {
        "content": "<p>right, all the work we do in FACT is basically something that an interpreter could skip</p>",
        "id": 374330788,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689093775
    },
    {
        "content": "<ol>\n<li>how many hours of work would the take (ballpark)?</li>\n<li>the zkWasm app uses wasmi to create execution traces which it then uses to create proofs, just to be sure, you can't use wasmtime which already supports CM for this, right?</li>\n<li>lifting and lowering instructions are new wasm opcodes?</li>\n<li>could you pls refer me to links that might be useful in understanding the work that needs to be done?</li>\n</ol>",
        "id": 374333451,
        "sender_full_name": "monkeyontheloose",
        "timestamp": 1689094391
    },
    {
        "content": "<p>all the relevant documents are linked from the README here: <a href=\"https://github.com/WebAssembly/component-model/\">https://github.com/WebAssembly/component-model/</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/ccdbd20cd8d35357be3946839a87a872c77edefc\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646333376161643135643061636337626635656464363565376265393134363632366133613465313233333639323036333237363966313933323832366164652f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/\" title=\"GitHub - WebAssembly/component-model: Repository for design and specification of the Component Model\">GitHub - WebAssembly/component-model: Repository for design and specification of the Component Model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - GitHub - WebAssembly/component-model: Repository for design and specification of the Component Model</div></div></div>",
        "id": 374342706,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689096711
    },
    {
        "content": "<p>I'd estimate a month of work for someone who is familiar with wasmi and wasm</p>",
        "id": 374342892,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689096747
    },
    {
        "content": "<p>the lifting and lowering instructions are at the component model level, not core wasm. they can't be interspersed with regular wasm opcodes. they statically appear within a different context.</p>",
        "id": 374343156,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689096814
    },
    {
        "content": "<p>you might be able to pre-process the wasm before running it to insert instrumentation to create execution traces and then run the instrumented wasm in your wasmtime embedding that provides the hooks that the aforementioned instrumentation relies upon. I don't really know that particular domain and what kind of traces it is taking so I can't really say more than that.</p>",
        "id": 374343566,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689096921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"630754\">Michelle Thalakottur</span> has marked this topic as resolved.</p>",
        "id": 374755940,
        "sender_full_name": "Notification Bot",
        "timestamp": 1689200167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"630754\">Michelle Thalakottur</span> has marked this topic as unresolved.</p>",
        "id": 374755957,
        "sender_full_name": "Notification Bot",
        "timestamp": 1689200173
    },
    {
        "content": "<p>this is also in my area of interest -- we're using wasmi (and have had to hand-roll an ABI) -- and I've .. struggled to understand obligations on the host and guest from the linked docs</p>",
        "id": 377056144,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689873157
    },
    {
        "content": "<p>is it correct to understand that the \"canonical ABI\" is part of what's going to be standardized, or is the CM like .. parameterized by multiple possible ABIs, or something?</p>",
        "id": 377056387,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689873211
    },
    {
        "content": "<p>The CM is designed to support many possible ABIs. And, the Canonical ABI is a particular ABI that is being developed to be standardized.</p>",
        "id": 377057897,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1689873579
    },
    {
        "content": "<p>hmm .. ok .. that's unfortunatley even less to go on. I'll keep reading! but like .. just to provide feedback as a reader: I understand the wasm 1.0 model I think fairly well at this point, and I understand how wasmi implements it / am basically comfortable with the wasmi codebase, and .. reading the above docs (which I've attempted to read several times in the past ~12 months) brings me very little clarity about what I, or the wasmi maintainer, would need to do to the wasmi codebase to make it \"support the CM\". like it's not at all clear where the boundaries of responsibilities are between (say) an interpreter codebase, the embedding environment using the interpreter, guest code (wasm, wit or guest source-language) that users see when working in their modules, guest toolchain features (eg. rustc features), code assumed (in perpetuity, by design) to be generated by extra tools, and polyfills.</p>",
        "id": 377061721,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689874398
    },
    {
        "content": "<p>I get that there's a set of answers to that! but it is sure not something a non-system-designer-reader can parse from those docs, much less find a specification of.</p>",
        "id": 377061983,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689874455
    },
    {
        "content": "<p>I can't even really figure out the dependency graph of specs, like what other post-1.0 extensions (or parts of them) it depends on a runtime having implemented (which I suspect are \"more than none\" and might well be \"more than wasmi supports\", i.e. it might be quite a ways before the starting line for \"supporting the CM\")</p>",
        "id": 377063189,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689874718
    },
    {
        "content": "<p>At least personally I agree that that the docs right now could be better, and <code>CanonicalABI.md</code> is a bit dense approaching it from nothing. That being said all this is still in-development and not \"finished\" so to some degree this is expected. Not to say we couldn't do better!</p>\n<p>From a wasmi perspective I would recommend considering CM support as roughly analagous to core wasm support. Wasmi presumably supports loading a binary-encoded wasm module and doing things with it. The component model at that high layer is the same way, you're given a binary and you enable doing things with it. What can be done is primarily different through a different set of types of values at runtime and through a different \"shape\" of a component (e.g. it does more than export a flat list of functions but can export bags of functions through instances and such)</p>",
        "id": 377063346,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689874767
    },
    {
        "content": "<p>At the moment, the Canonical ABI is the only ABI you can use. It is parametric in that it can be configured using Canonical ABI options (<code>canonopts</code>) when lifting module exports to the Component level or lowering Component imports to the module level. This involves things like specifying the encoding being used for strings, the memory and allocator to use, etc.</p>",
        "id": 377063360,
        "sender_full_name": "Robin Brown",
        "timestamp": 1689874773
    },
    {
        "content": "<p>The CM does not depend on any core wasm features beyond the MVP, so you're safe in that regard</p>",
        "id": 377063463,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689874796
    },
    {
        "content": "<p>One thing you might find helpful is to explore examples, which I might recommend Wasmtime's test suite for. There's <code>tests/misc_testsuite/component-model/*.wast</code> which has a lot of components of various shapes and sizes. There's also the <code>wit-bindgen</code> test suite which builds a bunch of components as part of its tests you can poke around with as well. For the \"poking\" I'd recommend the <code>wasm-tools</code> CLI since it's the only one I'm aware of with component model support</p>",
        "id": 377063789,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689874879
    },
    {
        "content": "<p>it depends, surely, on extern refs, no? (luckily wasmi does seem to support those)</p>",
        "id": 377064719,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689875103
    },
    {
        "content": "<p>If it helps, some more details on the ABI business is that on one hand there's the component model functions, aka \"this function returns a string\". On the other hand there's core wasm functions, aka \"this function returns an integers\". These two concepts are bridged through \"lifting\" and \"lowering\" where you lift a core wasm function into a component function and then you can lower a component function into a core wasm function. For example a host provides a component function, the component lowers it, then a core wasm inside the component imports it. Or alternatively a core wasm in a component exports a core wasm function, then a component lifts that, then a host calls it.</p>\n<p>The lifting/lowering operations are currently only defined in the context of the \"canonical ABI\" which you see as <code>canon lower</code> and <code>canon lift</code>. This dictates exact ABI details such as what integer means what, how to handle many arguments, many returns, where do strings live, how do things get allocated, all that stuff. This is the main body of <code>CanonicalABI.md</code>. You might also find it useful to explore the canonical ABI through <code>*.wit</code> files and generated bindings code through <code>wit-bindgen</code>. For example this WIT file:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">package</span><span class=\"w\"> </span><span class=\"n\">my</span>:<span class=\"nc\">example</span>\n\n<span class=\"n\">world</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"o\">-</span><span class=\"n\">world</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"n\">foo</span>: <span class=\"nc\">func</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">string</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>you can generate Rust bindings with <code>wit-bindgen rust foo.wit</code> and see what's generated to see how the ABI details there work.</p>",
        "id": 377065219,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689875239
    },
    {
        "content": "<blockquote>\n<p>it depends, surely, on extern refs, no?</p>\n</blockquote>\n<p>The component model does not, no. If you're thinking that resources are connected to externrefs they're similar but not the same. Resources when lowered are an index into a component-specific table, which means that core wasm always sees resources as integers (think file descriptors)</p>",
        "id": 377065485,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689875303
    },
    {
        "content": "<p>hmm so ok very basic baby question (which, apologies for not being able to parse out of the docs): does every module, as a wasm blob, contain its _own_ copy of lifting/lowering functions? or does the runtime provide some common set?</p>",
        "id": 377065779,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689875380
    },
    {
        "content": "<p>On the guest (core wasm) side, lifting and lowering code is generated by wit-bindgen for the guest language. On the wasmtime host side its mostly runtime with some macro generation to make the interfaces nicer</p>",
        "id": 377066560,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689875568
    },
    {
        "content": "<p>lifting/lowering is represented as \"lift this core wasm function\" or \"lower this component function\", so it's a function without a body sort of where the \"body\" is implied by the canonical ABI</p>",
        "id": 377066785,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689875616
    },
    {
        "content": "<p>so in that sense I suppose you can think of it as runtimes provide lifting/lowering operations, and components specify what lifting/lowering they'll need</p>",
        "id": 377066869,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689875635
    },
    {
        "content": "<p>it is the runtime's responsibility to do the lifting and lowering, and it is free to dedupe as much of them as it can</p>",
        "id": 377066961,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689875652
    },
    {
        "content": "<p>(separately, the guest language might want to do another layer of massaging/translating/lifting/lowering from the canonical ABI into its data types, this is what <span class=\"user-mention\" data-user-id=\"480579\">@Lann Martin</span> was getting at, I think. eg turn a <code>(usize, usize)</code> from the canonical ABI into a <code>Box&lt;str&gt;</code> in Rust or something like that)</p>",
        "id": 377067253,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689875737
    },
    {
        "content": "<blockquote>\n<p>For example a host provides a component function, the component lowers it, then a core wasm inside the component imports it</p>\n</blockquote>\n<p>I'd like to understand, in detail, all the actors involved in accomplishing this sentence. my host is a rust program, it has a wasm interpreter in it, it has rust types. currently it has a rust type that's the union of all possible core wasm types (i32/i64/f32/f64) and n-ary functions taking and returning N of those union types can be registered with the wasm interpreter and dispatched-to, using a little bit of rust type system fudging, using rust dyn fn objects and such. if I have a host function that has a structured component type .. I'm using .. some code generated by another tool that's VM specific? or non-VM-specific?</p>",
        "id": 377067596,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689875815
    },
    {
        "content": "<p>One of the documentation pieces missing is a glossary <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 377067663,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689875830
    },
    {
        "content": "<blockquote>\n<p>it is the runtime's responsibility to do the lifting and lowering, and it is free to dedupe as much of them as it can</p>\n</blockquote>\n<p>Ok so .. there's like a list stapled to the module of functions that will need the runtime to provide lift/lower wrappers, the part of the runtime's job instantiating the module is to synthesize such wrappers?</p>",
        "id": 377067800,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689875878
    },
    {
        "content": "<p>The list is part of the component, rather than in any core module inside the component, but yes, I think that's basically right.</p>",
        "id": 377068301,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1689875996
    },
    {
        "content": "<p>(but those are lift/lower wrappers on the runtime's side, not the guest's side? if the guest uses ABI X and the runtime uses ABI Y, they're supposed to interoperate, right? so .. the guest isn't asking the runtime to synthesize lift/lower code for ABI X and inject it into the guest's module-space, is it?)</p>",
        "id": 377068336,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689876003
    },
    {
        "content": "<p>I'm confused by the discussion of multiple ABIs. All of the component tooling currently being worked on assumes the Canonical ABI (which itself is parameterized in a couple of very limited ways).</p>",
        "id": 377070476,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689876539
    },
    {
        "content": "<p>well, ok, setting aside \"different ABIs\" (above discussion wasn't clear on how much this can vary, apparently there are parameters and _maybe_ other ABIs in the future?), even just focusing on guest-vs-host, I want to understand who generated what code and whether they did so ahead of time, or at instantiation time. and if ahead of time, if it's at module-compilation time or host-and-VM compilation time.</p>",
        "id": 377071799,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689876842
    },
    {
        "content": "<p>wit-bindgen is going to spit out (a) some stuff that gets compiled-in to a guest module, but also (b) some stuff that gets compiled-in to a host-and-VM pair? and then there's some stuff (c) that the host-and-VM pair is supposed to synthesize on the fly when the component-and-module bundle shows up asking to be instantiated</p>",
        "id": 377072142,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689876921
    },
    {
        "content": "<p>so I guess I'm wondering: is that correct? do (a), (b) and (c) all exist? if so I can I think ignore (a), need to teach wasmi to conform to the type signatures and expectations of (b), and need to teach wasmi to actually _do_ (c), unless it's provided by some standard crate in terms of (b)</p>",
        "id": 377072694,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689877007
    },
    {
        "content": "<p>fwiw I think in the context of an interpreter you won't need to \"synthesize\" (c), just walk over the type information you get out of the component to transform between your host-side enum variants and the core wasm types expected by the guest</p>",
        "id": 377073365,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1689877144
    },
    {
        "content": "<p>(b) is sort of true of wit-bindgen today but that's an internal detail of the current state of tooling; a runtime can get all of the type information it needs from the component binary itself</p>",
        "id": 377074840,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689877498
    },
    {
        "content": "<p>ok but .. since the runtime needs to connect to a bunch of statically-typed embedder host functions .. I think the embedder probably wants to get a projection of the wit into a static type in the embedder language, no? or is the VM just supposed to make up a projection from the generalized component type system into type system entities in the host PL? (doing so would likely couple the embedder to a specific VM's choice of projection, much more so than currently since the current 1.0 type system is relatively simple to massage if you change VMs)</p>",
        "id": 377076074,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689877849
    },
    {
        "content": "<p>(a long time ago I worked on CORBA systems -- some number of people in the room now have all the blood draining out of their faces in horror but I will continue -- and we used to have tools generate \"stubs and skeletons\", the skeletons being static types and interfaces that host-side callbacks implement and then pass into the runtime to get called-back through. I'm not clear on whether that is assumed here.)</p>",
        "id": 377076503,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689877951
    },
    {
        "content": "<p>my understanding is that if you specifically want static types in the embedder language then you want to use wit-bindgen to generate that glue, and that you need to teach wit-bindgen what that glue should look like for wasmi. it's also possible to introspect on an unknown component at runtime and offer the same kind of interface that you described wasmi having for core wasm (\"a rust type that's the union of all possible core wasm types (i32/i64/f32/f64) and n-ary functions taking and returning N of those union types can be registered with the wasm interpreter and dispatched-to, using a little bit of rust type system fudging, using rust dyn fn objects\"). both forms can be useful</p>",
        "id": 377078457,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1689878393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634398\">Graydon Hoare</span> <a href=\"#narrow/stream/206238-general/topic/adding.20component.20model.20support.20to.20wasmi/near/377068336\">said</a>:</p>\n<blockquote>\n<p>(but those are lift/lower wrappers on the runtime's side, not the guest's side? if the guest uses ABI X and the runtime uses ABI Y, they're supposed to interoperate, right? so .. the guest isn't asking the runtime to synthesize lift/lower code for ABI X and inject it into the guest's module-space, is it?)</p>\n</blockquote>\n<p>everyone speaks the canonical ABI, if a guest wants the data in another format after it receives it in canonical abi format, then it is free to do any further transformations of the data it wants to. but when sending and receiving data, it must be in the canonical ABI.</p>\n<p>the trampolines that the runtime is responsible for are for getting two (or more) components linked together: they pass a string, say, and the trampoline has to do the copy from the source to the destination. it is the runtime's responsiblity to create this trampoline (or do equivalent interpreted things) because each component is shared-nothing: they do not have access to each other's core instances' internal state.</p>\n<p>backing up a bit:</p>\n<ul>\n<li>a component can contain zero or more core wasm instances that can all share memories and things (or not, but they have the ability to do so)</li>\n<li>components have imports and exports. these are defined in terms of interface types rather than core value types</li>\n<li>components cannot share state, they are \"shared nothing\". no sharing of memory or tables or any of that</li>\n<li>components can be composed to create new components, fitting various imports and exports together. so components can contain zero or more other component instances on top of the core wasm instances mentioned earlier</li>\n<li>when two components are linked together such that the export of one is the import of another, <em>this</em> is where a trampoline is required and the runtime must provide it</li>\n<li>this trampoline lifts the interface values from one component and lowers them into the other. in practice, the lift and lower is pretty much always fused together such that there is one copy from src to dst, and no intermediate interface value is actually materialized</li>\n</ul>\n<p>for example, given:</p>\n<ul>\n<li>component <em>A</em> that exports a <code>string -&gt; string</code> component function where it is given a name string and returns \"hello &lt;name&gt;\"<ul>\n<li><em>A</em> contains a core wasm instance that exports this function (taking arguments in canonical ABI format and returning results in canonical ABI format)</li>\n<li><em>A</em> lifts the core wasm export function into a component function</li>\n<li><em>A</em> exports this lifted component function</li>\n</ul>\n</li>\n<li>component <em>B</em> wraps an instance of component <em>A</em> and exports a component function <code>unit -&gt; string</code><ul>\n<li><em>B</em> lowers <em>A</em>'s exported component function to a core wasm function that uses the canonical ABI</li>\n<li>passes that as an import to its core wasm instance</li>\n<li><em>B</em>'s core wasm instance exports a core wasm function that passes a \"CM\" string (in canonical ABI format) to the imported function and returns the result (again in canoncial ABI format)</li>\n<li><em>B</em> lifts the core wasm instance's export into a component function and exports it</li>\n</ul>\n</li>\n</ul>\n<p>this is the sequence of events when the host calls <em>B</em>'s exported component function:</p>\n<ul>\n<li>the host lowers its arguments to canonical ABI format (no arguments in this particular case, tho)</li>\n<li>these arguments are passed to the core wasm function that <em>B</em> lifted and exported</li>\n<li>this core function calls its import, which is a trampoline that the runtime provided, passing the string \"CM\"</li>\n<li>this trampoline is the <code>lower(lift(A.export))</code> composition</li>\n<li>the details vary for different types and the details should be <code>CanonicalABI.md</code>, but for strings, this effectively means that it asks <em>A</em> to malloc space for the string and then copies from <em>B</em>'s core instance's memory into <em>A</em>'s core instance's memory while simultaneously validating that the bytes are utf8</li>\n<li>then the trampoline calls <em>A</em>'s core instance's function with the copied-over string (in canonical ABI format)</li>\n<li><em>A</em>'s core instance's function returns \"Hello CM\" in the canonical ABI format</li>\n<li>the trampoline does the same copying and validation in the other direction now: from <em>A</em>'s core instance's memory to <em>B</em>'s core instance's memory</li>\n<li>the trampoline returns to <em>B</em>'s core instance's function</li>\n<li><em>B</em>'s core instance's function returns the string (in canonical ABI form)</li>\n<li>the host receives the result in canonical ABI form and can translate it into whatever representation is useful for the host</li>\n</ul>\n<p>fin</p>\n<p>does that make sense?</p>\n<p><code>wit-bindgen</code> is a bit of a distraction here. it is a tool for allowing people to write guest/host programs that talk canonical ABI. but it doesn't have any bearing on what the runtime has to do to support the component model. it is just sugar for turning <code>(u32, u32)</code> (the canonical ABI representation of a string) into <code>Box&lt;str&gt;</code> in rust and stuff like that</p>",
        "id": 377079308,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689878570
    },
    {
        "content": "<p>Yes, you can use wit-bindgen to help generate host/embedder language bindings. <code>wasmtime-py</code> does that here: <a href=\"https://github.com/bytecodealliance/wasmtime-py/blob/main/rust/bindgen/src/bindgen.rs\">https://github.com/bytecodealliance/wasmtime-py/blob/main/rust/bindgen/src/bindgen.rs</a></p>",
        "id": 377081409,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689879084
    },
    {
        "content": "<p>As a warning, that tooling is probably quite unstable (moreso than the CM/CABI specs), though Alex would have the best perspective on that</p>",
        "id": 377082115,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689879239
    },
    {
        "content": "<p>Yeah I wouldn't rely on specific details there per se, but I do think that they can be an interesting way to explore how things work. I mentioned <code>wit-bindgen rust</code> above but the wasmtime-py support, available through <code>python -m wasmtime.bindgen</code>, can be a good way to explore components from a host side. The python support is build on Wasmtime's C API which only supports core modules, so the bindings generated by <code>python -m wasmtime.bindgen</code> can perhaps be helpful to read over and see how things are hooked up. You'll find liftings/lowerings there and such</p>",
        "id": 377085271,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689879920
    },
    {
        "content": "<blockquote>\n<p>A lifts the core wasm export function into a component function</p>\n</blockquote>\n<p>(thanks for the details!) Can I .. dig into this point? A is a component, which is a byte blob. You're describing it doing something as a verb here: \"A lifts ..\". What does that mean? When does A do this? Or rather, which tool does what to accomplish this lifting? Or are you saying that the blob that is A contains a binary declaration in itself somewhere that declares a lifting-relationship between the core function and the component function?</p>",
        "id": 377089060,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689880852
    },
    {
        "content": "<p>The latter: there are <code>canon lift</code> and <code>canon lower</code> operations which convert between core and CM functions</p>",
        "id": 377090920,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689881260
    },
    {
        "content": "<p>e.g. (somewhat loosly): <code>(canon lift &lt;core-funcidx&gt; &lt;component-func-type&gt;)</code> produces a component function from a core function and the component function type</p>",
        "id": 377091415,
        "sender_full_name": "Lann Martin",
        "timestamp": 1689881372
    },
    {
        "content": "<p>I think what you're looking for is that A contains a declaration (the textual syntax is as shown by Lann) indicating that in order to run, it needs one of its functions lifted. the host is responsible for making that actually happen</p>",
        "id": 377091829,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1689881466
    },
    {
        "content": "<p>the <em>wasm runtime</em> is responsible for making that happen</p>\n<p>(I like to reserve \"host\" for the embedder of the runtime, and I think that's how we usually use it)</p>",
        "id": 377109458,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1689886504
    },
    {
        "content": "<p>ah, that's a good distinction</p>",
        "id": 377111912,
        "sender_full_name": "Jamey Sharp",
        "timestamp": 1689887309
    },
    {
        "content": "<p>ok so .. just to be 100% clear (it's extremely hard for non-spec-editors to read the examples since they're full of abbreviated forms) .. the (canon ..) form is a declaration form, at the component level, and it defines .. the obligation to build a specific trampoline? or half-trampoline?</p>",
        "id": 377115624,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689888576
    },
    {
        "content": "<p>aside, I find the textual definitions almost impossible to read due to all the abbreviations, the only way I've been able to understand wasm _at all_ is by referring to the binary structure definition of a module. like I have no idea at all -- despite staring for the past half hour -- how to parse this example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$run</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">canon</span><span class=\"w\"> </span><span class=\"n\">lift</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$main</span><span class=\"w\"> </span><span class=\"s\">\"run\"</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"cp\">$libc</span><span class=\"w\"> </span><span class=\"s\">\"mem\"</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">realloc</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$libc</span><span class=\"w\"> </span><span class=\"s\">\"realloc\"</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"p\">))</span>\n</code></pre></div>",
        "id": 377115959,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689888671
    },
    {
        "content": "<blockquote>\n<p>like I have no idea at all -- despite staring for the past half hour</p>\n</blockquote>\n<p>One thing that may help with this is to run the examples through <code>wasm-tools print</code>. That prints the binary form which has a lot more index annotations. Not exactly readable, but it may help perhaps</p>",
        "id": 377116664,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689888939
    },
    {
        "content": "<p>I think that desugars to a canon definition -- desugaring the <code>(func ... (canon lift ...))</code> into a <code>(canon lift ... (func ...))</code> and then I think there's an inline-sugar declaration of a core func, maybe? and then .. I don't have any idea what the memory or realloc forms are in there, they do not look like externdescs to me through any desugaring path I can understand</p>",
        "id": 377116683,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689888949
    },
    {
        "content": "<blockquote>\n<p>One thing that may help with this is to run the examples through wasm-tools print.</p>\n</blockquote>\n<p><code>wasm-tools</code> I get from <code>cargo install</code> does not accept the examples in the docs. maybe there's a fresher version? or should I look instead at the examples in the repo, not the docs?</p>",
        "id": 377117754,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689889251
    },
    {
        "content": "<p>oh, maybe the <code>(memory)</code> and <code>(realloc)</code> forms there are <code>&lt;canonopt&gt;</code> and the outer desugaring is .. somehow .. defining the lifting of the <code>(core func ...)</code> form?</p>",
        "id": 377120021,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689890061
    },
    {
        "content": "<p>Yes, they are <code>canonopt</code>s. This syntax is defining a component function that wraps a core-wasm function, using the specified realloc and memory to communicate the string data with the core-wasm function.</p>",
        "id": 377122939,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1689891121
    },
    {
        "content": "<p>ah yeah <code>wasm-tools</code> will only work in the context of a \"full component\" which in this case isn't there since it's just one func. There's also a number of syntax differences/typos in the spec so you can probably disregard my suggestion (the spec examples aren't tested yet)</p>",
        "id": 377124859,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689891797
    },
    {
        "content": "<blockquote>\n<p>ah yeah wasm-tools will only work in the context of a \"full component\" which in this case isn't there since it's just one func.</p>\n</blockquote>\n<p>No I don't just mean this one func. I mean the full component example in the explainer (\"we can finally write a non-trivial component\"). there appear to be enough syntax differences that I can't figure out how to edit it back to being-right (especially since I am reading it to try to figure out what it means, editing it isn't something I have a lot of confidence in)</p>",
        "id": 377128210,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689893359
    },
    {
        "content": "<p>it's ok, I can .. at least conceptually picture what this is doing, I think. to restate -- can you confirm? -- this is declaring -- entirely declaratively -- that the existing declared-earlier core func \"run\", in the $main instance, which had core type ((i32,i32)-&gt;i32) where it was declared, should be lifted to a CM func $run of CM type string-&gt;string, and the trampoline (or half-trampoline?) that the runtime needs to synthesize to do that should map \"a CM string\" conceptually to a linear-address-and-length pair in the \"mem\" memory of the $libc instance (itself in the $main instance), and should make allocations it needs in that instance by calling a realloc-shaped core export named \"realloc\" in the $libc instance.</p>",
        "id": 377129235,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689893884
    },
    {
        "content": "<p>is that right?</p>",
        "id": 377129336,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689893949
    },
    {
        "content": "<p>Indeed! That all sounds right to me</p>",
        "id": 377129651,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894089
    },
    {
        "content": "<p>Sorry we should go through the examples in the spec and validate they all use actual valid syntax -- as you have probably figured out all the examples were written before we had any parsers and we never went back and updated them.</p>",
        "id": 377129705,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894117
    },
    {
        "content": "<p>(if so, what's the difference between the lift and the lower applied to \"log\"? log is external? if it's in \"CM space\" already why does it need to be lowered too? just to attempt to fuse it with a lift?)</p>",
        "id": 377129888,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894166
    },
    {
        "content": "<p>s'ok, just  pointing it out if you're doing docs-updates at some point. I can file a bug on the repo if you want but I'm not sure this repo is the long-term home of reference material anyway?</p>",
        "id": 377129950,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894218
    },
    {
        "content": "<p>The one thing I might clarify is the \"half-trampoline\" aspect there. This is creating, as you say declaratively, a function in the component model which has type string -&gt; string. The implementation of this function is defined as the \"half trampoline\" you're thinking of where the function when called with a string will pass through the string as defined by the canonical ABI using the memory/realloc options. Similarly when the wasm function returns it will interpret the return values using the memory/realloc options. </p>\n<p>This component model function, whether it actually concretely exists or not, sort of depends on the runtime. For example sometimes in Wasmtime it's \"fused\" with another component's request for the function that's where a whole-trampoline as you're thinking exists. If the host uses this function directly it's sort of a half-trampoline.</p>\n<p>Basically I wanted to point out the half/whole trampoline may not be quite the right way to think about it. It sort of is and sort of isn't, but may be worthwhile understanding the context here of \"it's a function in its own right\" and the definition of what that function is depends on the host.</p>",
        "id": 377130084,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894267
    },
    {
        "content": "<blockquote>\n<p>I'm not sure this repo is the long-term home of reference material anyway?</p>\n</blockquote>\n<p>Oh WebAssembly/component-model will probably stick around for quite a long time, so bugs are appreciated!</p>",
        "id": 377130157,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894311
    },
    {
        "content": "<p>the specifics of when half-trampolines exist or are fused-away is indeed something I need to get straight, glad you pointed it out. would it fuse, say, only when the canonopts match exactly, including their referents, so as to allow passing through not just an unaltered representation but crucially pointers in the same memory?</p>",
        "id": 377130409,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894423
    },
    {
        "content": "<p>Ah sorry I don't have the link to what you're looking at on hand (I can poke at it though to take a look), but in general you're right that there's the \"CM space\" and the \"core space\" and lift/lower go between these two. So you'll lift from core-&gt;CM and lower from CM-&gt;core. Component boundaries only support CM things, so if you want to take a core function from one component to another you'll have to lift it to the CM then lower it somewhere else. This produces the \"fused\" operation where a runtime can do clever things if it so desires, but the \"clever things\" aren't necessarily stricly spec-mandated.</p>\n<p>This is where the Python bits-and-pieces of <code>CanonicalABI.md</code> show up where a lift-then-lower is sort of like a curry of the <code>canon_lift</code> and <code>canon_lower</code> functions. I think though you have to squint a bit to see it line up for sure at the current time.</p>",
        "id": 377130471,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894459
    },
    {
        "content": "<p>I'm looking at the example a page or two down from this anchor: <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#canonical-definitions\">https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#canonical-definitions</a> -- search for \"we can finally write a non-trivial component\"</p>",
        "id": 377130625,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894539
    },
    {
        "content": "<blockquote>\n<p>the specifics of when half-trampolines exist or are fused-away is indeed something I need to get straight, glad you pointed it out. would it fuse, say, only when the canonopts match exactly, including their referents, so as to allow passing through not just an unaltered representation but crucially pointers in the same memory?</p>\n</blockquote>\n<p>Ah specifically no! Fusing happens between entirely different components, which can't share any state. So their options fundamentally will be different (e.g. you're transferring a string from one linear memory to another). The way you can think about it is that component model values have an abstract definition of sorts, but the ABI makes it concrete on either end.</p>\n<p>So for example if component A encodes strings as utf-8 but component B uses utf-16 they're both using the same concept of a \"string\" as a valid unicode thing (I forget the technical name) but they're represented differently. In this case the fused adapter, the lift/lower pair, would transcode from. utf-8 to utf-16 when transferring strings</p>",
        "id": 377130673,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894565
    },
    {
        "content": "<p>so a lift will sort of interpret all the input parameters/options/etc into an abstract set of values which may or may not get re-ified in the host itself (e.g. a simple interpreter might always create an actual <code>Val</code> representation), and then the lower translates from these abstract representations back into the destination as configured</p>",
        "id": 377130844,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894642
    },
    {
        "content": "<p>oh, wait, so in this case the fact that \"log\" and \"run\" are both declared to deal in the same memory \"mem\" is not nudging the system towards possibly fusing their lift/lower pair, because strings represented as i32,i32 pairs are literally pointing into the same memory space?</p>",
        "id": 377130873,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894661
    },
    {
        "content": "<p>however the host represents it is entirely up to the host, so long as it can faithfully represent all possible values</p>",
        "id": 377130878,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894662
    },
    {
        "content": "<p>let me look more closely at the example</p>",
        "id": 377130904,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894674
    },
    {
        "content": "<p>aha so there is no fusing at all in this example</p>",
        "id": 377130935,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894696
    },
    {
        "content": "<p>np. you also don't have to hang around here answering my questions! I know you're very busy</p>",
        "id": 377130958,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894713
    },
    {
        "content": "<p>The log function, a component model thing, is lowered down into a core wasm thing which goes into the \"blob\" of core wasm</p>",
        "id": 377131025,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894728
    },
    {
        "content": "<p>somehow coming out of that core wasm is a \"run\" function which is lifted into a separate CM thing</p>",
        "id": 377131045,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894738
    },
    {
        "content": "<p>log/run, however, aren't connected at all</p>",
        "id": 377131053,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894744
    },
    {
        "content": "<p>except well through the core wasm I suppose</p>",
        "id": 377131061,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894749
    },
    {
        "content": "<p>let me see if I can find a fusing example</p>",
        "id": 377131102,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894772
    },
    {
        "content": "<p>ah ok so here's a \"hello world\" of fusing -- <a href=\"https://github.com/bytecodealliance/wasmtime/blob/53274fefe433944964bafd3f2942a942c33bf6c1/tests/misc_testsuite/component-model/fused.wast#L2-L21\">https://github.com/bytecodealliance/wasmtime/blob/53274fefe433944964bafd3f2942a942c33bf6c1/tests/misc_testsuite/component-model/fused.wast#L2-L21</a></p>",
        "id": 377131216,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894836
    },
    {
        "content": "<p>(I just was involved in building a wasmi-based system recently that had to roll its own ABI and everyone keeps showing up and asking \"why didn't you use the wasm CM to link in definitions and allow inter-component magic?\" and my answers are a bit wishy-washy somewhere between \"the schedule doesn't seem to line up, it's not ready yet\" and \"I still actually have no idea how to adapt wasmi to support the CM, every time I try to understand that I get lost trying to understand the mechanisms implied by the CM\" so I figured I might ask more about that...)</p>",
        "id": 377131219,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689894837
    },
    {
        "content": "<p>no worries! Confusion is IMO a good way to shape how to word the docs when we get around to it :)</p>",
        "id": 377131316,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894880
    },
    {
        "content": "<p>but I mostly wanted to point out that everything related to adapter fusion of lift/lower pairs may have been misunderstood so far,  but it requires the same value to get lifted/lowered, not just lifts/lowers of separate values in a component</p>",
        "id": 377131404,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894925
    },
    {
        "content": "<p>and it also requires a component boundary, e.g. the sub-component in that example above</p>",
        "id": 377131433,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894935
    },
    {
        "content": "<p>(not sure if it helps to see this though)</p>",
        "id": 377131442,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689894941
    },
    {
        "content": "<p>looking. I think I still don't quite get what a lower _is_ besides meaninglessly \"the inverse of a lift\". like it's declaring a CM type maps to a given core type, but .. it's a bijection right? .. can that not be _exactly_ rewritten as a lift? why give it a separate form?</p>",
        "id": 377131584,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895010
    },
    {
        "content": "<p>(and like what entities-with-CM-types even exist that are not, themselves, lifts of core entities? when do you have such a CM entity you need to lower, independent of a core entity you need to lift?)</p>",
        "id": 377131702,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895082
    },
    {
        "content": "<p>To answer the second question first which may provide more context, the biggest answer is \"host things\"</p>",
        "id": 377131795,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895123
    },
    {
        "content": "<p>aka the host has a function that returns a string and wasm wants to use it</p>",
        "id": 377131808,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895133
    },
    {
        "content": "<p>but the host function basically doesn't know it's being called by wasm</p>",
        "id": 377131835,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895143
    },
    {
        "content": "<p>lift/lower are different halves of the operation which is what makes them necessary -- perhaps it may be helpful to ignore sub-components and fusion for now?</p>",
        "id": 377131896,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895192
    },
    {
        "content": "<p>e.g. you get \"host stuff\" and you lower it, and to give functionality to the host you lift it</p>",
        "id": 377131962,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895206
    },
    {
        "content": "<p>ok. that's a good starting schema!</p>",
        "id": 377131991,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895223
    },
    {
        "content": "<p>but you can't swap those since the host stuff isn't a lift of anything, it just is host stuff</p>",
        "id": 377132000,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895231
    },
    {
        "content": "<p>they we just throw in separate memories and an Owens-Flatt unit linking language :P</p>",
        "id": 377132080,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895290
    },
    {
        "content": "<p>heh yeah it's true that much of the interesting stuff doesn't come up until there's more than one component in the system, but some of the bits and pieces I've found are more helpfully motivated if they're ignored when first learning</p>",
        "id": 377132216,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895359
    },
    {
        "content": "<p>hmm .. ok but the \"lower\" of a host function is .. uh .. in core-space?</p>",
        "id": 377132219,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895361
    },
    {
        "content": "<p>so the runtime has to do the lower-side just to call the host function, because it's some wild win32 or cocoa API speaking UTF-16</p>",
        "id": 377132260,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895388
    },
    {
        "content": "<p>this is where the runtime sort of has a lot of flexibility</p>",
        "id": 377132277,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895404
    },
    {
        "content": "<p>somehow it needs to produce a \"core looking thing\", and how to interpret the arguments to the core-looking-thing are dicated by the canonical ABI</p>",
        "id": 377132295,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895423
    },
    {
        "content": "<p>and then what the host does with that is up to it</p>",
        "id": 377132304,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895428
    },
    {
        "content": "<p>but yeah if it receives a utf-8 string and talks to a cocoa utf-16 api then the host has to transcode</p>",
        "id": 377132318,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895441
    },
    {
        "content": "<p>here the host has the choice of representing strings as (encoding, wasm bytes) or it could unconditionally translate everything to a utf-16 string and run with that</p>",
        "id": 377132389,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895465
    },
    {
        "content": "<p>if you've got some cocoa thing though and wasm wants to call it, the goop between wasm and cocoa is basically \"the thing that <code>lower</code> produces\"</p>",
        "id": 377132456,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895504
    },
    {
        "content": "<p>it's tough to point at it and say \"yes it's this\" since it's probably spread out a bit as it's doing type translation, crossing core wasm ABIs, etc</p>",
        "id": 377132483,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895523
    },
    {
        "content": "<p>mhm. ok, informative! it still seems to me like that lift and lower are both just \"CM-to-core bijections\" where sometimes the bijectee is in host-world not VM-world, but .. meh .. doesn't matter!</p>\n<p>I actually have to step out for a bit, but .. uh .. it's coming more into focus, and if it's ok with you I would love to return to this and pepper you with more questions another time?</p>",
        "id": 377132495,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1689895536
    },
    {
        "content": "<p>In wasmtime for example it's a mixture of Rust-monomorphized code plus a Cranelift-generated trampoline</p>",
        "id": 377132515,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895545
    },
    {
        "content": "<p>Happy to help out!</p>",
        "id": 377132581,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1689895564
    }
]