[
    {
        "content": "<p>I am curious about the option of providing \"host\" functionality to modules via other modules. Particularly interesting is a case where a \"decorator\" module satisfies the import of a \"user\" module -- the function \"func\" for example -- , does a particular operation on the argument provided by the user module, and then calls the \"func\" function provided by the host (i.e., the environment where wasmtime is embedded). We could have a similar functionality in the other direction, where the decorator \"intercepts\" the value \"returned\" by the host.</p>\n<p>It would be really cool to flexibly say that we either want to instantiate the module linking against the host or adding one or multiple decorators in between.</p>\n<p>I am aware of the component model, but would first like to look into the more straight forward and stable implementations using import/exports of modules. </p>\n<p>For the case where the function takes and returns only primitive types, I got it to work by using (a) different linkers for the \"decorator\" and the \"user\" module ( the \"func\" import of the decorator is linked to the host function in the decorator-linker, the exports of decorator module are provided as functions in the user-linker, where they are used to satisfy the import of the user module ) and a bit of aliasing to map between the function names and namespaces.</p>\n<p>The more interesting case is the case where we want to \"exchange\" more complex data types. When interacting with the host, we would just allow it to read the information out of the module's memory and write the \"result\" back into it. I am reasonably sure that I could get the above flow to work by providing the \"decorator\" with functions offered by the host which would let it copy data between modules. </p>\n<p>Super ideally, I would like to have a decorator which does not introduce additional copying. Since the \"contract\" between user module and decorator seems to be the same as between the user module and the host, it seems to be safe to let them share memory (the user blocks on each call which is served by the decorator/host).</p>\n<p>So, what I was trying to do was to let both modules import memory and, upon instantiation, providing them with the same memory. The two problems I am running into there are:</p>\n<ul>\n<li>There does not seem to be a way to compile against the <code>wasi32-wasm</code> target with cargo, while setting the shared flag (I could hack around that though)</li>\n<li>The modules error out when run, since WASI expect them to export memory</li>\n</ul>\n<p>Sorry for the long description. To formulate my question a bit shorter:</p>\n<ul>\n<li>Is it possible to deploy two modules, both using the WASI interface, with one module being linked to the other and both sharing their memory? Without going to the component module?</li>\n</ul>\n<p>Thank you! :)</p>",
        "id": 426559910,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710428135
    },
    {
        "content": "<p>Here's the one weird trick to building Wasm .so modules which import their memory and function table with Rust today: <a href=\"#narrow/stream/235408-rust-toolchain/topic/Rust.20cdylib/near/424769116\">https://bytecodealliance.zulipchat.com/#narrow/stream/235408-rust-toolchain/topic/Rust.20cdylib/near/424769116</a>.  Needless to say, we're planning to make that easier in the future.</p>\n<p>To actually use such modules, your only option today is to use the component model via <code>wasm-tools component link</code> (which is what <code>componentize-py</code> does, and the CRuby folks are experimenting with doing likewise).</p>\n<p>FWIW, I've had informal discussions with a few people about expanding <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\">https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md</a> to describe a module-level host interface for linking Wasm .so files either at startup or dynamically (via <code>dlopen</code>) without necessarily using the component model.  Emscripten already supports this, but presumably won't be able to fulfill WASI imports.  Ideally, WASI-capable runtimes like Wasmtime would also support the same convention once we've documented it.  I have no immediate plans to work on that myself (mostly because I'm all-in on the component model and have no reason to avoid it), but I do think it's a great idea.</p>",
        "id": 426567548,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710430159
    },
    {
        "content": "<p>I suppose I should add that you <em>can</em> use WASI .so files today without the component model, but you'd be responsible for writing a custom embedding of Wasmtime (or whatever your favorite WASI runtime is) and hooking everything up yourself, providing the imports, implementing <code>dlopen</code> and friends if applicable, etc.</p>",
        "id": 426569886,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710430749
    },
    {
        "content": "<p>Thank you for your answer Joel :) . Two additional questions if I may:</p>\n<ul>\n<li>What is an .so module? Is it a standalone module, as opposed to a component? Or is it a module compiled with the .so ending (in that case, what is that?)</li>\n<li>I will definitely look into implementing the flow with the component model (we are in a project where we have multiple different runtimes based on WAMR and Wasmtime and doing different things, so was looking for a solution which is based on something that has been around for a while and is likely supported by everything). One question there: Would it be possible to take a module which was compiled \"normally\" (not as a component) and then satisfy its imports by a module compiled as a component?</li>\n</ul>",
        "id": 426574824,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710432097
    },
    {
        "content": "<p>The .so terminology comes from UNIX .so files (meaning \"shared object\"), equivalent to .dll files in Windows.  The convention we've been using so far is to name libraries lib&lt;name&gt;.so, e.g. <code>libpython312.so</code>, mirroring UNIX.  You could instead name it e.g. <code>python312.wasm,</code> but then it might be confused with the statically-linked <code>python312.wasm</code> which is meant to be used as a CLI executable, not a shared library.</p>\n<p>Yes, you can link a core module with a component by first wrapping the core module in a component using <code>wasm-tools component new</code>.  If the core module targets WASI 0.1, you'll need to give <code>wasm-tools</code> an adapter (e.g. <a href=\"https://github.com/bytecodealliance/wasmtime/releases/download/v18.0.3/wasi_snapshot_preview1.reactor.wasm\">https://github.com/bytecodealliance/wasmtime/releases/download/v18.0.3/wasi_snapshot_preview1.reactor.wasm</a>) which translates the 0.1 imports to 0.2 imports.  Then you'll end up with two components which you can link together in a shared-nothing fashion using <code>wasm-tools compose</code>.  The key to making that work is to define the interface which the two components use to communicate with each other using WIT such that one of the components imports the interface and the other one exports it.</p>\n<p>However, from what you described earlier, I take it you want \"shared-everything\" linking instead, such that the modules share the same memory and can pass pointers back and forth.  In that case, you don't want component-level composition, but rather  <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/examples/SharedEverythingDynamicLinking.md\">https://github.com/WebAssembly/component-model/blob/main/design/mvp/examples/SharedEverythingDynamicLinking.md</a>, in which case you'll want to leave the units of composition as core modules (<em>not</em> components) and then use <code>wasm-tools component link</code> to combine the modules into a single component.  In that case you won't use WIT but rather the traditional C ABI.  And in that case, you can even create a cyclical dependency where module A can import from module B and also vice versa -- <code>wasm-tools component link</code> will handle that automatically.</p>",
        "id": 426579382,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710433401
    },
    {
        "content": "<p>I will dive into all of this and try it out.</p>\n<p>Thank you for the great answer! :)</p>",
        "id": 426593177,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710437480
    },
    {
        "content": "<p>If I understood correctly, using the \"shared-everything\" linking would allow me to take two core modules: module A which imports a function (e.g., <code>double_sum</code>) and module B which exports the function required by A while importing a function from the host (e.g., <code>double_sum_host</code>). I then would use the <code>wasm-tools component link</code> command on these two modules to create a single component which would import <code>double_sum_host</code> and export a method used to start the module (which it would take from module A).</p>\n<p>I tried to implement a minimal example with this functionality. Module A is compiled from a bin crate with the following <code>main.rs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">time</span>::<span class=\"n\">Duration</span><span class=\"p\">;</span>\n\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">double_num</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">thread</span>::<span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">Duration</span>::<span class=\"n\">from_millis</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"p\">));</span>\n<span class=\"w\">        </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">double_num</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"doubled the num; New value: {num}\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Module B is compiled from a lib crate with the following <code>lib.rs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">double_num_host</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#[no_mangle]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">double_num</span><span class=\"p\">(</span><span class=\"n\">input</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">doubled_once</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">double_num_host</span><span class=\"p\">(</span><span class=\"n\">doubled_once</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>I create core modules from these crates using <code>cargo build --target=wasm32-wasi --release</code>. When I then try to link the modules using <code>wasm-tools component link -o linked_module.wasm module_a.wasm module_b.wasm</code>I am getting the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">modules</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n   <span class=\"mi\">0</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"n\">linking</span><span class=\"w\"> </span><span class=\"n\">metadata</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">module_a</span><span class=\"p\">.</span><span class=\"n\">wasm</span>\n<span class=\"w\">   </span><span class=\"mi\">1</span>: <span class=\"nc\">unsupported</span><span class=\"w\"> </span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">memory</span>: <span class=\"nc\">Memory</span>\n</code></pre></div>\n<p>(getting the same error for <code>module_b.wasm</code> if I omit <code>module_a.wasm</code> from the link command).</p>\n<p>Could you please tell me what I am doing wrong? Is it a problem with how I compile the modules to WASM?</p>",
        "id": 427680471,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710850769
    },
    {
        "content": "<p>I am not an expert here but I believe <code>wasm-tools component link</code> is specific to <em>dynamic</em> libraries, following <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md\">dynamic linking conventions</a>; I'm not sure what extra steps that entails, possibly just different rustc options</p>",
        "id": 427690113,
        "sender_full_name": "Lann Martin",
        "timestamp": 1710853685
    },
    {
        "content": "<p>Ah I think this is the magic: <a href=\"#narrow/stream/235408-rust-toolchain/topic/Rust.20cdylib/near/424769116\">https://bytecodealliance.zulipchat.com/#narrow/stream/235408-rust-toolchain/topic/Rust.20cdylib/near/424769116</a></p>",
        "id": 427691626,
        "sender_full_name": "Lann Martin",
        "timestamp": 1710854182
    },
    {
        "content": "<p>Ahh, I see, I have to compile them differently so that they can be dynamically linked. Thank you for the tip :) </p>\n<p>Now, if I take the module B as in the example above and follow information you linked for creating a dynamically linked shared library module by :</p>\n<p>(a) changing the crate-type to <code>staticlib</code></p>\n<p>(b) running <code>RUSTFLAGS=\"-C relocation-model=pic\" cargo +nightly build -Zbuild-std=panic_abort,std --release --target=wasm32-wasi</code> (runs without complaining; creates the files <code>libmodule_b.a</code> and <code>libmodule_b.d</code> in <code>target/wasm32-wasi/release</code>)</p>\n<p>(c) and then trying running <code>clang -shared -Wl,--whole-archive libmodule_b.a --Wl,--no-whole-archive</code> I get the error:</p>\n<p><code>clang: error: unsupported option '--Wl,--no-whole-archive'</code>.</p>\n<p>Could you maybe point me to what I am doing wrong here?</p>",
        "id": 427740415,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710859912
    },
    {
        "content": "<p>Perhaps an old version of <code>clang</code>? Or your OS is lying about it actually being clang? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  What does <code>clang --version</code> show?</p>",
        "id": 427742153,
        "sender_full_name": "Lann Martin",
        "timestamp": 1710860321
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Ubuntu</span><span class=\"w\"> </span><span class=\"n\">clang</span><span class=\"w\"> </span><span class=\"n\">version</span><span class=\"w\"> </span><span class=\"mf\">14.0.0</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"n\">ubuntu1</span>\n<span class=\"n\">Target</span>: <span class=\"nc\">x86_64</span><span class=\"o\">-</span><span class=\"n\">pc</span><span class=\"o\">-</span><span class=\"n\">linux</span><span class=\"o\">-</span><span class=\"n\">gnu</span>\n<span class=\"n\">Thread</span><span class=\"w\"> </span><span class=\"n\">model</span>: <span class=\"nc\">posix</span>\n<span class=\"n\">InstalledDir</span>: <span class=\"o\">/</span><span class=\"n\">usr</span><span class=\"o\">/</span><span class=\"n\">bin</span>\n</code></pre></div>",
        "id": 427742438,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710860392
    },
    {
        "content": "<p>You have an extra dash; it should just be <code>-Wl,--no-whole-archive</code> with only one leading dash.</p>",
        "id": 427743241,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1710860566
    },
    {
        "content": "<p>Ah, I see. Should have figured that out since it is in the command twice :) . Now a new error:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">/</span><span class=\"n\">usr</span><span class=\"o\">/</span><span class=\"n\">bin</span><span class=\"o\">/</span><span class=\"n\">ld</span>: <span class=\"nc\">libmodule_b</span><span class=\"p\">.</span><span class=\"n\">a</span>: <span class=\"nc\">member</span><span class=\"w\"> </span><span class=\"n\">libmodule_b</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">module_b</span><span class=\"o\">-</span><span class=\"mi\">98</span><span class=\"n\">a5ed2d35966c6a</span><span class=\"p\">.</span><span class=\"n\">module_b</span><span class=\"p\">.</span><span class=\"mi\">4409</span><span class=\"n\">c8c284b8a334</span><span class=\"o\">-</span><span class=\"n\">cgu</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">rcgu</span><span class=\"p\">.</span><span class=\"n\">o</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">archive</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">object</span>\n<span class=\"n\">clang</span>: <span class=\"nc\">error</span>: <span class=\"nc\">linker</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">exit</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">see</span><span class=\"w\"> </span><span class=\"n\">invocation</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 427744710,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710860876
    },
    {
        "content": "<p>/usr/bin/ld is probably your host system linker; you'll need wasm-ld to link a wasm binary. One way to get one is <a href=\"https://github.com/WebAssembly/wasi-sdk/\">https://github.com/WebAssembly/wasi-sdk/</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/wasi-sdk/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/25efc5099f0986840550d2ffacb78f401d717137\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646139343161356261363134636633373563333436393034383639383462613730616461373632633833393133353866376266366131383130323961336132322f576562417373656d626c792f776173692d73646b)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/wasi-sdk/\" title=\"GitHub - WebAssembly/wasi-sdk: WASI-enabled WebAssembly C/C++ toolchain\">GitHub - WebAssembly/wasi-sdk: WASI-enabled WebAssembly C/C++ toolchain</a></div><div class=\"message_embed_description\">WASI-enabled WebAssembly C/C++ toolchain. Contribute to WebAssembly/wasi-sdk development by creating an account on GitHub.</div></div></div>",
        "id": 427745167,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1710860986
    },
    {
        "content": "<p>Installed the release binary version 20 and defined it as the <code>CC</code> variable as described in the repository. <code>echo $CC</code> now prints <code>/root/wasi-sdk-20.0/bin/clang --sysroot=/root/wasi-sdk-20.0/share/wasi-sysroot</code>. </p>\n<p>When I then run <code>$CC -shared -Wl,--whole-archive libmodule_b.a -Wl,--no-whole-archive</code>, I am getting</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">clang</span><span class=\"o\">-</span><span class=\"mi\">16</span>: <span class=\"nc\">warning</span>: <span class=\"nc\">argument</span><span class=\"w\"> </span><span class=\"n\">unused</span><span class=\"w\"> </span><span class=\"n\">during</span><span class=\"w\"> </span><span class=\"n\">compilation</span>: <span class=\"o\">'-</span><span class=\"n\">shared</span><span class=\"o\">'</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">Wunused</span><span class=\"o\">-</span><span class=\"n\">command</span><span class=\"o\">-</span><span class=\"n\">line</span><span class=\"o\">-</span><span class=\"n\">argument</span><span class=\"p\">]</span>\n<span class=\"n\">wasm</span><span class=\"o\">-</span><span class=\"n\">ld</span>: <span class=\"nc\">error</span>: <span class=\"o\">/</span><span class=\"n\">root</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">-</span><span class=\"n\">sdk</span><span class=\"o\">-</span><span class=\"mf\">20.0</span><span class=\"o\">/</span><span class=\"n\">share</span><span class=\"o\">/</span><span class=\"n\">wasi</span><span class=\"o\">-</span><span class=\"n\">sysroot</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">libc</span><span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">__main_void</span><span class=\"p\">.</span><span class=\"n\">o</span><span class=\"p\">)</span>: <span class=\"nc\">undefined</span><span class=\"w\"> </span><span class=\"n\">symbol</span>: <span class=\"nc\">main</span>\n<span class=\"n\">clang</span><span class=\"o\">-</span><span class=\"mi\">16</span>: <span class=\"nc\">error</span>: <span class=\"nc\">linker</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">exit</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">see</span><span class=\"w\"> </span><span class=\"n\">invocation</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 427756681,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710863733
    },
    {
        "content": "<p>Support for shared libraries is new in wasi-sdk version 21; so it looks like you need a newer version.</p>",
        "id": 427761400,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1710864890
    },
    {
        "content": "<p>Thank you! :) </p>\n<p>I think we are nearly there :) . With wasi-sdk version 21, the above command runs through (with just a warning about <code>-share</code> being unstable) and creates a <code>.wasm</code> file. </p>\n<p>I have then changed <code>module A</code> to also be a static lib, which then exports a <code>run</code> function. When I now try to link these modules running <code>wasm-tools component link -o combined.wasm module_a.wasm module_b.wasm</code>, I am getting an error about the modules requiring <code>libc.so</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">modules</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">missing</span><span class=\"w\"> </span><span class=\"n\">libraries</span>:\n        <span class=\"nc\">module_a</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">libc</span><span class=\"p\">.</span><span class=\"n\">so</span>\n<span class=\"w\">        </span><span class=\"n\">module_b</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">libc</span><span class=\"p\">.</span><span class=\"n\">so</span>\n</code></pre></div>\n<p>do I need <code>libc</code> as a module as well? How would I provide it to the modules?</p>",
        "id": 427765584,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710866012
    },
    {
        "content": "<p>Yes, <code>libc.so</code> is shipped as part of <code>wasi-sdk</code> 21, so you can use that one.  You'll need to tell <code>wasm-tools component link</code> about it explicitly as one of the parameters.</p>",
        "id": 427765880,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710866093
    },
    {
        "content": "<p>On my system, it lives in <code>/opt/wasi-sdk-21.0/share/wasi-sysroot/lib/wasm32-wasi/libc.so</code></p>",
        "id": 427766101,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710866158
    },
    {
        "content": "<p>Great :) . So, if I give it the <code>libc.so</code> by specifying the <code>--dl-openable &lt;PATH-TO-libc.so&gt;</code> of the <code>wasm-tools component link</code> command, it stops complaining about <code>libc.so</code>, but now is not happy that it doesn't know how to provide the import of <code>module_b</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">modules</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"mi\">0</span>: <span class=\"nc\">unresolved</span><span class=\"w\"> </span><span class=\"n\">symbol</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>:\n        <span class=\"nc\">module_b</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">double_num_host</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">I32</span><span class=\"p\">]</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"n\">I32</span><span class=\"p\">])</span>\n</code></pre></div>\n<p>I understand that this import is not fulfilled, but this is kind of the point in my case: This is the import which would be satisfied by the host when the module created by linking is deployed. Would it be possible to adjust the configuration, such that not defined imports would not cause an error but could be linked to functions provided by the host/runtime?</p>",
        "id": 427768526,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710866800
    },
    {
        "content": "<p>Is the <code>--adapt</code> parameter part of the solution? Would I need some kind of adapter explaining that this import will be available during deployment?</p>",
        "id": 427768888,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710866901
    },
    {
        "content": "<p>Keep in mind that <code>wasm-tools component link</code> doesn't generate a module -- it generates a component.  That means any undefined symbols must be imported at the component level (i.e. via an interface defined in WIT), not at the module level.  </p>\n<p>Alternatively, you could generate a component that imports a module, and use that imported module to provide the symbol, but <code>wasm-tools component link</code> does not yet have support for that, unfortunately.  It's definitely been something I've been planning to add, but haven't gotten around to it yet.  I don't think it would be super hard to do, but I haven't even experimented with module imports in the component model yet, so I'm not sure how they work.</p>",
        "id": 427772939,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710868123
    },
    {
        "content": "<p>I see. Maybe a stupid question: As I compile the modules, they are using WASI, right (at the very least for the printing)? Why doesn't <code>wasm-tools</code> have the same problem there? Aren't the wasi functions provided to the component by the host at the point of its deployment, the same way I would like to provide the <code>double_num_host</code> function? How come they don't cause the same kind of problem for <code>wasm-tools</code>?</p>",
        "id": 427774421,
        "sender_full_name": "Fedor Smirnov",
        "timestamp": 1710868578
    },
    {
        "content": "<p>If we're talking about WASI 0.2 imports, those all happen at the component level, so they're imported by the component as described above.  If we're talking about WASI 0.1 imports, they are transformed into WASI 0.2 imports via an adapter.</p>",
        "id": 427774769,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710868701
    },
    {
        "content": "<p>Either way, <code>wasm-tools component link</code> discovers information about component-level imports via custom sections attached to some or all of the modules it is given as parameters and uses that to determine what the component will import.  Likewise for any component-level exports.</p>",
        "id": 427775996,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710869104
    },
    {
        "content": "<p>Those custom sections are normally added by <code>wit-bindgen</code> when compiling the module(s).</p>",
        "id": 427776081,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710869133
    },
    {
        "content": "<p>If none of the modules have such custom sections, then either the component won't import or export anything (which would be kind of useless) or it needs the WASI 0.1-&gt;0.2 adapter, which will have the custom section with the component type information.</p>",
        "id": 427776417,
        "sender_full_name": "Joel Dice",
        "timestamp": 1710869211
    }
]