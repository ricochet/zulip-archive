[
    {
        "content": "<p>Hello!</p>\n<p>I am interested by loading and running in Java language a WebAssembly module created using the project <code>wit-bindgen</code>. Actually I was looking for the Java bindings for this but I could not find any related project, or at least any equivalent project. </p>\n<p>As mention in <code>wasmtime.dev</code>, there are 2 options : the <code>wasmtime-java</code> from kawamuray or  the one from bluejekyll (and I already both thank them for their work). Be able to run a <code>wit-bindgen WASM module</code> would allow us (and me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> ) to have a unique WASM module loaded by different languages (Python, Java, Javascript, C, etc.).</p>\n<p>I took the option <code>wasmtime-java</code> from bluejekyll (thank you <span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span>):  it is WIP project that could interest a lots of people for sure. I tried to run a very basic <code>wit-bindgen WASM</code>, I encounter 2 problems (those problems have been addressed to Benjamin and we agree to expose them here to find some help) : </p>\n<p>The WASM module exports those 3 functions (through the Rust bindings generated with <code>wit-bindgen</code>): </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"nf\">play_with_bytes</span><span class=\"p\">(</span><span class=\"nl\">input</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"nf\">play_with_result</span><span class=\"p\">(</span><span class=\"nl\">input</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"nf\">play_with_struct</span><span class=\"p\">(</span><span class=\"nl\">abc</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"o\">::</span><span class=\"n\">Abc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"o\">::</span><span class=\"n\">Abc</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>this first problem deals with the de/allocation functions: for <code>wasmtime-java</code>, the WASM file needs to have the 2 exported functions <code>__alloc_bytes</code> and <code>__dealloc_bytes</code>). A quick workaround is to add those 2 functions in the WASM source code. Of course it would be better to use the existing wit-bindgen allocation functions but at least we can continue the tests.</li>\n<li>the second problem occurs when function-signature (in WASM) looks like <code>fn my_function(input: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;</code>. I cannot find a way to load the return value. I confirm that I can \"see\" when debugging the expected vector in the WASM memory but I don't understand how to find the correct offset of this result in memory (and the related result size in bytes). The offset returned by the function call (which is correct) does not match the good offset of the result. In parallel, I run the same WASM module from python (with the python-bindings generate by <code>wit-bindgen</code>) and we can compare the results: the output result is the same in both cases but shifting the memory to get the correct pointer of the expected ouptut does not work with <code>wasmtime-java</code>.</li>\n</ul>\n<p>The following link is a very short fork of <code>wasmtime-java</code> to include new tests with a <code>wit-bindgen WASM module</code> :  <a href=\"https://github.com/Manuthor/wasmtime-java/tree/feature/add_ref_return_value\">https://github.com/Manuthor/wasmtime-java/tree/feature/add_ref_return_value</a>.<br>\nAny help will be greatly appreciated! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Manuthor/wasmtime-java/tree/feature/add_ref_return_value\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b51240f82c2b49b374ff3c400fffa1e33410fd4b\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f616464653663303236653534643931363535363737383530663935386162366234323337383761613839333530663561623836343564323534343630316638362f4d616e7574686f722f7761736d74696d652d6a617661)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Manuthor/wasmtime-java/tree/feature/add_ref_return_value\" title=\"GitHub - Manuthor/wasmtime-java at feature/add_ref_return_value\">GitHub - Manuthor/wasmtime-java at feature/add_ref_return_value</a></div><div class=\"message_embed_description\">Wasmtime bindings for Java. Contribute to Manuthor/wasmtime-java development by creating an account on GitHub.</div></div></div>",
        "id": 266860065,
        "sender_full_name": "Manuthor",
        "timestamp": 1641328741
    },
    {
        "content": "<p>For some background. I started the <code>wasmtime-java</code> project a while back and have been working on it pretty much solo. I have gotten a lot of help here, but I'm sure I've made some decisions that are not compliant or are not best practice. I've recently updated the project to the current <code>wasmtime</code> version, but there are some issues in regards to the handling of returned complex types (like Vec/Arrays). I've only just started looking at the <code>wit</code> ABI spec, but I think this will have a nice effect of normalizing a lot of this support.</p>",
        "id": 266860882,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641329184
    },
    {
        "content": "<p>A question I have in regards to the <code>wit-bindgen</code> and <code>wasm</code> is there a best practices spec for working with complex types in what is generated for those interfaces?</p>",
        "id": 266861134,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641329328
    },
    {
        "content": "<p>The intention with <code>wit-bindgen</code> is that there would be a <code>wasmtime</code> embedding in Java, but it wouldn't actually concern itself with anything interface-types related. For example the <code>wasmtime-java</code> project wouldn't worry about vectors, abi, etc, or anything like that. It would instead be a pure binding of simply the C API in a Java-like fashion that feels idiomatic in Java.</p>\n<p>On top of this hypothetical <code>wasmtime-java</code> library the <code>wit-bindgen</code> crate would then generate <code>*.java</code> files (omg it's been so long since I wrote java, that's the source extension, right?) which would use <code>wasmtime-java</code> and then use the interface types definitions of ABIs and such to translate back and forth between java-native representations and wasm representations. For example (if I recall the syntax correctly) a <code>Vec&lt;u8&gt;</code> in the wasm module would be <code>byte[]</code> in Java and the generated code by <code>wit-bindgen</code> would do the translation</p>",
        "id": 266862154,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641329788
    },
    {
        "content": "<p>there's lots of details about how the precise ABI maps out (allocation functions, where to store return values, etc), but that's all theoretically handled by the code-generation-functionalities of <code>wit-bindgen</code> (which currently doesn't have a Java mode or implementation)</p>",
        "id": 266862196,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641329819
    },
    {
        "content": "<p>Basically all that is to say that in the same way that <code>wasmtime-py</code> knows nothing about interface types, yet <code>wit-bindgen python</code> generates Python code, would be how <code>wasmtime-java</code> would work. The <code>wasmtime-java</code> library itself would have nothing interface-types-specific (yet) and then the generated code by <code>wit-bindgen</code> would leverage <code>wasmtime-java</code> and do the translation.</p>",
        "id": 266862304,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641329881
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span>. I think the confusing thing I have right now is return by-ref or multi-value return data (and subsequent ownership). I think the confusing thing I've always had with the idea that <code>wasmtime-java</code> knows nothing about interface types is that it absolutely cares at the FFI boundary for complex types. For example, in the <code>wasmtime-java</code> code, in order to support passing slices back to have, there's a complex pointer type that mimics a Rust slice passed by reference into the WASM, and then copied into the JVM as a <code>byte[]</code> and the return by ref from WASM is then freed (via the <code>__dealloc_bytes</code>). This has always felt wrong to me, and implied I've done something wrong, and it's the part of the ABI that I get confused in.</p>",
        "id": 266863395,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641330372
    },
    {
        "content": "<p>From <code>wasmtime-java</code>'s perspective there's not really any such thing as <code>byte[]</code> because wasm has no notion of byte slices. In that sense <code>wasmtime-java</code> knows nothing about either passing or returning byte slices in wasm functions</p>",
        "id": 266863537,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330479
    },
    {
        "content": "<p>Once <code>wit-bindgen</code> comes into the picture it uses the canonical abi for interface types to define how this happens, and the canonical abi is defined in terms of core wasm features, such as multiple return values at the wasm level and things like that</p>",
        "id": 266863638,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330512
    },
    {
        "content": "<p>so <code>wasmtime-java</code> needs to support calling arbitrary wasm functions with arbitrary values (in addition to modifying wasm memory)</p>",
        "id": 266863655,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330528
    },
    {
        "content": "<p>but it doesn't need to support things like <code>byte[]</code></p>",
        "id": 266863665,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330537
    },
    {
        "content": "<p>in a sense <code>wasmtime-java</code> is so simple that it won't be too useful to anyone, but it's a building block to build something more advanced if that makes sense</p>",
        "id": 266863721,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330581
    },
    {
        "content": "<p>(in the same way that <code>wasmtime-py</code> and the <code>wasmtime</code> crate are quite \"primitive\")</p>",
        "id": 266863743,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330597
    },
    {
        "content": "<p>Maybe I can share an example of the function call from/to Java to help clarify my point of concern, because I think we're not quite but almost talking past each other, here's a call from Java into the wasmtime runtime and into a WASM module with slices and returned data by ref: <a href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/src/test/java/net/bluejekyll/wasmtime/tests/SliceTests.java#L115\">https://github.com/bluejekyll/wasmtime-java/blob/main/src/test/java/net/bluejekyll/wasmtime/tests/SliceTests.java#L115</a> then here is the other side of that in a Rust function with the C ABI for the support in WASM: <a href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/tests/slices/src/lib.rs#L39-L43\">https://github.com/bluejekyll/wasmtime-java/blob/main/tests/slices/src/lib.rs#L39-L43</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/src/test/java/net/bluejekyll/wasmtime/tests/SliceTests.java#L115\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b258952f9f74420f7a39c5de867d4daab1073f3b\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f336635363730313538306234346432376461323531373136613165353562313162313666653761616434643662393039313936633233316562336639623764372f626c75656a656b796c6c2f7761736d74696d652d6a617661)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/src/test/java/net/bluejekyll/wasmtime/tests/SliceTests.java#L115\" title=\"wasmtime-java/SliceTests.java at main · bluejekyll/wasmtime-java\">wasmtime-java/SliceTests.java at main · bluejekyll/wasmtime-java</a></div><div class=\"message_embed_description\">Wasmtime bindings for Java. Contribute to bluejekyll/wasmtime-java development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/tests/slices/src/lib.rs#L39-L43\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b258952f9f74420f7a39c5de867d4daab1073f3b\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f336635363730313538306234346432376461323531373136613165353562313162313666653761616434643662393039313936633233316562336639623764372f626c75656a656b796c6c2f7761736d74696d652d6a617661)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bluejekyll/wasmtime-java/blob/main/tests/slices/src/lib.rs#L39-L43\" title=\"wasmtime-java/lib.rs at main · bluejekyll/wasmtime-java\">wasmtime-java/lib.rs at main · bluejekyll/wasmtime-java</a></div><div class=\"message_embed_description\">Wasmtime bindings for Java. Contribute to bluejekyll/wasmtime-java development by creating an account on GitHub.</div></div></div>",
        "id": 266864324,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641330913
    },
    {
        "content": "<p>ah yeah so these are details that wouldn't be implemented by <code>wasmtime-java</code></p>",
        "id": 266864496,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641330999
    },
    {
        "content": "<p>so for example the Rust crate has no way of doing this</p>",
        "id": 266864514,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331011
    },
    {
        "content": "<p>\"wouldn't\" be, I mean, they kinda are now <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 266864536,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641331025
    },
    {
        "content": "<p>from Rust you can call a wasm function, but there's no concept of a byte slice in wasm, so you can't call wasm with a byte slice (or wasm can't return to you a byte slice)</p>",
        "id": 266864540,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331028
    },
    {
        "content": "<p>well my point is that if you're baking in an ABI like this that's basically a design choice, and it's not that interface types is intending todo</p>",
        "id": 266864582,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331058
    },
    {
        "content": "<p>there basically is no standard answer to the question \"how do I get a slice of bytes from wasm\" if all you can use is core wasm</p>",
        "id": 266864676,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331086
    },
    {
        "content": "<p>once you involve interface types that question can be answered, however, but it's a distinct answer (and layered as such)</p>",
        "id": 266864714,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331106
    },
    {
        "content": "<p>Am I asking the wrong question then? Maybe I should reask a question I had long ago... what is the best practice for passing a byte array into WASM and vis/versa returning one? Or better yet, what's the best practice for accessing that data if not by passing arrays?</p>",
        "id": 266864825,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641331189
    },
    {
        "content": "<p>in a sense this is kind of the wrong question , kind of isn't. Like this is a perfectly valid thing to ask since it's the first thing any embedded wasm module wants to do. The tl;dr is that this is a struggle and this can't be done in a standard way so everyone is left to their own devices. The longer answer is \"interface types will solve this\", which is what <code>wit-bindgen</code> is. When <code>wit-bindgen</code> gets a Java implementation it will not rely on what you have today to implement <code>byte[]</code> but instead it will do its own thing, similar to what all other <code>wit-bindgen</code> generation modes are doing</p>",
        "id": 266865357,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331481
    },
    {
        "content": "<p>To answer \"what's the best practice\" it's \"there is none\"</p>",
        "id": 266865389,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331501
    },
    {
        "content": "<p>which isn't a great answer, hence the focus on work on interface types</p>",
        "id": 266865404,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331510
    },
    {
        "content": "<p>If I might jump in here, in a shared nothing model, which I understood interface types to be, does this imply copying the <code>byte[]</code> ?</p>",
        "id": 266865679,
        "sender_full_name": "Scott Waye",
        "timestamp": 1641331671
    },
    {
        "content": "<p>this sounds a little bit like semantics though... i.e. if <code>wit-bindgen</code> generates interop between <code>byte[]</code> and the target function vs. <code>wastime-java</code> doing that, right? i.e. something needs to translate between those points, right now I do a bunch of reflection in Java to build the bridging code between the two envs...</p>",
        "id": 266865696,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641331679
    },
    {
        "content": "<p>yeah it's true that precisely where implements what doesn't really matter, I don't mean to say one particular way is correct vs another</p>",
        "id": 266865881,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331774
    },
    {
        "content": "<p>one of the focuses of interface types is cross-language interop, which means we can't focus really all that much on one particular binding, and so far I've been trying to do things that work everywhere</p>",
        "id": 266865924,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331796
    },
    {
        "content": "<p>and <span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> that's correct, for interface types the <code>byte[]</code> type would be copied in/out of wasm, there's no concept of a \"mutable slice buffer\"</p>",
        "id": 266865996,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641331818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> for correctness reasons in the JVM there is <code>byte[]</code> which must be copied to/from the WASM memory. There is <code>ByteBuffer</code> which can reference data directly in WASM theoretically, but I haven't figured out a good ownership model for that, so stopped trying to support it.</p>",
        "id": 266866042,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641331846
    },
    {
        "content": "<p>It might be useless, and I expect it is, but I did start a c# wit-bindgen to see how hard it would be.  Java I think has a lot of the same concerns.  I did some of the string bit and left it at that as it looked solvable with just \"some hours\" more work.  <a href=\"https://github.com/yowl/witx-bindgen/blob/csharp/crates/gen-csharp/src/lib.rs\">https://github.com/yowl/witx-bindgen/blob/csharp/crates/gen-csharp/src/lib.rs</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/yowl/witx-bindgen/blob/csharp/crates/gen-csharp/src/lib.rs\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/a29c382fab0b7ad3e5a31af1624c7d06ce2b1249\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636234313933663961396637316464396538393164663937313235623738333365626636663761663838336165303330393635396362353237646264383237312f796f776c2f776974782d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/yowl/witx-bindgen/blob/csharp/crates/gen-csharp/src/lib.rs\" title=\"witx-bindgen/lib.rs at csharp · yowl/witx-bindgen\">witx-bindgen/lib.rs at csharp · yowl/witx-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for `witx` (a precursor to WebAssembly interface types) - witx-bindgen/lib.rs at csharp · yowl/witx-bindgen</div></div></div>",
        "id": 266866491,
        "sender_full_name": "Scott Waye",
        "timestamp": 1641332067
    },
    {
        "content": "<p>Right, <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span>, and I still owe you a beer <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>. But I guess my higher level question is, if we don't do this in <code>wasmtime-java</code> then we'll do it in the generated code from <code>wit-bindgen</code> which sounds like will be something similar to what we're already doing. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> And maybe I can work on the <code>wit-bindgen</code> Java outputs, but I'd still (I think) need to support the calling convention in WASM.</p>",
        "id": 266866522,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332087
    },
    {
        "content": "<p>that's true yeah and w/e shape of things you're doing is the exact same shape of what wit-bindgen would otherwise generate (aka the canonical abi), it's probably just a few minor differences in the details</p>",
        "id": 266866668,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641332135
    },
    {
        "content": "<p>Calling-convention-wise what <code>wit-bindgen</code> (and interface types and/or the canonical abi) need is \"call this wasm with these types and get these types as a result\" where temporarily you know that the number of returned values is either 0 or 1</p>",
        "id": 266866922,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641332182
    },
    {
        "content": "<p>plus the ability to read/write bytes in memory</p>",
        "id": 266866963,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641332192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> , I think one thing you're lucky in CSharp with is that it has decent native type and FFI support with C, Java and JNI is bleh.</p>",
        "id": 266867424,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span>, yeah, I think I'm grokking you. I'm guessing there is still something that I'll need in Java though to allocate bytes for return by ref values, etc... right? today I do that in <code>wasmtim-java</code> when doing the function calls into WASM. So there needs to be some amount of support in <code>wasmtime-java</code> for that functionality, right? and after return freeing the associated memory?</p>",
        "id": 266867757,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332479
    },
    {
        "content": "<p>I'll take a look at implementing the Java bindings to <code>wit-bindgen</code> for java and see what needs to happen there.</p>",
        "id": 266867857,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332524
    },
    {
        "content": "<p>you might want to look at the stuff generated by <code>wit-bindgen</code> today, e.g. the <code>wasmtime-py</code> python bindings</p>",
        "id": 266867904,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641332547
    },
    {
        "content": "<p>that may help show what wit-bindgen does and what's expected of the binding library right now</p>",
        "id": 266867923,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641332561
    },
    {
        "content": "<p>Yeah, I'll do that. I only perused it at a high-level so far. Thanks for all your answers and help (again).</p>",
        "id": 266867978,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span>  You _might_ find <a href=\"https://medium.com/@scottwaye/experiments-in-c-and-webassembly-interface-types-b7a3a85ce966\">https://medium.com/@scottwaye/experiments-in-c-and-webassembly-interface-types-b7a3a85ce966</a> interesting, its how I spiked c# with the component ABI to get an idea about what would be required for wit-bindgen</p>",
        "id": 266868032,
        "sender_full_name": "Scott Waye",
        "timestamp": 1641332640
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> , I'll look at that.</p>",
        "id": 266868138,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641332698
    },
    {
        "content": "<p>btw, <span class=\"user-mention\" data-user-id=\"461589\">@Manuthor</span> , give me a moment to follow Alex's suggestions and see about working with the wit and generating some Java bindings, though, it might take a while.</p>",
        "id": 266892675,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641351913
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> , <span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span> and <span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> for all your insights. Let me know Benjamin how to help you.</p>",
        "id": 266912974,
        "sender_full_name": "Manuthor",
        "timestamp": 1641374465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> , I think I see the direction this is going in with your Python impl. It appears that you've exposed a huge number of primitives to the Python environment for working with Memory/Store and other contstructs in the wasmtime runtime, in order to allocate and deallocate on the WASM heap, etc. I was trying to avoid exposing the entire wastime surface area in this MVP, but looking at your code here it makes me realize that might not be possible. I still don't feel like trying to work with the C api in Java is the correct direction, because JNI is a little funky, but I at least better understand the air gap you have in mind between interface types and the wasmtime engine. So thank you for your answers to the questions yesterday.</p>",
        "id": 266975631,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641409119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461589\">@Manuthor</span>, I think there is a lot of work to be done to start exposing all the layers from Wasmtime needed by the Interface Types implementations. Might mean a bunch of refactoring to make this work correctly.</p>",
        "id": 266975744,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641409191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span> ah ok makes sense! I must admit I've never bound a C library in Java before so I'm quite ignorant as to the difficulties and the nuances there as well</p>",
        "id": 266976625,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641409550
    },
    {
        "content": "<p>what works for python may not work well for java for sure</p>",
        "id": 266976636,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641409556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> , I've been reviewing the details in the wit-bindgen output. I've found the rust generated code to be the most useful for understanding wit-bindgen. First, I really like the use of a static for the return pointer, I think this removes the need for the allocation I'm doing in the Java for the trampoline between wasm and the JVM. But I'm confused about something... and that's the difference in the way these bindings are generated in Rust for the export vs. the import.</p>",
        "id": 267015755,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641432301
    },
    {
        "content": "<p>Example, for the wit <code>list-return: function() -&gt; list&lt;u32&gt;</code>, the generated import Rust C FFI is <code>fn wit_import(_: i32);</code> which I export (return by ref) while the generated export C FFI is <code>unsafe extern \"C\" fn __wit_bindgen_list_return() -&gt; i32</code>, which is returning the pointer directly from the fn.</p>",
        "id": 267015864,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641432448
    },
    {
        "content": "<p>Either works, but I don't quite understand the calling convention in that case? Am I understanding this correctly?</p>",
        "id": 267015930,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641432500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350398\">Benjamin Fry</span> <a href=\"#narrow/stream/206238-general/topic/.5BJava.2FJNI.5D.20Load.2FRun.20WASM.20module.20created.20with.20wit-bindgen/near/267015864\">said</a>:</p>\n<blockquote>\n<p>Example, for the wit <code>list-return: function() -&gt; list&lt;u32&gt;</code>, the generated import Rust C FFI is <code>fn wit_import(_: i32);</code> which I export (return by ref) while the generated export C FFI is <code>unsafe extern \"C\" fn __wit_bindgen_list_return() -&gt; i32</code>, which is returning the pointer directly from the fn.</p>\n</blockquote>\n<p>\"...which I export...\" =&gt; ...which I did expect...</p>",
        "id": 267019001,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641436206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span> oh that's where the import and export ABI of the same-signatured-function isn't the same</p>",
        "id": 267073171,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641482900
    },
    {
        "content": "<p>there's always going to be an adapter between the two anyway which will translate the ABI as well</p>",
        "id": 267073206,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641482918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/stream/206238-general/topic/.5BJava.2FJNI.5D.20Load.2FRun.20WASM.20module.20created.20with.20wit-bindgen/near/267073171\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"350398\">Benjamin Fry</span> oh that's where the import and export ABI of the same-signatured-function isn't the same</p>\n</blockquote>",
        "id": 267086824,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641489095
    },
    {
        "content": "<p>gah, hit enter too soon. Doesn't that mean that there isn't a consistent FFI calling convention for these types?</p>",
        "id": 267086912,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641489130
    },
    {
        "content": "<p>I guess I would expect the signature to be the same for the FFI so that all the language wrappers would work in a consistent way, regardless of import or export...</p>",
        "id": 267087032,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641489190
    },
    {
        "content": "<p>For example, with the current ABI, doesn't this imply that if there are two Rust WASM modules, one with a wit-bindgen export and the other with the same wit-bindgen import, then those two modules wouldn't be able to be linked at runtime? This is where I'm currently confused.</p>",
        "id": 267092183,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641491772
    },
    {
        "content": "<p>Sorry for reaching you, but where can I find a simple \"hello world\" Cranelift example, that just builds a simple (adder?) function, JIT compile it and calls it. The simplest example I could find is the \"toy\" which has an entire programming language and a lot of extra stuff. Really hard to get started on Cranelift right now.</p>",
        "id": 267101263,
        "sender_full_name": "Victor Maia",
        "timestamp": 1641496310
    },
    {
        "content": "<p>That's correct, yeah, the ABI for each type differs depending on whether it's used in an import or an export. For most types it's the same but some slightly differ. The function signatures won't line up exactly</p>",
        "id": 267101393,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641496378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"469132\">@Victor Maia</span> I think you may want to start a new \"topic\" in the <a class=\"stream\" data-stream-id=\"217117\" href=\"/#narrow/stream/217117-cranelift\">#cranelift</a> channel for your question?</p>",
        "id": 267101451,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641496408
    },
    {
        "content": "<p>My bad, I never used Zulip. Will do. Can I delete the previous message?</p>",
        "id": 267101576,
        "sender_full_name": "Victor Maia",
        "timestamp": 1641496447
    },
    {
        "content": "<p>I'm not actually sure! But no worries!</p>",
        "id": 267101620,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1641496480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/stream/206238-general/topic/.5BJava.2FJNI.5D.20Load.2FRun.20WASM.20module.20created.20with.20wit-bindgen/near/267101393\">said</a>:</p>\n<blockquote>\n<p>That's correct, yeah, the ABI for each type differs depending on whether it's used in an import or an export. For most types it's the same but some slightly differ. The function signatures won't line up exactly</p>\n</blockquote>\n<p>I'm definitely missing something here as I can't figure out how this won't be a problem. But I'll roll with it as best I can <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 267111351,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641501609
    },
    {
        "content": "<p>imports and exports are never glued directly to each other, there is always an adapter in between (which will eventually be customizable via adapter functions in interface types)</p>",
        "id": 267115300,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1641503708
    },
    {
        "content": "<blockquote>\n<p>there is always an adapter in between</p>\n</blockquote>\n<p>Is there an example of the adapter that I can see?</p>",
        "id": 267125691,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641509154
    },
    {
        "content": "<p>And will that need to be handled by the host language? or do we anticipate the adapter being built into wasmtime?</p>",
        "id": 267125894,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641509279
    },
    {
        "content": "<p>And thank you, I've been trying to read all the docs, it's just been hard to keep up with everything.</p>",
        "id": 267125995,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641509328
    },
    {
        "content": "<p>There's a proof-of-concept \"linker\" (really just an wasm adapter generator) implementation <a href=\"https://github.com/bytecodealliance/wit-bindgen/tree/main/crates/wasmlink\">here</a>, but I fully expect Wasmtime to eventually support generating canonical adapters for components or perhaps other tooling that can be used to compose together different components ahead-of-time</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/tree/main/crates/wasmlink\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/969e0866bba1f99bb1de5d3b5d9b6257fe1780a5\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333032643132346333313965633134653963633266393866356364336663376539623361363765323939383066646434383663643237386261623164663561342f62797465636f6465616c6c69616e63652f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/tree/main/crates/wasmlink\" title=\"wit-bindgen/crates/wasmlink at main · bytecodealliance/wit-bindgen\">wit-bindgen/crates/wasmlink at main · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - wit-bindgen/crates/wasmlink at main · bytecodealliance/wit-bindgen</div></div></div>",
        "id": 267129617,
        "sender_full_name": "Peter Huene",
        "timestamp": 1641511761
    },
    {
        "content": "<p>whereas <code>wasmlink</code> generates a new wasm module with the adapter glue code inside it, the wasmtime bindings generator can be used to implement a custom host that generates similar \"adapter glue\" (at runtime) that sits between the host and the module (may be easier to see with the <a href=\"https://bytecodealliance.github.io/wit-bindgen/\">online demo</a> than the wasm generated by wasmlink)</p>",
        "id": 267131340,
        "sender_full_name": "Peter Huene",
        "timestamp": 1641513046
    },
    {
        "content": "<p>if it helps to clarify, adapter implementation is outside the scope of the language-specific wit bindings generators; they pass pointers and get back pointers into their own linear memory and it's their job to translate from/to the canonical ABI to/from whatever the implementation language uses for type representation. the adapter that ultimately sits between the caller and callee of an interface function is responsible for marshaling data (when necessary) between the linear memories, as well as ensuring parameters and results properly conform to the canonical ABI (e.g. a handle to a resource is valid prior to invoking the callee).</p>",
        "id": 267132996,
        "sender_full_name": "Peter Huene",
        "timestamp": 1641514113
    },
    {
        "content": "<p>Thank you. I think this is the missing piece in my understanding.</p>",
        "id": 267133938,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641514704
    },
    {
        "content": "<p>This is nowhere near ready, but I've got at least got imports started. I have to do a lot of conversion. <a href=\"https://github.com/bluejekyll/wit-bindgen/tree/wasmtime-java\">https://github.com/bluejekyll/wit-bindgen/tree/wasmtime-java</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bluejekyll/wit-bindgen/tree/wasmtime-java\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/d36b0d078da7e8084e43e38910d0c452020266fe\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f306437346333353930656161303633666133343966376435326661646662643261323134363638636262616238643564626135306261323833316238333339342f626c75656a656b796c6c2f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bluejekyll/wit-bindgen/tree/wasmtime-java\" title=\"GitHub - bluejekyll/wit-bindgen at wasmtime-java\">GitHub - bluejekyll/wit-bindgen at wasmtime-java</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - bluejekyll/wit-bindgen at wasmtime-java</div></div></div>",
        "id": 267528075,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1641866507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461589\">@Manuthor</span> , thanks for sharing this. I've gotten pinged by some other folks with interest here as well. I've directed them to come back into this conversation to see if we can get more support here.</p>",
        "id": 282700944,
        "sender_full_name": "Benjamin Fry",
        "timestamp": 1652818580
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350398\">@Benjamin Fry</span> , good idea! I must admit, due to WASM performances (being 6x times slower than native ELF binary in my particular case) I had to change my implementation and finally use FFI/JNA in Java. But still, having WASM working natively in Java would be awesome.</p>",
        "id": 282961288,
        "sender_full_name": "Manuthor",
        "timestamp": 1652980055
    }
]