[
    {
        "content": "<p>Hello everyone,</p>\n<p>I am studying the state of the art of tools around there to serialise structured data on the wire in a cross-platform/language way (<code>protobuf</code>, <code>capnproto</code>, <code>flatbuffers</code>).</p>\n<p>I really like <code>flatbuffer</code> and consider using it in one of my side-project but I also found out about <a href=\"https://github.com/bytecodealliance/wrpc\">wRPC</a> and <a href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\">WAVE</a>.</p>\n<p>I am not really fluent with our ABI, but I understand <code>lower</code> and <code>lift</code> as <code>serialize</code> and <code>deserialize</code> respectively. (I find their name a bit confusing, is it a term used a lot in related literature?). So in theory, if we implement libraries in different language, for different platform to do <em>lifting</em> and <em>lowering</em>, we basically get there, right?</p>\n<p>All the tools I mentioned have their own IDL, a corresponding serialisation / deserialisation format, and eventually, they propose a default RPC implementation.</p>\n<p>So we have <strong>a tuple</strong> <code>(IDL, serialisation format, RPC)</code> which, in our case could be <code>(WIT, WAVE, wRPC)</code>.<br>\nSo at the end of the day, it's all about packaging such a <strong>tuple</strong> in a user-friendly way and extending <code>wave</code> to be cross-language and cross-platform right?</p>\n<p>I think it would be beneficial for our eco-system to have a well-defined tuple like that, with tools to support its usage, indeed: that would allow incremental introduction of Wasm Components in legacy environments made of native / POSIX software. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<p>Even performance wise, if <code>wave</code> supports features like zero-copy and our end-users use inter-process (or even intra-process, e.g., from host to components instance but I guess the ABI already covers that.) transport, then <em>Wasm Component</em> adoption becomes even simpler, we can even design fully-native systems using this tuple of technology for their API, so they can interact nicely with Wasm Components (what I am trying to do, btw).</p>\n<p>I know wRPC is kind of following this path since it's completely usable out of any wasm runtime, but in the current form,<br>\nvalue encoding doesn't seem standardised. IIUC, <code>wave</code> existed before the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\">Value Definition spec</a>, and, anyway, <em>Value Definitions</em> is not a general-purpose encoding specification, but more focused on the use-case of <code>global</code> values in a Wasm Component context.</p>\n<p>Finally, my questions are:</p>\n<ol>\n<li>Would it make sense to start working on packaging such a <strong>tuple</strong> <code>(IDL, serialisation format, RPC)</code> ?</li>\n<li>Does <code>(WIT, WAVE, wRPC)</code> make sense, specifically is <code>WAVE</code> the good tool for that? How it relates to the ABI?</li>\n<li>Should we make <code>WAVE</code> have its own repository and be end-users entrypoint? What I mean by that is that all the 3 technologies I mentioned are known to the wide-audience by their serialisation format most of the time (i.e., <code>protobuf</code>, <code>capnproto</code>, <code>flatbuffers</code>).</li>\n</ol>\n<p>Thanks for taking the time reading me <span aria-label=\"praise\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"praise\">:praise:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wrpc\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/6e2affba1da62d556c2ab80d602812452c23748f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f386636373465633730636565393062383461373039323564663239643966633533643731663265663234323239653136613135643865333361353062623664342f62797465636f6465616c6c69616e63652f77727063&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wrpc\" title=\"GitHub - bytecodealliance/wrpc: Wasm component-native RPC framework\">GitHub - bytecodealliance/wrpc: Wasm component-native RPC framework</a></div><div class=\"message_embed_description\">Wasm component-native RPC framework. Contribute to bytecodealliance/wrpc development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f5077c6ecbcffcc89a99730c404a7b7e5db5c33d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633535666562656561373265663834643233393437386630343664326665313863363736393465393232633462633736376639623430303634656633323664612f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\" title=\"wasm-tools/crates/wasm-wave at main · bytecodealliance/wasm-tools\">wasm-tools/crates/wasm-wave at main · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/88a69656cef8345e543b3f2ca6450f79777c02e9/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f326466616135363064333930396161326565343063663162613937646366373338323133643337346438323263653135383735613239656435646137303761642f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\" title=\"component-model/design/mvp/Explainer.md at main · WebAssembly/component-model\">component-model/design/mvp/Explainer.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 486459345,
        "sender_full_name": "raskyld",
        "timestamp": 1733472267
    },
    {
        "content": "<p>wit-bindgen has json support for wit as well, to make it much easier for languages.</p>",
        "id": 486460556,
        "sender_full_name": "Ralph",
        "timestamp": 1733472817
    },
    {
        "content": "<p>wit-bindgen is focused on the generation of the bindings specifically right? so we still a tool to do the serde right?</p>",
        "id": 486460935,
        "sender_full_name": "raskyld",
        "timestamp": 1733472968
    },
    {
        "content": "<p>(sorry for dumb questions, I just try to get a really high-level overview of all the moving parts)</p>",
        "id": 486461088,
        "sender_full_name": "raskyld",
        "timestamp": 1733473041
    },
    {
        "content": "<blockquote>\n<p>I am not really fluent with our ABI, but I understand <code>lower</code> and <code>lift</code> as <code>serialize</code> and <code>deserialize</code> respectively. (I find their name a bit confusing, is it a term used a lot in related literature?). So in theory, if we implement libraries in different language, for different platform to do <em>lifting</em> and <em>lowering</em>, we basically get there, right?</p>\n</blockquote>\n<p>Protobufs, flatbuffers, etc. serialize to a single bytestream. The terms lifting and lowering in Wasm components describe serializing to a calling convention, which is similar, but has some important differences. For example, lifting and lowering don't store everything in bytes in memory; some of the data is transmitted as call arguments and return values instead. For another example, data in memory isn't in a single contiguous byte array; it's in buffers pointed to by pointers.</p>\n<blockquote>\n<p>So we have <strong>a tuple</strong> <code>(IDL, serialisation format, RPC)</code> which, in our case could be <code>(WIT, WAVE, wRPC)</code>.<br>\nSo at the end of the day, it's all about packaging such a <strong>tuple</strong> in a user-friendly way and extending <code>wave</code> to be cross-language and cross-platform right?</p>\n</blockquote>\n<p>WAVE and wRPC both encode values with Wit types, so they're both cross-language and cross-platform.</p>\n<blockquote>\n<p>I know wRPC is kind of following this path since it's completely usable out of any wasm runtime, but in the current form,<br>\nvalue encoding doesn't seem standardised. IIUC, <code>wave</code> existed before the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\">Value Definition spec</a>, and, anyway, <em>Value Definitions</em> is not a general-purpose encoding specification, but more focused on the use-case of <code>global</code> values in a Wasm Component context.</p>\n</blockquote>\n<p>WAVE is a <a href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\">human-focused text format</a>. The <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\">Value Definition spec</a> is a binary format. Both are general-purpose encoding specifications.</p>\n<blockquote>\n<p>Finally, my questions are:</p>\n<ol>\n<li>Would it make sense to start working on packaging such a <strong>tuple</strong> <code>(IDL, serialisation format, RPC)</code> ?</li>\n</ol>\n</blockquote>\n<p>It could. It depends on whether there are people volunteering to do this particular packaging.</p>\n<p>One thing to consider is that an alternative to all of this is to build adapters between WIT and protobuf/capnproto/flatbuffers. It's a tradeoff; you'd get less direct component integration, but more compatibility with established ecosystems. Different use cases will want different things.</p>\n<blockquote>\n<ol start=\"2\">\n<li>Does <code>(WIT, WAVE, wRPC)</code> make sense, specifically is <code>WAVE</code> the good tool for that? How it relates to the ABI?</li>\n</ol>\n</blockquote>\n<p>I expect that particular tuple isn't what you're looking for here, because WAVE is a text format, so it's not particularly compact or efficient. <code>(WIT, something based on Value Definition encoding, wRPC)</code> is closer, and that's what wRPC basically already is. I suggest looking at wRPC to see if it's perhaps already one of the things you want.</p>\n<blockquote>\n<ol start=\"3\">\n<li>Should we make <code>WAVE</code> have its own repository and be end-users entrypoint? What I mean by that is that all the 3 technologies I mentioned are known to the wide-audience by their serialisation format most of the time (i.e., <code>protobuf</code>, <code>capnproto</code>, <code>flatbuffers</code>).</li>\n</ol>\n</blockquote>\n<p>The Value Definition encoding doesn't currently have its own personality, tooling, and a short name, like protobuf/etc. all have. And, the Value Definition encoding doesn't currently have a design for schema evolution. For example, if someone adds new optional fields to records in their WIT, how can old data be read by new consumers? But those are all things that could be worked on, if someone were interested.</p>\n<blockquote>\n<p>wit-bindgen is focused on the generation of the bindings specifically right? so we still a tool to do the serde right?</p>\n</blockquote>\n<p>Right; wit-bindgen is focused on the calling convention space, rather than the single-bytestream space.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f5077c6ecbcffcc89a99730c404a7b7e5db5c33d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633535666562656561373265663834643233393437386630343664326665313863363736393465393232633462633736376639623430303634656633323664612f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-wave\" title=\"wasm-tools/crates/wasm-wave at main · bytecodealliance/wasm-tools\">wasm-tools/crates/wasm-wave at main · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/88a69656cef8345e543b3f2ca6450f79777c02e9/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f326466616135363064333930396161326565343063663162613937646366373338323133643337346438323263653135383735613239656435646137303761642f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#-value-definitions\" title=\"component-model/design/mvp/Explainer.md at main · WebAssembly/component-model\">component-model/design/mvp/Explainer.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 486528695,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1733495860
    },
    {
        "content": "<p>Thanks a lot for your comprehensive answer <span aria-label=\"praise\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"praise\">:praise:</span> </p>\n<p>So the bindings generated know where in the linear memory they need to place stuff (call parameters) and where to expect return values, etc.. I guess I need to throughly read the Canonical ABI to get all the nuances.</p>\n<blockquote>\n<p>WAVE and wRPC both encode values with Wit types, so they're both cross-language and cross-platform.</p>\n</blockquote>\n<p>What I mean is that we actually need to write the encode/decode libraries in different languages and for different targets right? </p>\n<blockquote>\n<p>One thing to consider is that an alternative to all of this is to build adapters between WIT and protobuf/capnproto/flatbuffers.</p>\n</blockquote>\n<p>That sounds like a really interesting approach, indeed, we could use a proven technology for that.</p>\n<blockquote>\n<p>and that's what wRPC basically already is. I suggest looking at wRPC to see if it's perhaps already one of the things you want.</p>\n</blockquote>\n<p>Yeah I started looking at wRPC and saw it used Value Definition but I was wondering if we could decouple the two things, so Value Definition gets its own personality as you said!</p>\n<blockquote>\n<p>The Value Definition encoding doesn't currently have its own personality, tooling, and a short name, like protobuf/etc. all have. And, the Value Definition encoding doesn't currently have a design for schema evolution. For example, if someone adds new optional fields to records in their WIT, how can old data be read by new consumers? But those are all things that could be worked on, if someone were interested.</p>\n</blockquote>\n<p>I think there is two path for that:</p>\n<ol>\n<li>Evolving WIT to support API evolution, but then, there is the underlying question of: is WIT supposed to have such a feature?</li>\n<li>Avoiding touching WIT and instead working on adapters with other serialisation format.</li>\n</ol>\n<p>For now, I don't know which path make the most sense so I guess I will wait to see what people from the Zulip think to see if we reach a consensus of what should be our approach or if the base idea is interesting or not.</p>",
        "id": 486561262,
        "sender_full_name": "raskyld",
        "timestamp": 1733505623
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>WAVE and wRPC both encode values with Wit types, so they're both cross-language and cross-platform.</p>\n</blockquote>\n<p>What I mean is that we actually need to write the encode/decode libraries in different languages and for different targets right?</p>\n</blockquote>\n<p>Right.</p>\n<blockquote>\n<ol>\n<li>Evolving WIT to support API evolution, but then, there is the underlying question of: is WIT supposed to have such a feature?</li>\n</ol>\n</blockquote>\n<p>WIT will surely need to address API evolution at some point, considering how important it is in other similar systems, such as protobufs.</p>",
        "id": 486567864,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1733507880
    },
    {
        "content": "<p>Hm.. anyway I guess that if we ever want to explore option (2) i.e. interoperability with other serialization format, we would need feature parity i.e. making WIT support API evolution / fields tagged with integers instead of using names etc..</p>",
        "id": 486582514,
        "sender_full_name": "raskyld",
        "timestamp": 1733513825
    },
    {
        "content": "<p>Hej!</p>\n<p>I have started on my part-time (I will open-source it once I get the basics done) a pluggable WIT compiler.</p>\n<p>Basically, the library takes a pipeline defined as multiple \"steps\" which are just Wasm Components capable of taking a <a href=\"https://docs.rs/wit-parser/latest/wit_parser/struct.Resolve.html\">WIT AST</a> as an input and either manipulate it or translate it to AST of programming languages so a last component in the pipeline ends-up writing actual Rust / Go / Python / Whatever code. I had to implement the equivalent of reflection e.g. <a href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto\">for protobuf</a> to manipulate WIT package in a WebAssembly runtime.</p>\n<p>I realised that whatever path I choose, I will end-up needing a flexible WIT compiler to generate bindings and adaptors to serialisation formats.</p>\n<p>Accidentally, the crate could be useful to generate markdown / single HTML page to document WIT packages.</p>\n<p>Are you aware of anything like that in the eco-system?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/96f84799fa06891be01f337231c7d864fde49548/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633932303736306139376133323338666237396633356161326462333965663665623863343434666631333132353833666661626330353131373838353063632f70726f746f636f6c627566666572732f70726f746f627566&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.proto\" title=\"protobuf/src/google/protobuf/descriptor.proto at main · protocolbuffers/protobuf\">protobuf/src/google/protobuf/descriptor.proto at main · protocolbuffers/protobuf</a></div><div class=\"message_embed_description\">Protocol Buffers - Google's data interchange format - protocolbuffers/protobuf</div></div></div>",
        "id": 488046799,
        "sender_full_name": "raskyld",
        "timestamp": 1733907586
    },
    {
        "content": "<p>One thing to note is that WIT provides a superset of features available in e.g. protobuf. While one could figure out a way to encode a <code>resource</code> - it seems like <code>future</code> and <code>stream</code> types, which will be available very soon in WASI 0.3, would posses a greater challenge. All that is to say that encoding any, arbitrary, generic WIT value to a flat byte buffer is not possible. E.g. if a specific interface allows stream buffering - one could encode it as a <code>list&lt;T&gt;</code>, but that's not an assumption that can be made in a generic way.</p>\n<p>wRPC was designed to specifically enable <code>async</code> and Component Model encoding was effectively extracted from the original implementation. wRPC still needs to extend that encoding to define representation of <code>resource</code>, <code>future</code> and <code>stream</code>.</p>",
        "id": 488052811,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1733909485
    },
    {
        "content": "<p>I have been considering those cases, that is what drove me to first build this WIT compiler.<br>\nI am not yet settled on the exact serialisation format, we could totally translate WIT types in Flatbuffers <em>Tables</em> but, as you mentioned, WIT has features which put constraints on the transport layer that will be in use. That also means, the exact way some concepts are represented must be customisable.</p>\n<p>For example, you can represent <code>resource</code>s as an uint64 which has meaning only in the context of a persistent connection between a client and a server at RPC level.</p>\n<p>Maybe you want to go one way further, and the RPC protocol you will end-up using is capable to go further and issue cryptographic handles to clients which can be used to invoke method on a resource without persistent connection, etc. etc..<br>\nCap'n'proto have support for capabilities and promises: <a href=\"https://capnproto.org/rpc.html\">https://capnproto.org/rpc.html</a></p>\n<p>My current mental picture is that the serialisation format <strong>MUST</strong> allow end-users to produce different schema for a same WIT concept (e.g. how are represented <code>resources</code>, <code>streams</code>, and <code>promise</code> on the wire).</p>",
        "id": 488055083,
        "sender_full_name": "raskyld",
        "timestamp": 1733910193
    },
    {
        "content": "<p>The way I plan to address that is by having different <code>world</code> (or <em>plugin type</em>) in the compiler:</p>\n<ol>\n<li>A pure WIT to WIT AST processors,</li>\n<li>WIT AST to Language-specific AST (LSA) processors (e.g. WIT to Go AST),</li>\n<li>LSA to LSA processors (this is where, we could specify / override the representation of a <code>resource</code> on the wire).</li>\n<li>LSA to filesystem outputters.</li>\n</ol>\n<p>So RPC vendors could release plugins (3) just to specialise the representation of advanced concepts.</p>\n<p>Ofc, that's just ideation and I will likely have to address challenges but guess I need to try first <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 488056858,
        "sender_full_name": "raskyld",
        "timestamp": 1733910749
    }
]