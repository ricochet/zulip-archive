[
    {
        "content": "<p>Hi Folks, A group of us are considering setting up an embedded / industrail special interest group. This group would focus on supporting the needs of the already deployed embedded WASM customers by providing tooling, notes and recommendations for useage. It could also, I hope would,  provide guidence and support via use case examples / user scenarios / requirements to the standardization bodies.  We're still at a very early stage of just sketching out the goals for the SIG. I'd love your thoughts on this, and if there was anything specific you feel such a SIG could provide that would help the overall community.  cc: <span class=\"user-mention\" data-user-id=\"614853\">@Ayako Akasaka</span> <span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span> <span class=\"user-mention\" data-user-id=\"513417\">@Marcin Kolny</span></p>",
        "id": 421898795,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708102128
    },
    {
        "content": "<p>Hey Chris, I think it's a great idea. There are things <em>underneath</em> wasm that require more careful thought about where and how they should fit together.</p>",
        "id": 421899408,
        "sender_full_name": "Ralph",
        "timestamp": 1708102328
    },
    {
        "content": "<p>I very much like the idea of having an embedded/industrial SIG and applaud the plans to work that out.  I can imagine there are a number of related platform, hardware, and tool chain use cases that would absolutely benefit from collaborative focus, yielding enhancements both to existing project work and the possibility of new projects coming into existence.</p>",
        "id": 421903997,
        "sender_full_name": "David Bryant",
        "timestamp": 1708103864
    },
    {
        "content": "<p>Hi Chris, I agree, this is a great idea. I've been working on a <a href=\"https://gist.github.com/sunfishcode/0b4a6f855dce99542798c6c5e835b2be\">sketch</a> of what a Wit interface for I²C, GPIO, etc. might look like, largely derived from <a href=\"https://docs.rs/embedded-hal/latest/embedded_hal/\">embedded-hal</a>. It'd be great to talk more about what a bigger picture might look like.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/sunfishcode/0b4a6f855dce99542798c6c5e835b2be\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/91f9baed8f4fc08c462d1a4de5a8c23942d45e97\\/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f6173736574732f676973742d6f672d696d6167652d3534666437646330373133652e706e67)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/sunfishcode/0b4a6f855dce99542798c6c5e835b2be\" title=\"gist:0b4a6f855dce99542798c6c5e835b2be\">gist:0b4a6f855dce99542798c6c5e835b2be</a></div><div class=\"message_embed_description\">GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 421911874,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708106481
    },
    {
        "content": "<p>Hi Dan, that's awesome, and overlaps with some of the work I've seen from academia and internally. This would be an ideal topic for the SIG.</p>",
        "id": 421923483,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708111204
    },
    {
        "content": "<p>I've now put together a simple project that uses that embedded.wit file to build a component that (in theory) blinks an LED: <a href=\"https://github.com/sunfishcode/hello-embedded\">https://github.com/sunfishcode/hello-embedded</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/sunfishcode/hello-embedded\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/ed1abd716ad6b3f8baa360c5a1075686a2614d04\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363365643866613633363662616330336565333236313532383532636235356366353038646533353266663937613462643765306134653531613833613966632f73756e66697368636f64652f68656c6c6f2d656d626564646564)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/sunfishcode/hello-embedded\" title=\"GitHub - sunfishcode/hello-embedded: Hello Embedded!\">GitHub - sunfishcode/hello-embedded: Hello Embedded!</a></div><div class=\"message_embed_description\">Hello Embedded! Contribute to sunfishcode/hello-embedded development by creating an account on GitHub.</div></div></div>",
        "id": 421961168,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708130900
    },
    {
        "content": "<p>Hi Chris, count me as interested in this group. I feel that functional safety and ahead of time compilation are my key interests.</p>\n<p>I can also contribute some experience on using preview2 modules with wasm2c or w2c2, sadly there are yet some gaps in (host) bindgen for this.</p>",
        "id": 422031298,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708192886
    },
    {
        "content": "<p>I've now added a host implementation that simulates an LED and a timer and can run the component, to the hello-embedded repo linked above.</p>",
        "id": 422032255,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708193735
    },
    {
        "content": "<p>In case anyone else would like to build it, note that it requires <a href=\"https://github.com/bytecodealliance/cargo-component/pull/231\">this fix in cargo-component</a> .</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/cargo-component/pull/231\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/069e331268bfe283b16e0d24e9ea41a345f19cd4\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646530343330303731333835363836366162613734373537626238323636653938633564363838396535363631303061343336636437323966653661636630382f62797465636f6465616c6c69616e63652f636172676f2d636f6d706f6e656e742f70756c6c2f323331)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/cargo-component/pull/231\" title=\"Add support for `std_feature` by sunfishcode · Pull Request #231 · bytecodealliance/cargo-component\">Add support for `std_feature` by sunfishcode · Pull Request #231 · bytecodealliance/cargo-component</a></div><div class=\"message_embed_description\">Add support for the std_feature flag in\n[package.metadata.component.bindings], so that cargo-component can produce no_std components.</div></div></div>",
        "id": 422032317,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708193776
    },
    {
        "content": "<p>Thank you for setting this up. <span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> <br>\nWe want to discuss </p>\n<ul>\n<li>How to reduce memory usage and processing overhead to withstand the use of embedded products, the I/F that should be there for this purpose</li>\n<li>The appropriate level of abstraction I/F for HW that takes advantage of the portability of Wasm.</li>\n</ul>\n<p>I look forward to working with you.</p>",
        "id": 422173068,
        "sender_full_name": "Ayako Akasaka",
        "timestamp": 1708326743
    },
    {
        "content": "<p>I'm interested from an industrial control protocol point-of-view (serial, gpib, lxi)! Seems like component model virtualization could lead to an interesting set of experiments on instrument control HALs and testing simulation.</p>",
        "id": 422279824,
        "sender_full_name": "Milan",
        "timestamp": 1708362963
    },
    {
        "content": "<p>This is exciting! One thing that immediately jumped out at me is the SPI pin names. I would expect controller/peripheral (COPI/CIPO) following <a href=\"https://www.oshwa.org/a-resolution-to-redefine-spi-signal-names/\">this resolution</a>. (It's also just a better name from a technical perspective than \"sub\", and is free from the weirdly sexual connotation of that word.)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://www.oshwa.org/a-resolution-to-redefine-spi-signal-names/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/b7583de879488c96369f9288f1ec797d9057e580\\/68747470733a2f2f69302e77702e636f6d2f7777772e6f736877612e6f72672f77702d636f6e74656e742f75706c6f6164732f323032332f31302f6176617461722e706e673f6669743d3430312532433430312673736c3d31)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://www.oshwa.org/a-resolution-to-redefine-spi-signal-names/\" title=\"A Resolution to Redefine SPI Signal Names\">A Resolution to Redefine SPI Signal Names</a></div><div class=\"message_embed_description\">We, the undersigned, encourage educators, engineers, designers, and community members to discontinue the use of the terms MOSI/MISO/SS and in their place use SDO/SDI/CS. New signal names: SDO &amp;#821…</div></div></div>",
        "id": 422329831,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708392643
    },
    {
        "content": "<p>I also have a design question. In <code>pwm.set-duty-cycle</code>, you have both <code>set-duty-cycle</code>/<code>max-duty-cycle</code> and <code>set-duty-cycle-fully-off</code>. Isn't the latter completely redundant? It seems to me that having both has essentially no benefits in terms of usability (it's slightly shorter at the cost of having one more function to remember and two ways to write the same code) but has the drawback that the two implementations can desync, that proxy components will have to proxy those calls too, and so on.</p>\n<p>Should we have these methods?</p>",
        "id": 422330150,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708392909
    },
    {
        "content": "<p>A perhaps less interesting, but still (to me at least) interesting question is that of <code>spi.operation.delay-ns</code>. This is undeniably very useful, and there are plenty of cases (ADCs for example) where one <em>has</em> to insert wait states for the device to work correctly. If I recall, in the Rust Embedded discussions, this operation was added because of practical necessity. I'm wondering if we should not reconsider it, namely, replace it with something more composable in the Wasm world, where we can coordinate delays between several peripherals, which does come up a lot more often than you wish it would.</p>",
        "id": 422330441,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708393192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422329831\">said</a>:</p>\n<blockquote>\n<p>This is exciting! One thing that immediately jumped out at me is the SPI pin names. I would expect controller/peripheral (COPI/CIPO) following <a href=\"https://www.oshwa.org/a-resolution-to-redefine-spi-signal-names/\">this resolution</a>. (It's also just a better name from a technical perspective than \"sub\", and is free from the weirdly sexual connotation of that word.)</p>\n</blockquote>\n<p>Main/sub is Wikipedia's current choice, but I'm happy to switch to controller/peripheral, COPI/CIPO, etc., and cite that OSHWA resolution. Thanks for that link!</p>",
        "id": 422342849,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708402737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422330150\">said</a>:</p>\n<blockquote>\n<p>I also have a design question. In <code>pwm.set-duty-cycle</code>, you have both <code>set-duty-cycle</code>/<code>max-duty-cycle</code> and <code>set-duty-cycle-fully-off</code>. Isn't the latter completely redundant? It seems to me that having both has essentially no benefits in terms of usability (it's slightly shorter at the cost of having one more function to remember and two ways to write the same code) but has the drawback that the two implementations can desync, that proxy components will have to proxy those calls too, and so on.</p>\n<p>Should we have these methods?</p>\n</blockquote>\n<p>This is a good point. These methods are provided methods in the <a href=\"https://docs.rs/embedded-hal/latest/embedded_hal/pwm/trait.SetDutyCycle.html\">embedded-hal trait</a> these are based on. If there were ever a reason to implement them differently, then it'd be valuable to have them, but looking at them more closely, that does seem pretty unlikely. So I'll remove them.</p>",
        "id": 422343299,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708402988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422330441\">said</a>:</p>\n<blockquote>\n<p>A perhaps less interesting, but still (to me at least) interesting question is that of <code>spi.operation.delay-ns</code>. This is undeniably very useful, and there are plenty of cases (ADCs for example) where one <em>has</em> to insert wait states for the device to work correctly. If I recall, in the Rust Embedded discussions, this operation was added because of practical necessity. I'm wondering if we should not reconsider it, namely, replace it with something more composable in the Wasm world, where we can coordinate delays between several peripherals, which does come up a lot more often than you wish it would.</p>\n</blockquote>\n<p>We can certainly reconsider it. The main question is, what should the interface look like?</p>",
        "id": 422343779,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708403252
    },
    {
        "content": "<p>Hey Chris - Atym would love to participate in an industrial-related SIG. We’ve built an orchestration and management solution using Wasm for constrained devices. We’re committed to standardization and it would be great to collaborate.</p>",
        "id": 422460956,
        "sender_full_name": "Stephen Berard",
        "timestamp": 1708448325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422343779\">said</a>:</p>\n<blockquote>\n<p>We can certainly reconsider it. The main question is, what should the interface look like?</p>\n</blockquote>\n<p>This is a very high-level description, but to me, the underlying problem would be solvable with an event scheduling system, where:</p>\n<ul>\n<li>you can start two concurrent processes simultaneously (e.g. toggle two GPIOs at once to make data that was inserted into shift registers previously take place--think of DACs for example)</li>\n<li>you can start a process after the end of another process, and potentially a delay between these (e.g. start readout from ADC a few micros after initiating conversion)</li>\n<li>you can start a process after the start of another process, with a delay (e.g. periodically starting readout)</li>\n<li>you can wake the CPU up at any arbitrary point that can be specified with these rules</li>\n<li>you can loop the entire thing so it continues forever</li>\n</ul>\n<p>If you look at this system at a very high level, this is basically a mini-language for a common subset of hardware acceleration for various peripherals. You could map this to what e.g. STM32's peripherals are capable of and reap the benefit of lower power consumption where you don't need to start the PLL for the main core, etc.</p>\n<p>You could also say that this is out of scope and any delays should be inserted using an async function driving these component interfaces because it's fully redundant with <code>delay</code>, in a similar way as the <code>set-duty-cycle-fully-off</code> is fully redundant. (No SPI peripheral I know of has built-in delay functionality, so the implementation of the embedded-hal trait would have to use some sort of hardware timer, shared or dedicated, which is what a normal async delay would use too. I could of course be wrong here, but this is what my experience indicates.)</p>\n<p>I think either solution would work well for embedded components. My personal API design principles suggest implementing the latter ('just write an async function') before the former ('event scheduling system').</p>\n<p>This is probably clear by now, but I'd be interested to participate in the Embedded SIG ^^</p>",
        "id": 422477141,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708453686
    },
    {
        "content": "<p>Wow - some great conversations happening already, this is pretty awesome! Thank you all. Please do keep the suggestions going. There definately does seem to be a need and a desire to tackle the problems within the embedded space. I think moving to a structured conversation with a SIG would be pretty awesome.</p>\n<p>I'll continue on with the next step in getting the SIG going, that's the paper work / git updates and start coordinating with the BCA.</p>",
        "id": 422529094,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708479178
    },
    {
        "content": "<p>I've now added a <a href=\"https://github.com/sunfishcode/hello-embedded/tree/main/linux-host\">linux-embedded-hal host</a> to the hello-embedded demo. I don't have a board to test it on, but if I wired everything up right, on a board configured for it, that should let the same guest blink an actual LED.</p>",
        "id": 422538473,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708486818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422538473\">said</a>:</p>\n<blockquote>\n<p>I've now added a <a href=\"https://github.com/sunfishcode/hello-embedded/tree/main/linux-host\">linux-embedded-hal host</a> to the hello-embedded demo. I don't have a board to test it on, but if I wired everything up right, on a board configured for it, that should let the same guest blink an actual LED.</p>\n</blockquote>\n<p>This is awsome I like the fact that it is based on the Rust embedded-hal. We can benefit from their experience in designing a portable HAL layer.</p>",
        "id": 422558539,
        "sender_full_name": "Pascal Bach",
        "timestamp": 1708500411
    },
    {
        "content": "<p>Another topic we talked before is safe reentry of wasm code by the interrupt handing.</p>",
        "id": 422565707,
        "sender_full_name": "Wang Xin",
        "timestamp": 1708503724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/421961168\">said</a>:</p>\n<blockquote>\n<p>I've now put together a simple project that uses that embedded.wit file to build a component that (in theory) blinks an LED: <a href=\"https://github.com/sunfishcode/hello-embedded\">https://github.com/sunfishcode/hello-embedded</a></p>\n</blockquote>\n<p>Pretty cool! Wondering if the plan is to do the same split rust embedded hal does between blocking traits and async ones? </p>\n<p>I think c guests are particularly relevant here, and these could be more welcoming of non-async interfaces. Android's Context Hub Runtime Environment (CHRE), might be an additional design point worth checking out: <br>\n<a href=\"https://source.android.com/docs/core/interaction/contexthub\">https://source.android.com/docs/core/interaction/contexthub</a>  </p>\n<p>The CHRE is for C/C++ but has several frameworks called Platform Abstraction Layers for stuff like sensor IO, location, audio, and more.</p>",
        "id": 422639588,
        "sender_full_name": "Nuno Pereira",
        "timestamp": 1708528429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422538473\">said</a>:</p>\n<blockquote>\n<p>I've now added a <a href=\"https://github.com/sunfishcode/hello-embedded/tree/main/linux-host\">linux-embedded-hal host</a> to the hello-embedded demo. I don't have a board to test it on, but if I wired everything up right, on a board configured for it, that should let the same guest blink an actual LED.</p>\n</blockquote>\n<p>This begs a question  I've been wanting to ask -- what hardware is a  good target for your demo  app, <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>?  I have a workbench cabinet full of various MCU boards and would love to give the app a try.  And if I don't have any suitable hardware I know where  to  get more. :-)</p>",
        "id": 422667579,
        "sender_full_name": "David Bryant",
        "timestamp": 1708535594
    },
    {
        "content": "<p>The host impl I built is based on linux-embedded-hal, which should support Raspberry Pi and similar boards.</p>",
        "id": 422668292,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708535794
    },
    {
        "content": "<p>It looks like there are embedded-hal drives for FTDI boards, and others. I haven't looked into it much yet, but the nice thing about the API being close to embedded-hal is that there is an ecosystem out there that we can directly use.</p>",
        "id": 422669304,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708536123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441103\">David Bryant</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422667579\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422538473\">said</a>:</p>\n<blockquote>\n<p>I've now added a <a href=\"https://github.com/sunfishcode/hello-embedded/tree/main/linux-host\">linux-embedded-hal host</a> to the hello-embedded demo. I don't have a board to test it on, but if I wired everything up right, on a board configured for it, that should let the same guest blink an actual LED.</p>\n</blockquote>\n<p>This begs a question  I've been wanting to ask -- what hardware is a  good target for your demo  app, <span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span>?  I have a workbench cabinet full of various MCU boards and would love to give the app a try.  And if I don't have any suitable hardware I know where  to  get more. :-)</p>\n</blockquote>\n<p>I shared some of this perspective at the last W3C in person meeting. Once we get to the devices which run Linux, the question becomes - Why WebAssembly? - Why not just a container? - and you can, if you are careful make really small containers.</p>\n<p>The sweet spot for WASM are devices which run an RTOS, and are not capable of running Linux and Containerized applications.  Roughly speaking, this is devices with 16 - maybe 8megs of RAM or less. Something like an STM32, or an ESP32.</p>\n<p>I love the discussion here already, it's very cool, and Dan's work is really interesting - the Pi is a great platform to develop with - and a fantastic starting point, but the final target hardware is likely to be considerably cheaper and hence less powerful than a Pi. </p>\n<p>This is a fantastic discussion in general for the SIG and community, what would be a realistic minimal hardware footprint to target?</p>\n<p>Edit: Type-o, I used W2C instead of W3C ... you know you've been playing with WABT for too long when... ;p</p>",
        "id": 422670977,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708536620
    },
    {
        "content": "<p>Looks like I need to pick a different host driver, to avoid my API being seen as \"The Pi is a great platform, but\" <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 422671428,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708536745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422671428\">said</a>:</p>\n<blockquote>\n<p>Looks like I need to pick a different host driver, to avoid my API being seen as \"The Pi is a great platform, but\" <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>\n</blockquote>\n<p>For speed of development and iterating through interfaces, it's totally the right platform! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 422671869,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708536887
    },
    {
        "content": "<p>Ok, this is a little more work than I'm looking to do right right now, but, there are embedded-hal implementations for <a href=\"https://crates.io/crates/esp32-hal\">ESP32</a>, <a href=\"https://crates.io/crates/stm32h7xx-hal\">STM32H7</a> and others.</p>",
        "id": 422673413,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708537422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422670977\">said</a>:</p>\n<blockquote>\n<p>The sweet spot for WASM are devices which run an RTOS, and are not capable of running Linux and Containerized applications.  Roughly speaking, this is devices with 16 - maybe 8megs of RAM or less. Something like an STM32, or an ESP32.</p>\n</blockquote>\n<p>What about that same class of hardware but with no OS whatsoever?</p>\n<p>And +1 to being fine developing and iterating on  the Pi, especially in terms  of engaging lots of developers.</p>",
        "id": 422673917,
        "sender_full_name": "David Bryant",
        "timestamp": 1708537630
    },
    {
        "content": "<p>Dear <span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> do not get me started on the usage of containers, pretty much anywhere intending to pretend either portability or security. But they're useful, they sure are.</p>",
        "id": 422675977,
        "sender_full_name": "Ralph",
        "timestamp": 1708538346
    },
    {
        "content": "<p>This, however, <span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span>, is a critical point to get clear on: \"This is a fantastic discussion in general for the SIG and community, what would be a realistic minimal hardware footprint to target?\"</p>",
        "id": 422676105,
        "sender_full_name": "Ralph",
        "timestamp": 1708538403
    },
    {
        "content": "<p>once the resource constraints of a device become limiting even to wasm, then those things will remain \"artisanal\" or native targets. Wasm brings some security and radical portability (containers, why bother in truly constrained environments?), but scenarios that do NOT benefit from those features are not likely targets for wasm. So your question is the first correct one I think: <em>where is the standard hardware/OS boundary underneath which it makes no sense to use wasm/components?</em></p>",
        "id": 422676584,
        "sender_full_name": "Ralph",
        "timestamp": 1708538561
    },
    {
        "content": "<p>and everyone will likely differ, but that conversation will tend to clarify which features do and do not have persuasive power with someone, and clarity is always good.....</p>",
        "id": 422681170,
        "sender_full_name": "Ralph",
        "timestamp": 1708540353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"441103\">David Bryant</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422673917\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422670977\">said</a>:</p>\n<blockquote>\n<p>The sweet spot for WASM are devices which run an RTOS, and are not capable of running Linux and Containerized applications.  Roughly speaking, this is devices with 16 - maybe 8megs of RAM or less. Something like an STM32, or an ESP32.</p>\n</blockquote>\n<p>What about that same class of hardware but with no OS whatsoever?</p>\n<p>And +1 to being fine developing and iterating on  the Pi, especially in terms  of engaging lots of developers.</p>\n</blockquote>\n<p>Yup, totally viable too; you don't need an RTOS, it is conceivable, that someone in the future produces a very thin layer, a BSP that get's a minimal runtime executing, that is very true. It's guess that that layer will start \"thick\" with an RTOS, but will migrate to something much thinner; much in the same way we've seen unikernels develop.</p>",
        "id": 422704791,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708549529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422343299\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422330150\">said</a>:</p>\n<blockquote>\n<p>Should we have these methods?</p>\n</blockquote>\n<p>This is a good point. These methods are provided methods in the <a href=\"https://docs.rs/embedded-hal/latest/embedded_hal/pwm/trait.SetDutyCycle.html\">embedded-hal trait</a> these are based on. If there were ever a reason to implement them differently, then it'd be valuable to have them, but looking at them more closely, that does seem pretty unlikely. So I'll remove them.</p>\n</blockquote>\n<p>I will need to look up the details but I recall from either the embassy or embedded WG matrix that a fraction can't represent all hardware states and thus the second one was added, dirbaio will know the details as he made the change.</p>\n<p>Also please dare to dream small, arduino might already be large enough to do wasm aot compilation on chip, an interpreter will surely fit.</p>",
        "id": 422714877,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708554450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268586\">@Ralph</span> Thinking about the smallest scenario in which the benefits of WASM make sense is a great idea and I’m happy to share some thinking and some research here, and I mean this as a way to provoke discussion and debate – I hope everyone can chip in your own view too.</p>\n<p>There are perhaps three key things, to think about with regard to the smallest possible target, these are:</p>\n<ol>\n<li>Defining a viable minimal set of functionality. By this I mean to leverage the benefit of portability, isolated execution and security, we'd need some way of remotely deploying and managing the life cycle of a WASM element – this at the very least implies some form of networking stack. (Others may not need the remote life cycle management and we could reduce the platform further removing connectivity and life cycle from the software footprint. – and this would be a good point to discuss too)</li>\n<li>The 64kb WASM page size, sets an effective limit. The smallest WASM enabled application is going to need 64kb of RAM for linear memory, additional ram for the function table, bytecode, runtime state, stack pointers, and runtime code, plus whatever RTOS or elements we have today to provide threading, heap and peripheral management. This gives a minimal executable WASM application. (As Keith pointed out, using WASM2C and dropping the effective size of runtime down to something smaller allows us to go a little further.)</li>\n<li>Today's compilers introduce another set of limitations. The default smallest page allocation for Zig and Rust appears to be 1meg or 16 WASM pages. For C it's 2 pages, or 128kb. I know we can change these defaults and lower them, but it is something to be aware of.</li>\n</ol>",
        "id": 422715292,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708554635
    },
    {
        "content": "<p>We've done some experiments and a device with 340kb of RAM was a really viable target. Anything smaller than that became difficult to use. This experiment was done with 'c' based WASM applications with their lifecycle remotely controlled.</p>",
        "id": 422715311,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708554651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span>  - \"Dare to dream small\" <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 422715537,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708554762
    },
    {
        "content": "<p>Pardon the pun of \"chip\" in your own view, when talking about embedded solutions... I need a coffee <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 422715732,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708554855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422715292\">said</a>:</p>\n<blockquote>\n<p>The smallest WASM enabled application is going to need 64kb of RAM for linear memory, additional ram for the function table, bytecode, runtime state, stack pointers, and runtime code, ...</p>\n</blockquote>\n<p>On the tiniest of hardware and with special compiler support, a program could use globals instead of linear memory. That doesn't change points 1 and 3, of course: less than 64kb user memory would be enough for a blinking lights demo, but I don't know about real use-cases.</p>",
        "id": 422718283,
        "sender_full_name": "IFcoltransG",
        "timestamp": 1708556358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"570431\">@IFcoltransG</span>  Ohh.. now there is a thought, no linear memory.... interesting... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n<p>But speaking of special compiler support, we didn't mention using  some form of AoT compiled WASM with a runtime....</p>",
        "id": 422719039,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708556725
    },
    {
        "content": "<p>I think it's pretty likely that we could get the Wasm CG to accept a proposal for &lt;64KiB page sizes.</p>",
        "id": 422719270,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708556878
    },
    {
        "content": "<p>That's a cool idea...</p>",
        "id": 422719584,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708557068
    },
    {
        "content": "<p>I found the paper: <a href=\"https://dl.acm.org/doi/10.1145/3498361.3538922\">https://dl.acm.org/doi/10.1145/3498361.3538922</a> or <a href=\"https://github.com/liborui/WAIT\">https://github.com/liborui/WAIT</a> claims an 4kb RAM and 128kb flash ATmega enough for simple on-chip AoT compilations. This for sure is an extreme.</p>\n<p><a href=\"https://github.com/TOPLLab/WARDuino\">https://github.com/TOPLLab/WARDuino</a> mentions the 64k wasm page size lower limit.</p>\n<p>When I said small, I had really tiny CPUs in mind, loosely remembering above paper.</p>\n<p>Given enough backing a &lt;64k page size standard would be possible and an extension of the relocation convention at <br>\n<a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md#processing-relocations\">https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md#processing-relocations</a> could permit separating read-only data sections into ROM by introducing a special relocation base (probably weakening insulation).</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://dl.acm.org/doi/10.1145/3498361.3538922\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/d523dc68e83c029bf779a5febd410a2096d75f43\\/68747470733a2f2f646c2e61636d2e6f72672f636d732f61737365742f36333535356239322d376330382d346439322d616538632d6535306365303633313535322f333439383336312e636f7665722e6a7067)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://dl.acm.org/doi/10.1145/3498361.3538922\" title=\"Bringing webassembly to resource-constrained iot devices for seamless device-cloud integration | Proceedings of the 20th Annual International Conference on Mobile Systems, Applications and Services\">Bringing webassembly to resource-constrained iot devices for seamless device-cloud integration | Proceedings of the 20th Annual International Conference on Mobile Systems, Applications and Services</a></div><div class=\"message_embed_description\">Zhejiang University, and Alibaba-Zhejiang University Joint Institute of Frontier Technologies, China</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/liborui/WAIT\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/2420dee4b08e4e0559afd9d40635124fe0c503df\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353134386235313263373766646664663430306335386533356334346539383638333733376633373036306533623634646333656132626638323464313134652f6c69626f7275692f57414954)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/liborui/WAIT\" title=\"GitHub - liborui/WAIT\">GitHub - liborui/WAIT</a></div><div class=\"message_embed_description\">Contribute to liborui/WAIT development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/TOPLLab/WARDuino\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/fb9205adbab1a4ed3ed404ef9b81238efa3b0cba\\/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3231333337383233352f38326163326438302d363230322d313165612d386663332d643934363639306232616364)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/TOPLLab/WARDuino\" title=\"GitHub - TOPLLab/WARDuino: A dynamic WebAssembly VM for embedded systems\">GitHub - TOPLLab/WARDuino: A dynamic WebAssembly VM for embedded systems</a></div><div class=\"message_embed_description\">A dynamic WebAssembly VM for embedded systems. Contribute to TOPLLab/WARDuino development by creating an account on GitHub.</div></div></div>",
        "id": 422719745,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708557213
    },
    {
        "content": "<p>Wow - great find. I've got some homework / reading to do.</p>",
        "id": 422719878,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708557289
    },
    {
        "content": "<p><a href=\"https://github.com/gwsystems/aWsm?tab=readme-ov-file#advice-for-wasm-standardization\">https://github.com/gwsystems/aWsm?tab=readme-ov-file#advice-for-wasm-standardization</a> contains similar recommendations for embedded wasm runtimes (page size, read only memory, out of bounds trap guarantees)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/gwsystems/aWsm?tab=readme-ov-file#advice-for-wasm-standardization\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/d33beb598cda35d652c4ddffba11c2053c1e27a0\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636263306565646132386337343564633761613663356433386533626137646632656563616361636366613838373061353933346562306630353262643638612f677773797374656d732f6157736d)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/gwsystems/aWsm?tab=readme-ov-file#advice-for-wasm-standardization\" title=\"GitHub - gwsystems/aWsm: WebAssembly ahead-of-time compiler and runtime. Focuses on generating fast code, simplicity, and portability.\">GitHub - gwsystems/aWsm: WebAssembly ahead-of-time compiler and runtime. Focuses on generating fast code, simplicity, and portability.</a></div><div class=\"message_embed_description\">WebAssembly ahead-of-time compiler and runtime. Focuses on generating fast code, simplicity, and portability. - gwsystems/aWsm</div></div></div>",
        "id": 422721408,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708558282
    },
    {
        "content": "<p>Looking at those recommendations, I'd guess that page sizes and read only memory are doable if we design them carefully. However, I expect \"undefined behavior on Out of Bounds\" would face a lot of pressure to find alternative solutions.</p>",
        "id": 422722077,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708558728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"693438\">Nuno Pereira</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422639588\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/421961168\">said</a>:</p>\n<blockquote>\n<p>I've now put together a simple project that uses that embedded.wit file to build a component that (in theory) blinks an LED: <a href=\"https://github.com/sunfishcode/hello-embedded\">https://github.com/sunfishcode/hello-embedded</a></p>\n</blockquote>\n<p>Pretty cool! Wondering if the plan is to do the same split rust embedded hal does between blocking traits and async ones? </p>\n<p>I think c guests are particularly relevant here, and these could be more welcoming of non-async interfaces. Android's Context Hub Runtime Environment (CHRE), might be an additional design point worth checking out: <br>\n<a href=\"https://source.android.com/docs/core/interaction/contexthub\">https://source.android.com/docs/core/interaction/contexthub</a>  </p>\n<p>The CHRE is for C/C++ but has several frameworks called Platform Abstraction Layers for stuff like sensor IO, location, audio, and more.</p>\n</blockquote>\n<p>You might want to check out this regarding Wasm for CHRE:<br>\n<a href=\"https://wasmcon2023.sched.com/event/1PmEw/develop-the-android-context-hub-runtime-environment-chre-nanoapps-in-webassembly-mingqiu-sun-intel\">https://wasmcon2023.sched.com/event/1PmEw/develop-the-android-context-hub-runtime-environment-chre-nanoapps-in-webassembly-mingqiu-sun-intel</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://wasmcon2023.sched.com/event/1PmEw/develop-the-android-context-hub-runtime-environment-chre-nanoapps-in-webassembly-mingqiu-sun-intel\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/16c5adcd6f1c763487399abd9c8eb209efa1a378\\/68747470733a2f2f7761736d636f6e323032332e73636865642e636f6d2f696d672f6170702d69636f6e2e706e673f31373038353539393039)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://wasmcon2023.sched.com/event/1PmEw/develop-the-android-context-hub-runtime-environment-chre-nanoapps-in-webassembly-mingqiu-sun-intel\" title=\"WasmCon 2023: Develop the Android Context Hub Runtime...\">WasmCon 2023: Develop the Android Context Hub Runtime...</a></div><div class=\"message_embed_description\">View more about this event at WasmCon 2023</div></div></div>",
        "id": 422723601,
        "sender_full_name": "Wang Xin",
        "timestamp": 1708559888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422714877\">said</a>:</p>\n<blockquote>\n<p>I will need to look up the details but I recall from either the embassy or embedded WG matrix that a fraction can't represent all hardware states and thus the second one was added, dirbaio will know the details as he made the change.</p>\n</blockquote>\n<p>I just recall the <code>fully-on</code> is not necessarily the same as 100% and <code>fully-off</code> not identical with 0%, so all three might be necessary. Some hardware still gives small spikes at minimum and maximum width, so these special functions decouple the pin from from the pwm/timer to drive constant level output.</p>",
        "id": 422723826,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708560055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"693438\">Nuno Pereira</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422639588\">said</a>:</p>\n<blockquote>\n<p>Pretty cool! Wondering if the plan is to do the same split rust embedded hal does between blocking traits and async ones? </p>\n</blockquote>\n<p>I currently have both sync and async inteteraces; embedded.wit has the sync interfaces and async.wit has the async ones: <a href=\"https://github.com/sunfishcode/hello-embedded/tree/main/wit\">https://github.com/sunfishcode/hello-embedded/tree/main/wit</a></p>\n<blockquote>\n<p>The CHRE is for C/C++ but has several frameworks called Platform Abstraction Layers for stuff like sensor IO, location, audio, and more.</p>\n</blockquote>\n<p>I myself am hoping to focus on just the embedded-hal featureset for now, because it's pretty small and simple. But if someone else wants to look into what the SIG might do in the space of sensors, location, audio, etc., that'd be cool.</p>",
        "id": 422726466,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708561779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422722077\">said</a>:</p>\n<blockquote>\n<p>Looking at those recommendations, I'd guess that page sizes and read only memory are doable if we design them carefully. However, I expect \"undefined behavior on Out of Bounds\" would face a lot of pressure to find alternative solutions.</p>\n</blockquote>\n<p>I re-checked the paper for what exactly they proposed and it is masking addresses instead of comparing to the current bound. So oob addresses will wrap into the sandbox instead of trapping. This maintains the integrity of the sandbox but not trapping isn't spec compliant.</p>",
        "id": 422759734,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708586135
    },
    {
        "content": "<p>I wake up to wonderful things! Lots of reading to do, which means a great day. :-)</p>",
        "id": 422761115,
        "sender_full_name": "Ralph",
        "timestamp": 1708586939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422723826\">said</a>:</p>\n<blockquote>\n<p>I just recall the <code>fully-on</code> is not necessarily the same as 100% and <code>fully-off</code> not identical with 0%, so all three might be necessary. Some hardware still gives small spikes at minimum and maximum width, so these special functions decouple the pin from from the pwm/timer to drive constant level output.</p>\n</blockquote>\n<p>What if we fixed this by saying that on hardware that does that, <code>set-duty-cycle(0)</code> must be special-cased in the host to turn the power fully off? And similarly for <code>set-duty-cycle(max-duty-cycle())</code> .</p>",
        "id": 422848992,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708617498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268586\">Ralph</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422676584\">said</a>:</p>\n<blockquote>\n<p>[...] Wasm brings some security and radical portability (containers, why bother in truly constrained environments?), but scenarios that do NOT benefit from those features are not likely targets for wasm.</p>\n</blockquote>\n<p>In addition to security and portability, I'd encourage us to keep in mind a third reason: toolchains. Even when people don't need Wasm's style of security or portability, they may want to use the same tools that they use when they do need those things.</p>",
        "id": 422859550,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708620431
    },
    {
        "content": "<p>that argument is likely to be less persuasive than it at first might appear. Most businesses do not make money ensuring that their customers can use the wasm-friendly tool chains. Either they can, or they can't -- in either case, typically a business wouldn't care. if they're using Zork language now, and in the future Zork also supports components, for example, that's great, but in the specific scenario where wasm doesn't help, it's a no-op: they'll just keep using Zork native.</p>",
        "id": 422860462,
        "sender_full_name": "Ralph",
        "timestamp": 1708620709
    },
    {
        "content": "<p>is that what you meant? It's how I parsed it......</p>",
        "id": 422860493,
        "sender_full_name": "Ralph",
        "timestamp": 1708620718
    },
    {
        "content": "<p>I'm expecting there will be a fuzzy and evolving boundary between wasm making sense and not. Sometimes it clearly will, sometimes it clearly won't (8-bit MCUs say hi). But sometimes, if a device can run Wasm, but you don't need the security or portability, you may still use Wasm, for the toolchains.</p>",
        "id": 422861216,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708620956
    },
    {
        "content": "<p>Just for clarity on the container comments. It is not a comparison of technical merit. It is just the reality of dealing with an incumbent technical solution, which, today, for larger devices containers are seen as good enough.</p>\n<p>There is always a cost of adopting a new technical solution. That cost is offset by a lower bill of materials (BoM). This is an opportunity for WASM, but also an effective limitation. </p>\n<p>If embedded WASM’s required bill of materials is so high that I can use a container, then WASM as a solution will struggle to get the traction it may technically deserve. </p>\n<p>As the cost of adoption drops, this equation will change, but at least, initially, it’s something to be cognizant of.</p>",
        "id": 422862221,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708621227
    },
    {
        "content": "<p>opportunity cost is real.</p>",
        "id": 422862342,
        "sender_full_name": "Ralph",
        "timestamp": 1708621260
    },
    {
        "content": "<p>I really like to test wasm binaries/components locally on my favorite PC environment before deploying them to embedded (or cloud). In the case of multiple CPU targets this gets more and more attractive, even if I convert them back to native before flashing to a specific device. Wasm is so much more portable than source code <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 422862751,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708621367
    },
    {
        "content": "<p>Its also incredibly difficult to reproduce embedded environments on workstations; just being able to reliably virtualize at that level would be a huge win for testing and rapid iteration</p>",
        "id": 422863717,
        "sender_full_name": "Lann Martin",
        "timestamp": 1708621641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422723826\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422714877\">said</a>:</p>\n<blockquote>\n<p>I will need to look up the details but I recall from either the embassy or embedded WG matrix that a fraction can't represent all hardware states and thus the second one was added, dirbaio will know the details as he made the change.</p>\n</blockquote>\n<p>I just recall the <code>fully-on</code> is not necessarily the same as 100% and <code>fully-off</code> not identical with 0%, so all three might be necessary. Some hardware still gives small spikes at minimum and maximum width, so these special functions decouple the pin from from the pwm/timer to drive constant level output.</p>\n</blockquote>\n<p>But what happens if you read the duty after setting it to fully-on? Does it exceed the stated max duty? This seems like a bad idea to entrench in the API design to me.</p>",
        "id": 422923589,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708645238
    },
    {
        "content": "<p>cargo-component 0.8 is now released, so the hello-component demo no longer needs a custom build!</p>",
        "id": 422927372,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708647464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/422923589\">said</a>:</p>\n<blockquote>\n<p>But what happens if you read the duty after setting it to fully-on? Does it exceed the stated max duty? This seems like a bad idea to entrench in the API design to me.</p>\n</blockquote>\n<p>I asked on <a href=\"https://matrix.to/#/!BHcierreUuwCMxVqOf:matrix.org/$_L916rubYL22T6FHzcQ8_hMFSH-h3PoA7a5HCdrL-EQ?via=matrix.org&amp;via=catircservices.org&amp;via=tchncs.de\">rust embedded matrix</a> and received confirmation that now these functions have become a special case of set_duty_cycle. So I was remembering an older design limitation which was worked around by extending the duty cycle domain to one higher than the hardware limit.</p>\n<p>So it is confirmed that fully is no longer needed.</p>",
        "id": 422957818,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708670275
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span>!</p>",
        "id": 423087209,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708719070
    },
    {
        "content": "<p><strong>Draft Proposal Looking for Feedback</strong><br>\nHappy Friday folks. The paperwork for requesting the SIG is underway! - As mentioned on the last WASI call I've been working on an initial draft proposal text for the Embedded SIG. I've put it up on GitHub here for everyone to review. Please do take a look, comment, correct me, and / or improve.  I did try to include our discussion on defining the small footprint devices we'd try to support, as I think from our discussion here that it provides an important scope setting criteria for the SIG.</p>\n<p><a href=\"https://github.com/woodsmc/bca_governance/blob/SIG_Embedded/SIGs/SIG-embedded/proposal.md\">https://github.com/woodsmc/bca_governance/blob/SIG_Embedded/SIGs/SIG-embedded/proposal.md</a></p>\n<p><strong>Call for Support</strong><br>\nTo create the SIG, we need to ask for your support, if you are interested in expressing your support please do let me know, I'd be delighted to add a name to the list.</p>\n<p><strong>Call for Co-Chairs?</strong><br>\nI know we've a lot of embedded contributions from all over the globe and in the proposal text, you'll see I'll suggested that the SIG have a rotating meeting schedule, between Europe, Asia and the Americas. This is just an idea, and we'd need to run it past the TSC of course, but to make it work, we'd ideally need to have volunteers to help co-chair from each of the geographical regions, do you think this is a good idea? Would you like to volunteer to help?</p>",
        "id": 423098616,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708724287
    },
    {
        "content": "<blockquote>\n<p>The group may provide notes and guides to the embedded community on how to address the specific constraints the ecosystem, this may complement the tooling available from the Bytecode Alliance.</p>\n</blockquote>\n<p>Hi Chris, overall this looks great! Could you clarify what \"this may complement the tooling available from the Bytecode Alliance\" means here? I think I kind of get what it's saying there, but it feels like it'd be good to clarify.</p>",
        "id": 423108262,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708729403
    },
    {
        "content": "<p>Hi Dan. Thanks for the quick turn around and the feedback. Love it. </p>\n<p>The embedded world can be quite fragmented, and I was imagining a situation in which the group <strong>may</strong> need in the future to provide something specific for a board, or a platform. Depending on what it was, of course, it may not be something we support long term - but something that may help a partner get WASM / WASI up and running on their particular platform. I could envisage a bunch of scenarios like this which might occur.  So its, not a core tool, but a complementary tool.... practically, that's what I was thinking about.</p>\n<p>By complementary, I mean perhaps peripheral too and aligned with the general direction we're all heading in.</p>\n<p>I'm happy to word-smith that better, or be more specific too. Is there a specific concern, a way I can phrase that a little better?</p>",
        "id": 423109119,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708730019
    },
    {
        "content": "<p>The sentence starts off talking about notes and guidance. If it's about building tools, perhaps that part should be part of sentence 5, which is about providing software?</p>",
        "id": 423111252,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708731537
    },
    {
        "content": "<p>That makes sense. I'll make the change. Thanks Dan.</p>",
        "id": 423125649,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708743785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423098616\">said</a>:</p>\n<blockquote>\n<p><strong>Draft Proposal Looking for Feedback</strong><br>\nHappy Friday folks. The paperwork for requesting the SIG is underway! - As mentioned on the last WASI call I've been working on an initial draft proposal text for the Embedded SIG. I've put it up on GitHub here for everyone to review. Please do take a look, comment, correct me, and / or improve.  I did try to include our discussion on defining the small footprint devices we'd try to support, as I think from our discussion here that it provides an important scope setting criteria for the SIG.</p>\n<p><a href=\"https://github.com/woodsmc/bca_governance/blob/SIG_Embedded/SIGs/SIG-embedded/proposal.md\">https://github.com/woodsmc/bca_governance/blob/SIG_Embedded/SIGs/SIG-embedded/proposal.md</a></p>\n<p><strong>Call for Support</strong><br>\nTo create the SIG, we need to ask for your support, if you are interested in expressing your support please do let me know, I'd be delighted to add a name to the list.</p>\n<p><strong>Call for Co-Chairs?</strong><br>\nI know we've a lot of embedded contributions from all over the globe and in the proposal text, you'll see I'll suggested that the SIG have a rotating meeting schedule, between Europe, Asia and the Americas. This is just an idea, and we'd need to run it past the TSC of course, but to make it work, we'd ideally need to have volunteers to help co-chair from each of the geographical regions, do you think this is a good idea? Would you like to volunteer to help?</p>\n</blockquote>\n<p>Thx Chris. Looks good.<br>\nI'd like to add my support where needed, especially looking at the Co-Chair question, I can offer my participation for Europe.</p>",
        "id": 423152269,
        "sender_full_name": "Dominik Tacke",
        "timestamp": 1708765626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"693032\">Dominik Tacke</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423152269\">said</a>:</p>\n<blockquote>\n<p>Thx Chris. Looks good.<br>\nI'd like to add my support where needed, especially looking at the Co-Chair question, I can offer my participation for Europe.</p>\n</blockquote>\n<p>Hello Dominik <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span>, feel free to count me in for Europe activities. With already (co-)leading a Rust group at SAE and AUTOSAR I need to limit additional responsibilities, but wasm is dear to my heart.</p>",
        "id": 423153370,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708766650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span>  awesome, does that mean I can put you down as a supporter? ;p</p>",
        "id": 423168768,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708780416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>  - Just got the text updated.</p>",
        "id": 423168857,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708780491
    },
    {
        "content": "<p>you people</p>",
        "id": 423168861,
        "sender_full_name": "Ralph",
        "timestamp": 1708780496
    },
    {
        "content": "<p>I'm not looking at this until Monday</p>",
        "id": 423168869,
        "sender_full_name": "Ralph",
        "timestamp": 1708780503
    },
    {
        "content": "<p>but <em>lllloooooovvvvveeee</em> it</p>",
        "id": 423168879,
        "sender_full_name": "Ralph",
        "timestamp": 1708780510
    },
    {
        "content": "<p>Have a great weekend <span class=\"user-mention\" data-user-id=\"268586\">@Ralph</span> . Just  aheads up, I'm flying to Germany on Sunday and will be at an internal work conference next week. Will be checking in here, but there will be involuntary periods of disconnection, and response times will be more within the European timezone... albeit with jet lag...</p>",
        "id": 423169400,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708780967
    },
    {
        "content": "<p>I'm already in Europe, so no sympathy here buddy</p>",
        "id": 423170146,
        "sender_full_name": "Ralph",
        "timestamp": 1708781532
    },
    {
        "content": "<p>(enough tz dances for a lifetime)</p>",
        "id": 423170209,
        "sender_full_name": "Ralph",
        "timestamp": 1708781585
    },
    {
        "content": "<p>Fly safe!</p>",
        "id": 423170216,
        "sender_full_name": "Ralph",
        "timestamp": 1708781590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/421961168\">said</a>:</p>\n<blockquote>\n<p>I've now put together a simple project that uses that embedded.wit file to build a component that (in theory) blinks an LED: <a href=\"https://github.com/sunfishcode/hello-embedded\">https://github.com/sunfishcode/hello-embedded</a></p>\n</blockquote>\n<p>Hi Dan, I just wanted to say thanks for the amazing repo! Using your <code>embedded.wit</code> as an API, I was able to successfully control an LCD screen I connected to my Raspberry Pi via I2C. (<a href=\"https://github.com/Zelzahn/i2c-wasm-components\">code</a>)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Zelzahn/i2c-wasm-components\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/4c07d1c9d064aa9af1990c3b1272a22ac7cdea18\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356539643666303635653862616662396262393761633564373938353066646166303433393061383162626666366666343839363836386131306465643636632f5a656c7a61686e2f6932632d7761736d2d636f6d706f6e656e7473)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Zelzahn/i2c-wasm-components\" title=\"GitHub - Zelzahn/i2c-wasm-components: A proof of conecpt for using WebAssembly together with I2C\">GitHub - Zelzahn/i2c-wasm-components: A proof of conecpt for using WebAssembly together with I2C</a></div><div class=\"message_embed_description\">A proof of conecpt for using WebAssembly together with I2C - Zelzahn/i2c-wasm-components</div></div></div>",
        "id": 423175502,
        "sender_full_name": "Friedrich Vandenberghe",
        "timestamp": 1708785485
    },
    {
        "content": "<p>I'd like to express my support for the Embedded SIG.</p>",
        "id": 423247152,
        "sender_full_name": "Catherine (whitequark)",
        "timestamp": 1708852325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423168768\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span>  awesome, does that mean I can put you down as a supporter? ;p</p>\n</blockquote>\n<p>Yes, please. But please skip me when looking for a European chair.</p>\n<p>PS: I prepared more of my WIT without wasm (sic) prototype, you can find it at &lt;<a href=\"https://github.com/cpetig/wit-bindgen/tree/wasm64/crates/cpp/tests/native_strings\">https://github.com/cpetig/wit-bindgen/tree/wasm64/crates/cpp/tests/native_strings</a>&gt; and it leverages Dan's recent wasm-tools work to enable 64 bit compatible code generation. I plan to create a w2c2 based wasm embedded and AoT variant of this example using the identical plugin ABI later.</p>",
        "id": 423297058,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708900260
    },
    {
        "content": "<p>PPS: A rust based example (guest and host side) is planed afterwards. Feedback and help (modifying the Rust codegen macros) is welcome.</p>",
        "id": 423297258,
        "sender_full_name": "Christof Petig",
        "timestamp": 1708900453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684890\">Catherine (whitequark)</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423247152\">said</a>:</p>\n<blockquote>\n<p>I'd like to express my support for the Embedded SIG.</p>\n</blockquote>\n<p>Awesome <span class=\"user-mention\" data-user-id=\"684890\">@Catherine (whitequark)</span>  - I've added your name to the list of supporters, thank you!</p>",
        "id": 423344647,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708936162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268586\">Ralph</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423170209\">said</a>:</p>\n<blockquote>\n<p>(enough tz dances for a lifetime)</p>\n</blockquote>\n<p>Living off the caffine.. :-p</p>",
        "id": 423344793,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708936213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661362\">Friedrich Vandenberghe</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423175502\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/421961168\">said</a>:</p>\n<blockquote>\n<p>I've now put together a simple project that uses that embedded.wit file to build a component that (in theory) blinks an LED: <a href=\"https://github.com/sunfishcode/hello-embedded\">https://github.com/sunfishcode/hello-embedded</a></p>\n</blockquote>\n<p>Hi Dan, I just wanted to say thanks for the amazing repo! Using your <code>embedded.wit</code> as an API, I was able to successfully control an LCD screen I connected to my Raspberry Pi via I2C. (<a href=\"https://github.com/Zelzahn/i2c-wasm-components\">code</a>)</p>\n</blockquote>\n<p>That's  really cool. Just checking  out the repository now.</p>",
        "id": 423344888,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708936259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423098616\">said</a>:</p>\n<blockquote>\n<p><strong>Draft Proposal Looking for Feedback</strong><br>\n...<br>\n<strong>Call for Support</strong><br>\nTo create the SIG, we need to ask for your support, if you are interested in expressing your support please do let me know, I'd be delighted to add a name to the list.<br>\n...</p>\n</blockquote>\n<p>I would also like to express my support for the Embedded SIG.</p>",
        "id": 423383032,
        "sender_full_name": "Nuno Pereira",
        "timestamp": 1708949531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"693438\">Nuno Pereira</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423383032\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423098616\">said</a>:</p>\n<blockquote>\n<p><strong>Draft Proposal Looking for Feedback</strong><br>\n...<br>\n<strong>Call for Support</strong><br>\nTo create the SIG, we need to ask for your support, if you are interested in expressing your support please do let me know, I'd be delighted to add a name to the list.<br>\n...</p>\n</blockquote>\n<p>I would also like to express my support for the Embedded SIG.</p>\n</blockquote>\n<p>Thanks Nuno! I've added you to the page!</p>",
        "id": 423403807,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708956725
    },
    {
        "content": "<p>Wait, I wanna join the list! Has that happened?</p>",
        "id": 423404065,
        "sender_full_name": "Ralph",
        "timestamp": 1708956794
    },
    {
        "content": "<p>Thanks Ralph! - You're on the list!</p>",
        "id": 423405131,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708957124
    },
    {
        "content": "<p>Hi Chris, can I join the list too?</p>",
        "id": 423405209,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708957147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661362\">Friedrich Vandenberghe</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423175502\">said</a>:</p>\n<blockquote>\n<p>Hi Dan, I just wanted to say thanks for the amazing repo! Using your <code>embedded.wit</code> as an API, I was able to successfully control an LCD screen I connected to my Raspberry Pi via I2C. (<a href=\"https://github.com/Zelzahn/i2c-wasm-components\">code</a>)</p>\n</blockquote>\n<p>Very cool! I hadn't tested the I2C interface yet; it's fun seeing things go from \"this should theoretically work\" to \"it actually works\" <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 423405592,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1708957261
    },
    {
        "content": "<p>\"first try\"</p>",
        "id": 423405702,
        "sender_full_name": "Ralph",
        "timestamp": 1708957297
    },
    {
        "content": "<p>Thanks Dan, and thanks for the working first time \"sketch\", I spent this morning, rather Jet lagging chatting about it with colleagues. Really cool stuff!</p>",
        "id": 423406201,
        "sender_full_name": "Chris Woods",
        "timestamp": 1708957436
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> for putting together the draft for the Embedded SIG.  I'd like to express my support for the Embedded SIG.</p>\n<p>Overall, your document looks good to me.  Thank you for all your efforts here.</p>",
        "id": 423430946,
        "sender_full_name": "Stephen Berard",
        "timestamp": 1708964064
    },
    {
        "content": "<p>Thanks Stephen! Awesome, I've added your support to the document.</p>",
        "id": 423542370,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709016447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423109119\">said</a>:</p>\n<blockquote>\n<p>By complementary, I mean perhaps peripheral too and aligned with the general direction we're all heading in.</p>\n<p>I'm happy to word-smith that better, or be more specific too. Is there a specific concern, a way I can phrase that a little better?</p>\n</blockquote>\n<p>Reading it again, \"may complement the tooling available from the BA\" still feels a little unclear. What would you think of having the bullet point say something like this:</p>\n<blockquote>\n<p>The group may provide software to support embedded use cases including proof of concept implementations, producer tools, or proposed solutions, which may be specialized for specific use cases.</p>\n</blockquote>",
        "id": 423617111,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709043896
    },
    {
        "content": "<p>Hey everyone! This is a great initiative! Please keep me in the loop! I'm happy to support the SIG. Should I create a PR or just let you add me?</p>\n<p>We're super interested in Wasm for embedded devices, both on microcontrollers and embedded Linux devices. <span class=\"user-mention\" data-user-id=\"661362\">@Friedrich Vandenberghe</span> is working on I2C support, and <span class=\"user-mention\" data-user-id=\"659125\">@Wouter Hennen</span> and <span class=\"user-mention\" data-user-id=\"657912\">@Warre Dujardin</span>  are working on USB support.</p>\n<p>One of the things that I think we will need to ensure capability-based security in the long term is the possibility to add additional metadata to components that describe not only what interfaces they use, but also what devices they support behind that interface. For example, a component might support a USB camera of a certain type, but it should not have access to other USB devices. Once that metadata is in place and indexable in warg, we could have a runtime that automatically loads drivers for connected hardware devices. For more info, see <a href=\"https://www.youtube.com/watch?v=TSFHUiNxFqE&amp;list=PLTxJmWeyp02CbDpQ4aLPVNBSfyoB_uYtC&amp;index=7\">YouTube - Wasm Research Day 2023 – Merlijn Sebrechts</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"TSFHUiNxFqE\" href=\"https://www.youtube.com/watch?v=TSFHUiNxFqE&amp;list=PLTxJmWeyp02CbDpQ4aLPVNBSfyoB_uYtC&amp;index=7\"><img src=\"https://uploads.zulipusercontent.net/3b0c5ce289cda503fd93effa4ccf2c59cb1f8252/68747470733a2f2f692e7974696d672e636f6d2f76692f5453464855694e784671452f64656661756c742e6a7067\"></a></div>",
        "id": 423651011,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709051867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> Hope I'm not late to the party! I'd like to participate as a supporting member on the Embedded and Industrial Applications SIG as Milan Raj (National Instruments) @rajsite</p>",
        "id": 423718244,
        "sender_full_name": "Milan",
        "timestamp": 1709077170
    },
    {
        "content": "<p>Welcome!</p>",
        "id": 423725978,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709081070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"639836\">@Merlijn Sebrechts</span> How fine-grained are you imagining the USB device access control being? More like \"this component shall access specific deviceIds/vendorIds/serialNumbers/etc.\", or more like \"this component shall only access digital cameras and not other kinds of devices\"?</p>",
        "id": 423726870,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709081372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> Hey Chris, I'd like to be a support member on this SIG as Qi Huang (Xiaomi), thanks for this great ieda</p>",
        "id": 423733775,
        "sender_full_name": "Qi Huang",
        "timestamp": 1709086369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"567488\">@Qi Huang</span> <span class=\"user-mention\" data-user-id=\"417958\">@Milan</span> <span class=\"user-mention\" data-user-id=\"639836\">@Merlijn Sebrechts</span>  Thanks folks! - I've added your names to the list of supporters.</p>",
        "id": 423754477,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709101715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423617111\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423109119\">said</a>:</p>\n<blockquote>\n<p>By complementary, I mean perhaps peripheral too and aligned with the general direction we're all heading in.</p>\n<p>I'm happy to word-smith that better, or be more specific too. Is there a specific concern, a way I can phrase that a little better?</p>\n</blockquote>\n<p>Reading it again, \"may complement the tooling available from the BA\" still feels a little unclear. What would you think of having the bullet point say something like this:</p>\n<blockquote>\n<p>The group may provide software to support embedded use cases including proof of concept implementations, producer tools, or proposed solutions, which may be specialized for specific use cases.</p>\n</blockquote>\n</blockquote>\n<p>Hey <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> good morning, sorry for the delayed response - internal conference and timezones. Yes, I like this a lot actually. How about...</p>\n<blockquote>\n<p>The group may provide software to support embedded use cases including proof of concept implementations, producer tools, or proposed solutions, which may be specialized for specific use cases or platforms.</p>\n</blockquote>\n<p>Just thinking one of the reasons for this is the occasional weirdness of a specific IoT platform - HW + RTOS combination. I guess you could say that's covered by \"use case\" too? Or are we being overly specific? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 423755088,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709102165
    },
    {
        "content": "<p>I've added the proposed text to the md file, rewording point 5. What do you think?</p>",
        "id": 423755213,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709102265
    },
    {
        "content": "<p>&gt; </p>\n<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423726870\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"639836\">Merlijn Sebrechts</span> How fine-grained are you imagining the USB device access control being? More like \"this component shall access specific deviceIds/vendorIds/serialNumbers/etc.\", or more like \"this component shall only access digital cameras and not other kinds of devices\"?</p>\n</blockquote>\n<p>Yes, I'm assuming we simply use existing standards and ad-hoc identifiers like serial numbers, device ids and vendor IDs. At the level that I'm talking about, this would be a driver getting access to the devices that it supports.</p>\n<p>I think things like \"this component shall only access digital cameras and not other kinds of devices\" should be done at a higher level. A driver, for example, would turn a USB interface into a video stream interface. Then an app would state \"I want access to a video stream\" and be connected as such.</p>",
        "id": 423863752,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709139917
    },
    {
        "content": "<p>But at that level, I think the current setup of matching interfaces already works. A <code>h264-stream</code> interface, for example is descriptive enough and possible using the current version of the component model. It might be interesting to see if there are other use-cases for \"additional metadata for an interface\" beyond hardware interfaces, though.</p>",
        "id": 423864408,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709140128
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"639836\">@Merlijn Sebrechts</span> what of that information should be required of the capability interface, and what of the implementation? The way you described it, the <code>For example, a component might support a USB camera of a certain type, but it should not have access to other USB devices. Once that metadata is in place and indexable in warg, we could have a runtime that automatically loads drivers for connected hardware devices.</code> </p>\n<p>So..... which type of component artifact should have what kind of information, the way you're thinking about it. I -- that is, the human personality that is Ralph -- would say hey, you implement wasi:digital-camera, but underneath you might have the supplying implementation that <em>uses</em> a wasi:usb to connect to and consume the camera stream but return only that. </p>\n<p>you sorta reference that with your last comment, but is that how you think about it?</p>",
        "id": 423865093,
        "sender_full_name": "Ralph",
        "timestamp": 1709140367
    },
    {
        "content": "<p>and there's a difference between the component having this metadata itself vs. having that level of searchable metadata in the registry.........</p>",
        "id": 423865227,
        "sender_full_name": "Ralph",
        "timestamp": 1709140423
    },
    {
        "content": "<p>But, love the thoughts, keep 'em coming</p>",
        "id": 423865267,
        "sender_full_name": "Ralph",
        "timestamp": 1709140438
    },
    {
        "content": "<p>So let's say you have a component that uses <code>wasi:digital-camera</code>. It processes a video feed. The runtime has access to a <code>sony-f390</code> camera module via USB. It needs a \"driver\" component that translates <code>wasi:usb</code> to <code>wasi-digital-camera</code>. But every USB camera driver component will have that.  How can the runtime</p>\n<ol>\n<li>Find the component that consumes <code>wasi:usb</code> for the <code>sony-f390</code> camera and implements <code>wasi-digital-camera</code>.</li>\n<li>Give that component access to only that USB device.</li>\n</ol>\n<p>So the driver should have metadata that says \"I'm consuming <code>wasi:usb</code> with the specific property <code>device-id: sony-f390</code>\".</p>\n<p>Runtimes that don't understand the property should just give it access to all usb devices. Runtimes that understand the property should only give it access to that specific device. Moreover, runtimes can use this metadata to dynamically load drivers based on what USB device is connected.</p>\n<p>Does this answer your question?</p>",
        "id": 423867148,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709141143
    },
    {
        "content": "<p>yup, and I would think that there WOULD be a device specific interface for the sony-f390, not merely a \"label\" for it</p>",
        "id": 423867306,
        "sender_full_name": "Ralph",
        "timestamp": 1709141196
    },
    {
        "content": "<p>at the impl level</p>",
        "id": 423867325,
        "sender_full_name": "Ralph",
        "timestamp": 1709141201
    },
    {
        "content": "<p>but <em>this is a first pass</em> kind of thought, don't take it too seriously as I'm working out at what level I'd drive that information.....</p>",
        "id": 423867452,
        "sender_full_name": "Ralph",
        "timestamp": 1709141245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268586\">Ralph</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423867306\">said</a>:</p>\n<blockquote>\n<p>yup, and I would think that there WOULD be a device specific interface for the sony-f390, not merely a \"label\" for it</p>\n</blockquote>\n<p>So the thing I'm trying to enable is giving a 10-year old embedded device access to new connected devices by dynamically loading drivers.</p>\n<p>We could have a separate interface for every single device connected to USB, but </p>\n<ol>\n<li>that would blow up the size of supported interfaces, if every device would be supported, and </li>\n<li>would limit runtimes to only supporting devices released before that runtime.</li>\n</ol>",
        "id": 423867833,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709141363
    },
    {
        "content": "<p>In your scenario, the runtime could support passing USB to components. The drivers could be available, but it still wouldn't be possible to match the two simply because the runtime sees <code>usb-sony-f390</code> as a separate, unsupported interface.</p>",
        "id": 423868111,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709141452
    },
    {
        "content": "<p>Yeah, that's the challenge I see too. Currently our main tool for components making static semantic declarations are signatures, but we don't currently have good tools for being generic or abstracting over different signatures.</p>",
        "id": 423868206,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709141491
    },
    {
        "content": "<p>the two stories I'm extracting from this are those who do not care about devices will use any wasi:digital-camera impl; those who DO would want to:</p>\n<ul>\n<li>prevent usage of any other camera with that \"driver\" component</li>\n<li>separated metadata that would enable a runtime to make out of band decisions either in advance or at runtime</li>\n</ul>",
        "id": 423868326,
        "sender_full_name": "Ralph",
        "timestamp": 1709141525
    },
    {
        "content": "<p>I'm not sure I follow. In my scenario, <code>wasi:digital-camera</code> consumers should never care about what the underlying device is. They just process a video stream. That's not the level that I'm talking about.</p>\n<p>I'm talking about a <code>wasi:usb</code> consumer that only supports a specific camera.</p>",
        "id": 423868636,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709141650
    },
    {
        "content": "<p>meta-suggestion: maybe its time to make a SIG-embedded stream and break this into several threads</p>",
        "id": 423869507,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1709141968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253992\">Pat Hickey</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423869507\">said</a>:</p>\n<blockquote>\n<p>meta-suggestion: maybe its time to make a SIG-embedded stream and break this into several threads</p>\n</blockquote>\n<p>Just a question on etiquette, should we make sure we get the SIG formally recognized first? Or is it ok to go ahead to setup a SIG-Embeded without the formal SIG being established ?</p>\n<p>I'd like to give folks a few more days to review, comment, voice support, offer to co-chair - we're still looking for volunteers, particularly in the America's...  </p>\n<p>Loved <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> feedback so far (thank you!) .</p>\n<p>Perhaps we can give it to Friday afternoon US time and if there are no further comments I can formally request the SIG proposal be reviewed by the TSC, and submit the PR?</p>\n<p>Does that sound ok to all?</p>",
        "id": 423938914,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709173439
    },
    {
        "content": "<p>I'm really loving the active conversation, and comments so far... I'm excited about getting the SIG setup so we can make these conversations easier, and more effective.</p>",
        "id": 423939151,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709173573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423938914\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"253992\">Pat Hickey</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/423869507\">said</a>:</p>\n<blockquote>\n<p>meta-suggestion: maybe its time to make a SIG-embedded stream and break this into several threads</p>\n</blockquote>\n<p>Just a question on etiquette, should we make sure we get the SIG formally recognized first? Or is it ok to go ahead to setup a SIG-Embeded without the formal SIG being established ?<br>\n</p>\n</blockquote>\n<p>Maybe you can start with a <code>proposed-SIG Embedded</code> stream and rename it to <code>SIG Embedded</code> once it becomes official?</p>",
        "id": 423976595,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1709197682
    },
    {
        "content": "<p>It could also be called 'Embedded' until the SIG is formed, which is a little easier to read.</p>",
        "id": 423989886,
        "sender_full_name": "IFcoltransG",
        "timestamp": 1709202544
    },
    {
        "content": "<p>Here's a question for people to ponder: What should <em>portability</em> mean for Embedded?</p>\n<p>Suppose we were to take eg. wasi-sdk and add flags like <code>--chip=stm32</code>, <code>--chip=esp32</code>, <code>--chip=nrf5x</code>, and more, which produce \"Wasm\" code that runs faster and with less RAM on those chips, but on other chips runs slower, or perhaps doesn't run at all, or perhaps has a risk of behaving differently. How would you think about this?</p>\n<ul>\n<li>That compromises the core value proposition of Wasm.</li>\n<li>That'd be normal and expected.</li>\n<li>It depends on how slow, or how big a risk, or other factors.</li>\n</ul>\n<p>Please explain your reasoning <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> .</p>",
        "id": 424297026,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709315022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/424297026\">schrieb</a>:</p>\n<blockquote>\n<p>Here's a question for people to ponder: What should <em>portability</em> mean for Embedded?</p>\n<p>Suppose we were to take eg. wasi-sdk and add flags like <code>--chip=stm32</code>, <code>--chip=esp32</code>, <code>--chip=nrf5x</code>, and more, which produce \"Wasm\" code that runs faster and with less RAM on those chips, but on other chips runs slower, or perhaps doesn't run at all, or perhaps has a risk of behaving differently. How would you think about this?</p>\n<ul>\n<li>That compromises the core value proposition of Wasm.</li>\n<li>That'd be normal and expected.</li>\n<li>It depends on how slow, or how big a risk, or other factors.</li>\n</ul>\n<p>Please explain your reasoning <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> .</p>\n</blockquote>\n<p>To me, personally, portability is the least important thing.<br>\nHere is my priority:</p>\n<ol>\n<li>Sandboxing</li>\n<li>Low footprint</li>\n<li>High performance</li>\n<li>Portability</li>\n</ol>\n<p>Here are my reasons:</p>\n<ul>\n<li>Having a sandboxed execution on an embedded device implies “value” (patching software without harming the underlying system + without the need of flashing it)</li>\n<li>Embedded devices have different capabilities: SPI, I2C, UART, … -&gt; so, portability is often not only a question of the chip, but the „interfaces“ it provides to interact with the outside world -&gt; regarding WASI/component model/wit description: maybe the “connection” to WoT (web-of-things) standards could be considered when thinking about wit-file definitions. This might relate to the discussion above about “on which semantic/abstraction level should a wit-file act?”…</li>\n<li>Portable code and high performance are contradictory. In most cases, imho, performance is more important -&gt; to get performance you must use AOT compilation, because using JIT just needs too much memory (ROM+RAM) on an embedded device; using JIT means higher footprint, which worsens the bill-of-material -&gt; if you must use AOT anyways, something like cross-compilation kicks in - this is to be done latest just before the deployment process happens</li>\n<li>Deployment questions on wasm modules on embedded devices relate to the “device capabilities” questions - the concrete chip is just one of many criterias for deployment.</li>\n</ul>\n<p>Other than that:<br>\nLooking forward if this proposal gets approved to do those discussions.</p>",
        "id": 424302274,
        "sender_full_name": "Thomas Trenner",
        "timestamp": 1709317139
    },
    {
        "content": "<blockquote>\n<p>patching software without harming the underlying system + without the need of flashing it</p>\n</blockquote>\n<p>My earliest interest in Wasm was for exactly this. It is hard to overstate just how painful field updates can be.</p>",
        "id": 424303175,
        "sender_full_name": "Lann Martin",
        "timestamp": 1709317502
    },
    {
        "content": "<p>Following on from what Thomas has said - In a production environment, the most likely commerical deployment is going to be via an AoT compiled binary. WAMR excels at this and in some circumstances (along with WASMEdge) produces code which can run faster than native code. - I think Mats has seen the same results as we have.</p>\n<p>It's not only the speed here that is important it is the runtime size and prodction overhead for dealing with AoT is smaller than JIT. - This allows us to address a wider demographic of devices in general.</p>\n<p>In this world the original WASM is cross compiled on demand for the target device.</p>\n<p>This addresses bytecode portability, and performance as <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>  raised this point.</p>\n<p>But the other point is ABI portability. We still need a way to deploy code which can run on a family of devices. The code will need to discover the functionality available from its host and adapt at runtime to that. This could be everything from asking how many I2C or I2C devces are available. Through to querying more higher level constructs, like local device storage, communication protocols etc.</p>",
        "id": 424303788,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709317746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>  - the AoT delta is so significant, I'm wondering if that's something the folks at fastly would look at too?</p>",
        "id": 424304081,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709317844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span> Fastly already does use AOT. We don't have a JIT in the fleet.</p>",
        "id": 424304493,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709317997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>  - ahh, so you folks will probably have the next problem that this opens up - managing service catalogues and WASM + native assets... depending on how hetrogenous the fleet is, of course. :-) this is less a WASM and more an orchestraton / scheduling problem of course.</p>",
        "id": 424306755,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709318877
    },
    {
        "content": "<p>Yeah, so for our use cases, portability matters a lot, in the sense of being able to run the code on different kinds of machines, and also in letting our users run their code on different Wasm runtimes.</p>",
        "id": 424307149,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1709319019
    },
    {
        "content": "<p>Just to add one thing:<br>\nI would try to ensure that the semantics of the code stay the same on different devices. I.e.: if you have a control code using floats, then the result of the calculation should be the same, independent of where it gets executed. It might execute slower (which can have sever impact), but it yields the same (=predictable) results. <br>\nAt this point, I guess deciding on what is more important (speed vs deterministic results) is to be done from case to case. Some discussions were done regarding SIMD &amp; relaxed_simd.</p>\n<p>However, having portability is a good thing to have. But with AoT, it could be reached (with some pain) with cross-compilation of wasm bytecode.</p>",
        "id": 424307479,
        "sender_full_name": "Thomas Trenner",
        "timestamp": 1709319140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254083\">Dan Gohman</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/424307149\">said</a>:</p>\n<blockquote>\n<p>Yeah, so for our use cases, portability matters a lot, in the sense of being able to run the code on different kinds of machines, and also in letting our users run their code on different Wasm runtimes.</p>\n</blockquote>\n<p>Yes I can see this, particularly as part of the development story and we will have the same in the IoT space. The best runtime for development on the desktop could be different to the embedded runtime. We've looked at WAMR for IoT and I did discuss with Pat and Bailey trying to run the same code in Wasmtime on a desktop... it doesn't work. The networking / socket API in particular is different, and this was the source of the pain. I think from a WASI (interface) world solving this would be amazing. </p>\n<p>Overall, in the WASI-P1 environment there is some fragementation between networking implementations , as these were not standardized in P1. It means writing adpaters to convert from P1 to P2 may end up being runtime specific, which would just be a lot of work. But a back port of the socket api from P2 to P1 as a P1 standard would give P1 dependent folks a way to migrate and prep for P2 and ultimately WASI V1 - just a thought.</p>",
        "id": 424308170,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709319419
    },
    {
        "content": "<p>Just to clarify, while we've looked at WAMR, it isn't the only solution of course, there are lots of other solutions for embedded devices, I know that there is some amazing work on Wasmtime recently, and also some great work on getting WASM2C as a runtime too.</p>\n<p>Cracking the code portability issues between these platforms, particularly with communications would be awesome. </p>\n<p>I think we touched on this in the discussion above, there are perhaps two key ways to think about emebdded systems:</p>\n<ol>\n<li>A world similar to the proposal from <span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span> 's excelltn WIT, and the work from <span class=\"user-mention\" data-user-id=\"639836\">@Merlijn Sebrechts</span> <span class=\"user-mention\" data-user-id=\"659125\">@Wouter Hennen</span> <span class=\"user-mention\" data-user-id=\"657912\">@Warre Dujardin</span> <span class=\"user-mention\" data-user-id=\"661362\">@Friedrich Vandenberghe</span> (and I'm sure I've forgotten other names I should really add here) on a low level interface. In this world, perhaps you write your device driver in WASM.</li>\n<li>A world where the low level interface is hidden, and devices are described - an LCD screen is directly exposed, or a external sensor provides an API - perhaps the device driver here is native. </li>\n</ol>\n<p>I could imagine that this all depends on the target device and it's capabiltiies, security concerns, etc. .. </p>\n<p>I'm really excited about talking more with everyone...</p>",
        "id": 424314104,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709321874
    },
    {
        "content": "<p>Speaking of talking more with everyone... </p>\n<p>I submitted the PR for creating the SIG. I think this kicks off the formal Bytecode Allaince process and as far as I know is the first step in asking the TSC to consider our request. I imagine that there will be some feedback on text and some improvements to that.</p>\n<p>I'll keep you all posted on what I hear.</p>",
        "id": 424314586,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709322095
    },
    {
        "content": "<p>So far for co-chairs, as a recap ... we have:</p>\n<ol>\n<li>Europe - <span class=\"user-mention\" data-user-id=\"693032\">@Dominik Tacke</span> volunteered</li>\n<li>Asia - <span class=\"user-mention\" data-user-id=\"268650\">@Wang Xin</span> volunteered</li>\n<li>Americas - I've offered to help.</li>\n</ol>\n<p>If you are interested in helping with the coordination, or if I've missed your offer of help (It can happen and I apologise in advance) let me know! - many thanks, and Happy Friday to all.</p>",
        "id": 424315083,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709322322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435699\">Chris Woods</span> <a href=\"#narrow/stream/206238-general/topic/Begining.20the.20process.20of.20proposing.20an.20Embedded.20SIG/near/424314586\">said</a>:</p>\n<blockquote>\n<p>Speaking of talking more with everyone... </p>\n<p>I submitted the PR for creating the SIG. I think this kicks off the formal Bytecode Allaince process and as far as I know is the first step in asking the TSC to consider our request. I imagine that there will be some feedback on text and some improvements to that.</p>\n<p>I'll keep you all posted on what I hear.</p>\n</blockquote>\n<p>Oh, exciting news. Looking at this thread, there are so many awesome people already discussing and it is a lot of things which would need our attention. It will not be an easy but I think a very fulfilling and exiting task to pave the way for embedded wasm.</p>",
        "id": 424324849,
        "sender_full_name": "Dominik Tacke",
        "timestamp": 1709326808
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"435699\">@Chris Woods</span>, if possible I would also like to join the SIG  <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 424488068,
        "sender_full_name": "Friedrich Vandenberghe",
        "timestamp": 1709455121
    },
    {
        "content": "<p>Hi everyone, very interesting conversation here, I'll have to catch up the very first messages. I'm also currently working with WASM on highly constrained devices and especially integrating peripherals. So I'm very interested in joining the discussion (and the SIG of course)</p>",
        "id": 424537175,
        "sender_full_name": "Maximilian Seidler",
        "timestamp": 1709494515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"661362\">@Friedrich Vandenberghe</span>  - <br>\nOf course, SIG is open to all. I was just collecting supporting names from members of the Bytecode Alliance, it's a part of the application process to establish the SIG.</p>",
        "id": 424691483,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709568640
    },
    {
        "content": "<p>For anyone wanting to track the PR for establishing the SIG, you can find it here: <a href=\"https://github.com/bytecodealliance/governance/pull/79\">https://github.com/bytecodealliance/governance/pull/79</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/governance/pull/79\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/26981f36fb38e45f267441cb71d76338e25358a5\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333833306133386638356366366335643435383333373962653439313264383839653531316532326264396632646136343739336139663038653837316434622f62797465636f6465616c6c69616e63652f676f7665726e616e63652f70756c6c2f3739)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/governance/pull/79\" title=\"A Proposal to create a Sig Embedded by woodsmc · Pull Request #79 · bytecodealliance/governance\">A Proposal to create a Sig Embedded by woodsmc · Pull Request #79 · bytecodealliance/governance</a></div><div class=\"message_embed_description\">Hello folks, please accept this PR as a formal request to establish an embedded / Industrial IoT Special Interest Group. The proposal has generated a considerable amount of interest both inside the...</div></div></div>",
        "id": 424691877,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709568711
    },
    {
        "content": "<p>Hi Folks, I've had a few folks reach out and ask how they can continue to show support for the proposed SIG. Now the PR is submitted, if you'd like to show support for the SIG please do comment on the Github PR (link above).</p>",
        "id": 424889872,
        "sender_full_name": "Chris Woods",
        "timestamp": 1709651244
    },
    {
        "content": "<p>Hey everyone; we created a WIP stream for discussing WASI on embedded systems: <a href=\"#narrow/stream/434034-WIP-Embedded\">https://bytecodealliance.zulipchat.com/#narrow/stream/434034-WIP-Embedded</a></p>",
        "id": 434728735,
        "sender_full_name": "Merlijn Sebrechts",
        "timestamp": 1713787031
    },
    {
        "content": "<p>Hi Folks, we've got the second meeting of the embedded sig scheduled for tomorrow - full details available on the embedded-sig channel here : <a href=\"#narrow/stream/438936-SIG-Embedded/topic/Zoom.20Links.20and.20Meeting.20Schedule/near/446649135\">https://bytecodealliance.zulipchat.com/#narrow/stream/438936-SIG-Embedded/topic/Zoom.20Links.20and.20Meeting.20Schedule/near/446649135</a></p>",
        "id": 446649946,
        "sender_full_name": "Chris Woods",
        "timestamp": 1719244070
    }
]