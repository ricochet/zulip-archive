[
    {
        "content": "<p><a href=\"https://kerkour.com/webassembly-wasi-preview2\">https://kerkour.com/webassembly-wasi-preview2</a></p>\n<p>As someone who was around with COM, DCOM, SOAP, WSDL, etc (I think) I understand the concern here.</p>\n<p>I'm interested in any reflections.</p>\n<p>Requisite thread: <a href=\"https://news.ycombinator.com/item?id=40439681\">https://news.ycombinator.com/item?id=40439681</a></p>",
        "id": 440193572,
        "sender_full_name": "Kevin Moore",
        "timestamp": 1716416096
    },
    {
        "content": "<p>I think when someone rolls in with hot takes like \"in Rust, async is a failure\", it's clear what kind of post they're going for.</p>",
        "id": 440195427,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1716416950
    },
    {
        "content": "<p>The async features being worked on for Preview 3 are quite different from Rust's async. I encourage anyone interested in learning more to watch <a href=\"https://www.youtube.com/watch?v=y3x4-nQeXxc\">Luke's talk</a>, including how it avoids the function coloring problem.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"y3x4-nQeXxc\" href=\"https://www.youtube.com/watch?v=y3x4-nQeXxc\"><img src=\"https://uploads.zulipusercontent.net/fa271afed70af4e4e72d46494a06afe170b460d0/68747470733a2f2f692e7974696d672e636f6d2f76692f793378342d6e51655878632f64656661756c742e6a7067\"></a></div>",
        "id": 440196484,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1716417379
    },
    {
        "content": "<p>I don’t think this post deserves any amplification in this venue</p>",
        "id": 440203847,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1716420427
    },
    {
        "content": "<p>The post is a rant and not worth anyone’s time to address, if you or the author find there to be any substantial critique in there i encourage you to write it in a way that’s not deliberately inflammatory</p>",
        "id": 440204764,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1716420833
    },
    {
        "content": "<p>I think there are enough justifications for why high-level abstractions are worth extra complexity compared to a plain ABI. (See e.g. Luke's other talks on components.) We can certainly do our best to make it ergonomic for library users as the tooling develops.</p>",
        "id": 440205590,
        "sender_full_name": "IFcoltransG",
        "timestamp": 1716421283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253992\">Pat Hickey</span> <a href=\"#narrow/stream/206238-general/topic/Component.20model.20critique/near/440204764\">said</a>:</p>\n<blockquote>\n<p>The post is a rant and not worth anyone’s time to address, if you or the author find there to be any substantial critique in there i encourage you to write it in a way that’s not deliberately inflammatory</p>\n</blockquote>\n<p>At a minimum, it might be good for folks here (with more context) to add to the discussion on HN. Might...</p>",
        "id": 440233179,
        "sender_full_name": "Kevin Moore",
        "timestamp": 1716431106
    },
    {
        "content": "<p>As someone on the original OLE32 team, then COM, then DCOM, then WS*/SOAP -- he pulls out his OLDZ IDENTITY CARD -- the component model is completely different than the problem he describes as _the one he thinks is worth paying attention to_. Each and every one of those technologies had successes and failures and learning from them both puts us here.</p>",
        "id": 440291890,
        "sender_full_name": "Ralph",
        "timestamp": 1716459632
    },
    {
        "content": "<p>PERSONALLY, as a megacorp old, I could not care less what dialogue takes place on the Orange Cheeto site. I am NOT a fan. What posts there that are helpful are also available outside that framework.</p>",
        "id": 440292058,
        "sender_full_name": "Ralph",
        "timestamp": 1716459684
    },
    {
        "content": "<p>Now, others might think about the Cheeto site, so <span class=\"user-mention\" data-user-id=\"498813\">@Kevin Moore</span> I do not begrudge you the point!!! :-) I'd prefer to extract one point from that screed, to \"wit\": he takes WIT to be for developers, like everyone else who does not yet grok that no one should ever need WIT unless they were building some sort of platform.</p>",
        "id": 440292352,
        "sender_full_name": "Ralph",
        "timestamp": 1716459784
    },
    {
        "content": "<p>So there's clearly still a messaging problem: The solid critique of components is that they have not yet arrived.</p>",
        "id": 440292419,
        "sender_full_name": "Ralph",
        "timestamp": 1716459811
    },
    {
        "content": "<p>almost all of the incoming people do not learn quickly -- QUICKLY -- that what we have now are the underpinnings of a language-toolchain based way of using wasm modules. That we have only two runtimes (really) yet implementing it. And that the work between now and the end of the calendar year will really be when it can be taken seriously IFF you're looking for an \"scale out, approachable developer platform\".</p>",
        "id": 440292748,
        "sender_full_name": "Ralph",
        "timestamp": 1716459934
    },
    {
        "content": "<p>for example, just YESTERDAY there was this conversation with someone reading through the bits/docs: <a href=\"#narrow/stream/219900-wasi/topic/Understanding.20component.20model.20entities/near/440127963\">https://bytecodealliance.zulipchat.com/#narrow/stream/219900-wasi/topic/Understanding.20component.20model.20entities/near/440127963</a>. All because someone entering to understand wasn't getting the message that the conflict they were looking at is real but only at this point in time, and that we are planning for its future resolution.</p>",
        "id": 440293067,
        "sender_full_name": "Ralph",
        "timestamp": 1716460061
    },
    {
        "content": "<p>this screed makes the same mistake, then adds as much pointless hubris as it can. Beyond this, I don't gain too much from it.</p>",
        "id": 440293190,
        "sender_full_name": "Ralph",
        "timestamp": 1716460103
    },
    {
        "content": "<p>I answered on mastodon, which I consider a valuable platform to respond on. <a href=\"https://hachyderm.io/@christofp/112489754175439957\">https://hachyderm.io/@christofp/112489754175439957</a></p>",
        "id": 440309056,
        "sender_full_name": "Christof Petig",
        "timestamp": 1716466240
    },
    {
        "content": "<p>Good response!</p>",
        "id": 440329445,
        "sender_full_name": "Ralph",
        "timestamp": 1716472736
    },
    {
        "content": "<p>If nothing else, what this post highlights is the lack of accessible information about component model. <br>\nAt this moment, information about component model is all over the place on Zulip, Github issues/prs/readmes of related projects, random talks, RFCs etc... Most people can't keep up with this.</p>\n<p>So, any random blogpost can say whatever it wants, as there's very few people who can actually counter them (and even fewer who do) as most people don't know enough to refute any lies/hyperbole arguments.</p>\n<p>Some common questions (in random places) I often see are</p>\n<ol>\n<li>why is wasi 0.1 (interface types) abandoned? and why do we have CM now?</li>\n<li>Where can one go to learn about CM? any comprehensive user level (guide?) docs.</li>\n<li>Is there a tiny example repository which explains all the different parts of CM?</li>\n</ol>\n<p>it would be nice if more people involved in CM work wrote some articles now and then describing one feature of CM for mainstream audience. </p>\n<p>The only thing this article gets right is the amount of rust people involved in this project.</p>",
        "id": 440441672,
        "sender_full_name": "code red art",
        "timestamp": 1716528974
    },
    {
        "content": "<blockquote>\n<ol start=\"2\">\n<li>Where can one go to learn about CM? any comprehensive user level (guide?) docs.</li>\n</ol>\n</blockquote>\n<p>The SIG Documentation group is working on <a href=\"https://component-model.bytecodealliance.org\">https://component-model.bytecodealliance.org</a>. It would be fantastic to hear where this is falling short.</p>",
        "id": 440479024,
        "sender_full_name": "Ryan Levick (rylev)",
        "timestamp": 1716545235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590805\">@Ryan Levick (rylev)</span> one thing is an explanation at the top that says \"this is what exists at the moment; for information about the future intended evolution of the component model (v0.3, RC, 1.0, etc.) please see......\"</p>",
        "id": 440480635,
        "sender_full_name": "Ralph",
        "timestamp": 1716545960
    },
    {
        "content": "<p>people read that thinking that this IS the component model (present tense) as if there is no future tense -- because we don't make that clear</p>",
        "id": 440480681,
        "sender_full_name": "Ralph",
        "timestamp": 1716545991
    },
    {
        "content": "<p>in ADDITION, we should be clear where the benefits accrue; and that it's not required to use it -- it sits on top of core wasm.</p>",
        "id": 440480828,
        "sender_full_name": "Ralph",
        "timestamp": 1716546038
    },
    {
        "content": "<p>that kind of thing</p>",
        "id": 440480834,
        "sender_full_name": "Ralph",
        "timestamp": 1716546040
    },
    {
        "content": "<p>happy to work with you to come up with an example we can review...</p>",
        "id": 440480879,
        "sender_full_name": "Ralph",
        "timestamp": 1716546056
    },
    {
        "content": "<p>I think the game changers are sandboxing (and now better sandboxing), plugins, composition and async.</p>\n<p>The experience people here bring to the table speaks loudly to the significance of what is being accomplished. I hope no-one is taking to heart the easy shots someone can make if they resort to slight misrepresentations or leaving out a fuller picture.</p>\n<p>And to me, being new here, but not new to async or wasm or to siloed platforms, it seems perfectly natural that the documentation doesn't represent everything yet and doesn't make things easy yet. It couldn't possibly do justification to the technology that is rising here.</p>\n<p>I agree with the comment above that non-constructive critiques and requests for comment on critiques don't need amplification here (yet I'm commenting). One of the double-edge swords of having such an open and welcoming environment around this project means there are the occasional cuts when something as innocuous sounding as would you care to comment on this critique is thrown in.</p>\n<p>The people already here don't need encouragement to continue what they are doing. I guess I wanted to add my voice for anyone else new, to be quick to try the examples and watch the issues and PRs and be slow to critique.</p>",
        "id": 440504618,
        "sender_full_name": "Frank Rehwinkel",
        "timestamp": 1716555653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"590805\">@Ryan Levick (rylev)</span> I personally did not know that <a href=\"https://component-model.bytecodealliance.org/\">https://component-model.bytecodealliance.org/</a> existed, and it looks like a wonderful resource. My only thought of where it's falling short is discoverability <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Where could I find that link if I were looking through the BCA / WebAssembly repos?</p>",
        "id": 440506940,
        "sender_full_name": "Brooks Townsend",
        "timestamp": 1716556487
    },
    {
        "content": "<p>That's a good point. I've opened an issue for increasing visibility: <a href=\"https://github.com/bytecodealliance/component-docs/issues/138\">https://github.com/bytecodealliance/component-docs/issues/138</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/component-docs/issues/138\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/9360892e5b74264e873294ec3c897170a2c6652c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333737646463616238626333393731656434626163313066653836323831326530643637646263353734626664326561623361613763393462663337636339652f62797465636f6465616c6c69616e63652f636f6d706f6e656e742d646f63732f6973737565732f313338&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/component-docs/issues/138\" title=\"Advertise existence of this resource in more places · Issue #138 · bytecodealliance/component-docs\">Advertise existence of this resource in more places · Issue #138 · bytecodealliance/component-docs</a></div><div class=\"message_embed_description\">I've received some feedback that the component docs are not discoverable enough. Perhaps we could do a concerted effort of going to other component related BA repos and making sure the link to thes...</div></div></div>",
        "id": 440513615,
        "sender_full_name": "Ryan Levick (rylev)",
        "timestamp": 1716558605
    },
    {
        "content": "<p>And I'll see about helping point the way to that as well!!</p>",
        "id": 440525487,
        "sender_full_name": "Ralph",
        "timestamp": 1716562381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590805\">Ryan Levick (rylev)</span> <a href=\"#narrow/stream/206238-general/topic/Component.20model.20critique/near/440479024\">said</a>:</p>\n<blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>Where can one go to learn about CM? any comprehensive user level (guide?) docs.</li>\n</ol>\n</blockquote>\n<p>The SIG Documentation group is working on <a href=\"https://component-model.bytecodealliance.org\">https://component-model.bytecodealliance.org</a>. It would be fantastic to hear where this is falling short.</p>\n</blockquote>\n<p>I think there's three improvements to make it more accessible (subjective ofc).</p>\n<p>First,  there needs to be a minimal (but realistic) use-case used as a reference throughout the doc. For example, <a href=\"https://github.com/getditto/safer_ffi\">safer_ffi</a> crate's README uses a tiny example of a <code>Point { x: f32, y: f32 }</code> struct and a <code>fn midpoint(&amp;self, other: &amp;Point) -&gt; Point</code> fn. Then, it refers to these items as concrete examples whenever it explains a concept.  The <a href=\"https://doc.rust-lang.org/cargo/reference/build-script-examples.html\">cargo reference</a>'s build script chapter also takes zlib (<code>libz-sys</code> crate) as an example to explain the various concepts. </p>\n<p>Second, there needs to be a brief explanation of wasm concepts <em>before</em> we even start with component model. Most people interact with wasm via wasm_bindgen or emscripten, which don't really tell you about concepts like linear memories. Without knowing about that, one cannot understand the concept of each component having separating memories or \"exporting\" a memory. wasm -&gt; component model -&gt; wasi feels like natural progress. While explaining the concepts, we should also tell why we even need it. Personally, I had trouble understanding interfaces, worlds and packages. interfaces/worlds just feel like rust modules with almost no difference, while package feels like a crate (which itself is also a root module). I kind of get that package is for distribution (like crates), worlds are for actual instantiation (like a dll/so) based on parameterized imports and interfaces are the actual rust modules where we group some items. But, the guide could have definitely helped by explaining their intended use-cases explicitly.  </p>\n<p>Third, We need a cheatsheet or something which shows the parallels of CM concepts to some real world implementations. package seems similar to java/go packages. components seems similar to shared libraries (dll/so objects). wasi seems like a \"std library\" (libc is just c's std library, and wasi is libc of CM). Option&lt;T&gt; is nullable or something. The blogpost we are discussing makes these words seem like some scary foreign concept and that the complexity of CM has exploded, but most of these are simple basic concepts that almost every programmer knows and has direct parallels for any mainstream programming language ecosystem.  A simple graphic cheatsheet would do wonders compared to a textual guide (especially to share on twitter or to use it in medium articles).</p>\n<p>Slightly off-topic, but I think there should be some beginner articles on the bytecode alliance website in addition to the book. something similar to <a href=\"https://www.khronos.org/blog/an-introduction-to-vulkan-video\">Introduction to Vulkan Video extensions</a> from <a href=\"https://www.khronos.org/blog/tags/tag/vulkan/P15\">Khronos blog</a>.  Blogposts are easier to share on twitter/reddit to reach mainstream audience, compared to an mdbook.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/getditto/safer_ffi\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/131ac6f67a0289238c586707ea702d994a57c1d6/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393861613034343362376637636230336263383439616532323934613130623465313639376263326438343631316237656565653437396638316366623166372f676574646974746f2f73616665725f666669&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/getditto/safer_ffi\" title=\"GitHub - getditto/safer_ffi: Write safer FFI code in Rust without polluting it with unsafe code\">GitHub - getditto/safer_ffi: Write safer FFI code in Rust without polluting it with unsafe code</a></div><div class=\"message_embed_description\">Write safer FFI code in Rust without polluting it with unsafe code - getditto/safer_ffi</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://www.khronos.org/blog/an-introduction-to-vulkan-video\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c3f34a33cb2da279cc7eb0294a9a77fe70ecf035/68747470733a2f2f7777772e6b68726f6e6f732e6f72672f6173736574732f75706c6f6164732f617069732f56756c6b616e2d5371756172652e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://www.khronos.org/blog/an-introduction-to-vulkan-video\" title=\"An Introduction to Vulkan Video\">An Introduction to Vulkan Video</a></div><div class=\"message_embed_description\">Deploying and developing royalty-free open standards for 3D graphics, Virtual and Augmented Reality, Parallel Computing, Neural Networks, and Vision Processing</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://www.khronos.org/blog/tags/tag/vulkan/P15\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/0c0465be56699686feddfdaa18e24016a1e5a9dd/68747470733a2f2f7777772e6b68726f6e6f732e6f72672f6173736574732f696d616765732f4b68726f6e6f732d32353070782d776974682d7461676c696e652d4e65772e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://www.khronos.org/blog/tags/tag/vulkan/P15\" title=\"The Khronos Group\">The Khronos Group</a></div><div class=\"message_embed_description\">Deploying and developing royalty-free open standards for 3D graphics, Virtual and Augmented Reality, Parallel Computing, Neural Networks, and Vision Processing</div></div></div>",
        "id": 440548323,
        "sender_full_name": "code red art",
        "timestamp": 1716571153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"345681\">Brooks Townsend</span> <a href=\"#narrow/stream/206238-general/topic/Component.20model.20critique/near/440506940\">said</a>:</p>\n<blockquote>\n<p>I personally did not know that <a href=\"https://component-model.bytecodealliance.org/\">https://component-model.bytecodealliance.org/</a> existed, and it looks like a wonderful resource.</p>\n</blockquote>\n<p>It shoes how to make to make the guest and how to run in from the command line, but not how to run a component from Rust. It's definitely a step forward to have an actual tutorial, but unfortunately it's still not complete.</p>",
        "id": 440814350,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1716802231
    },
    {
        "content": "<p>The post went from kind of making sense to being completely unhinged to sort of making sense again. Their \"expected example\" of interface definition looks (really) no different from a wit file, except for different formatting and wording, so I don't understand what is their problem there.</p>\n<p>I would agree that async is done sub-optimally (forcing WASI users to use async even if they don't want to), but that is not what the article said. There are genuine problems in the current implementation of the component models, for example guest resources being completely untyped on the host, no recursive structures or unable to use guest resources in host imported function, but the article doesn't mention any of them.</p>\n<p>The biggest problem (IMO) currently with the component model is that very few languages support it, but again, it's not mentioned in the article.</p>",
        "id": 440816291,
        "sender_full_name": "Karel Hrkal (kajacx)",
        "timestamp": 1716802760
    },
    {
        "content": "<p>It's entirely fair to not like the current version we have for almost any reason, and that's because it's not done yet. It is also fair if from some position \"not done yet\" isn't what you want. For example, there's a reason that few language chains directly support it, as it's very new. That much I get! Totes fair.....</p>",
        "id": 440823325,
        "sender_full_name": "Ralph",
        "timestamp": 1716805190
    },
    {
        "content": "<p>Where's the best place to submit minor feedback about <a href=\"https://component-model.bytecodealliance.org/\">https://component-model.bytecodealliance.org/</a> ?</p>",
        "id": 441603799,
        "sender_full_name": "Andrew Chin",
        "timestamp": 1717124856
    },
    {
        "content": "<p>About the website? You might want the issue tracker at <a href=\"https://github.com/bytecodealliance/component-docs/issues\">https://github.com/bytecodealliance/component-docs/issues</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/component-docs/issues\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/80ab1995e76b28ae02c0ef8abd6300bd52066183/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333465363732366139353534393662333235643533626565333935303564326331306332306463643130623365323437373230336139376166383261396635652f62797465636f6465616c6c69616e63652f636f6d706f6e656e742d646f6373&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/component-docs/issues\" title=\"Issues · bytecodealliance/component-docs\">Issues · bytecodealliance/component-docs</a></div><div class=\"message_embed_description\">Documentation around creating and using WebAssembly Components - Issues · bytecodealliance/component-docs</div></div></div>",
        "id": 441604618,
        "sender_full_name": "IFcoltransG",
        "timestamp": 1717125335
    },
    {
        "content": "<p>thanks.  overall, this book looks like a really great resource</p>",
        "id": 441611091,
        "sender_full_name": "Andrew Chin",
        "timestamp": 1717129182
    },
    {
        "content": "<p>I know it's an old post, but I wanted to leave a comment here from a perspective of a developer working on a hobby project, who is not in any way associated with ByteCode Alliance nor has particularly deep knowledge on WASM and most of the proposals.</p>\n<p>I work on a stress testing tool that runs scenarios compiled to WASM. I started it a long time ago, but I tend to work in small batches here and there when I find motivation, so I implemented most of the WASM support in the beginning of this year. I decided to go with manual communication between the modules and the host by sharing the linear memory. It's not ideal, cause there is quite a lot of plumbing to do, but it worked well and WASI components were even younger than they are now. Recently I've been looking into WASI components more and more and it seemed like it becomes a viable technology. I know it may change in the future previews, but it sure seems usable already. So I bit the bullet and rewrote the WASM/WASI part of my library to WASI components. Here is a <a href=\"https://github.com/drogus/crows/pull/4\">PR</a> if anyone is interested. Look at all the code and hairy memory management that I could remove! So far I'm very happy with the changes, especially that I know I'm not only removing Rust bindings for guest modules, but essentially removing the need to implement most of the plumbing for other languages too.</p>\n<p>What's even better, it's not even the final state of the rewrite. I purposefully started with custom types for http implementation, but in the near future I would like to implement the <code>wasi:http</code> package. And as far as I understand it will make my life <em>so much easier</em>. For context - I need to gather detailed timing information on each HTTP request and response, like: time to establish a connection, time to do the TLS handshake, time to first byte etc. Typically what stress testing libraries do is to create their own version of HTTP request functions in order to be able to gather metrics. After I implement <code>wasi:http</code> package I will be able to plug any component that uses the package and have all of the custom metrics pretty much for free. Like, for example if I use a JS runtime that implements <code>fetch()</code> with the <code>wasi:http</code> interfaces, a user could write a scenario in JS using <code>fetch</code> (or use any library that uses <code>fetch()</code> under the hood) and it would go through my implementation of the HTTP stack. That's wicked! Not only I can have support for multiple languages almost for free, but also I can potentially hook their standard APIs!</p>\n<p>Needless to say, I really enjoy the WASI component model. I agree that all of the rules regarding imports and includes are a bit hard to grasp in the beginning, but honestly I don't see where is the problem in that - if you don't want to use them and just want to define a simple interface with just basic types, nothing can stop you! But in the real world there is often a need for a bit more complex stuff. For example the streaming that the author complains about - sure, not everyone needs it and it increases complexity. But if there was no streaming support in the http package, I couldn't use it anyway, so what would be the point of that? The same is true to anyone that works on a high performance tooling.</p>\n<p>I will not even waste time to comment on the weird notion of async/await being a failure. I think only people that have never used it for anything serious can say that. Without async/await I wouldn't be able to use Rust for some applications I've worked on in the past (or at least it would be much harder as I would have to handle epoll or io_uring manually). Not even sure what does it mean that it's still in beta <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/drogus/crows/pull/4\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/26ca45d453406a528a480e21f67a6da4c5c70706/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623164336266363639643466646163613930313965393362336130623637343761666139353536333563646135353233393938306664626130613231383535372f64726f6775732f63726f77732f70756c6c2f34&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/drogus/crows/pull/4\" title=\"Implement WASI component model instead of custom module communication by drogus · Pull Request #4 · drogus/crows\">Implement WASI component model instead of custom module communication by drogus · Pull Request #4 · drogus/crows</a></div><div class=\"message_embed_description\">We read every piece of feedback, and take your input very seriously.</div></div></div>",
        "id": 475312527,
        "sender_full_name": "Piotr Sarnacki",
        "timestamp": 1728311813
    },
    {
        "content": "<p>your take is still a good one; thanks for the time to post it.</p>",
        "id": 475316795,
        "sender_full_name": "Ralph",
        "timestamp": 1728313020
    },
    {
        "content": "<p>thank you for sharing this! It's really appreciated, and fantastic to hear that you're having a good experience already, while looking forward to improving on it even further <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> As someone who did an implementation of the JS <code>fetch</code> API in terms of <code>wasi:http</code>, and leads a team maintaining a runtime (<a href=\"https://developer.fermyon.com/spin/index\">Spin)</a> that, among others, has similar requirements regarding telemetry collection, I can confirm that everything you're saying works out in full.</p>\n<p>Regarding future previews: WASIp3 will be purely additive, so all content running in p2 compatible environments will continue running. And for an eventual WASI 1.0, we'll provide the kind of adapter we created for going from p1 to p2, so it should be possible to keep content working without interruption indefinitely</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://developer.fermyon.com/spin/index\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/35d6be246a07a5e6039e6c42a1f9c7e2eb03ea3c/68747470733a2f2f646576656c6f7065722e6665726d796f6e2e636f6d2f7374617469632f696d6167652f747769747465725f636172645f73756d6d6172792e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://developer.fermyon.com/spin/index\" title=\"Introducing Spin\">Introducing Spin</a></div><div class=\"message_embed_description\">\nA checklist app that persists data in a key value store\n</div></div></div>",
        "id": 475584732,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1728398761
    },
    {
        "content": "<blockquote>\n<p>WASIp3 will be purely additive, so all content running in p2 compatible environments will continue running. And for an eventual WASI 1.0, we'll provide the kind of adapter we created for going from p1 to p2, so it should be possible to keep content working without interruption indefinitely</p>\n</blockquote>\n<p>One thing I personally, as someone who's deeply familiar with WebAssembly, but not so much with WASI 0.2, do not understand, is how is that even possible? The Component Model is a Phase 1 proposal that is not implemented by V8, Spidermonkey or JavaScriptCore... so really only wasmtime implements it. How can you claim that it will forever be forwards compatible when it's so extremely experimental in nature?</p>",
        "id": 475651404,
        "sender_full_name": "CryZe",
        "timestamp": 1728415856
    },
    {
        "content": "<p>For context: the component model is going through a versioning process with the Bytecode Alliance, separate from core wasm/W3C's standardisation process. 1.0 will be the version proposed to W3C. Wasmtime and JCO both have implementations of the component model.</p>",
        "id": 475662811,
        "sender_full_name": "IFcoltransG",
        "timestamp": 1728418595
    },
    {
        "content": "<p>That doesn't really change much. The forwards compatibility claim is still extremely questionable then.</p>",
        "id": 475664569,
        "sender_full_name": "CryZe",
        "timestamp": 1728419117
    },
    {
        "content": "<p>In the end the claim here is only as strong as amount of effort people are willing to put into the design itself and keep older things working. There's quite a lot of effort and implementation work behind keeping components working as-is. It's impossible to say we'll have 100% forward-compat in every way shape and form because we don't even know what the future looks like. That being said no one involved in any part of the design has any intention on breaking anything at this time and it's understood everywhere that if anything must be changed it must have a smooth path going forwards. </p>\n<p>What that exactly means for wasip3, wasip4, wasi 1.0, is unclear. I think it's unclear not because the intent-to-not-break is illegitimate, unfounded, or unreasonable. It's unclear in that we have no idea what those stories are going to be. The design of wasip3 and beyond are going to be extremely heavily influenced by ensuring the entire ecosystem doesn't break all at once.</p>",
        "id": 475665366,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1728419328
    },
    {
        "content": "<p>Alright so the problem I'm somewhat seeing merging it upstream without breaking things: With WebAssembly itself gaining struct, array, and similar types (possibly even async?), wouldn't or rather shouldn't that somewhat affect the component model, so it builds on top of those types instead of defining its own stuff? Though I may just be uninformed and it already is designed to support those.</p>",
        "id": 475668267,
        "sender_full_name": "CryZe",
        "timestamp": 1728420248
    },
    {
        "content": "<p>Perhaps! Rust, for example, is unlikely to use the new struct/array types. Other languages though, for sure! We've already planned a \"hole\" in the component model to support that by means of the 'canonical abi' which is the bridge between core wasm types and component model types. There's extension locations in place to create a branch between wasm gc values and component model types when gc support is added.</p>\n<p>The existence of struct/array in core wasm doesn't mean that types should be removed in the component model though. There's different goals such as shared-nothing linking and being able to operate without a gc which the component model still has</p>",
        "id": 475668700,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1728420392
    },
    {
        "content": "<p>One clarification might perhaps help here: I deliberately talked about future <em>previews</em> retaining backwards-compatibility, not the component model across all versions in perpetuity. The idea is indeed to make whatever breaking changes we've identified as necessary for a (very) long-term stable standard at that point, instead of breaking things for each preview</p>",
        "id": 475954754,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1728506837
    },
    {
        "content": "<blockquote>\n<p>the component model is going through a versioning process with the Bytecode Alliance, separate from core wasm/W3C's standardisation process.<br>\n<span class=\"user-mention silent\" data-user-id=\"570431\">IFcoltransG</span> that's not really true: the body doing the versioning is the WASI Subgroup, which is under governance of the WebAssembly Community Group, and hence also the WebAssembly Working Group and ultimately the W3C. The Versions in this case are about the WASI APIs, not the component model, but the express intent is to publish a semver observant versioning scheme that people can rely on</p>\n</blockquote>",
        "id": 475955309,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1728507010
    },
    {
        "content": "<blockquote>\n<p>CryZe: Alright so the problem I'm somewhat seeing merging it upstream without breaking things: With WebAssembly itself gaining struct, array, and similar types (possibly even async?), wouldn't or rather shouldn't that somewhat affect the component model, so it builds on top of those types instead of defining its own stuff? Though I may just be uninformed and it already is designed to support those.</p>\n</blockquote>\n<p>That is indeed something already considered in the design: all of these features are explicitly meant to stay as implementation details of individual components, which don't affect what other components need to do. To take the GC types you mention as an example, here's a <a href=\"https://github.com/WebAssembly/component-model/pull/317\">draft of a specification</a> for how those can be integrated into the component model. This won't affect existing content at all, and will allow composing existing components using linear memory with new components using WasmGC</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/pull/317\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/dc2db3f3f9f1d9e908da14791b530470564d364b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313632396139366363646164666335373838333061353538353337313935666365393261323131346661383138623834363734313138393238643064663336642f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f70756c6c2f333137&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/pull/317\" title=\"working with gc types by oovm · Pull Request #317 · WebAssembly/component-model\">working with gc types by oovm · Pull Request #317 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Add Canonical ABI options to support passing parameters by reference type\n\nClose Working with GC types without copy #305</div></div></div>",
        "id": 475955985,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1728507227
    }
]