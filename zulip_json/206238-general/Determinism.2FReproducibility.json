[
    {
        "content": "<p>So Dan and I were discussing deterministic/reproducible behavior in WASI.</p>",
        "id": 214394910,
        "sender_full_name": "indolering",
        "timestamp": 1603493627
    },
    {
        "content": "<p>One thing that came up is sort order, which is a cause of non-determinism in a lot of languages.</p>",
        "id": 214394957,
        "sender_full_name": "indolering",
        "timestamp": 1603493657
    },
    {
        "content": "<p>I don't know of a any prior art in this space, so all I have right now are ideas off the top of my head</p>",
        "id": 214395107,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603493834
    },
    {
        "content": "<p>I had suggested earlier that some sort of way to control deterministic/reproducible behavior, such as defining the sorting of files based on name (as opposed to timestamps).  This would be slow, especially without the help of the underlying filesystem/b-tree structure.</p>",
        "id": 214395115,
        "sender_full_name": "indolering",
        "timestamp": 1603493847
    },
    {
        "content": "<p>One option would be to have the implementation maintain its own index, that it'd update every time it creates or renames a file.</p>",
        "id": 214395120,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603493865
    },
    {
        "content": "<p>But have that be configurable, so you can turn that one but it will be slow and not all runtimes will support it.</p>",
        "id": 214395168,
        "sender_full_name": "indolering",
        "timestamp": 1603493896
    },
    {
        "content": "<p>Then, <code>fd_readdir</code> etc. would iterate over that index, rather than over thee host directory.</p>",
        "id": 214395172,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603493903
    },
    {
        "content": "<p>Right, slow, and it'd get out of date if other processes can access the dir.</p>",
        "id": 214395184,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603493917
    },
    {
        "content": "<p>So yeah, we'd want it to be optional</p>",
        "id": 214395238,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603493971
    },
    {
        "content": "<p>There are FUSE filesystems, Android used wrapfs to enable case-folded file lookup.</p>",
        "id": 214395433,
        "sender_full_name": "indolering",
        "timestamp": 1603494129
    },
    {
        "content": "<p>I wonder if the problem of other processes could be solved, or at least mitigated, by having the implementation compare the timestamp of the index to the timestamp of the directory. If the directory is more recently modified, re-scan the directory and regenerate the index.</p>",
        "id": 214395448,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494153
    },
    {
        "content": "<p>And disorderfs, which can actually list directories in a specified sort order.</p>",
        "id": 214395452,
        "sender_full_name": "indolering",
        "timestamp": 1603494158
    },
    {
        "content": "<p>Ah, FUSE etc. is a good idea too. If we can make the host FS do what we need, that'd avoid the need for an external index</p>",
        "id": 214395480,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494197
    },
    {
        "content": "<p>In my research on case-folded lookups on case-sensitive file systems, all of the solutions were racy.</p>",
        "id": 214395496,
        "sender_full_name": "indolering",
        "timestamp": 1603494220
    },
    {
        "content": "<p>Maybe that's the first question then. Are there any non-racy solutions?</p>",
        "id": 214395597,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494316
    },
    {
        "content": "<p>I don't know.</p>",
        "id": 214395668,
        "sender_full_name": "indolering",
        "timestamp": 1603494374
    },
    {
        "content": "<p>Or  perhaps we just need to say, don't enable this option if anyone can access the FS concurrently?</p>",
        "id": 214395683,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494388
    },
    {
        "content": "<p>I mean, SQLITE can be as fast as filesystem access.  So a virtual filesystem could work.</p>",
        "id": 214395715,
        "sender_full_name": "indolering",
        "timestamp": 1603494446
    },
    {
        "content": "<p>If that meets your needs, it sounds like a reasonable thing to do to me</p>",
        "id": 214395824,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494549
    },
    {
        "content": "<p>BeFS allowed arbitrary metadata, but no one seems eager to emulate that FS.</p>",
        "id": 214395832,
        "sender_full_name": "indolering",
        "timestamp": 1603494561
    },
    {
        "content": "<p>OS X, Windows, etc all just maintain a file-based search index.</p>",
        "id": 214395858,
        "sender_full_name": "indolering",
        "timestamp": 1603494592
    },
    {
        "content": "<p>But again, I think it would be possible to define a well specified standard but allow non-deterministic access that relies on the underlying FS.</p>",
        "id": 214395934,
        "sender_full_name": "indolering",
        "timestamp": 1603494643
    },
    {
        "content": "<p>Could you describe your goal here in more detail?</p>",
        "id": 214396022,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494736
    },
    {
        "content": "<p>If you can assume an exclusive lock on the directory, then you should be able to enable case-folded lookups on that directory in Linux.  This is currently only working on EXT4 and F2FS but those efforts are very much intended to spread to the other Linux filesystems.</p>",
        "id": 214396024,
        "sender_full_name": "indolering",
        "timestamp": 1603494763
    },
    {
        "content": "<p>The filesystem is a global shared state, it helps if you can nail down its behavior as finely as possible.</p>",
        "id": 214396046,
        "sender_full_name": "indolering",
        "timestamp": 1603494801
    },
    {
        "content": "<p>My other big concern from earlier to preventing a standard which adopts case-sensitivity by default, as it's very hard to undo that choice later.</p>",
        "id": 214396104,
        "sender_full_name": "indolering",
        "timestamp": 1603494854
    },
    {
        "content": "<p>Does Linux have a way to lock directories?</p>",
        "id": 214396111,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603494867
    },
    {
        "content": "<p>As a usability engineer, we are often brought in waaaaay to late to make any changes.</p>",
        "id": 214396117,
        "sender_full_name": "indolering",
        "timestamp": 1603494877
    },
    {
        "content": "<p>I mean, through permissions.  But ~/.wine essentially assumes exclusive access and enables case-insensitivity on that directory.</p>",
        "id": 214396149,
        "sender_full_name": "indolering",
        "timestamp": 1603494918
    },
    {
        "content": "<p>If you have an implementation in mind, could you write up some pseudo-code for how, eg. creating a file, and listing the contents of a directory, would work?</p>",
        "id": 214396264,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495034
    },
    {
        "content": "<p>I don't, the simplest would be to create a sort order based on unicode codepoints.  But that is a basic sort.</p>",
        "id": 214396368,
        "sender_full_name": "indolering",
        "timestamp": 1603495144
    },
    {
        "content": "<p>AFAICT, EXT4, BTRFS, and F2FS all maintain a hashed filename index.  So it won't be sorted according to anything close to Unicode sort order, but still sorted.</p>",
        "id": 214396436,
        "sender_full_name": "indolering",
        "timestamp": 1603495214
    },
    {
        "content": "<p>So picking a specific ordering is one thing, yes, but I'm still trying to get a picture for what problem you're looking to solve, or which specific context you're looking to solve it in.</p>",
        "id": 214396449,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495233
    },
    {
        "content": "<p>The specific problem I'm looking to solve is serving up files from the FS in an order based on the filename, as opposed to insertion order in the b-tree.</p>",
        "id": 214396499,
        "sender_full_name": "indolering",
        "timestamp": 1603495321
    },
    {
        "content": "<p>Cool, and are you hoping to enable this for general-purpose use, or only within virtual filesystems and perhaps private-directory filesystems where we have exclusive access?</p>",
        "id": 214396572,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495389
    },
    {
        "content": "<p>Disorderfs is actually used by the reproducible build community to debug builds where the FS ordering of files creeps into build scripts.</p>",
        "id": 214396586,
        "sender_full_name": "indolering",
        "timestamp": 1603495409
    },
    {
        "content": "<p>The last two.</p>",
        "id": 214396593,
        "sender_full_name": "indolering",
        "timestamp": 1603495421
    },
    {
        "content": "<p>We could do general purpose, but I would just stub that code out and document how you would like it done.</p>",
        "id": 214396648,
        "sender_full_name": "indolering",
        "timestamp": 1603495449
    },
    {
        "content": "<p>Listing directories specific directories based on filename in a deterministic fashion is totally doable.</p>",
        "id": 214396660,
        "sender_full_name": "indolering",
        "timestamp": 1603495481
    },
    {
        "content": "<p>Emulating case-insensitivity on a case-sensitive filesystem can work well enough in 80</p>",
        "id": 214396716,
        "sender_full_name": "indolering",
        "timestamp": 1603495544
    },
    {
        "content": "<p>% of cases.</p>",
        "id": 214396720,
        "sender_full_name": "indolering",
        "timestamp": 1603495548
    },
    {
        "content": "<p>But it's always going to be slower, racy, and blow up in your face if you do something dumb like \"/foo/BAR/readme.txt\" and \"/foo/bar/readme.txt\"</p>",
        "id": 214396815,
        "sender_full_name": "indolering",
        "timestamp": 1603495630
    },
    {
        "content": "<p>I imagine for virtual-fs and private-directory cases we can case-fold the host files, so it'd work</p>",
        "id": 214396896,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495697
    },
    {
        "content": "<p>Perhaps we should discuss filename, encoding, and case-sensitivity and to what degree the API should enforce its opinions on everyone?</p>",
        "id": 214396901,
        "sender_full_name": "indolering",
        "timestamp": 1603495706
    },
    {
        "content": "<p>Are you venturing into the general-purpose side of things now?</p>",
        "id": 214396909,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495728
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 214396917,
        "sender_full_name": "indolering",
        "timestamp": 1603495736
    },
    {
        "content": "<p>My working assumption is that case-insensitivity is just \"whether and how it's done is nondeterministic\"</p>",
        "id": 214397006,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495821
    },
    {
        "content": "<p>in the general-purpose case</p>",
        "id": 214397014,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495832
    },
    {
        "content": "<p>and we just let whatever the host FS does shine through</p>",
        "id": 214397023,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495843
    },
    {
        "content": "<p>I don't think we can impose our invariants on the underlying filesystem without things breaking.</p>",
        "id": 214397044,
        "sender_full_name": "indolering",
        "timestamp": 1603495864
    },
    {
        "content": "<p>So agree there.</p>",
        "id": 214397050,
        "sender_full_name": "indolering",
        "timestamp": 1603495872
    },
    {
        "content": "<p>But I strongly disagree that we should fail if (as was suggested) the case differs from what was looked up.</p>",
        "id": 214397069,
        "sender_full_name": "indolering",
        "timestamp": 1603495900
    },
    {
        "content": "<p>Ah, interesting.</p>",
        "id": 214397120,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603495930
    },
    {
        "content": "<p>You are basically making the API opinionated in favor of case-sensitivity, which is not what end-users/consumers want.</p>",
        "id": 214397145,
        "sender_full_name": "indolering",
        "timestamp": 1603495972
    },
    {
        "content": "<p>And it's a nightmare to try and fix that choice later.</p>",
        "id": 214397150,
        "sender_full_name": "indolering",
        "timestamp": 1603495980
    },
    {
        "content": "<p>Have you seen sandboxfs?</p>",
        "id": 214397166,
        "sender_full_name": "indolering",
        "timestamp": 1603496005
    },
    {
        "content": "<p>Actually, let's shelf that for a minute.</p>",
        "id": 214397170,
        "sender_full_name": "indolering",
        "timestamp": 1603496018
    },
    {
        "content": "<p>shelve*</p>",
        "id": 214397172,
        "sender_full_name": "indolering",
        "timestamp": 1603496023
    },
    {
        "content": "<p>That \"check to see if the case differs\" is meant to avoid programs which accidentally depend on running on case-insensitive filesystems</p>",
        "id": 214397358,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496214
    },
    {
        "content": "<p>Your point seems to be \"case insensitive filesystems are The Path Forward\", so we should embrace them and not risk locking ourselves out of an all-case-insensitive future</p>",
        "id": 214397392,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496266
    },
    {
        "content": "<p>primarily-case-insensitive future.</p>",
        "id": 214397451,
        "sender_full_name": "indolering",
        "timestamp": 1603496295
    },
    {
        "content": "<p>I hadn't though of it like that</p>",
        "id": 214397452,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496296
    },
    {
        "content": "<p>But yeah, mostly.</p>",
        "id": 214397454,
        "sender_full_name": "indolering",
        "timestamp": 1603496298
    },
    {
        "content": "<p>I mean, people have scripts that work on OS X but fail on Linux because case suddenly matters.</p>",
        "id": 214397477,
        "sender_full_name": "indolering",
        "timestamp": 1603496330
    },
    {
        "content": "<p>What we might do, is have that check, but don't make it part of the WASI spec. Just make it a debugging feature that engines can optionally provide.</p>",
        "id": 214397578,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496435
    },
    {
        "content": "<p>What confuses me is that you are proposing normalizing all names to UTF-8, which is similar to case-folding in that the string used to lookup a file in a UCS-2 the language won't match the string returned as the filename.</p>",
        "id": 214397589,
        "sender_full_name": "indolering",
        "timestamp": 1603496453
    },
    {
        "content": "<p>assuming we do something like ARF strings or modified UTF8-C8, the differences is that the translation is reversible</p>",
        "id": 214397631,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496513
    },
    {
        "content": "<p>case-folding is lossy</p>",
        "id": 214397632,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496516
    },
    {
        "content": "<p>That's still pushing people to use case, which shouldn't matter.</p>",
        "id": 214397634,
        "sender_full_name": "indolering",
        "timestamp": 1603496519
    },
    {
        "content": "<p>For sure, but it will still require manual refactoring.</p>",
        "id": 214397682,
        "sender_full_name": "indolering",
        "timestamp": 1603496538
    },
    {
        "content": "<p>The theory with ARF strings is that <del>non-Unicode</del>ill-formed filenames are so rare that many programs wouldn't need to bother</p>",
        "id": 214397702,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496573
    },
    {
        "content": "<p>Also, if you are going to convert to UTF-8, are you also going to normalize to NFC?</p>",
        "id": 214397712,
        "sender_full_name": "indolering",
        "timestamp": 1603496588
    },
    {
        "content": "<p>Agreed.</p>",
        "id": 214397718,
        "sender_full_name": "indolering",
        "timestamp": 1603496599
    },
    {
        "content": "<p>No, I expect NFC/NFD is just \"whatever the host does\"</p>",
        "id": 214397731,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496615
    },
    {
        "content": "<p>Hrm.</p>",
        "id": 214397854,
        "sender_full_name": "indolering",
        "timestamp": 1603496756
    },
    {
        "content": "<p>This is a tad above my paygrade: my understanding is that <em>if you are going to mess with encoding, then you should probably do NFC too</em>.  &lt;- might be wrong.</p>",
        "id": 214397906,
        "sender_full_name": "indolering",
        "timestamp": 1603496795
    },
    {
        "content": "<p>arbitrary codepoint sequence -&gt; NFC or NFD is also lossy</p>",
        "id": 214397914,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496804
    },
    {
        "content": "<p>Basically, you have to do NFC or NFD if you want deterministic sort order.</p>",
        "id": 214397937,
        "sender_full_name": "indolering",
        "timestamp": 1603496857
    },
    {
        "content": "<p>NFD is faster, but doesn't match what most keyboards and applications do, so it makes it hard to find the file in the filesystem.  But since you don't care about re-encoding the file name....</p>",
        "id": 214397999,
        "sender_full_name": "indolering",
        "timestamp": 1603496903
    },
    {
        "content": "<p>in the general-purpose case, we can't prevent other processes from creating non-NFC or non-NFD names on hosts which don't enforce those</p>",
        "id": 214398026,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603496958
    },
    {
        "content": "<p>Linus hates this, it was seen as a mistake for HFS+ to do this, and that all filesystems should preserve encoding/case as the filename returned but store an NFD/NFC normalized filename in the metadata.</p>",
        "id": 214398029,
        "sender_full_name": "indolering",
        "timestamp": 1603496964
    },
    {
        "content": "<p>Okay, I actually agree we should go that way.</p>",
        "id": 214398094,
        "sender_full_name": "indolering",
        "timestamp": 1603497011
    },
    {
        "content": "<p>Alright, so I will post my concerns about blowing up when there is a case mismatch in that filename thread.</p>",
        "id": 214398123,
        "sender_full_name": "indolering",
        "timestamp": 1603497063
    },
    {
        "content": "<p>And post info about performance in the Gist I made.</p>",
        "id": 214398131,
        "sender_full_name": "indolering",
        "timestamp": 1603497071
    },
    {
        "content": "<p>Uhh, last thing I wanted to discuss: using FUSE/encryption to enforce access control and determinism.</p>",
        "id": 214398145,
        "sender_full_name": "indolering",
        "timestamp": 1603497096
    },
    {
        "content": "<p>Bazel created sandboxfs too speedup access-control permissions in builds.</p>",
        "id": 214398219,
        "sender_full_name": "indolering",
        "timestamp": 1603497167
    },
    {
        "content": "<p>I believe Apple uses encryption to enforce access control too, IIRC it gets as finely grained as append only writes.</p>",
        "id": 214398242,
        "sender_full_name": "indolering",
        "timestamp": 1603497198
    },
    {
        "content": "<p>That would also help with determinism.</p>",
        "id": 214398294,
        "sender_full_name": "indolering",
        "timestamp": 1603497244
    },
    {
        "content": "<p>Do you know of any literature that defines the limits of what encryption based ocap can do?</p>",
        "id": 214398346,
        "sender_full_name": "indolering",
        "timestamp": 1603497294
    },
    {
        "content": "<p>(to address your comment above, normalizing to NFC is worth considering, but in the general-purpose case we similarly run into O(2^N) situations where you have to check for all possible variations of non-normalized filenames created by other processes)</p>",
        "id": 214398422,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497375
    },
    {
        "content": "<p>At the level we're operating at right now, all encryption is \"the next level down\"</p>",
        "id": 214398437,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497416
    },
    {
        "content": "<p>Bits on disk are encrypted by the host's filesystem code, but that's all transparent outside of the kernel</p>",
        "id": 214398450,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497447
    },
    {
        "content": "<p>userspace never sees the encrypted bits, and the only security function the encryption serves is to foil attackers that can access the underlying storage media directly, which userspace can't do under normal circumstances</p>",
        "id": 214398571,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497597
    },
    {
        "content": "<p>capability-based security is about controlling what things you can ask for. The basic idea is that you're given handles, which are program values that you can pass around as arguments and return values and so on, that represent resources you have access to, instead of naming things with strings</p>",
        "id": 214398662,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497682
    },
    {
        "content": "<p><code>open(\"foo\", O_RDONLY)</code> plucks the name <code>foo</code> from thin air and requests access to it. This implies a global namespace in which the request can be resolved, which might have ACLs to govern access, but ACLs are awkward to manage in a bunch of ways.</p>",
        "id": 214398762,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497818
    },
    {
        "content": "<p>Yeah, I get that.  But I believe the original E language had some crypto capabilities built into it.</p>",
        "id": 214398848,
        "sender_full_name": "indolering",
        "timestamp": 1603497924
    },
    {
        "content": "<p>There is some research into using handles across networks.</p>",
        "id": 214398916,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603497984
    },
    {
        "content": "<p>And there are some researchers who would like to reduce the security of a lot of systems down to cryptographic primitives.</p>",
        "id": 214398918,
        "sender_full_name": "indolering",
        "timestamp": 1603497985
    },
    {
        "content": "<p>But out of scope, clearly.</p>",
        "id": 214398922,
        "sender_full_name": "indolering",
        "timestamp": 1603497992
    },
    {
        "content": "<p>The key property of handles is that you can't \"forge\" them, or obtain them without being explicitly given them. Within a single host, that's straightforward, but if you want to pass a handle to another host on the network, and they might pass it on to someone else, how do you ensure that noone can forge such a handle?</p>",
        "id": 214399030,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603498153
    },
    {
        "content": "<p>I don't have links handy, but there has been research along those lines</p>",
        "id": 214399180,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603498350
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 214399200,
        "sender_full_name": "indolering",
        "timestamp": 1603498405
    },
    {
        "content": "<p>The only comprehensive survey of capabilities I've seen are by the CHERI people, and they have formal models tying their capabilities to memory tagged hardware.  I'll go ask them about alternative modes of enforcement.</p>",
        "id": 214399257,
        "sender_full_name": "indolering",
        "timestamp": 1603498480
    },
    {
        "content": "<p>Okay, thanks dan!</p>",
        "id": 214399260,
        "sender_full_name": "indolering",
        "timestamp": 1603498483
    },
    {
        "content": "<p>yw!</p>",
        "id": 214399268,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603498503
    },
    {
        "content": "<p>Oh, Dan, it's not O(N^filename) runtime.</p>",
        "id": 214399958,
        "sender_full_name": "indolering",
        "timestamp": 1603499418
    },
    {
        "content": "<p>It's O(log files)</p>",
        "id": 214399959,
        "sender_full_name": "indolering",
        "timestamp": 1603499425
    },
    {
        "content": "<p>As you just get a list of all files in a directory and convert their names to the canonical casefolded name.</p>",
        "id": 214399974,
        "sender_full_name": "indolering",
        "timestamp": 1603499460
    },
    {
        "content": "<p>And do a compare.</p>",
        "id": 214399978,
        "sender_full_name": "indolering",
        "timestamp": 1603499464
    },
    {
        "content": "<p>You would only get exponential behavior if someone created a lot of directories with lots of cases, such as /foo/bar/baz/..., /Foo/bar/baz/..., /FOo/bar/baz.</p>",
        "id": 214400168,
        "sender_full_name": "indolering",
        "timestamp": 1603499666
    },
    {
        "content": "<p>Even then, if your goal is to create a lint, you would could just error when there are no exact case-sensitive matches but multiple case insensitive matches.</p>",
        "id": 214400260,
        "sender_full_name": "indolering",
        "timestamp": 1603499781
    },
    {
        "content": "<p>I am mildly perplexed by \"primarily case insensitive future\" because Mac and Windows both introduced the ability to make their file systems case sensitive, and I don't think it's any less troublesome going from case insensitive to case sensitive here.</p>",
        "id": 214794957,
        "sender_full_name": "Jubilee",
        "timestamp": 1603858598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"357097\">@indolering</span> If I need to create N files (suppose I'm unpacking an archive, compiling lots of source files to object files, etc.), and each time I create a file I have to scan the directory to see if there's a file with a case-folding-equivalent name, it goes O(N^2) in the number of files I'm creating</p>",
        "id": 214902513,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603922093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356464\">@Jubilee</span> My working ssumption is that WASI will end up saying that host fileystem directories can be either case-sensitive or insensitive, and we just expose that to applications as-is.</p>",
        "id": 214904700,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603923550
    },
    {
        "content": "<p>Applications will just need to avoid depending on either case sensitivity or case insensitivity if they want to be portable.</p>",
        "id": 214904743,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603923595
    },
    {
        "content": "<p>There may be some debugging facilities we can add to help applications catch mistakes, and I think the observation above is, we shouldn't make those features mandatory, because if filesystems do end up converging on case-insensitive, we don't want to be stuck with those debugging features forever.</p>",
        "id": 214905007,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1603923766
    },
    {
        "content": "<p>Mmm, that's reasonable I guess?! I will concede I myself genuinely don't see a reason that file systems should <em>be</em> case insensitive from a data perspective, as it makes it possible to trust an address that is not bit-equal to another address is in fact not the same address (modulo some canonicalization), and user-space can support case-insensitive comparisons where it makes sense just fine. But here I am extending more of a \"would-write-an-FS perspective\" than a \"would-like-to-solve-platform-compatibility-issues\" perspective, and so venturing a bit further afield from The Point. Aside from \"everyone should clearly adopt my perspective and then there would be no more compatibility issues\" which I recognize is in actuality a non-starter. :^)</p>",
        "id": 215156755,
        "sender_full_name": "Jubilee",
        "timestamp": 1604095893
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356464\">@Jubilee</span> 99% of users on an OS with a filesystem that is case-insensitive by default.</p>",
        "id": 215265399,
        "sender_full_name": "indolering",
        "timestamp": 1604269295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254083\">@Dan Gohman</span>  I think there is a miscommunication WRT operating modes and error handling.</p>",
        "id": 215265781,
        "sender_full_name": "indolering",
        "timestamp": 1604269875
    },
    {
        "content": "<p>I heard somewhere that, among developers, it's much more evenly split between Linux, Windows, and macOS (about 1/3 for each). Nearly all Linux OSes are case-sensitive by default.</p>",
        "id": 215265838,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1604269940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315881\">@Jacob Lifshay</span> True, lots of server-side stuff is going to run on case-sensitive filesystems by default.  That being said, at least on Stack Overflow, Linux devs are out-numbered 3:1.</p>",
        "id": 215265996,
        "sender_full_name": "indolering",
        "timestamp": 1604270197
    },
    {
        "content": "<p><a href=\"https://insights.stackoverflow.com/survey/2020#technology-developers-primary-operating-systems\">https://insights.stackoverflow.com/survey/2020#technology-developers-primary-operating-systems</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://insights.stackoverflow.com/survey/2020#technology-developers-primary-operating-systems\" style=\"background-image: url(https://cdn.sstatic.net/insights/Img/Survey/2020/devsurvey2020-og.png?v=b8ce57e10a52)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://insights.stackoverflow.com/survey/2020#technology-developers-primary-operating-systems\" title=\"Stack Overflow Developer Survey 2020\">Stack Overflow Developer Survey 2020</a></div><div class=\"message_embed_description\">Nearly 65,000 took this comprehensive, annual survey of people who code. Demographics. Most loved, dreaded and wanted technologies. Salary and careers.</div></div></div>",
        "id": 215265998,
        "sender_full_name": "indolering",
        "timestamp": 1604270198
    },
    {
        "content": "<p>I also think that for all of the wailing and gnashing of teeth, distros will eventually switch to case-insensitive by default.  At least for home directories.</p>",
        "id": 215266016,
        "sender_full_name": "indolering",
        "timestamp": 1604270248
    },
    {
        "content": "<p>That being said, I believe that virtually every filesystem allows for setting this behavior on a per-directory basis.</p>",
        "id": 215266029,
        "sender_full_name": "indolering",
        "timestamp": 1604270280
    },
    {
        "content": "<p>My main concern was that the tickets I read were suggesting fail fast on case-insensitive filesystems.  That's a mistake.</p>",
        "id": 215266205,
        "sender_full_name": "indolering",
        "timestamp": 1604270466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356464\">@Jubilee</span> The web is case-insensitive: a domain name is basically a pointer to a server and paths are basically case-insensitive lookups on a filesystem.</p>",
        "id": 215266376,
        "sender_full_name": "indolering",
        "timestamp": 1604270735
    },
    {
        "content": "<p>From a security and reproducibility perspective, you want to minimize the impedance mismatch between the client and the host.</p>",
        "id": 215266436,
        "sender_full_name": "indolering",
        "timestamp": 1604270827
    },
    {
        "content": "<p>From a data-perspective, we definitely want valid UTF-8 right?</p>",
        "id": 215266624,
        "sender_full_name": "indolering",
        "timestamp": 1604271105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356464\">@Jubilee</span> Sorry, I'll stop hammering you.  I'm writing another ticket right now and my thought streams are crossing :P</p>",
        "id": 215266691,
        "sender_full_name": "indolering",
        "timestamp": 1604271177
    },
    {
        "content": "<p><a href=\"/user_uploads/15107/WDm1QElom5K-QBWA0qwateZZ/image.png\">image.png</a> &lt;img src=\"<a href=\"http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg?1501582414\">http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg?1501582414</a>\" alt=\"Picture\"/&gt;</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/WDm1QElom5K-QBWA0qwateZZ/image.png\" title=\"image.png\"><img src=\"/user_uploads/15107/WDm1QElom5K-QBWA0qwateZZ/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg?1501582414\"><img src=\"https://uploads.zulipusercontent.net/3d237d71806971dabb0a7c62a683b9a1bd5d2941/687474703a2f2f616c696e6b656e2e70656f706c652e75612e6564752f75706c6f6164732f382f372f392f322f38373932393639302f7075626c69736865642f67686f7374627573746572732e6a70673f31353031353832343134\"></a></div>",
        "id": 215266703,
        "sender_full_name": "indolering",
        "timestamp": 1604271202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"357097\">@indolering</span> That is not true anymore, and has not been for a long time.<br>\niOS and Android OS use primarily case sensitive FS while supporting operations on case-insensitive FS for back-compat and with many applications exposing case-insensitive functionality.<br>\ni.e. my preferred scheme.<br>\nAs far as the web goes, not all servers implement those accesses as case insensitive, and of those which do, they commonly involve a redirect to a canonical version. It took... 3 tries? to find a case-sensitive access that fails without a redirect.</p>",
        "id": 215266991,
        "sender_full_name": "Jubilee",
        "timestamp": 1604271675
    },
    {
        "content": "<p>( the first hardly counts, since I was just doublechecking against my memory of domain names being case insensitive. )</p>",
        "id": 215267057,
        "sender_full_name": "Jubilee",
        "timestamp": 1604271756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"357097\">indolering</span> <a href=\"#narrow/stream/206238-general/topic/Determinism.2FReproducibility/near/215266376\">said</a>:</p>\n<blockquote>\n<p>The web is case-insensitive: a domain name is basically a pointer to a server and paths are basically case-insensitive lookups on a filesystem.</p>\n</blockquote>\n<p>DNS is case insensitive (but only for ASCII I think -- IIRC punycode doesn't do any case folding before encoding). Most servers run Linux with case-sensitive filesystems, so I'd expect the other parts of a url to be usually case sensitive.</p>",
        "id": 215267228,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1604272021
    },
    {
        "content": "<p>From a security perspective, the fact that I can write the link <a href=\"https://googIe.com\">https://googIe.com</a> and it does not go to the same place as <a href=\"https://google.com\">https://google.com</a> is a source of endless phishing tech, so no, you may consider me suitably skeptical that even exposing case insensitivity to a user serves their security that much.</p>\n<p>And from a data perspective an address can be raw bytes for all I care (and still must, because not all OS enforce UTF-8 path validity!). File systems should cast their eye to living a life longer than an encoding scheme. It's, again, userspace's job to make it intelligible in my opinion. Sometimes an impedance mismatch is simply why we have software.</p>",
        "id": 215267619,
        "sender_full_name": "Jubilee",
        "timestamp": 1604272600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"356464\">@Jubilee</span> FWIW, WASI-filesystem is expected to use UTF-8 paths. The \"filenames are just bytes\" strategy was practical in its day, but with UTF-8 the practicalities line up very differently.</p>",
        "id": 215270468,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1604277388
    },
    {
        "content": "<p>I stand corrected: path handling is case preserving and server/filesystem dependent, but Linux of course defaults to case sensitive matching.  I guess I was in DNS land for too long!</p>\n<ul>\n<li>DNS labels are case-insensitive, even i18n ones (punycode case-folds everything).</li>\n<li>Android sdcard access has historically provided case-insensitive lookups, but case-insensitive FS semantics are now enforced using F2FS.  The stock file manager on my Pixel defaults to case-insensitive behavior, even for internal storage.</li>\n<li>Google Drive is case sensitive.</li>\n<li>iOS is case sensitive, but both iCloud and APFS on OS X default to case insensitive semantics.  I do not have an iOS device to test whether the filesystem manager attempts to enforce case-insensitive behavior (as I suspect my Files app is doing).</li>\n</ul>",
        "id": 215270472,
        "sender_full_name": "indolering",
        "timestamp": 1604277395
    },
    {
        "content": "<p>I mean, from the perspective of usability (carrying out end-user intent) and enforcing a single namespace in the filesystem, you want the lowest common denominator normalization (NFKD casefold) so that an attacker can't do something like store a ligature ℀ which some server or client could NFKD into a filename path.</p>",
        "id": 215270889,
        "sender_full_name": "indolering",
        "timestamp": 1604278129
    },
    {
        "content": "<p>And the only way to be <em>sure</em> you don't accidentally allow two unicode strings that normalize into some other unicode string is at the filesystem level.</p>",
        "id": 215270972,
        "sender_full_name": "indolering",
        "timestamp": 1604278218
    },
    {
        "content": "<p>But yeah, I also don't want some firewall allowlist filter to be bypassed because filename lookups are case/normalization insensitive.</p>",
        "id": 215270998,
        "sender_full_name": "indolering",
        "timestamp": 1604278282
    },
    {
        "content": "<p>Oh yes, I expect WASI to use UTF-8 because that is more sensible for WASI's purposes than letting someone decide the next UTF-16 is a good idea.</p>",
        "id": 215272395,
        "sender_full_name": "Jubilee",
        "timestamp": 1604280554
    },
    {
        "content": "<p>But that already involves hitting a translation layer between existing systems and WASI, from my perspective, and at that point where the translation layer exists is subject to some negotiation (since it is, as it were, already a negotiation). But it's slightly more audacious to reformat a user's hard drive than to replace the user's kernel, which is what drives my sentiments regarding where such canonicalization \"belongs\".</p>",
        "id": 215272993,
        "sender_full_name": "Jubilee",
        "timestamp": 1604281571
    },
    {
        "content": "<p>I like how you put it -- a \"negotiation\" describes it well.</p>",
        "id": 215274126,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1604283553
    },
    {
        "content": "<p>Agreed!  Determinism can only be enforced if WASI can assume exclusive control at the FS level (akin to WINE setting case-insensitive behavior on <code>~/.wine/</code>).</p>",
        "id": 215275123,
        "sender_full_name": "indolering",
        "timestamp": 1604285376
    },
    {
        "content": "<p>And a runtime can chose a fast/sloppy implementation that relies on whatever the filesystem does, which should work with 95% of real-world filenames.  If you want a truly deterministic filesystem, then you probably want to do something with FUSE or VFS (I suspect some Unicode compression/transliteration scheme could fit 99% of real-world filenames into the Posix portable filename subset, which is available on virtually every platform).</p>",
        "id": 215275412,
        "sender_full_name": "indolering",
        "timestamp": 1604285857
    },
    {
        "content": "<p>Just checked a iPod touch and the filesystem UI won't let me create two folders that differ in case.  So <em>for users</em> iOS is case-insensitive.  As iCloud enforces case-insensitivity, I would be surprised if Apple doesn't switch iOS to case-insensitive behavior as well.</p>",
        "id": 215515134,
        "sender_full_name": "indolering",
        "timestamp": 1604440835
    },
    {
        "content": "<p>But maybe the API should error out by default if the filename isn't an exact match, just as long as WASI can adapt to the underlying filestore in an ergonomic fashion.</p>",
        "id": 215517485,
        "sender_full_name": "indolering",
        "timestamp": 1604442389
    },
    {
        "content": "<p>If we have exclusive access to a directory (akin to Android, iOS, Flatpak, etc) then I would default to the lowest-common-denominator, so that everything \"just works\" regardless of the case or normalization conventions of the FS.  But I need to do a review of all the issues with IDNA, Stringprep, and the i18n filesystem RFCs first.</p>",
        "id": 215521679,
        "sender_full_name": "indolering",
        "timestamp": 1604444311
    },
    {
        "content": "<p>Does anyone have experience with/thoughts on <a href=\"https://tools.ietf.org/html/rfc8264#section-5.2.4\">PRECIS</a>?  It's the IETF followup to the Stringprep algorithm.</p>",
        "id": 215635234,
        "sender_full_name": "indolering",
        "timestamp": 1604520745
    },
    {
        "content": "<p>Do you know if there are any filesystems which do case-sensitive lookups, but still prevent creating files that differ only in case?</p>",
        "id": 215657491,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1604535068
    },
    {
        "content": "<p>Not off the top of my head.  However, if a file has a non-normalized name, Linux falls back to using the bytestring as an opaque identifier.</p>",
        "id": 215663334,
        "sender_full_name": "indolering",
        "timestamp": 1604540969
    },
    {
        "content": "<p>FWIW, I am planning on documenting this behavior (with functional testing) in a git repo at some point.</p>",
        "id": 215663446,
        "sender_full_name": "indolering",
        "timestamp": 1604541089
    },
    {
        "content": "<p>I need to nail down the behavior of how filenames are handled across platforms and  I'm at the point where I need to start testing.  I don't know if this work will be upstreamed, but is there an infrastructure preference WRT functional testing and virtual machines?</p>",
        "id": 215922109,
        "sender_full_name": "indolering",
        "timestamp": 1604709933
    }
]