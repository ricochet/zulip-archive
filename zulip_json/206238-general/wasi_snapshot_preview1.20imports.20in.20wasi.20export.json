[
    {
        "content": "<p>I've written a basic rust lib with an exported function, and compiled it to wasm32-wasi with crate-type set to <code>cdylib</code>.<br>\nAnd from another Rust crate, I'm trying to load this wasm module with wasmtime, and instantiate the exported function, though it gives an error \"expected 4 imports, found 0\".</p>\n<p>When I inspect the wasm file to wat, I see that there are 4 imports defined:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"s\">\"wasi_snapshot_preview1\"</span><span class=\"w\"> </span><span class=\"s\">\"fd_write\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$wasi_snapshot_preview1</span><span class=\"p\">.</span><span class=\"n\">fd_write</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"cp\">$t6</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"s\">\"wasi_snapshot_preview1\"</span><span class=\"w\"> </span><span class=\"s\">\"environ_get\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$wasi_snapshot_preview1</span><span class=\"p\">.</span><span class=\"n\">environ_get</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"cp\">$t5</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"s\">\"wasi_snapshot_preview1\"</span><span class=\"w\"> </span><span class=\"s\">\"environ_sizes_get\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$wasi_snapshot_preview1</span><span class=\"p\">.</span><span class=\"n\">environ_sizes_get</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"cp\">$t5</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"s\">\"wasi_snapshot_preview1\"</span><span class=\"w\"> </span><span class=\"s\">\"proc_exit\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$wasi_snapshot_preview1</span><span class=\"p\">.</span><span class=\"n\">proc_exit</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"cp\">$t0</span><span class=\"p\">)))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I understand that I could define these functions and provide them as imports when instantiating the module, but I'm wondering if wasmtime provides any default imports for these common functions so I don't have to figure out the code for fd_write, environ_get, etc.?</p>",
        "id": 308790909,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668001909
    },
    {
        "content": "<p>Oh I just came across the wasi crate.<br>\nThough, is there any examples on integrating this with wasmtime?</p>",
        "id": 308796024,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668003432
    },
    {
        "content": "<p>I'm almost there.<br>\nI've found the <code>wasmtime_wasi::add_to_linker</code>, but I'm just trying to figure out how to make the <code>WasiCtx::new</code>. All I've managed to create is the Rng with <code>Box::new(OsRng)</code>.</p>",
        "id": 308799578,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668004403
    },
    {
        "content": "<p>e.g. <code>WasiCtxBuilder::new().arg(\"&lt;wasm module&gt;\")?.build()</code></p>",
        "id": 308799783,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668004443
    },
    {
        "content": "<p>See <a href=\"https://docs.rs/wasmtime-wasi/2.0.1/wasmtime_wasi/sync/struct.WasiCtxBuilder.html\">https://docs.rs/wasmtime-wasi/2.0.1/wasmtime_wasi/sync/struct.WasiCtxBuilder.html</a> for full docs.</p>",
        "id": 308800028,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668004511
    },
    {
        "content": "<p>Ohh, I didnt see that!<br>\nWhat is <code>.arg(\"&lt;wasm module&gt;\")</code> for examle? Is it needed?</p>",
        "id": 308800049,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668004517
    },
    {
        "content": "<p>I just pasted that from some code I wrote a while ago.  Probably not needed unless your module expects at least one argv value.</p>",
        "id": 308800259,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668004565
    },
    {
        "content": "<p>Doesn't look like yours uses WASI arguments at all, so not relevant.</p>",
        "id": 308800368,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668004601
    },
    {
        "content": "<p>This should probably be another topic post, but I'll just ask here.</p>\n<p>I'm trying to define a function in my Rust wasm lib which will eventually be Vec&lt;u8&gt;, but since its wasm, I'm taking in offset and length:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">offset</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{id_offset} {id_len}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And from my wasmtime, I have written to the memory some random bytes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_memory</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">])</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// write 0, 1, 2</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_typed_func</span>::<span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"new\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">new</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">))</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But now my question is, how do I actually read this memory from my new fn? I can print the offset and length correctly, but I don't know how to read my own wasm memory from the Rust file which is compiled.</p>",
        "id": 308803214,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668005393
    },
    {
        "content": "<p>I think you'll need to cast <code>offset</code> to a <code>const u8*</code> and then use e.g. <code>https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html</code> to produce a <code>&amp;[u8]</code>.</p>",
        "id": 308804446,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668005719
    },
    {
        "content": "<p>I'd be pretty nervous about writing to guest memory like that without involving the guest allocator, though.</p>",
        "id": 308804774,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668005801
    },
    {
        "content": "<p>Ohh, so this approach isn't really correct? I should be using some kind of allocator?<br>\nI saw in the docs for wasmtime memory, the only option really is <code>.write()</code></p>",
        "id": 308805261,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668005933
    },
    {
        "content": "<p>The usual approach is to export some equivalent of <code>malloc</code> from the guest which the host can use to allocate a destination for writes</p>",
        "id": 308805710,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668006047
    },
    {
        "content": "<p>Ah okay, I've just come across this:<br>\n&lt;<a href=\"https://radu-matei.com/blog/practical-guide-to-wasm-memory/\">https://radu-matei.com/blog/practical-guide-to-wasm-memory/</a>&gt;</p>\n<p>I thought Rust would already export something like this for you, but I guess not</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://radu-matei.com/blog/practical-guide-to-wasm-memory/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/98f3a46af15d1cbb6300c1db78743909925ad753\\/68747470733a2f2f7777772e67726176617461722e636f6d2f6176617461722f37623335636331653739613462353635313739313938383461396561363066323f733d323536)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://radu-matei.com/blog/practical-guide-to-wasm-memory/\" title=\"A practical guide to WebAssembly memory - radu's blog\">A practical guide to WebAssembly memory - radu's blog</a></div><div class=\"message_embed_description\">Memory in WebAssembly is one of the topics that creates confusion for newcomers, particularly for those with experience in languages with memory management features like garbage collection, such as JavaScript, Go, or Java. In this article we explore using memory in WebAssembly in various scenarios - passing JavaScript arrays to Rust and AssemblyScript modules, checking for some basic memory leaks using Valgrind, or exchanging strings between runtimes and modules using Wasmtime.</div></div></div>",
        "id": 308805907,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668006105
    },
    {
        "content": "<p>Depending on your specific situation you could possibly export some other kind of pointer from the guest like a statically allocated buffer, but then you take responsibility for managing that</p>",
        "id": 308806029,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668006131
    },
    {
        "content": "<p>Hmm, when I define my function to take a Rust type, such as String:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It produces this wat code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$new</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span> <span class=\"cp\">$t0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"cp\">$p0</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is there anywhere I can read up on what this param is? Is it just a pointer to the string?</p>",
        "id": 308809464,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668007181
    },
    {
        "content": "<p>The rust abi is unstable. If you want to export a function from the wasm module you will have to use <code>#[no_mangle] extern \"C\" fn new</code>. You also can't use <code>String</code> as it has an unstable layout. Using <a href=\"https://github.com/bytecodealliance/wit-bindgen/\">wit-bindgen</a> is probably the easiest way for exporting an interface from wasm that uses non-primitive types like strings.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/\" style=\"background-image: url(https\\:\\/\\/uploads\\.zulipusercontent\\.net\\/401a858b8685cc69f63b2fb42d1658c4a101d43c\\/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353139346266643662626366346261613965656439626262636664613735386366366532393638613962396561383832366162623336303230393139633438372f62797465636f6465616c6c69616e63652f7769742d62696e6467656e)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/\" title=\"GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types\">GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - bytecodealliance/wit-bindgen: A language binding generator for WebAssembly interface types</div></div></div>",
        "id": 308812427,
        "sender_full_name": "bjorn3",
        "timestamp": 1668007980
    },
    {
        "content": "<p>Thanks! I'm looking into <code>&amp;str</code> now since it's just a pointer and a length.<br>\nWhen invoking the function, I'm sending:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// arbitrary</span>\n<span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">b\"hey\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">data_ptr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_typed_func</span>::<span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"new\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">new</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">))</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But I get an error of out of bounds memory access. </p>\n<p>Is <code>memory.data_ptr()</code> the right method to get the start address of the memory?</p>",
        "id": 308813140,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668008173
    },
    {
        "content": "<p>The guest code sees its own linear memory starting at zero</p>",
        "id": 308814728,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668008650
    },
    {
        "content": "<p>From the guest's point of view, memory starts at zero, so <code>base</code> should be 128.  Note that since you didn't ask the guest to allocate memory you're using, you're clobbering whatever was already at that address, with unpredictable consequences.</p>",
        "id": 308814759,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668008661
    },
    {
        "content": "<p>I see, though I'm only calling an exported function which should have no side effects. So I'd assume the memory would be compleltely empty the first time I invoke any function <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 308815165,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668008780
    },
    {
        "content": "<p>Oh I actually got it working!</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">8_</span><span class=\"k\">i32</span><span class=\"p\">.</span><span class=\"n\">to_le_bytes</span><span class=\"p\">().</span><span class=\"n\">to_vec</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"mi\">3_</span><span class=\"k\">i32</span><span class=\"p\">.</span><span class=\"n\">to_le_bytes</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"s\">b\"Hey\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_typed_func</span>::<span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"new\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">new</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 308815371,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668008847
    },
    {
        "content": "<blockquote>\n<p>I'd assume the memory would be compleltely empty the first time I invoke any function</p>\n</blockquote>\n<p>Depends on the source language/runtime. Almost all languages will stick <em>something somewhere</em> on startup, at least in some contexts</p>",
        "id": 308815710,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668008938
    },
    {
        "content": "<p>Since:</p>\n<ul>\n<li>I know exactly what functions are exported, and their types.</li>\n<li>The wasm will always come from Rust (for now).<br>\nI think it's worth doing this approach for the sake of avoiding having to export an allocator, and writing glue code</li>\n</ul>",
        "id": 308816035,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668009034
    },
    {
        "content": "<p>Though, I realise Rust didn't compile for that &amp;str to be there, so when I write new memory, it could overwrite the memory of the string I guess...</p>",
        "id": 308816235,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668009098
    },
    {
        "content": "<p>Also note that even a Rust function with no side effects and no explicit allocations may use the \"shadow\" stack, which lives on the heap, so you may find that whatever you write to memory gets clobbered once the function is run.</p>",
        "id": 308816373,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668009130
    },
    {
        "content": "<p>And statically allocated data goes in the linear memory too. You really don't want to do it that way.</p>",
        "id": 308816604,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668009202
    },
    {
        "content": "<p>It is possible to write a Rust guest that never touches memory, but it's surprisingly difficult and limiting.</p>",
        "id": 308816913,
        "sender_full_name": "Joel Dice",
        "timestamp": 1668009297
    },
    {
        "content": "<p>My guest will always export only these 3 basic functions:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">name</span>: <span class=\"nb\">String</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">apply</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">state</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">event</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">handle</span><span class=\"p\">(</span><span class=\"n\">state</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">command</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>What if I export some static buffers for this instead of the parameters?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">PARAM_1</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"p\">];</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Would something like this work fine?</p>",
        "id": 308817313,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668009428
    },
    {
        "content": "<p>It should. You'll have to beware buffer overflows</p>",
        "id": 308818598,
        "sender_full_name": "Lann Martin",
        "timestamp": 1668009802
    },
    {
        "content": "<p>Sounds like a nice solution then!<br>\nI can make some macros <code>#[new]</code>, <code>#[apply]</code>, and <code>#[handle]</code> which declare these statics and transform the bytes into the correct types.</p>",
        "id": 308818801,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668009856
    },
    {
        "content": "<p>still it would be strongly suggested to write those 3 functions with wit files, it will continue to work if the standard evolves</p>",
        "id": 308818849,
        "sender_full_name": "Ramon Klass",
        "timestamp": 1668009875
    },
    {
        "content": "<p>I realised this gets complicated if I want to take a parameter of <code>state: Vec&lt;u8&gt;</code>, since state could become arbitrarily large.</p>",
        "id": 308822080,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668010884
    },
    {
        "content": "<p>I'm trying to use wit-bindgen to compile a gust module from Rust, and run it in a host with wasmtime.</p>\n<p>My guest code uses:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wit_bindgen_guest_rust</span>::<span class=\"n\">generate</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">name</span>: <span class=\"s\">\"module\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">export</span>: <span class=\"s\">\"module.wit\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n\n<span class=\"n\">export_module</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">MyModule</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">MyModule</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">module</span>::<span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyModule</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And I compile it to wasm32-wasi.</p>\n<p>Then on the host side, I'm trying to use:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wit_bindgen_host_wasmtime_rust</span>::<span class=\"n\">generate</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">name</span>: <span class=\"s\">\"module\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">import</span>: <span class=\"s\">\"module.wit\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">ModuleHandler</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">module</span>::<span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ModuleHandler</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Module</span>::<span class=\"n\">from_file</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">module</span>::<span class=\"n\">add_to_linker</span>::<span class=\"o\">&lt;</span><span class=\"n\">Data</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">cx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">module_handler</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cm\">/* ... */</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Though my first problem came when it was complaining that my linker is from <code>wasmtime::Linker</code>, and it wanted <code>wasmtime::component::Linker</code>.</p>\n<p>So I changed my items to use exports from <code>wasmtime::component::{...}</code>, but when running my code I get the error:</p>\n<blockquote>\n<p>Error: failed to parse WebAssembly module</p>\n<p>Caused by:<br>\n    attempted to parse a wasm module with a component parser</p>\n</blockquote>",
        "id": 308916581,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668053645
    },
    {
        "content": "<p>I'm quite confused why I'd need to implement a trait when I'm importing too. I would expect it would be something just like <code>module::new(&amp;instance, \"param\".to_string());</code></p>",
        "id": 308917518,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668054351
    },
    {
        "content": "<p>Do I need to compile my guest rust to wasm in a different way to make it a \"component\"?<br>\nAny help would be appreciated, I cant figure this out at all</p>",
        "id": 308918565,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668055287
    },
    {
        "content": "<p>Okay I've discovered the wit-component cli. But when trying to use it to convert my wasm file, I get this error:</p>\n<blockquote>\n<p>module requires an import interface named <code>wasi_snapshot_preview1</code></p>\n</blockquote>",
        "id": 308919893,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668056437
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"err\">‚ùØ</span><span class=\"w\"> </span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">counter</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">adapt</span><span class=\"w\"> </span><span class=\"o\">../../../../</span><span class=\"n\">bytecodealliance</span><span class=\"o\">/</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">wasi_snapshot_preview1</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"mi\">2022</span><span class=\"o\">-</span><span class=\"mi\">11</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"n\">T05</span>:<span class=\"mi\">09</span>:<span class=\"mi\">10</span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">ERROR</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"o\">/</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">wasm32</span><span class=\"o\">-</span><span class=\"n\">wasi</span><span class=\"o\">/</span><span class=\"n\">release</span><span class=\"o\">/</span><span class=\"n\">counter</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"err\">`</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n        <span class=\"mi\">0</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">adapter</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">its</span><span class=\"w\"> </span><span class=\"n\">minimal</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"mi\">1</span>: <span class=\"nc\">locally</span><span class=\"o\">-</span><span class=\"n\">defined</span><span class=\"w\"> </span><span class=\"n\">memories</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">local</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 308920669,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668056989
    },
    {
        "content": "<p>I got it working by compiling things with rustflags. Though now I'm trying to figure out why it says:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Error</span>: <span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">parse</span><span class=\"w\"> </span><span class=\"n\">WebAssembly</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"></span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span>:\n    <span class=\"nc\">WebAssembly</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"n\">model</span><span class=\"w\"> </span><span class=\"n\">feature</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">enabled</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 308923324,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668058691
    },
    {
        "content": "<p>I got it all working in the end :)</p>",
        "id": 308926684,
        "sender_full_name": "Ari Seyhun",
        "timestamp": 1668061242
    }
]