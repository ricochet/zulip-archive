[
    {
        "content": "<p>Hey everyone!</p>\n<p>I've been reading <strong>A LOT</strong> of spec / explainers this week-end (yes. I have fun week-ends <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>): core wasm, canonical ABI, started the Async explainer, a lot of <a href=\"https://github.com/WebAssembly/memory-control/tree/main\">memory-control proposals</a> since I am trying to deepen my knowledge of the eco-system.</p>\n<p>It seems really fair to say that the community went way further with WebAssembly than what it has been made for initially (i.e. the \"Web\"). So I tried to establish a cognitive model of how is the broader eco-system governed. IIUC:</p>\n<p>W3C &gt; WebAssembly WG &gt; WebAssembly Community Groups.</p>\n<p>Then, the Bytecode Alliance position itself like:</p>\n<blockquote>\n<p>The Bytecode Alliance is focused on creating a shared implementation of standards produced by the WebAssembly CG and other standardization bodies.</p>\n</blockquote>\n<p><strong>(1) So the BA is independent from the aforementioned structure right?</strong></p>\n<p>Then, another question came up to my mind while reading the <a href=\"https://www.w3.org/2023/wasm-wg-charter.html\">WebAssembly WG Charter</a>, namely:</p>\n<blockquote>\n<p>The <strong>mission</strong> of the <a href=\"https://www.w3.org/groups/wg/wasm/\">WebAssembly Working Group</a> is to standardize a size-efficient, load-time-efficient format and execution environment — allowing compilation to the web with consistent behavior across a variety of implementations.</p>\n</blockquote>\n<p>This definition seems to exclude out-of-the-web use-cases, so It would be legitimate for the WG to consider some proposal out-of-scope and refuse changes to the instruction set or other \"feature\" of Core WebAssembly, right? So, while it seems unlikely, and clearly not something any of us want, <strong>(2) is it theoretically possible that one day out-of-the-browser users like us end-up diverging from Core WebAssembly, because they need something out of the scope of the WebAssembly WG \"mandate\"</strong>?</p>\n<p>(That's just dumb questions trying to understand how to picture the ecosystem today)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/memory-control/tree/main\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/be9bd3fdcc87885e325c813b56657e9d0f902b15/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f663030623133663336326264613235363434393834633962356464383337316466623632656531346361616336366635363134616436333761666364646333312f576562417373656d626c792f6d656d6f72792d636f6e74726f6c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/memory-control/tree/main\" title=\"GitHub - WebAssembly/memory-control: A proposal to introduce finer grained control of WebAssembly memory.\">GitHub - WebAssembly/memory-control: A proposal to introduce finer grained control of WebAssembly memory.</a></div><div class=\"message_embed_description\">A proposal to introduce finer grained control of WebAssembly memory. - WebAssembly/memory-control</div></div></div>",
        "id": 489227879,
        "sender_full_name": "raskyld",
        "timestamp": 1734353490
    },
    {
        "content": "<p>The BA is indeed independent of W3C and is not responsible for the governance of wasm. Many of us participate in the governance bodies but do so in a capacity no different from other CG members at other organizations/companies.</p>\n<p>As for out-of-browser usage, I can't speak for others but in my experience the CG well understands that the web isn't the only use case for wasm. I don't know the origins of that language in the charter and I naturally can't predict if it'll be weaponized in the future.</p>",
        "id": 489274447,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1734364716
    },
    {
        "content": "<p>The W3C is a venue for <em>standardization</em> and Wasm is spec'd and standardized under its umbrella.</p>\n<p>The BA is a venue for collaborating on <em>implementation</em> among like-minded folks in order to further a <a href=\"https://bytecodealliance.org/about#mission\">common mission</a>.</p>\n<p>The BA is indeed independent from the W3C, although many of us in the BA participate in the W3C standardization process, as Alex mentioned.</p>\n<blockquote>\n<p>is it theoretically possible that one day out-of-the-browser users like us end-up diverging from Core WebAssembly, because they need something out of the scope of the WebAssembly WG \"mandate\"?</p>\n</blockquote>\n<p>It is theoretically possible, but unlikely because no one is incentivized to do so long-term. First, as Alex mentioned, there Wasm standards group understands that Wasm is not just the Web at this point and they see the investment that non-Web folks make in things like shared tooling and language toolchains. Second, the outside-the-Web folks also generally realize that the reason that Wasm enjoys its current popularity is largely because of the Web, and that without the Web and Web folks' contributions to shared tooling, it wouldn't succeed. For example, adding and maintaining an LLVM backend is a lot of work in the first place, but it is also not clear that LLVM would even <em>want</em> to have an official backend for some random bytecode (which is what a non-Web fork of core Wasm would be) and the LLVM backend is really what props up the whole ecosystem.</p>\n<p>Finally, and we are getting further into my own personal speculation here, I think core Wasm's evolution is going to start largely slowing down. With stack switching, we are getting the last bits of control flow that was missing and impossible to implement efficiently without language support. With Wasm GC we are getting runtime-managed types. There are always going to be some new instructions to get more efficient code generation here and there, as well as extensions and generalizations of things that it already has (like richer GC stuff), but there really isn't much more stuff that core Wasm is fundamentally missing. Most of the evolution will be at the levels that are layered on top of core Wasm, like the component model, WASI, and Web/JS integration APIs.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://bytecodealliance.org/about#mission\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/b666ca74a20745aca2566cd241108afdcfa09d04/68747470733a2f2f62797465636f6465616c6c69616e63652e6f72672f696d616765732f6176617461722e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://bytecodealliance.org/about#mission\" title=\"Bytecode Alliance\">Bytecode Alliance</a></div><div class=\"message_embed_description\">Welcome to the Bytecode Alliance</div></div></div>",
        "id": 489287091,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1734367759
    },
    {
        "content": "<p>Thanks a lot for clarifications!</p>\n<p>It's funny you mention the \"end of wasm core evolution\" I was exactly wondering, while reading all those proposals and specs, where should Core Wasm stop and upper layers begin?</p>\n<p>The way I picture it in my head for now is that Core Wasm only covers feature you reasonably can expect of an ISA for a modern platform, and then the CM comes as a layer on top of that just as a kernel would. (yeah it's probably a really dumb way to see things but that somehow help me to picture if something should be Core Wasm or CM <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> )</p>",
        "id": 489314561,
        "sender_full_name": "raskyld",
        "timestamp": 1734374332
    },
    {
        "content": "<p>One distinction that might help clarify the line is between ISAs and ABIs. You can think of the Component Model, very roughly, as a set of standardized conventions to take higher-level types, interfaces, etc. down to Wasm primitives, and allow interop at a semantic level closer to source languages. Just as the SysV ABI (for example) allows separately-compiled C++ compilation units/shared libraries/... to talk in terms of classes, virtual methods, and the like. One wouldn't want to bake the ABI into the hardware necessarily -- it wouldn't fit some low-level use-cases, and it unnecessarily comingles two logically separate concerns. Likewise here: core Wasm is concerned with providing a programmable machine, and the Component Model describes how to interface together separate units of code on that machine</p>",
        "id": 489317586,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1734375292
    },
    {
        "content": "<p>Thanks a lot Chris, that makes a lot of sense <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 489320825,
        "sender_full_name": "raskyld",
        "timestamp": 1734376355
    }
]